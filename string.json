{
    "zed/crates/activity_indicator/src/activity_indicator.rs": {
        "Language server {server_name}:\\n\\n{status}": "",
        " ({}%)": "",
        ": ": "",
        " + {} more": "",
        "Debug: {}": "",
        "Downloading {}...": "",
        ", ": "",
        "Checking for updates to {}...": "",
        "Failed to run {}. Click to show error.": "",
        "Formatting failed: {failure}. Click to see logs.": "",
        "({server_name}) ": "",
        "({server_name}) Warning: ": "",
        "({server_name}) Error: ": "",
        " ": "",
        "{health_str}{truncated_message}": "",
        "{health_str}{message}": "",
        "Checking for Zed updates…": "",
        "Downloading Zed update…": "",
        "Installing Zed update…": "",
        "Click to restart and update Zed": "",
        "Failed to update Zed": "",
        "{error}": "",
        "Installing {extension_id} extension…": "",
        "Updating {extension_id} extension…": "",
        "Removing {extension_id} extension…": "",
        "Version: {}": "",
        "activity-indicator": "",
        "activity-indicator-popover": "",
        "activity-indicator-trigger": "",
        "activity-indicator-status": "",
        "Version: 1.0.0": "",
        "14d9a4189f058d8736339b06ff2340101eaea5af": "",
        "Version: 14d9a41…": ""
    },
    "zed/crates/anthropic/src/anthropic.rs": {
        "schemars": "",
        "claude-opus-4": "",
        "claude-opus-4-latest": "",
        "claude-opus-4-1": "",
        "claude-opus-4-1-latest": "",
        "claude-opus-4-thinking": "",
        "claude-opus-4-thinking-latest": "",
        "claude-opus-4-1-thinking": "",
        "claude-opus-4-1-thinking-latest": "",
        "claude-sonnet-4": "",
        "claude-sonnet-4-latest": "",
        "claude-sonnet-4-thinking": "",
        "claude-sonnet-4-thinking-latest": "",
        "claude-sonnet-4-5": "",
        "claude-sonnet-4-5-latest": "",
        "claude-sonnet-4-5-thinking": "",
        "claude-sonnet-4-5-thinking-latest": "",
        "claude-3-7-sonnet": "",
        "claude-3-7-sonnet-latest": "",
        "claude-3-7-sonnet-thinking": "",
        "claude-3-7-sonnet-thinking-latest": "",
        "claude-3-5-sonnet": "",
        "claude-3-5-sonnet-latest": "",
        "claude-haiku-4-5": "",
        "claude-haiku-4-5-latest": "",
        "claude-haiku-4-5-thinking": "",
        "claude-haiku-4-5-thinking-latest": "",
        "claude-3-5-haiku": "",
        "claude-3-5-haiku-latest": "",
        "claude-3-opus": "",
        "claude-3-opus-latest": "",
        "claude-3-sonnet": "",
        "claude-3-sonnet-latest": "",
        "claude-3-haiku": "",
        "claude-3-haiku-latest": "",
        "custom": "",
        "invalid model ID: {id}": "",
        "claude-3-sonnet-20240229": "",
        "claude-3-haiku-20240307": "",
        "claude-opus-4-20250514": "",
        "claude-opus-4-1-20250805": "",
        "claude-sonnet-4-20250514": "",
        "claude-sonnet-4-5-20250929": "",
        "claude-haiku-4-5-20251001": "",
        "Claude Opus 4": "",
        "Claude Opus 4.1": "",
        "Claude Opus 4 Thinking": "",
        "Claude Opus 4.1 Thinking": "",
        "Claude Sonnet 4": "",
        "Claude Sonnet 4 Thinking": "",
        "Claude Sonnet 4.5": "",
        "Claude Sonnet 4.5 Thinking": "",
        "Claude 3.7 Sonnet": "",
        "Claude 3.5 Sonnet": "",
        "Claude 3.7 Sonnet Thinking": "",
        "Claude Haiku 4.5": "",
        "Claude Haiku 4.5 Thinking": "",
        "Claude 3.5 Haiku": "",
        "Claude 3 Opus": "",
        "Claude 3 Sonnet": "",
        "Claude 3 Haiku": "",
        "prompt-caching-2024-07-31": "",
        "token-efficient-tools-2025-02-19": "",
        "{api_url}/v1/messages": "",
        "Anthropic-Version": "",
        "2023-06-01": "",
        "Anthropic-Beta": "",
        "X-Api-Key": "",
        "Content-Type": "",
        "application/json": "",
        "anthropic-ratelimit-{resource}-limit": "",
        "anthropic-ratelimit-{resource}-remaining": "",
        "anthropic-ratelimit-{resource}-reset": "",
        "retry-after": "",
        "anthropic-ratelimit-": "",
        "requests": "",
        "tokens": "",
        "input-tokens": "",
        "output-tokens": "",
        "missing header `{key}`": "",
        "data: ": "",
        "lowercase": "",
        "type": "",
        "text": "",
        "Option::is_none": "",
        "thinking": "",
        "redacted_thinking": "",
        "image": "",
        "tool_use": "",
        "tool_result": "",
        "Vec::is_empty": "",
        "message_start": "",
        "content_block_start": "",
        "content_block_delta": "",
        "content_block_stop": "",
        "message_delta": "",
        "message_stop": "",
        "ping": "",
        "error": "",
        "text_delta": "",
        "thinking_delta": "",
        "signature_delta": "",
        "input_json_delta": "",
        "Anthropic API Error: {error_type}: {message}": "",
        "rate_limit_error": "",
        "prompt is too long: ": "",
        " tokens": "",
        "invalid_request_error": "",
        "prompt is too long: 220000 tokens > 200000": "",
        "prompt is too long: 1234953 tokens": "",
        "not a prompt length error": "",
        "prompt is too long: 12345 tokens": "",
        "prompt is too long: invalid tokens": ""
    },
    "zed/crates/assets/src/assets.rs": {
        "../../assets": "",
        "fonts/**/*": "",
        "icons/**/*": "",
        "images/**/*": "",
        "themes/**/*": "",
        "themes/src/*": "",
        "sounds/**/*": "",
        "prompts/**/*": "",
        "*.md": "",
        "*.DS_Store": "",
        "loading asset at path {path:?}": "",
        "fonts": "",
        ".ttf": "",
        "Assets should never return None": "",
        "fonts/lilex/Lilex-Regular.ttf": ""
    },
    "zed/crates/assistant_slash_commands/src/diagnostics_command.rs": {
        "diagnostics": "",
        "Insert diagnostics": "",
        "workspace was dropped": "",
        "No diagnostics found": "",
        "--include-warnings": "",
        "diagnostics: {}": "",
        "{file_path}": "",
        "Diagnostics": "",
        " ({})": "",
        " {} errors": "",
        " {} warnings": "",
        "warning": "",
        "error": "",
        " {}: ": "",
        "\\n//{:padding$}": "",
        "{message}": ""
    },
    "zed/crates/auto_update/src/auto_update.rs": {
        "auto-updater-should-show-updated-notification": "",
        "hdiutil": "",
        "detach": "",
        "-force": "",
        "Successfully unmounted the disk image": "",
        "Failed to unmount disk image: {:?}": "",
        "Error while trying to unmount disk image: {:?}": "",
        "ZED_UPDATE_EXPLANATION": "",
        "Zed was installed via a package manager.": "",
        "Ok": "",
        "Could not check for updates": "",
        "Auto-updates disabled for non-bundled app.": "",
        "/releases/{release_channel}/{current_version}": "",
        "zed-auto-update": "",
        "No parent dir for Zed.exe": "",
        "updates": "",
        "failed to cleanup old directories": "",
        "auto-update check failed: error:{:?}": "",
        "auto-update failed: error:{:?}": "",
        "auto-update not initialized": "",
        "Fetching remote server release": "",
        "zed-remote-server": "",
        "{}.gz": "",
        "downloading zed-remote-server {os} {arch} version {}": "",
        "Downloading remote server": "",
        "latest": "",
        "/releases/{}/{}/asset": "",
        "failed to fetch release: {:?}": "",
        "error deserializing release {:?}": "",
        "Auto Update: checking for updates": "",
        "rsync": "",
        "Could not auto-update because the required rsync utility was not found.": "",
        "Zed.dmg": "",
        "zed.tar.gz": "",
        "Zed.exe": "",
        "not supported: {unsupported_os}": "",
        "failed to download remote server release: {:?}": "",
        "failed to download update: {:?}": "",
        "downloaded update. path:{:?}": "",
        "HOME": "",
        "no HOME env var set": "",
        "failed to create directory into which to extract update": "",
        "tar": "",
        "-xzf": "",
        "-C": "",
        "failed to extract {:?} to {:?}: {:?}": "",
        "stable": "",
        "zed{}.app": "",
        ".local": "",
        "{}/libexec/zed-editor": "",
        "-av": "",
        "--delete": "",
        "failed to copy Zed update from {:?} to {:?}: {:?}": "",
        "invalid running app path {running_app_path:?}": "",
        "attach": "",
        "-nobrowse": "",
        "-mountroot": "",
        "failed to mount: {:?}": "",
        "failed to copy app: {:?}": "",
        "install": "",
        "old": "",
        "/verysilent": "",
        "/update=true": "",
        "!desktopicon": "",
        "!quicklaunchicon": "",
        "failed to start installer: {:?}": "",
        "tools": "",
        "auto_update_helper.exe": "",
        "versions.txt": "",
        "--launch": "",
        "false": "",
        "Unable to set default settings": "",
        "Unable to set user settings": "",
        "/releases/stable/latest/asset": "",
        "/new-download": "",
        "auto updater should exist": "",
        "<fake-zed-update>": "",
        "a": "",
        "b": "",
        "c": ""
    },
    "zed/crates/breadcrumbs/src/breadcrumbs.rs": {
        "breadcrumb-container": "",
        "toggle outline view": "",
        "Show Symbol Outline": ""
    },
    "zed/crates/channel/src/channel_buffer.rs": {
        "channel buffer {} disconnected": ""
    },
    "zed/crates/channel/src/channel_store.rs": {
        "{}/channel/{}-{}": "",
        "/notes": "",
        "{:?} elapsed without receiving channels": "",
        "notes": "",
        "no channel for id: {channel_id}": "",
        "{error}": "",
        "failed to open channel {resource_name}": "",
        "missing channel in response": "",
        "invite request already in progress": "",
        "member request already in progress": ""
    },
    "zed/crates/cli/src/main.rs": {
        "We are not in an async environment, so std::process::Command is fine": "",
        "zed://": "",
        "file://": "",
        "ssh://": "",
        "The Zed CLI binary.\nThis CLI is a separate binary that invokes Zed.\n\nExamples:\n    `zed`\n          Simply opens Zed\n    `zed --foreground`\n          Runs in foreground (shows all logs)\n    `zed path-to-your-project`\n          Open your project in Zed\n    `zed -n path-to-file `\n          Open file/folder in a new window": "",
        "To read from stdin, append '-', e.g. 'ps axf | zed -'": "",
        "new": "",
        "reuse": "",
        "add": "",
        "`~/Library/Application Support/Zed`.": "",
        "`%LOCALAPPDATA%\\\\Zed`.": "",
        "`$XDG_DATA_HOME/zed`.": "",
        "DIR": "",
        "USER@DISTRO": "",
        "OLD_PATH": "",
        "NEW_PATH": "",
        "no-bundled-uninstall": "",
        "retrieving current directory": "",
        "parsing as path with position {argument_str}": "",
        "wsl.exe": "",
        "user is empty in wsl argument": "",
        "--user": "",
        "--distribution": "",
        "--exec": "",
        "wslpath": "",
        "-m": "",
        "//wsl.localhost/{}": "",
        "Bundle detection": "",
        "The `--system-specs` argument is not supported in the Zed CLI, only on Zed binary.": "",
        "To retrieve the system specs on the command line, run the following command:": "",
        "{} --system-specs": "",
        "uninstall.sh": "",
        "sh": "",
        "ZED_CHANNEL": "",
        "Failed to execute uninstall script": "",
        "Handshake before Zed spawn": "",
        "zed-cli://{server_name}": "",
        "file://{}": "",
        "Dev servers were removed in v0.157.x please upgrade to SSH remoting: https://zed.dev/docs/remote-development": "",
        "RayonWorker{}": "",
        "CliReceiver": "",
        "Handshake after Zed spawn": "",
        "{message}": "",
        "CliStdin": "",
        "CliAnonymousFd": "",
        "/proc/self/fd/": "",
        "memfd:": "",
        "/dev/fd/": "",
        "no parent path for cli": "",
        "../libexec/zed-editor": "",
        "../lib/zed/zed-editor": "",
        "./zed": "",
        "could not find any of: {}": "",
        ", ": "",
        "Zed {}{}{} – {}": "",
        "stable": "",
        "{} ": "",
        "RELEASE_VERSION": "",
        "ZED_COMMIT_SHA": "",
        " {commit_sha} ": "",
        "zed-{}.sock": "",
        "--user-data-dir": "",
        "failed to setsid: {}": "",
        "failed to close_fd: {}": "",
        "failed to exec {:?}: {}": "",
        "ZED_FLATPAK_LIB_PATH": "",
        "ZED_FLATPAK_NO_ESCAPE": "",
        "LD_LIBRARY_PATH": "",
        "/usr/bin/flatpak-spawn": "",
        "--host": "",
        "--env=ZED_UPDATE_EXPLANATION=Please use flatpak to update zed": "",
        "--env={EXTRA_LIB_ENV_NAME}={}": "",
        "lib": "",
        "bin": "",
        "--zed": "",
        "libexec": "",
        "zed-editor": "",
        "failed restart cli on host: {:?}": "",
        "FLATPAK_ID": "",
        "dev.zed.Zed": "",
        "/app/libexec/zed-editor": "",
        "ZED_UPDATE_EXPLANATION": "",
        "Please use flatpak to update zed": "",
        "flatpak": "",
        "info": "",
        "--show-location": "",
        "files": "",
        "XDG_DATA_HOME": "",
        "XDG_CONFIG_HOME": "",
        "XDG_CACHE_HOME": "",
        "XDG_STATE_HOME": "",
        "--env=FLATPAK_{}={}": "",
        "{}-Instance-Mutex": "",
        "Unable to create instance sync event": "",
        "\\\\\\\\.\\\\pipe\\\\{}-Named-Pipe": "",
        "--foreground": "",
        "CFBundleShortVersionString": "",
        "app": "",
        "cannot find app bundle containing {cli_path:?}": "",
        "Args bundle path {bundle_path:?} canonicalization": "",
        "bundle autodiscovery": "",
        "Contents/Info.plist": "",
        "Reading *.app bundle plist file at {plist_path:?}": "",
        "Zed {} – {}": "",
        "invalid app path {app_path:?}": "",
        "cannot start app bundle {}": "",
        "Executable {executable:?} path has no parent": "",
        "zed_dev.log": "",
        "Log file creation in {executable_parent:?}": "",
        "Cloning descriptor for file {subprocess_stdout_file:?}": "",
        "Spawning {command:?}": "",
        "Contents/MacOS/zed": "",
        "<development>": "",
        "POSIX path of (path to application \\\"{}\\\")": "",
        "osascript": "",
        "-e": "",
        "Could not determine app path for {}": "",
        "{app_path}/Contents/MacOS/cli": ""
    },
    "zed/crates/client/src/client.rs": {
        "ZED_SERVER_URL": "",
        "ZED_RPC_URL": "",
        "ZED_IMPERSONATE": "",
        "ZED_WEB_LOGIN": "",
        "ZED_ADMIN_API_TOKEN": "",
        "ZED_APP_PATH": "",
        "ZED_ALWAYS_ACTIVE": "",
        "Error parsing proxy settings: {}": "",
        "upgrade required": "",
        "unauthorized": "",
        "{0}": "",
        "{} {}": "",
        "handling queued rpc message. client_id:{}, sender_id:{:?}, type:{}": "",
        "unhandled message {}": "",
        "set status on client {}: {:?}": "",
        "client connect attempt timed out": "",
        "client connect attempt reset": "",
        "failed to connect: {error}": "",
        "already subscribed to entity": "",
        "{}:{} registered handler for the same message {} twice": "",
        "authentication canceled": "",
        "failed to validate credentials: {}": "",
        "connection timed out": "",
        "connection reset": "",
        "client auth and connect": "",
        "add connection to peer": "",
        "waiting for server hello": "",
        "no hello message received": "",
        "got server hello": "",
        "invalid hello message received: {:?}": "",
        "invalid peer id": "",
        "set status to connected (connection id: {:?}, peer id: {:?})": "",
        "connection error: {:?}": "",
        "invalid rpc url": "",
        "/rpc": "",
        "unexpected /rpc response status {}": "",
        "Location": "",
        "missing location header in /rpc response": "",
        "parsing collab rpc url {collab_url}": "",
        "https": "",
        "http": "",
        "invalid rpc url: {}": "",
        "missing host in rpc url": "",
        "connected to rpc endpoint {}": "",
        "wss": "",
        "ws": "",
        "x-zed-protocol-version": "",
        "x-zed-app-version": "",
        "x-zed-release-channel": "",
        "unknown": "",
        "x-zed-system-id": "",
        "x-zed-metrics-id": "",
        "failed to generate keypair for auth": "",
        "failed to serialize public key for auth": "",
        "authenticate as admin {login}, {token}": "",
        "127.0.0.1:0": "",
        "failed to find open port": "",
        "/native_app_signin?native_app_port={}&native_app_public_key={}": "",
        "impersonating user @{}": "",
        "&impersonate={}": "",
        "failed to parse login notification url": "",
        "failed to parse sign-in callback query parameters": "",
        "/native_app_signin_succeeded": "",
        "failed to respond to login http request": "",
        "didn't receive login redirect": "",
        "failed to decrypt access token": "",
        "/internal/users/impersonate": "",
        "Content-Type": "",
        "application/json": "",
        "Authorization": "",
        "Bearer {api_token}": "",
        "admin user request failed {} - {}": "",
        "not connected": "",
        "rpc send. client_id:{}, name:{}": "",
        "rpc request start. client_id:{}. name:{}": "",
        "rpc request finish. client_id:{}. name:{}": "",
        "rpc message received. client_id:{}, sender_id:{:?}, type:{}": "",
        "rpc message handled. client_id:{client_id}, sender_id:{original_sender_id:?}, type:{type_name}": "",
        "error handling message. client_id:{client_id}, sender_id:{original_sender_id:?}, type:{type_name}, error:{error:#}": "",
        "rpc respond. client_id:{}, name:{}": "",
        "token": ""
    },
    "zed/crates/client/src/telemetry.rs": {
        "ZED_CLIENT_CHECKSUM_SEED": "",
        "ZED_MINIDUMP_ENDPOINT": "",
        "^(global\\.json|Directory\\.Build\\.props|.*\\.(csproj|fsproj|vbproj|sln))$": "",
        "(\\s*\\(Build [^)]*[0-9]\\))": "",
        "Linux {}": "",
        "FreeBSD {}": "",
        "Version 15.6.1 (Build 24G90)": "",
        "15.6.1 (Build 24G90)": "",
        "Version ": "",
        "15.6.1": "",
        "26.0.0 (Build 25A5349a)": "",
        "/etc/os-release": "",
        "/usr/lib/os-release": "",
        "/var/run/os-release": "",
        "Failed to load /etc/os-release, /usr/lib/os-release, or /var/run/os-release": "",
        "unknown": "",
        "ID": "",
        "'),\n                Some((": "",
        ", val)) => version = val.trim_matches('": "",
        "{} {}": "",
        "App Closed": "",
        "telemetry.log": "",
        "Assistant Responded": "",
        "Assistant Invoked": "",
        "Assistant Response Accepted": "",
        "Assistant Response Rejected": "",
        "Editor Edited": "",
        "Project Opened": "",
        "pnpm-lock.yaml": "",
        "pnpm": "",
        "yarn.lock": "",
        "yarn": "",
        "package.json": "",
        "node": "",
        "dotnet": "",
        "telemetry": "",
        "event_source": "",
        "/telemetry/events": "",
        "Content-Type": "",
        "application/json": "",
        "x-zed-checksum": "",
        "Failed to send events: HTTP {:?}": "",
        "{:02x}": "",
        "system_id": "",
        "installation_id": "",
        "session_id": "",
        "test_key": "",
        "test_value": "",
        "test": "",
        "global.json": "",
        "Directory.Build.props": "",
        "file.csproj": "",
        "file.fsproj": "",
        "file.vbproj": "",
        "file.sln": ""
    },
    "zed/crates/client/src/test.rs": {
        "/client/users/me": "",
        "Unauthorized": "",
        "user-{client_user_id}": "",
        "server dropped": "",
        "server is forbidding connections": "",
        "not connected": "",
        "other half hung up": "",
        "fake server received unexpected message type: {:?}": "",
        "metrics-id-{user_id}": ""
    },
    "zed/crates/client/src/user.rs": {
        "can't upgrade user store handle": "",
        "can't upgrade client reference": "",
        "user {user_id} not found": "",
        "server responded with no users": "",
        "ZED_SIMULATE_PLAN": "",
        "free": "",
        "trial": "",
        "pro": "",
        "ZED_SIMULATE_PLAN must be one of 'free', 'trial', or 'pro'": "",
        "Failed to get Cloud client": "",
        "error loading users": "",
        "invalid peer id": "",
        "missing {limit_name:?} header": "",
        "missing {amount_name:?} header": ""
    },
    "zed/crates/clock/src/clock.rs": {
        "<local>": "",
        "<remote>": "",
        "<agent>": "",
        "<branch>": "",
        "synchronize": "",
        "Lamport {{MAX}}": "",
        "Lamport {{MIN}}": "",
        "Lamport {{{:?}: {}}}": "",
        "Global {{": "",
        ", ": "",
        "{:?}: {}": ""
    },
    "zed/crates/command_palette_hooks/src/command_palette_hooks.rs": {
        "malformed action name": ""
    },
    "zed/crates/collab/src/api/contributors.rs": {
        "/contributors": "",
        "/contributor": "",
        "must be one of `github_user_id` or `github_login`.": "",
        "renovate[bot]": "",
        "2017-06-02T07:04:12Z": "",
        "failed to parse 'created_at' for 'renovate[bot]'": ""
    },
    "zed/crates/collab/src/api/events.rs": {
        "/telemetry/events": "",
        "/telemetry/crashes": "",
        "/telemetry/panics": "",
        "/telemetry/hangs": "",
        "x-zed-checksum": "",
        "events not enabled": "",
        "can't parse event json: {err}": "",
        "no events": "",
        "app_version": "",
        "os_name": "",
        "os_version": "",
        "architecture": "",
        "release_channel": "",
        "signed_in": "",
        "checksum_matched": "",
        "country": "",
        "is_staff": ""
    },
    "zed/crates/collab/src/api/extensions.rs": {
        "/extensions": "",
        "/extensions/updates": "",
        "/extensions/:extension_id": "",
        "/extensions/:extension_id/download": "",
        "/extensions/:extension_id/:version/download": "",
        "extension_search": "",
        "unknown extension": "",
        "not supported": "",
        "unknown extension version": "",
        "extensions/{extension_id}/{version}/archive.tar.gz": "",
        "creating presigned extension download url": "",
        "no blob store client": "",
        "no blob store bucket": "",
        "fetching extensions from blob store": "",
        "extensions/": "",
        "fetched {} object(s) from blob store": "",
        "extensions": "",
        "manifest.json": "",
        "found {} published extensions": "",
        "fetched {} new extensions from blob store": "",
        "extensions/{extension_id}/{version}/manifest.json": "",
        "failed to download manifest for extension {extension_id} version {version}": "",
        "invalid manifest for extension {extension_id} version {version}: {}": "",
        "missing last modified timestamp for extension {extension_id} version {version}": "",
        "invalid version for extension {extension_id} version {version}": ""
    },
    "zed/crates/collab/src/bin/dotenv.rs": {
        "POWERSHELL": "",
        "$env:{}=\\\"{}\\\"": "",
        "export {}=\\\"{}\\\"": ""
    },
    "zed/crates/collab/src/db/queries/access_tokens.rs": {
        "no such access token": ""
    },
    "zed/crates/collab/src/db/queries/buffers.rs": {
        "user is not a member of channel": "",
        "can't rejoin buffer, epoch has changed": "",
        "can't rejoin buffer, no previous collaborator found": "",
        "not a collaborator on this project": "",
        "no such buffer": "",
        "missing buffer snapshot": "",
        "no such snapshot": "",
        "{error}": ""
    },
    "zed/crates/collab/src/db/queries/channels.rs": {
        "Creating channel '{}' with parent_path='{}', max_order={}, new_order={}": "",
        "channel-{}": "",
        "direction": "",
        "parent": "",
        "children": "",
        "channel name can't be blank": "",
        "no such invitation": "",
        "no such member": "",
        "sqlite": "",
        "UPPER(github_login) LIKE ?": "",
        "github_login ILIKE $1": "",
        "not role = 'admin', not role = 'member', not role = 'guest', not accepted, github_login": "",
        "user is not a channel admin or channel does not exist": "",
        "user is not a channel member or channel does not exist": "",
        "user is not a channel participant or channel does not exist": "",
        "parent_path || id || '/'": "",
        "\n                    UPDATE channels SET parent_path = REPLACE(parent_path, $1, $2)\n                    WHERE parent_path LIKE $3 || '%'\n                    RETURNING id\n                ": "",
        "Skipping reorder of root channel {}": "",
        "Reordering channel {} (parent_path: '{}', order: {})": "",
        "Looking for sibling with parent_path='{}' and order < {}": "",
        "Looking for sibling with parent_path='{}' and order > {}": "",
        "Found sibling {} (parent_path: '{}', order: {})": "",
        "No sibling found to swap with": "",
        "Reorder complete. Swapped channels {} and {}": "",
        "max_order": ""
    },
    "zed/crates/collab/src/db/queries/contacts.rs": {
        "user_a_participant": "",
        "user_b_participant": "",
        "user_a_busy": "",
        "user_b_busy": "",
        "contact already requested": "",
        "no such contact": "",
        "no such contact request": ""
    },
    "zed/crates/collab/src/db/queries/extensions.rs": {
        "name ILIKE $1": "",
        "no such extension: {extension_id}": "",
        "failed to insert extension": "",
        ", ": ""
    },
    "zed/crates/collab/src/db/queries/notifications.rs": {
        "Unknown notification kind": "",
        "invalid notification kind {:?}": ""
    },
    "zed/crates/collab/src/db/queries/projects.rs": {
        "could not find participant": "",
        "shared project on unexpected room": "",
        "guests cannot share projects": "",
        "project not found": "",
        "cannot unshare a project hosted by another user": "",
        "no such project": "",
        "invalid worktree update. removed entries: {}, updated entries: {}": "",
        "no such project: {project_id}": "",
        "invalid summary": "",
        "can't update a project hosted by someone else": "",
        "invalid language server": "",
        "unknown worktree settings kind: {kind}": "",
        "failed to deserialize repository's entry ids": "",
        "not a collaborator on this project": "",
        "failed to read project host": "",
        "not authorized to edit projects": "",
        "not authorized to read projects": "",
        "can only send project updates to a project you're in": "",
        "not room participants": ""
    },
    "zed/crates/collab/src/db/queries/rooms.rs": {
        "user is not in the room": "",
        "banned users cannot invite": "",
        "failed to build incoming call": "",
        "could not find call to decline": "",
        "no call to cancel": "",
        "no such room": "",
        "tried to join channel call directly": "",
        "room does not exist or was already joined": "",
        "no channel for room": "",
        "project does not exist": "",
        "no such project": "",
        "host not found among collaborators": "",
        "failed to deserialize repository's entry ids": "",
        "invalid location": "",
        "could not update room participant location": "",
        "only admins can set participant role": "",
        "could not update room participant role": "",
        "could not find room": "",
        "user has not signed the Zed CLA": "",
        "not a room participant": ""
    },
    "zed/crates/collab/src/db/queries/users.rs": {
        "too many users": "",
        "could not find user": "",
        "connected_once": "",
        "\n                SELECT users.*\n                FROM users\n                WHERE github_login ILIKE $1\n                ORDER BY github_login <-> $2\n                LIMIT $3\n            ": "",
        "cir": "",
        "%c%i%r%": ""
    },
    "zed/crates/collab_ui/src/collab_panel/channel_modal.rs": {
        "ChannelModal": "",
        "is-public": "",
        "Public": "",
        "copy-link": "",
        "Copy Link": "",
        "manage-members": "",
        "Manage Members": "",
        "invite-members": "",
        "Invite Members": "",
        "Search collaborator by username...": "",
        "Invited": "",
        "Admin": "",
        "Guest": "",
        "ellipsis": "",
        "You": "",
        "Member": "",
        "Failed to update role": "",
        "Failed to remove member": "",
        "Failed to invite member": "",
        "Demote to Guest": "",
        "Promote to Member": "",
        "Demote to Member": "",
        "Promote to Admin": "",
        "Remove from Channel": ""
    },
    "zed/crates/collab_ui/src/collab_panel/contact_finder.rs": {
        "Contacts": "",
        "Invite new contacts": "",
        "Search collaborator by username...": "",
        "icons/check.svg": "",
        "icons/x.svg": ""
    },
    "zed/crates/collab_ui/src/notifications/stories/collab_notification.rs": {
        "Incoming Call Notification": "",
        "accept": "",
        "Accept": "",
        "decline": "",
        "Decline": "",
        "maxdeviant is sharing a project in Zed": "",
        "Project Shared Notification": "",
        "open": "",
        "Open": "",
        "dismiss": "",
        "Dismiss": "",
        "iamnbutler": "",
        "is sharing a project in Zed:": ""
    },
    "zed/crates/collab_ui/src/notifications/incoming_call_notification.rs": {
        "accept": "",
        "Accept": "",
        "decline": "",
        "Decline": "",
        "{} is sharing a project in Zed": ""
    },
    "zed/crates/collab_ui/src/notifications/project_shared_notification.rs": {
        "open": "",
        "Open": "",
        "dismiss": "",
        "Dismiss": "",
        "is sharing a project in Zed{}": "",
        ", ": ""
    },
    "zed/crates/collab_ui/src/channel_view.rs": {
        "Channel Notes Opened": "",
        "Copy link to section": "",
        "Link copied to clipboard": "",
        "read-only": "",
        "disconnected": "",
        "<unknown>": "",
        "{name} - {status}": ""
    },
    "zed/crates/collab_ui/src/collab_panel.rs": {
        "CollaborationPanel": "",
        "toggle_on_modifiers_press": "",
        "{project:?}": "",
        "{room:?}": "",
        "Filter...": "",
        "reading collaboration panel from key value store": "",
        "Follow {}": "",
        "Calling": "",
        "leave-call": "",
        "Leave Call": "",
        "Guest": "",
        "Mic only": "",
        "untitled": "",
        ", ": "",
        "Failed to join project": "",
        "Open {}": "",
        "screen": "",
        "Screen": "",
        "Open shared screen": "",
        "channel-notes": "",
        "notes": "",
        "Open Channel Notes": "",
        "Grant Mic Access": "",
        "Failed to grant mic access": "",
        "Grant Write Access": "",
        "Failed to grant write access": "",
        "This user has not yet signed the CLA at https://zed.dev/cla.": "",
        "Mute": "",
        "Revoke Access": "",
        "Failed to revoke access": "",
        "Expand Subchannels": "",
        "Collapse Subchannels": "",
        "Open Notes": "",
        "Copy Channel Link": "",
        "Copy Channel Notes Link": "",
        "New Subchannel": "",
        "Rename": "",
        "Move '#{}' here": "",
        "Manage Members": "",
        "Move this channel": "",
        "Make Channel Private": "",
        "Make Channel Public": "",
        "Delete": "",
        "Leave Channel": "",
        "Invite {} to join": "",
        "Call {}": "",
        "Remove Contact": "",
        " ": "",
        "Failed to create channel": "",
        "Failed to hang up": "",
        "Failed to set channel visibility": "",
        "direction": "",
        "parent": "",
        "To make a channel public, its parent channel must be public.": "",
        "To make a channel private, all of its subchannels must be private.": "",
        "Failed to move channel": "",
        "Public channels must have public parents": "",
        "You cannot move a channel into itself": "",
        "You cannot move a channel into a different root channel": "",
        "Failed to move channel up": "",
        "Failed to move channel down": "",
        "CollabPanel": "",
        "menu": "",
        "editing": "",
        "not_editing": "",
        "Are you sure you want to leave \\\"#{}\\\"?": "",
        "Leave": "",
        "Cancel": "",
        "Failed to leave channel": "",
        "Are you sure you want to remove the channel \\\"{}\\\"?": "",
        "Remove": "",
        "Are you sure you want to remove \\\"{}\\\" from your contacts?": "",
        "Failed to remove contact": "",
        "Failed to respond to contact request": "",
        "Call failed": "",
        "Failed to join channel": "",
        "Work with your team in realtime with collaborative editing, voice, shared notes and more.": "",
        "sign_in": "",
        "Sign in": "",
        "Sign in to enable collaboration.": "",
        "icons/public.svg": "",
        "Copy public channel link.": "",
        "icons/hash.svg": "",
        "Copy private channel link.": "",
        "Current Call": "",
        "Requests": "",
        "Contacts": "",
        "Channels": "",
        "Invites": "",
        "Online": "",
        "Offline": "",
        "channel-link": "",
        "section-header": "",
        "Copy channel link": "",
        "add-contact": "",
        "Search for new contact": "",
        "add-channel": "",
        "Create a channel": "",
        "contact context menu": "",
        " {} is offline": "",
        " {} is on a call": "",
        "Invite {} to join call": "",
        "decline-contact": "",
        "Decline invite": "",
        "accept-contact": "",
        "Accept invite": "",
        "remove_contact": "",
        "Cancel invite": "",
        "reject-invite": "",
        "accept-invite": "",
        "channel-invite": "",
        "contact-placeholder": "",
        "Add a Contact": "",
        "+{extra_count}": "",
        "channel_notes": "",
        "Open channel notes": "",
        "channel-editor": "",
        "{display_name} ({})": "",
        "Collab Panel": "",
        "Join channel": ""
    },
    "zed/crates/collab_ui/src/collab_ui.rs": {},
    "zed/crates/collab_ui/src/notification_panel.rs": {
        "NotificationPanel": "",
        "notification_timestamp": "",
        "You accepted": "",
        "You declined": "",
        "decline": "",
        "Decline": "",
        "accept": "",
        "Accept": "",
        "icons/plus.svg": "",
        "{} wants to add you as a contact": "",
        "{} accepted your contact invite": "",
        "icons/hash.svg": "",
        "{} invited you to join the #{channel_name} channel": "",
        "Notifications": "",
        "connect_prompt_button": "",
        "Connect": "",
        "Connection timeout": "",
        "Connection reset": "",
        "Connect to view notifications.": "",
        "You have no notifications.": "",
        "Notification Panel": "",
        "suppress": "",
        "close": "",
        "notification_panel_toast": "",
        "Suppress.\\nClose with click.": "",
        "Close.\\nSuppress with shift-click": ""
    },
    "zed/crates/command_palette/src/command_palette.rs": {
        "CommandPalette": "",
        "Execute a command...": "",
        "Action Invoked": "",
        "command palette": "",
        "change": "",
        "Change Keybinding…": "",
        "add": "",
        "Add Keybinding…": "",
        "run-action": "",
        "Run": "",
        "Command": "",
        "name": "",
        "editor::GoToDefinition": "",
        "editor: go to definition": "",
        "editor::Backspace": "",
        "editor: backspace": "",
        "go_to_line::Deploy": "",
        "go to line: deploy": "",
        "editor:  backspace": "",
        "editor:    backspace": "",
        "editor:GoToDefinition": "",
        "editor::::GoToDefinition": "",
        "editor: :GoToDefinition": "",
        "abc": "",
        "cmd-shift-p": "",
        "bcksp": "",
        "enter": "",
        "ab": "",
        "editor": "",
        "Editor::    Backspace": "",
        "cmd-n": "",
        "1\\n2\\n3\\n4\\n5\\n6\\n": "",
        "go to line: Toggle": "",
        "3 enter": "",
        "[\n                    {\n                        ": "",
        ": {\n                            ": "",
        ": ": "",
        ",\n                            ": "",
        "\n                        }\n                    }\n                ]": ""
    },
    "zed/crates/copilot/src/copilot_chat.rs": {
        "GH_COPILOT_TOKEN": "",
        "github.com": "",
        "{}/chat/completions": "",
        "{}/responses": "",
        "{}/models": "",
        "lowercase": "",
        "/chat/completions": "",
        "/responses": "",
        "deserialize_models_skip_errors": "",
        "GitHub Copilot Chat model failed to deserialize: {:?}": "",
        "type": "",
        "Azure OpenAI": "",
        "xAI": "",
        "text": "",
        "image_url": "",
        "Vec::is_empty": "",
        "Option::is_none": "",
        "role": "",
        "invalid expires_at": "",
        "failed to determine LocalAppData directory": "",
        "XDG_CONFIG_HOME": "",
        ".config": "",
        "github-copilot": "",
        "hosts.json": "",
        "apps.json": "",
        "OAuth token is missing while updating Copilot Chat models": "",
        "Copilot chat is not enabled": "",
        "No OAuth token available": "",
        "chat": "",
        "enabled": "",
        "Authorization": "",
        "Content-Type": "",
        "application/json": "",
        "Copilot-Integration-Id": "",
        "vscode-chat": "",
        "Editor-Version": "",
        "vscode/1.103.2": "",
        "x-github-api-version": "",
        "2025-05-01": "",
        "Failed to request models: {}": "",
        "token {}": "",
        "Accept": "",
        "Failed to request API token: {body_str}": "",
        "oauth_token": "",
        "user": "",
        "agent": "",
        "Zed/{}": "",
        "CARGO_PKG_VERSION": "",
        "unknown": "",
        "X-Initiator": "",
        "Copilot-Vision-Request": "",
        "Failed to connect to API: {} {}": "",
        "data: ": "",
        "[DONE]": "",
        "{\n              ": "",
        ": [\n                {\n                  ": "",
        ": {\n                    ": "",
        ": false,\n                    ": "",
        ": 0\n                  },\n                  ": "",
        ": ": "",
        ",\n                    ": "",
        ": {\n                      ": "",
        ": 32768,\n                      ": "",
        ": 4096,\n                      ": "",
        ": 32768\n                    },\n                    ": "",
        ": { ": "",
        ": true, ": "",
        ": true },\n                    ": "",
        "\n                  },\n                  ": "",
        ",\n                  ": "",
        ": false,\n                  ": "",
        "\n                },\n                {\n                    ": "",
        ": 123\n                },\n                {\n                  ": "",
        ": true,\n                    ": "",
        ": 1,\n                    ": "",
        ": [\n                      ": "",
        ",\n                      ": "",
        "\n                    ]\n                  },\n                  ": "",
        ": 200000,\n                      ": "",
        ": 16384,\n                      ": "",
        ": 90000,\n                      ": "",
        ": {\n                        ": "",
        ": 3145728,\n                        ": "",
        ": 1,\n                        ": "",
        ": [": "",
        ", ": "",
        "]\n                      }\n                    },\n                    ": "",
        ": true,\n                      ": "",
        ": true\n                    },\n                    ": "",
        ": true,\n                  ": "",
        "\n                }\n              ],\n              ": "",
        "\n            }": "",
        "gpt-4": "",
        "claude-3.7-sonnet": "",
        ": 1\n                  },\n                  ": "",
        ": 128000,\n                      ": "",
        ": 8192,\n                      ": "",
        ": 120000\n                    },\n                    ": "",
        "future-model-v1": ""
    },
    "zed/crates/copilot/src/copilot.rs": {
        "must sign in before using copilot": "",
        "copilot is still starting": "",
        "copilot is disabled": "",
        "copilot was not started because of an error: {error}": "",
        "copilot setting change: did change configuration": "",
        "http:": "",
        "HTTP_PROXY": "",
        "https:": "",
        "HTTPS_PROXY": "",
        "Unsupported protocol scheme for language server proxy (must be http or https)": "",
        "NODE_TLS_REJECT_UNAUTHORIZED": "",
        "path/to/copilot": "",
        "copilot": "",
        "--experimental-sqlite": "",
        "--stdio": "",
        "C:/": "",
        "CARGO_PKG_VERSION": "",
        "zed-copilot": "",
        "0.0.1": "",
        "copilot: did change configuration": "",
        "copilot: check status": "",
        "copilot sign-in": "",
        "copilot: sign in confirm": "",
        "{err:?}": "",
        "copilot hasn't started yet": "",
        "copilot: notify accepted": "",
        "copilot: notify rejected": "",
        "copilot: get completions": "",
        "plaintext": "",
        "buffer://{}": "",
        "http": "",
        "proxy": "",
        "proxyStrictSSL": "",
        "github-enterprise": "",
        "uri": "",
        "Checking Node.js version for Copilot at: {:?}": "",
        "--version": "",
        "checking Node.js version at {:?}": "",
        "failed to run node --version for Copilot. stdout: {}, stderr: {}": "",
        "parsing Node.js version from '{}'": "",
        "\n        );\n    }\n\n    log::info!(\n        ": "",
        ",\n        version,\n        MIN_COPILOT_NODE_VERSION\n    );\n    Ok(())\n}\n\nasync fn get_copilot_lsp(fs: Arc<dyn Fs>, node_runtime: NodeRuntime) -> anyhow::Result<PathBuf> {\n    const PACKAGE_NAME: &str = ": "",
        ";\n    const SERVER_PATH: &str =\n        ": "",
        ";\n\n    let latest_version = node_runtime\n        .npm_package_latest_version(PACKAGE_NAME)\n        .await?;\n    let server_path = paths::copilot_dir().join(SERVER_PATH);\n\n    fs.create_dir(paths::copilot_dir()).await?;\n\n    let should_install = node_runtime\n        .should_install_npm_package(\n            PACKAGE_NAME,\n            &server_path,\n            paths::copilot_dir(),\n            VersionStrategy::Latest(&latest_version),\n        )\n        .await;\n    if should_install {\n        node_runtime\n            .npm_install_packages(paths::copilot_dir(), &[(PACKAGE_NAME, &latest_version)])\n            .await?;\n    }\n\n    Ok(server_path)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use gpui::TestAppContext;\n    use util::{path, paths::PathStyle, rel_path::rel_path};\n\n    #[gpui::test(iterations = 10)]\n    async fn test_buffer_management(cx: &mut TestAppContext) {\n        let (copilot, mut lsp) = Copilot::fake(cx);\n\n        let buffer_1 = cx.new(|cx| Buffer::local(": "",
        ", cx));\n        let buffer_1_uri: lsp::Uri = format!(": "",
        ", buffer_1.entity_id().as_u64())\n            .parse()\n            .unwrap();\n        copilot.update(cx, |copilot, cx| copilot.register_buffer(&buffer_1, cx));\n        assert_eq!(\n            lsp.receive_notification::<lsp::notification::DidOpenTextDocument>()\n                .await,\n            lsp::DidOpenTextDocumentParams {\n                text_document: lsp::TextDocumentItem::new(\n                    buffer_1_uri.clone(),\n                    ": "",
        ".into(),\n                    0,\n                    ": "",
        ".into()\n                ),\n            }\n        );\n\n        let buffer_2 = cx.new(|cx| Buffer::local(": "",
        ", cx));\n        let buffer_2_uri: lsp::Uri = format!(": "",
        ", buffer_2.entity_id().as_u64())\n            .parse()\n            .unwrap();\n        copilot.update(cx, |copilot, cx| copilot.register_buffer(&buffer_2, cx));\n        assert_eq!(\n            lsp.receive_notification::<lsp::notification::DidOpenTextDocument>()\n                .await,\n            lsp::DidOpenTextDocumentParams {\n                text_document: lsp::TextDocumentItem::new(\n                    buffer_2_uri.clone(),\n                    ": "",
        ".into()\n                ),\n            }\n        );\n\n        buffer_1.update(cx, |buffer, cx| buffer.edit([(5..5, ": "",
        ")], None, cx));\n        assert_eq!(\n            lsp.receive_notification::<lsp::notification::DidChangeTextDocument>()\n                .await,\n            lsp::DidChangeTextDocumentParams {\n                text_document: lsp::VersionedTextDocumentIdentifier::new(buffer_1_uri.clone(), 1),\n                content_changes: vec![lsp::TextDocumentContentChangeEvent {\n                    range: Some(lsp::Range::new(\n                        lsp::Position::new(0, 5),\n                        lsp::Position::new(0, 5)\n                    )),\n                    range_length: None,\n                    text: ": "",
        ".into(),\n                }],\n            }\n        );\n\n        // Ensure updates to the file are reflected in the LSP.\n        buffer_1.update(cx, |buffer, cx| {\n            buffer.file_updated(\n                Arc::new(File {\n                    abs_path: path!(": "",
        ").into(),\n                    path: rel_path(": "",
        ").into(),\n                }),\n                cx,\n            )\n        });\n        assert_eq!(\n            lsp.receive_notification::<lsp::notification::DidCloseTextDocument>()\n                .await,\n            lsp::DidCloseTextDocumentParams {\n                text_document: lsp::TextDocumentIdentifier::new(buffer_1_uri),\n            }\n        );\n        let buffer_1_uri = lsp::Uri::from_file_path(path!(": "",
        ")).unwrap();\n        assert_eq!(\n            lsp.receive_notification::<lsp::notification::DidOpenTextDocument>()\n                .await,\n            lsp::DidOpenTextDocumentParams {\n                text_document: lsp::TextDocumentItem::new(\n                    buffer_1_uri.clone(),\n                    ": "",
        ".into(),\n                    1,\n                    ": "",
        ".into()\n                ),\n            }\n        );\n\n        // Ensure all previously-registered buffers are closed when signing out.\n        lsp.set_request_handler::<request::SignOut, _, _>(|_, _| async {\n            Ok(request::SignOutResult {})\n        });\n        copilot\n            .update(cx, |copilot, cx| copilot.sign_out(cx))\n            .await\n            .unwrap();\n        assert_eq!(\n            lsp.receive_notification::<lsp::notification::DidCloseTextDocument>()\n                .await,\n            lsp::DidCloseTextDocumentParams {\n                text_document: lsp::TextDocumentIdentifier::new(buffer_1_uri.clone()),\n            }\n        );\n        assert_eq!(\n            lsp.receive_notification::<lsp::notification::DidCloseTextDocument>()\n                .await,\n            lsp::DidCloseTextDocumentParams {\n                text_document: lsp::TextDocumentIdentifier::new(buffer_2_uri.clone()),\n            }\n        );\n\n        // Ensure all previously-registered buffers are re-opened when signing in.\n        lsp.set_request_handler::<request::SignInInitiate, _, _>(|_, _| async {\n            Ok(request::SignInInitiateResult::AlreadySignedIn {\n                user: ": "",
        ".into(),\n            })\n        });\n        copilot\n            .update(cx, |copilot, cx| copilot.sign_in(cx))\n            .await\n            .unwrap();\n\n        assert_eq!(\n            lsp.receive_notification::<lsp::notification::DidOpenTextDocument>()\n                .await,\n            lsp::DidOpenTextDocumentParams {\n                text_document: lsp::TextDocumentItem::new(\n                    buffer_1_uri.clone(),\n                    ": "",
        ".into()\n                ),\n            }\n        );\n        assert_eq!(\n            lsp.receive_notification::<lsp::notification::DidOpenTextDocument>()\n                .await,\n            lsp::DidOpenTextDocumentParams {\n                text_document: lsp::TextDocumentItem::new(\n                    buffer_2_uri.clone(),\n                    ": ""
    },
    "zed/crates/copilot/src/sign_in.rs": {
        "Copilot is reinstalling...": "",
        "Copilot is starting...": "",
        "Copilot has started.": "",
        "Signing out of Copilot...": "",
        "Signed out of Copilot.": "",
        "Copied!": "",
        "Copy": "",
        "Waiting for connection...": "",
        "Connect to GitHub": "",
        "Use GitHub Copilot in Zed.": "",
        "Using Copilot requires an active subscription on GitHub.": "",
        "Paste this code into GitHub after clicking the button below.": "",
        "connect-button": "",
        "copilot-enable-cancel-button": "",
        "Cancel": "",
        "Copilot Enabled!": "",
        "You can update your settings or sign out from the Copilot menu in the status bar.": "",
        "copilot-enabled-done-button": "",
        "Done": "",
        "You must have an active GitHub Copilot subscription.": "",
        "You can enable Copilot by connecting your existing license once you have subscribed or renewed your subscription.": "",
        "copilot-subscribe-button": "",
        "Subscribe on GitHub": "",
        "copilot-subscribe-cancel-button": "",
        "icon_circle_arrow": "",
        "copilot code verification": ""
    },
    "zed/crates/db/src/db.rs": {
        "FALLBACK_MEMORY_DB": "",
        "db.sqlite": "",
        "0-{}": "",
        "Could not create db directory": "",
        "Opening database {}": "",
        "Opening fallback in-memory database": "",
        "Fallback in memory database failed. Likely initialization queries or migrations have fundamental errors": "",
        "global": "",
        "db_tests": "",
        "DbTests": "",
        "SELECT * FROM test2": ""
    },
    "zed/crates/db/src/query.rs": {
        "Error in {}, exec failed to execute or parse for: {}": "",
        "Error in {}, exec_bound failed to execute or parse for: {}": "",
        "Error in {}, select_row failed to execute or parse for: {}": "",
        "Error in {}, select_row_bound failed to execute or parse for: {}": "",
        "Error in {}, select_row_bound expected single row result but found none for: {}": ""
    },
    "zed/crates/diagnostics/src/diagnostics_tests.rs": {
        "/test": "",
        "consts.rs": "",
        "\n                const a: i32 = 'a';\n                const b: i32 = c;\n            ": "",
        "main.rs": "",
        "\n                fn main() {\n                    let x = vec![];\n                    let y = vec![];\n                    a(x);\n                    b(y);\n                    // comment 1\n                    // comment 2\n                    c(y);\n                    d(x);\n                }\n            ": "",
        "use of moved value\\nvalue used here after move": "",
        "move occurs because `y` has type `Vec<char>`, which does not implement the `Copy` trait": "",
        "value moved here": "",
        "move occurs because `x` has type `Vec<char>`, which does not implement the `Copy` trait": "",
        "§ main.rs\n             § -----\n             fn main() {\n                 let x = vec![];\n             § move occurs because `x` has type `Vec<char>`, which does not implement\n             § the `Copy` trait (back)\n                 let y = vec![];\n             § move occurs because `y` has type `Vec<char>`, which does not implement\n             § the `Copy` trait (back)\n                 a(x); § value moved here (back)\n                 b(y); § value moved here\n                 // comment 1\n                 // comment 2\n                 c(y);\n             § use of moved value\n             § value used here after move\n             § hint: move occurs because `y` has type `Vec<char>`, which does not\n             § implement the `Copy` trait\n                 d(x);\n             § use of moved value\n             § value used here after move\n             § hint: move occurs because `x` has type `Vec<char>`, which does not\n             § implement the `Copy` trait\n             § hint: value moved here\n             }": "",
        "mismatched types expected `usize`, found `char`": "",
        "§ consts.rs\n             § -----\n             const a: i32 = 'a'; § mismatched types expected `usize`, found `char`\n             const b: i32 = c;\n\n             § main.rs\n             § -----\n             fn main() {\n                 let x = vec![];\n             § move occurs because `x` has type `Vec<char>`, which does not implement\n             § the `Copy` trait (back)\n                 let y = vec![];\n             § move occurs because `y` has type `Vec<char>`, which does not implement\n             § the `Copy` trait (back)\n                 a(x); § value moved here (back)\n                 b(y); § value moved here\n                 // comment 1\n                 // comment 2\n                 c(y);\n             § use of moved value\n             § value used here after move\n             § hint: move occurs because `y` has type `Vec<char>`, which does not\n             § implement the `Copy` trait\n                 d(x);\n             § use of moved value\n             § value used here after move\n             § hint: move occurs because `x` has type `Vec<char>`, which does not\n             § implement the `Copy` trait\n             § hint: value moved here\n             }": "",
        "unresolved name `c`": "",
        "§ consts.rs\n             § -----\n             const a: i32 = 'a'; § mismatched types expected `usize`, found `char`\n             const b: i32 = c; § unresolved name `c`\n\n             § main.rs\n             § -----\n             fn main() {\n                 let x = vec![];\n             § move occurs because `x` has type `Vec<char>`, which does not implement\n             § the `Copy` trait (back)\n                 let y = vec![];\n             § move occurs because `y` has type `Vec<char>`, which does not implement\n             § the `Copy` trait (back)\n                 a(x); § value moved here (back)\n                 b(y); § value moved here\n                 // comment 1\n                 // comment 2\n                 c(y);\n             § use of moved value\n             § value used here after move\n             § hint: move occurs because `y` has type `Vec<char>`, which does not\n             § implement the `Copy` trait\n                 d(x);\n             § use of moved value\n             § value used here after move\n             § hint: move occurs because `x` has type `Vec<char>`, which does not\n             § implement the `Copy` trait\n             § hint: value moved here\n             }": "",
        "main.js": "",
        "\n            function test() {\n                return 1\n            };\n\n            tset();\n            ": "",
        "no method `tset`": "",
        "method `test` defined here": "",
        "§ main.js\n             § -----\n             ⋯\n\n             tset(); § no method `tset`": "",
        "§ main.js\n             § -----\n             function test() { § method `test` defined here\n                 return 1\n             };\n\n             tset(); § no method `tset`": "",
        "\n                a();\n                b();\n                c();\n                d();\n                e();\n            ": "",
        "error 1": "",
        "§ main.js\n             § -----\n             a(); § error 1\n             b();\n             c();": "",
        "warning 1": "",
        "§ main.js\n             § -----\n             a(); § error 1\n             b(); § warning 1\n             c();\n             d();": "",
        "warning 2": "",
        "§ main.js\n             § -----\n             a();\n             b(); § warning 1\n             c(); § warning 2\n             d();\n             e();": "",
        "§ main.js\n                 § -----\n                 a();\n                 b();\n                 c(); § warning 2\n                 d(); § warning 2\n                 e();": "",
        "OPERATIONS": "",
        "invalid `OPERATIONS` variable": "",
        "finishing diagnostic check for language server {server_id}": "",
        "updating diagnostics. language server {server_id} path {path:?}": "",
        "file:///test/fallback.rs": "",
        "updating mutated diagnostics view": "",
        "constructing reference diagnostics view": "",
        "§ diagnostic": "",
        "§ related info": "",
        "adding inlay at {position}/{}: {:?}": "",
        "Test inlay ": "",
        "next_inlay_id": "",
        "\n        ˇfn func(abc def: i32) -> u32 {\n        }\n    ": "",
        "Something's wrong!": "",
        "/root/file": "",
        "Should have a diagnostics group activated": "",
        "\n        fn func(abcˇ def: i32) -> u32 {\n        }\n    ": "",
        "\n        fn func(abc def: i32) -> ˇu32 {\n        }\n    ": "",
        "\n        fn func(abc ˇdef: i32) -> u32 {\n        }\n    ": "",
        "\n        fn func(abˇc def: i32) -> u32 {\n        }\n    ": "",
        "we've had problems with <https://link.one>, and <https://link.two> is broken": "",
        "\n        fn teˇst() { println!(); }\n    ": "",
        "\n        fn «test»() { println!(); }\n    ": "",
        "A test diagnostic message.": "",
        "\n            fn «test»() { println!(); }\n        ": "",
        "some new docs": "",
        "/root": "",
        "\n                function test() {\n                    const x = 10;\n                    const y = 20;\n                    return 1;\n                }\n                test();\n            ": "",
        "no-unused-vars": "",
        "eslint": "",
        "'x' is assigned a value but never used": "",
        "'y' is assigned a value but never used": "",
        "§ main.js\n             § -----\n             function test() {\n                 const x = 10; § 'x' is assigned a value but never used (eslint no-unused-vars)\n                 const y = 20; § 'y' is assigned a value but never used (eslint no-unused-vars)\n                 return 1;\n             }": "",
        "error warning info hiˇnt": "",
        "ˇerror warning info hint": "",
        "error ˇwarning info hint": "",
        "error warning ˇinfo hint": "",
        "error warning info ˇhint": "",
        "\n                fn main() {\n                    let x = vec![];\n                    let y = vec![];\n                    a(x);\n                    b(y);\n                    c(y);\n                    d(x);\n                }\n            ": "",
        "other.rs": "",
        "\n                fn other() {\n                    let unused = 42;\n                    undefined_function();\n                }\n            ": "",
        "unused variable: `unused`": "",
        "cannot find function `undefined_function` in this scope": "",
        "§ main.rs\n             § -----\n             fn main() {\n                 let x = vec![];\n             § move occurs because `x` has type `Vec<char>`, which does not implement\n             § the `Copy` trait (back)\n                 let y = vec![];\n             § move occurs because `y` has type `Vec<char>`, which does not implement\n             § the `Copy` trait\n                 a(x); § value moved here\n                 b(y); § value moved here\n                 c(y);\n             § use of moved value\n             § value used here after move\n                 d(x);\n             § use of moved value\n             § value used here after move\n             § hint: move occurs because `x` has type `Vec<char>`, which does not\n             § implement the `Copy` trait\n             }": "",
        "§ main.rs\n             § -----\n             fn main() {\n                 let x = vec![];\n             § move occurs because `x` has type `Vec<char>`, which does not implement\n             § the `Copy` trait (back)\n                 let y = vec![];\n                 a(x); § value moved here\n                 b(y);\n                 c(y);\n                 d(x);\n             § use of moved value\n             § value used here after move\n             § hint: move occurs because `x` has type `Vec<char>`, which does not\n             § implement the `Copy` trait\n             }": "",
        "§ main.rs\n             § -----\n                 a(x);\n                 b(y);\n                 c(y);\n             § use of moved value\n             § value used here after move\n                 d(x);\n             § use of moved value\n             § value used here after move\n             }": "",
        "  removing diagnostic at index {idx}": "",
        "  inserting {} at index {ix}. {},{}..{},{}": "",
        "   {}. {},{}..{},{}": "",
        "diagnostic {unique_id}": "",
        "related info {i} for diagnostic {unique_id}": ""
    },
    "zed/crates/diagnostics/src/diagnostics.rs": {
        "No problems in workspace": "",
        "No errors in workspace": "",
        "EmptyPane": "",
        "s": "",
        "Show {} warning{}": "",
        "diagnostics-show-warning-label": "",
        "Diagnostics": "",
        "disk based diagnostics finished for server {language_server_id}": "",
        "\n                    );\n                    this.update_stale_excerpts(window, cx);\n                }\n                _ => {}\n            },\n        );\n\n        let focus_handle = cx.focus_handle();\n        cx.on_focus_in(&focus_handle, window, Self::focus_in)\n            .detach();\n        cx.on_focus_out(&focus_handle, window, Self::focus_out)\n            .detach();\n\n        let excerpts = cx.new(|cx| MultiBuffer::new(project_handle.read(cx).capability()));\n        let editor = cx.new(|cx| {\n            let mut editor =\n                Editor::for_multibuffer(excerpts.clone(), Some(project_handle.clone()), window, cx);\n            editor.set_vertical_scroll_margin(5, cx);\n            editor.disable_inline_diagnostics();\n            editor.set_max_diagnostics_severity(\n                if include_warnings {\n                    DiagnosticSeverity::Warning\n                } else {\n                    DiagnosticSeverity::Error\n                },\n                cx,\n            );\n            editor.set_all_diagnostics_active(cx);\n            editor\n        });\n        cx.subscribe_in(\n            &editor,\n            window,\n            |this, _editor, event: &EditorEvent, window, cx| {\n                cx.emit(event.clone());\n                match event {\n                    EditorEvent::Focused => {\n                        if this.multibuffer.read(cx).is_empty() {\n                            window.focus(&this.focus_handle);\n                        }\n                    }\n                    EditorEvent::Blurred => this.close_diagnosticless_buffers(window, cx, false),\n                    EditorEvent::Saved => this.close_diagnosticless_buffers(window, cx, true),\n                    EditorEvent::SelectionsChanged { .. } => {\n                        this.close_diagnosticless_buffers(window, cx, true)\n                    }\n                    _ => {}\n                }\n            },\n        )\n        .detach();\n        cx.observe_global_in::<IncludeWarnings>(window, |this, window, cx| {\n            let include_warnings = cx.global::<IncludeWarnings>().0;\n            this.include_warnings = include_warnings;\n            this.editor.update(cx, |editor, cx| {\n                editor.set_max_diagnostics_severity(\n                    if include_warnings {\n                        DiagnosticSeverity::Warning\n                    } else {\n                        DiagnosticSeverity::Error\n                    },\n                    cx,\n                )\n            });\n            this.refresh(window, cx);\n        })\n        .detach();\n\n        let project = project_handle.read(cx);\n        let mut this = Self {\n            project: project_handle.clone(),\n            summary: project.diagnostic_summary(false, cx),\n            diagnostics: Default::default(),\n            blocks: Default::default(),\n            include_warnings,\n            workspace,\n            multibuffer: excerpts,\n            focus_handle,\n            editor,\n            paths_to_update: Default::default(),\n            update_excerpts_task: None,\n            diagnostic_summary_update: Task::ready(()),\n            _subscription: project_event_subscription,\n        };\n        this.refresh(window, cx);\n        this\n    }\n\n    /// Closes all excerpts of buffers that:\n    ///  - have no diagnostics anymore\n    ///  - are saved (not dirty)\n    ///  - and, if `retain_selections` is true, do not have selections within them\n    fn close_diagnosticless_buffers(\n        &mut self,\n        _window: &mut Window,\n        cx: &mut Context<Self>,\n        retain_selections: bool,\n    ) {\n        let snapshot = self\n            .editor\n            .update(cx, |editor, cx| editor.display_snapshot(cx));\n        let buffer = self.multibuffer.read(cx);\n        let buffer_ids = buffer.all_buffer_ids();\n        let selected_buffers = self.editor.update(cx, |editor, _| {\n            editor\n                .selections\n                .all_anchors(&snapshot)\n                .iter()\n                .filter_map(|anchor| anchor.start.buffer_id)\n                .collect::<HashSet<_>>()\n        });\n        for buffer_id in buffer_ids {\n            if retain_selections && selected_buffers.contains(&buffer_id) {\n                continue;\n            }\n            let has_no_blocks = self\n                .blocks\n                .get(&buffer_id)\n                .is_none_or(|blocks| blocks.is_empty());\n            if !has_no_blocks {\n                continue;\n            }\n            let is_dirty = self\n                .multibuffer\n                .read(cx)\n                .buffer(buffer_id)\n                .is_none_or(|buffer| buffer.read(cx).is_dirty());\n            if is_dirty {\n                continue;\n            }\n            self.multibuffer.update(cx, |b, cx| {\n                b.remove_excerpts_for_buffer(buffer_id, cx);\n            });\n        }\n    }\n\n    fn update_stale_excerpts(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n        if self.update_excerpts_task.is_some() {\n            return;\n        }\n\n        let project_handle = self.project.clone();\n        self.update_excerpts_task = Some(cx.spawn_in(window, async move |this, cx| {\n            cx.background_executor()\n                .timer(DIAGNOSTICS_UPDATE_DEBOUNCE)\n                .await;\n            loop {\n                let Some(path) = this.update(cx, |this, cx| {\n                    let Some(path) = this.paths_to_update.pop_first() else {\n                        this.update_excerpts_task = None;\n                        cx.notify();\n                        return None;\n                    };\n                    Some(path)\n                })?\n                else {\n                    break;\n                };\n\n                if let Some(buffer) = project_handle\n                    .update(cx, |project, cx| project.open_buffer(path.clone(), cx))?\n                    .await\n                    .log_err()\n                {\n                    this.update_in(cx, |this, window, cx| {\n                        let focused = this.editor.focus_handle(cx).contains_focused(window, cx)\n                            || this.focus_handle.contains_focused(window, cx);\n                        let retain_excerpts = if focused {\n                            RetainExcerpts::All\n                        } else {\n                            RetainExcerpts::Dirty\n                        };\n                        this.update_excerpts(buffer, retain_excerpts, window, cx)\n                    })?\n                    .await?;\n                }\n            }\n            Ok(())\n        }));\n    }\n\n    fn deploy(\n        workspace: &mut Workspace,\n        _: &Deploy,\n        window: &mut Window,\n        cx: &mut Context<Workspace>,\n    ) {\n        if let Some(existing) = workspace.item_of_type::<ProjectDiagnosticsEditor>(cx) {\n            let is_active = workspace\n                .active_item(cx)\n                .is_some_and(|item| item.item_id() == existing.item_id());\n\n            workspace.activate_item(&existing, true, !is_active, window, cx);\n        } else {\n            let workspace_handle = cx.entity().downgrade();\n\n            let include_warnings = match cx.try_global::<IncludeWarnings>() {\n                Some(include_warnings) => include_warnings.0,\n                None => ProjectSettings::get_global(cx).diagnostics.include_warnings,\n            };\n\n            let diagnostics = cx.new(|cx| {\n                ProjectDiagnosticsEditor::new(\n                    include_warnings,\n                    workspace.project().clone(),\n                    workspace_handle,\n                    window,\n                    cx,\n                )\n            });\n            workspace.add_item_to_active_pane(Box::new(diagnostics), None, true, window, cx);\n        }\n    }\n\n    fn toggle_warnings(&mut self, _: &ToggleWarnings, _: &mut Window, cx: &mut Context<Self>) {\n        cx.set_global(IncludeWarnings(!self.include_warnings));\n    }\n\n    fn toggle_diagnostics_refresh(\n        &mut self,\n        _: &ToggleDiagnosticsRefresh,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if self.update_excerpts_task.is_some() {\n            self.update_excerpts_task = None;\n        } else {\n            self.refresh(window, cx);\n        }\n        cx.notify();\n    }\n\n    fn focus_in(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n        if self.focus_handle.is_focused(window) && !self.multibuffer.read(cx).is_empty() {\n            self.editor.focus_handle(cx).focus(window)\n        }\n    }\n\n    fn focus_out(&mut self, _: FocusOutEvent, window: &mut Window, cx: &mut Context<Self>) {\n        if !self.focus_handle.is_focused(window) && !self.editor.focus_handle(cx).is_focused(window)\n        {\n            self.close_diagnosticless_buffers(window, cx, false);\n        }\n    }\n\n    /// Clears all diagnostics in this view, and refetches them from the project.\n    fn refresh(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n        self.diagnostics.clear();\n        self.editor.update(cx, |editor, cx| {\n            for (_, block_ids) in self.blocks.drain() {\n                editor.display_map.update(cx, |display_map, cx| {\n                    display_map.remove_blocks(block_ids.into_iter().collect(), cx)\n                });\n            }\n        });\n        self.multibuffer\n            .update(cx, |multibuffer, cx| multibuffer.clear(cx));\n        self.project.update(cx, |project, cx| {\n            self.paths_to_update = project\n                .diagnostic_summaries(false, cx)\n                .map(|(project_path, _, _)| project_path)\n                .collect::<BTreeSet<_>>();\n        });\n\n        self.update_stale_excerpts(window, cx);\n    }\n\n    fn diagnostics_are_unchanged(\n        &self,\n        existing: &[DiagnosticEntry<text::Anchor>],\n        new: &[DiagnosticEntryRef<'_, text::Anchor>],\n        snapshot: &BufferSnapshot,\n    ) -> bool {\n        if existing.len() != new.len() {\n            return false;\n        }\n        existing.iter().zip(new.iter()).all(|(existing, new)| {\n            existing.diagnostic.message == new.diagnostic.message\n                && existing.diagnostic.severity == new.diagnostic.severity\n                && existing.diagnostic.is_primary == new.diagnostic.is_primary\n                && existing.range.to_offset(snapshot) == new.range.to_offset(snapshot)\n        })\n    }\n\n    fn update_excerpts(\n        &mut self,\n        buffer: Entity<Buffer>,\n        retain_excerpts: RetainExcerpts,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<()>> {\n        let was_empty = self.multibuffer.read(cx).is_empty();\n        let mut buffer_snapshot = buffer.read(cx).snapshot();\n        let buffer_id = buffer_snapshot.remote_id();\n\n        let max_severity = if self.include_warnings {\n            lsp::DiagnosticSeverity::WARNING\n        } else {\n            lsp::DiagnosticSeverity::ERROR\n        };\n\n        cx.spawn_in(window, async move |this, cx| {\n            let diagnostics = buffer_snapshot\n                .diagnostics_in_range::<_, text::Anchor>(\n                    Point::zero()..buffer_snapshot.max_point(),\n                    false,\n                )\n                .collect::<Vec<_>>();\n\n            let unchanged = this.update(cx, |this, _| {\n                if this.diagnostics.get(&buffer_id).is_some_and(|existing| {\n                    this.diagnostics_are_unchanged(existing, &diagnostics, &buffer_snapshot)\n                }) {\n                    return true;\n                }\n                this.diagnostics.insert(\n                    buffer_id,\n                    diagnostics\n                        .iter()\n                        .map(DiagnosticEntryRef::to_owned)\n                        .collect(),\n                );\n                false\n            })?;\n            if unchanged {\n                return Ok(());\n            }\n\n            let mut grouped: HashMap<usize, Vec<_>> = HashMap::default();\n            for entry in diagnostics {\n                grouped\n                    .entry(entry.diagnostic.group_id)\n                    .or_default()\n                    .push(DiagnosticEntryRef {\n                        range: entry.range.to_point(&buffer_snapshot),\n                        diagnostic: entry.diagnostic,\n                    })\n            }\n            let mut blocks: Vec<DiagnosticBlock> = Vec::new();\n\n            let diagnostics_toolbar_editor = Arc::new(this.clone());\n            for (_, group) in grouped {\n                let group_severity = group.iter().map(|d| d.diagnostic.severity).min();\n                if group_severity.is_none_or(|s| s > max_severity) {\n                    continue;\n                }\n                let more = cx.update(|_, cx| {\n                    crate::diagnostic_renderer::DiagnosticRenderer::diagnostic_blocks_for_group(\n                        group,\n                        buffer_snapshot.remote_id(),\n                        Some(diagnostics_toolbar_editor.clone()),\n                        cx,\n                    )\n                })?;\n\n                blocks.extend(more);\n            }\n\n            let cmp_excerpts = |buffer_snapshot: &BufferSnapshot,\n                                a: &ExcerptRange<text::Anchor>,\n                                b: &ExcerptRange<text::Anchor>| {\n                let context_start = || a.context.start.cmp(&b.context.start, buffer_snapshot);\n                let context_end = || a.context.end.cmp(&b.context.end, buffer_snapshot);\n                let primary_start = || a.primary.start.cmp(&b.primary.start, buffer_snapshot);\n                let primary_end = || a.primary.end.cmp(&b.primary.end, buffer_snapshot);\n                context_start()\n                    .then_with(context_end)\n                    .then_with(primary_start)\n                    .then_with(primary_end)\n                    .then(cmp::Ordering::Greater)\n            };\n\n            let mut excerpt_ranges: Vec<ExcerptRange<_>> = this.update(cx, |this, cx| {\n                this.multibuffer.update(cx, |multi_buffer, cx| {\n                    let is_dirty = multi_buffer\n                        .buffer(buffer_id)\n                        .is_none_or(|buffer| buffer.read(cx).is_dirty());\n                    match retain_excerpts {\n                        RetainExcerpts::Dirty if !is_dirty => Vec::new(),\n                        RetainExcerpts::All | RetainExcerpts::Dirty => multi_buffer\n                            .excerpts_for_buffer(buffer_id, cx)\n                            .into_iter()\n                            .map(|(_, range)| range)\n                            .sorted_by(|a, b| cmp_excerpts(&buffer_snapshot, a, b))\n                            .collect(),\n                    }\n                })\n            })?;\n\n            let mut result_blocks = vec![None; excerpt_ranges.len()];\n            let context_lines = cx.update(|_, cx| multibuffer_context_lines(cx))?;\n            for b in blocks {\n                let excerpt_range = context_range_for_entry(\n                    b.initial_range.clone(),\n                    context_lines,\n                    buffer_snapshot.clone(),\n                    cx,\n                )\n                .await;\n                buffer_snapshot = cx.update(|_, cx| buffer.read(cx).snapshot())?;\n                let initial_range = buffer_snapshot.anchor_after(b.initial_range.start)\n                    ..buffer_snapshot.anchor_before(b.initial_range.end);\n                let excerpt_range = ExcerptRange {\n                    context: excerpt_range,\n                    primary: initial_range,\n                };\n                let i = excerpt_ranges\n                    .binary_search_by(|probe| cmp_excerpts(&buffer_snapshot, probe, &excerpt_range))\n                    .unwrap_or_else(|i| i);\n                excerpt_ranges.insert(i, excerpt_range);\n                result_blocks.insert(i, Some(b));\n            }\n\n            this.update_in(cx, |this, window, cx| {\n                if let Some(block_ids) = this.blocks.remove(&buffer_id) {\n                    this.editor.update(cx, |editor, cx| {\n                        editor.display_map.update(cx, |display_map, cx| {\n                            display_map.remove_blocks(block_ids.into_iter().collect(), cx)\n                        });\n                    })\n                }\n                let (anchor_ranges, _) = this.multibuffer.update(cx, |multi_buffer, cx| {\n                    let excerpt_ranges = excerpt_ranges\n                        .into_iter()\n                        .map(|range| ExcerptRange {\n                            context: range.context.to_point(&buffer_snapshot),\n                            primary: range.primary.to_point(&buffer_snapshot),\n                        })\n                        .collect();\n                    multi_buffer.set_excerpt_ranges_for_path(\n                        PathKey::for_buffer(&buffer, cx),\n                        buffer.clone(),\n                        &buffer_snapshot,\n                        excerpt_ranges,\n                        cx,\n                    )\n                });\n                #[cfg(test)]\n                let cloned_blocks = result_blocks.clone();\n\n                if was_empty && let Some(anchor_range) = anchor_ranges.first() {\n                    let range_to_select = anchor_range.start..anchor_range.start;\n                    this.editor.update(cx, |editor, cx| {\n                        editor.change_selections(Default::default(), window, cx, |s| {\n                            s.select_anchor_ranges([range_to_select]);\n                        })\n                    });\n                    if this.focus_handle.is_focused(window) {\n                        this.editor.read(cx).focus_handle(cx).focus(window);\n                    }\n                }\n\n                let editor_blocks = anchor_ranges\n                    .into_iter()\n                    .zip_eq(result_blocks.into_iter())\n                    .filter_map(|(anchor, block)| {\n                        let block = block?;\n                        let editor = this.editor.downgrade();\n                        Some(BlockProperties {\n                            placement: BlockPlacement::Near(anchor.start),\n                            height: Some(1),\n                            style: BlockStyle::Flex,\n                            render: Arc::new(move |bcx| block.render_block(editor.clone(), bcx)),\n                            priority: 1,\n                        })\n                    });\n\n                let block_ids = this.editor.update(cx, |editor, cx| {\n                    editor.display_map.update(cx, |display_map, cx| {\n                        display_map.insert_blocks(editor_blocks, cx)\n                    })\n                });\n\n                #[cfg(test)]\n                {\n                    for (block_id, block) in\n                        block_ids.iter().zip(cloned_blocks.into_iter().flatten())\n                    {\n                        let markdown = block.markdown.clone();\n                        editor::test::set_block_content_for_tests(\n                            &this.editor,\n                            *block_id,\n                            cx,\n                            move |cx| {\n                                markdown::MarkdownElement::rendered_text(\n                                    markdown.clone(),\n                                    cx,\n                                    editor::hover_popover::diagnostics_markdown_style,\n                                )\n                            },\n                        );\n                    }\n                }\n\n                this.blocks.insert(buffer_id, block_ids);\n                cx.notify()\n            })\n        })\n    }\n\n    fn update_diagnostic_summary(&mut self, cx: &mut Context<Self>) {\n        self.summary = self.project.read(cx).diagnostic_summary(false, cx);\n        cx.emit(EditorEvent::TitleChanged);\n    }\n}\n\nimpl Focusable for ProjectDiagnosticsEditor {\n    fn focus_handle(&self, _: &App) -> FocusHandle {\n        self.focus_handle.clone()\n    }\n}\n\nimpl Item for ProjectDiagnosticsEditor {\n    type Event = EditorEvent;\n\n    fn to_item_events(event: &EditorEvent, f: impl FnMut(ItemEvent)) {\n        Editor::to_item_events(event, f)\n    }\n\n    fn deactivated(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n        self.editor\n            .update(cx, |editor, cx| editor.deactivated(window, cx));\n    }\n\n    fn navigate(\n        &mut self,\n        data: Box<dyn Any>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> bool {\n        self.editor\n            .update(cx, |editor, cx| editor.navigate(data, window, cx))\n    }\n\n    fn tab_tooltip_text(&self, _: &App) -> Option<SharedString> {\n        Some(": "",
        ".into())\n    }\n\n    fn tab_content_text(&self, _detail: usize, _: &App) -> SharedString {\n        ": "",
        ".into()\n    }\n\n    fn tab_content(&self, params: TabContentParams, _window: &Window, _: &App) -> AnyElement {\n        h_flex()\n            .gap_1()\n            .when(\n                self.summary.error_count == 0 && self.summary.warning_count == 0,\n                |then| {\n                    then.child(\n                        h_flex()\n                            .gap_1()\n                            .child(Icon::new(IconName::Check).color(Color::Success))\n                            .child(Label::new(": "",
        ").color(params.text_color())),\n                    )\n                },\n            )\n            .when(self.summary.error_count > 0, |then| {\n                then.child(\n                    h_flex()\n                        .gap_1()\n                        .child(Icon::new(IconName::XCircle).color(Color::Error))\n                        .child(\n                            Label::new(self.summary.error_count.to_string())\n                                .color(params.text_color()),\n                        ),\n                )\n            })\n            .when(self.summary.warning_count > 0, |then| {\n                then.child(\n                    h_flex()\n                        .gap_1()\n                        .child(Icon::new(IconName::Warning).color(Color::Warning))\n                        .child(\n                            Label::new(self.summary.warning_count.to_string())\n                                .color(params.text_color()),\n                        ),\n                )\n            })\n            .into_any_element()\n    }\n\n    fn telemetry_event_text(&self) -> Option<&'static str> {\n        Some(": "",
        ")\n    }\n\n    fn for_each_project_item(\n        &self,\n        cx: &App,\n        f: &mut dyn FnMut(gpui::EntityId, &dyn project::ProjectItem),\n    ) {\n        self.editor.for_each_project_item(cx, f)\n    }\n\n    fn set_nav_history(\n        &mut self,\n        nav_history: ItemNavHistory,\n        _: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.editor.update(cx, |editor, _| {\n            editor.set_nav_history(Some(nav_history));\n        });\n    }\n\n    fn can_split(&self) -> bool {\n        true\n    }\n\n    fn clone_on_split(\n        &self,\n        _workspace_id: Option<workspace::WorkspaceId>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Task<Option<Entity<Self>>>\n    where\n        Self: Sized,\n    {\n        Task::ready(Some(cx.new(|cx| {\n            ProjectDiagnosticsEditor::new(\n                self.include_warnings,\n                self.project.clone(),\n                self.workspace.clone(),\n                window,\n                cx,\n            )\n        })))\n    }\n\n    fn is_dirty(&self, cx: &App) -> bool {\n        self.multibuffer.read(cx).is_dirty(cx)\n    }\n\n    fn has_deleted_file(&self, cx: &App) -> bool {\n        self.multibuffer.read(cx).has_deleted_file(cx)\n    }\n\n    fn has_conflict(&self, cx: &App) -> bool {\n        self.multibuffer.read(cx).has_conflict(cx)\n    }\n\n    fn can_save(&self, _: &App) -> bool {\n        true\n    }\n\n    fn save(\n        &mut self,\n        options: SaveOptions,\n        project: Entity<Project>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<()>> {\n        self.editor.save(options, project, window, cx)\n    }\n\n    fn save_as(\n        &mut self,\n        _: Entity<Project>,\n        _: ProjectPath,\n        _window: &mut Window,\n        _: &mut Context<Self>,\n    ) -> Task<Result<()>> {\n        unreachable!()\n    }\n\n    fn reload(\n        &mut self,\n        project: Entity<Project>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<()>> {\n        self.editor.reload(project, window, cx)\n    }\n\n    fn act_as_type<'a>(\n        &'a self,\n        type_id: TypeId,\n        self_handle: &'a Entity<Self>,\n        _: &'a App,\n    ) -> Option<AnyView> {\n        if type_id == TypeId::of::<Self>() {\n            Some(self_handle.to_any())\n        } else if type_id == TypeId::of::<Editor>() {\n            Some(self.editor.to_any())\n        } else {\n            None\n        }\n    }\n\n    fn as_searchable(&self, _: &Entity<Self>) -> Option<Box<dyn SearchableItemHandle>> {\n        Some(Box::new(self.editor.clone()))\n    }\n\n    fn breadcrumb_location(&self, _: &App) -> ToolbarItemLocation {\n        ToolbarItemLocation::PrimaryLeft\n    }\n\n    fn breadcrumbs(&self, theme: &theme::Theme, cx: &App) -> Option<Vec<BreadcrumbText>> {\n        self.editor.breadcrumbs(theme, cx)\n    }\n\n    fn added_to_workspace(\n        &mut self,\n        workspace: &mut Workspace,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.editor.update(cx, |editor, cx| {\n            editor.added_to_workspace(workspace, window, cx)\n        });\n    }\n}\n\nimpl DiagnosticsToolbarEditor for WeakEntity<ProjectDiagnosticsEditor> {\n    fn include_warnings(&self, cx: &App) -> bool {\n        self.read_with(cx, |project_diagnostics_editor, _cx| {\n            project_diagnostics_editor.include_warnings\n        })\n        .unwrap_or(false)\n    }\n\n    fn is_updating(&self, cx: &App) -> bool {\n        self.read_with(cx, |project_diagnostics_editor, cx| {\n            project_diagnostics_editor.update_excerpts_task.is_some()\n                || project_diagnostics_editor\n                    .project\n                    .read(cx)\n                    .language_servers_running_disk_based_diagnostics(cx)\n                    .next()\n                    .is_some()\n        })\n        .unwrap_or(false)\n    }\n\n    fn stop_updating(&self, cx: &mut App) {\n        let _ = self.update(cx, |project_diagnostics_editor, cx| {\n            project_diagnostics_editor.update_excerpts_task = None;\n            cx.notify();\n        });\n    }\n\n    fn refresh_diagnostics(&self, window: &mut Window, cx: &mut App) {\n        let _ = self.update(cx, |project_diagnostics_editor, cx| {\n            project_diagnostics_editor.refresh(window, cx);\n        });\n    }\n\n    fn toggle_warnings(&self, window: &mut Window, cx: &mut App) {\n        let _ = self.update(cx, |project_diagnostics_editor, cx| {\n            project_diagnostics_editor.toggle_warnings(&Default::default(), window, cx);\n        });\n    }\n\n    fn get_diagnostics_for_buffer(\n        &self,\n        buffer_id: text::BufferId,\n        cx: &App,\n    ) -> Vec<language::DiagnosticEntry<text::Anchor>> {\n        self.read_with(cx, |project_diagnostics_editor, _cx| {\n            project_diagnostics_editor\n                .diagnostics\n                .get(&buffer_id)\n                .cloned()\n                .unwrap_or_default()\n        })\n        .unwrap_or_default()\n    }\n}\nconst DIAGNOSTIC_EXPANSION_ROW_LIMIT: u32 = 32;\n\nasync fn context_range_for_entry(\n    range: Range<Point>,\n    context: u32,\n    snapshot: BufferSnapshot,\n    cx: &mut AsyncApp,\n) -> Range<text::Anchor> {\n    let range = if let Some(rows) = heuristic_syntactic_expand(\n        range.clone(),\n        DIAGNOSTIC_EXPANSION_ROW_LIMIT,\n        snapshot.clone(),\n        cx,\n    )\n    .await\n    {\n        Range {\n            start: Point::new(*rows.start(), 0),\n            end: snapshot.clip_point(Point::new(*rows.end(), u32::MAX), Bias::Left),\n        }\n    } else {\n        Range {\n            start: Point::new(range.start.row.saturating_sub(context), 0),\n            end: snapshot.clip_point(Point::new(range.end.row + context, u32::MAX), Bias::Left),\n        }\n    };\n    snapshot.anchor_after(range.start)..snapshot.anchor_before(range.end)\n}\n\n/// Expands the input range using syntax information from TreeSitter. This expansion will be limited\n/// to the specified `max_row_count`.\n///\n/// If there is a containing outline item that is less than `max_row_count`, it will be returned.\n/// Otherwise fairly arbitrary heuristics are applied to attempt to return a logical block of code.\nasync fn heuristic_syntactic_expand(\n    input_range: Range<Point>,\n    max_row_count: u32,\n    snapshot: BufferSnapshot,\n    cx: &mut AsyncApp,\n) -> Option<RangeInclusive<BufferRow>> {\n    let input_row_count = input_range.end.row - input_range.start.row;\n    if input_row_count > max_row_count {\n        return None;\n    }\n\n    // If the outline node contains the diagnostic and is small enough, just use that.\n    let outline_range = snapshot.outline_range_containing(input_range.clone());\n    if let Some(outline_range) = outline_range.clone() {\n        // Remove blank lines from start and end\n        if let Some(start_row) = (outline_range.start.row..outline_range.end.row)\n            .find(|row| !snapshot.line_indent_for_row(*row).is_line_blank())\n            && let Some(end_row) = (outline_range.start.row..outline_range.end.row + 1)\n                .rev()\n                .find(|row| !snapshot.line_indent_for_row(*row).is_line_blank())\n        {\n            let row_count = end_row.saturating_sub(start_row);\n            if row_count <= max_row_count {\n                return Some(RangeInclusive::new(\n                    outline_range.start.row,\n                    outline_range.end.row,\n                ));\n            }\n        }\n    }\n\n    let mut node = snapshot.syntax_ancestor(input_range.clone())?;\n\n    loop {\n        let node_start = Point::from_ts_point(node.start_position());\n        let node_end = Point::from_ts_point(node.end_position());\n        let node_range = node_start..node_end;\n        let row_count = node_end.row - node_start.row + 1;\n        let mut ancestor_range = None;\n        let reached_outline_node = cx.background_executor().scoped({\n            let node_range = node_range.clone();\n            let outline_range = outline_range.clone();\n            let ancestor_range = &mut ancestor_range;\n            |scope| {\n                scope.spawn(async move {\n                    // Stop if we've exceeded the row count or reached an outline node. Then, find the interval\n                    // of node children which contains the query range. For example, this allows just returning\n                    // the header of a declaration rather than the entire declaration.\n                    if row_count > max_row_count || outline_range == Some(node_range.clone()) {\n                        let mut cursor = node.walk();\n                        let mut included_child_start = None;\n                        let mut included_child_end = None;\n                        let mut previous_end = node_start;\n                        if cursor.goto_first_child() {\n                            loop {\n                                let child_node = cursor.node();\n                                let child_range =\n                                    previous_end..Point::from_ts_point(child_node.end_position());\n                                if included_child_start.is_none()\n                                    && child_range.contains(&input_range.start)\n                                {\n                                    included_child_start = Some(child_range.start);\n                                }\n                                if child_range.contains(&input_range.end) {\n                                    included_child_end = Some(child_range.end);\n                                }\n                                previous_end = child_range.end;\n                                if !cursor.goto_next_sibling() {\n                                    break;\n                                }\n                            }\n                        }\n                        let end = included_child_end.unwrap_or(node_range.end);\n                        if let Some(start) = included_child_start {\n                            let row_count = end.row - start.row;\n                            if row_count < max_row_count {\n                                *ancestor_range =\n                                    Some(Some(RangeInclusive::new(start.row, end.row)));\n                                return;\n                            }\n                        }\n                        *ancestor_range = Some(None);\n                    }\n                })\n            }\n        });\n        reached_outline_node.await;\n        if let Some(node) = ancestor_range {\n            return node;\n        }\n\n        let node_name = node.grammar_name();\n        let node_row_range = RangeInclusive::new(node_range.start.row, node_range.end.row);\n        if node_name.ends_with(": "",
        ") {\n            return Some(node_row_range);\n        } else if node_name.ends_with(": "",
        ") || node_name.ends_with(": "",
        ") {\n            // Expand to the nearest dedent or blank line for statements and declarations.\n            let tab_size = cx\n                .update(|cx| snapshot.settings_at(node_range.start, cx).tab_size.get())\n                .ok()?;\n            let indent_level = snapshot\n                .line_indent_for_row(node_range.start.row)\n                .len(tab_size);\n            let rows_remaining = max_row_count.saturating_sub(row_count);\n            let Some(start_row) = (node_range.start.row.saturating_sub(rows_remaining)\n                ..node_range.start.row)\n                .rev()\n                .find(|row| {\n                    is_line_blank_or_indented_less(indent_level, *row, tab_size, &snapshot.clone())\n                })\n            else {\n                return Some(node_row_range);\n            };\n            let rows_remaining = max_row_count.saturating_sub(node_range.end.row - start_row);\n            let Some(end_row) = (node_range.end.row + 1\n                ..cmp::min(\n                    node_range.end.row + rows_remaining + 1,\n                    snapshot.row_count(),\n                ))\n                .find(|row| {\n                    is_line_blank_or_indented_less(indent_level, *row, tab_size, &snapshot.clone())\n                })\n            else {\n                return Some(node_row_range);\n            };\n            return Some(RangeInclusive::new(start_row, end_row));\n        }\n\n        // TODO: doing this instead of walking a cursor as that doesn't work - why?\n        let Some(parent) = node.parent() else {\n            log::info!(\n                ": ""
    },
    "zed/crates/diagnostics/src/items.rs": {
        "diagnostic_message": "",
        "Next Diagnostic": "",
        "diagnostic-indicator": "",
        "Project Diagnostics": ""
    },
    "zed/crates/diagnostics/src/toolbar_controls.rs": {
        "Exclude Warnings": "",
        "Include Warnings": "",
        "stop-updating": "",
        "Stop diagnostics update": "",
        "refresh-diagnostics": "",
        "Refresh diagnostics": "",
        "toggle-warnings": ""
    },
    "zed/crates/docs_preprocessor/src/main.rs": {
        "keymaps/default-macos.json": "",
        "Failed to load MacOS keymap": "",
        "keymaps/default-linux.json": "",
        "Failed to load Linux keymap": "",
        "keymaps/default-windows.json": "",
        "Failed to load Windows keymap": "",
        "<!-- ZED_META {} -->": "",
        "supports": "",
        "Required argument": "",
        "not-supported": "",
        "postprocess": "",
        "chapter has path": "",
        "Invalid frontmatter line: {}": "",
        "Action not found: {}": "",
        "Deprecated action used: {} should be {}": "",
        "Invalid settings JSON at {}:{}\\nError: {}\\n\\n{}": "",
        "\\x1b[31m": "",
        "\\x1b[0m": "",
        "{ANSI_RED}ERROR{ANSI_RESET}: {}": "",
        "Found {} errors in docs": "",
        "(?s)^\\s*---(.*?)---": "",
        "{}: {}": "",
        "Failed to serialize metadata": "",
        "{#ACTIONS_TABLE#}": "",
        "\\{#kb (.*?)\\}": "",
        "<div>No default binding</div>": "",
        "<kbd class=\\\"keybinding\\\">{formatted_macos_binding}|{formatted_linux_binding}</kbd>": "",
        "\\{#action (.*?)\\}": "",
        "<code class=\\\"hljs\\\">{}</code>": "",
        "Not a valid OS: {}": "",
        "```json [": "",
        "Unclosed JSON block tag": "",
        "Missing closing code block": "",
        "\\n>": "",
        "settings": "",
        "\\n}": "",
        "keymap": "",
        "\\n]": "",
        "Failed to parse keymap JSON": "",
        "Failed to parse keystroke": "",
        "Failed to parse action": "",
        "debug": "",
        "tasks": "",
        "icon-theme": "",
        "Unexpected JSON code block tag: {}": "",
        "assistant::Assist": "",
        "\\\"editor::ToggleComments\\\", {\\\"advance_downwards\\\":false}": "",
        "editor::ToggleComments": "",
        "').to_string())\n        .unwrap_or(action_as_str)\n}\n\nfn chapter_breadcrumbs(chapter: &Chapter) -> String {\n    let mut breadcrumbs = Vec::with_capacity(chapter.parent_names.len() + 1);\n    breadcrumbs.extend(chapter.parent_names.iter().map(String::as_str));\n    breadcrumbs.push(chapter.name.as_str());\n    format!(": "",
        ", chapter.source_path, breadcrumbs.join(": "",
        "))\n}\n\nfn load_keymap(asset_path: &str) -> Result<KeymapFile> {\n    let content = util::asset_str::<settings::SettingsAssets>(asset_path);\n    KeymapFile::parse(content.as_ref())\n}\n\nfn for_each_chapter_mut<F>(book: &mut Book, mut func: F)\nwhere\n    F: FnMut(&mut Chapter),\n{\n    book.for_each_mut(|item| {\n        let BookItem::Chapter(chapter) = item else {\n            return;\n        };\n        func(chapter);\n    });\n}\n\n#[derive(Debug, serde::Serialize)]\nstruct ActionDef {\n    name: &'static str,\n    human_name: String,\n    deprecated_aliases: &'static [&'static str],\n    docs: Option<&'static str>,\n}\n\nfn dump_all_gpui_actions() -> Vec<ActionDef> {\n    let mut actions = gpui::generate_list_of_all_registered_actions()\n        .map(|action| ActionDef {\n            name: action.name,\n            human_name: command_palette::humanize_action_name(action.name),\n            deprecated_aliases: action.deprecated_aliases,\n            docs: action.documentation,\n        })\n        .collect::<Vec<ActionDef>>();\n\n    actions.sort_by_key(|a| a.name);\n\n    actions\n}\n\nfn handle_postprocessing() -> Result<()> {\n    let logger = zlog::scoped!(": "",
        ");\n    let mut ctx = mdbook::renderer::RenderContext::from_json(io::stdin())?;\n    let output = ctx\n        .config\n        .get_mut(": "",
        ")\n        .expect(": "",
        ")\n        .as_table_mut()\n        .expect(": "",
        ");\n    let zed_html = output.remove(": "",
        ").expect(": "",
        ");\n    let default_description = zed_html\n        .get(": "",
        ")\n        .as_str()\n        .expect(": "",
        ")\n        .to_string();\n    let default_title = zed_html\n        .get(": "",
        ")\n        .to_string();\n    let amplitude_key = std::env::var(": "",
        ").unwrap_or_default();\n\n    output.insert(": "",
        ".to_string(), zed_html);\n    mdbook::Renderer::render(&mdbook::renderer::HtmlHandlebars::new(), &ctx)?;\n    let ignore_list = [": "",
        "];\n\n    let root_dir = ctx.destination.clone();\n    let mut files = Vec::with_capacity(128);\n    let mut queue = Vec::with_capacity(64);\n    queue.push(root_dir.clone());\n    while let Some(dir) = queue.pop() {\n        for entry in std::fs::read_dir(&dir).context(": "",
        ")? {\n            let Ok(entry) = entry else {\n                continue;\n            };\n            let file_type = entry.file_type().context(": "",
        ")?;\n            if file_type.is_dir() {\n                queue.push(entry.path());\n            }\n            if file_type.is_file()\n                && matches!(\n                    entry.path().extension().and_then(std::ffi::OsStr::to_str),\n                    Some(": "",
        ")\n                )\n            {\n                if ignore_list.contains(&&*entry.file_name().to_string_lossy()) {\n                    zlog::info!(logger => ": "",
        ", entry.path().to_string_lossy());\n                } else {\n                    files.push(entry.path());\n                }\n            }\n        }\n    }\n\n    zlog::info!(logger => ": "",
        ", files.len());\n    let meta_regex = Regex::new(&FRONT_MATTER_COMMENT.replace(": "",
        ", ": "",
        ")).unwrap();\n    for file in files {\n        let contents = std::fs::read_to_string(&file)?;\n        let mut meta_description = None;\n        let mut meta_title = None;\n        let contents = meta_regex.replace(&contents, |caps: &regex::Captures| {\n            let metadata: HashMap<String, String> = serde_json::from_str(&caps[1]).with_context(|| format!(": "",
        ", &caps[1])).expect(": "",
        ");\n            for (kind, content) in metadata {\n                match kind.as_str() {\n                    ": "",
        " => {\n                        meta_description = Some(content);\n                    }\n                    ": "",
        " => {\n                        meta_title = Some(content);\n                    }\n                    _ => {\n                        zlog::warn!(logger => ": "",
        ", kind, pretty_path(&file, &root_dir));\n                    }\n                }\n            }\n            String::new()\n        });\n        let meta_description = meta_description.as_ref().unwrap_or_else(|| {\n            zlog::warn!(logger => ": "",
        ", pretty_path(&file, &root_dir));\n            &default_description\n        });\n        let page_title = extract_title_from_page(&contents, pretty_path(&file, &root_dir));\n        let meta_title = meta_title.as_ref().unwrap_or_else(|| {\n            zlog::debug!(logger => ": "",
        ", pretty_path(&file, &root_dir));\n            &default_title\n        });\n        let meta_title = format!(": "",
        ", page_title, meta_title);\n        zlog::trace!(logger => ": "",
        ", pretty_path(&file, &root_dir));\n        let contents = contents.replace(": "",
        ", meta_description);\n        let contents = contents.replace(": "",
        ", &amplitude_key);\n        let contents = title_regex()\n            .replace(&contents, |_: &regex::Captures| {\n                format!(": "",
        ", meta_title)\n            })\n            .to_string();\n        // let contents = contents.replace(": "",
        ", &meta_title);\n        std::fs::write(file, contents)?;\n    }\n    return Ok(());\n\n    fn pretty_path<'a>(\n        path: &'a std::path::PathBuf,\n        root: &'a std::path::PathBuf,\n    ) -> &'a std::path::Path {\n        path.strip_prefix(&root).unwrap_or(path)\n    }\n    fn extract_title_from_page(contents: &str, pretty_path: &std::path::Path) -> String {\n        let title_tag_contents = &title_regex()\n            .captures(contents)\n            .with_context(|| format!(": "",
        ", pretty_path))\n            .expect(": "",
        ")[1];\n\n        title_tag_contents\n            .trim()\n            .strip_suffix(": "",
        ")\n            .unwrap_or(title_tag_contents)\n            .trim()\n            .to_string()\n    }\n}\n\nfn title_regex() -> &'static Regex {\n    static TITLE_REGEX: OnceLock<Regex> = OnceLock::new();\n    TITLE_REGEX.get_or_init(|| Regex::new(r": "",
        ").unwrap())\n}\n\nfn generate_big_table_of_actions() -> String {\n    let actions = &*ALL_ACTIONS;\n    let mut output = String::new();\n\n    let mut actions_sorted = actions.iter().collect::<Vec<_>>();\n    actions_sorted.sort_by_key(|a| a.name);\n\n    // Start the definition list with custom styling for better spacing\n    output.push_str(": "",
        "line-height: 1.8;\\\">\\n": "",
        "<dt style=\\\"margin-top: 1.5em; margin-bottom: 0.5em; font-weight: bold;\\\"><code>": "",
        "</code></dt>\\n": "",
        "<dd style=\\\"margin-left: 2em; margin-bottom: 1em;\\\">\\n": "",
        "&amp;": "",
        "&lt;": "",
        "&gt;": "",
        "<br>\\n": "",
        "Keymap Name: <code>": "",
        "</code><br>\\n": "",
        "Deprecated Alias(es): ": "",
        "<code>": "",
        "</code>, ": "",
        "\\n</dd>\\n": "",
        "</dl>\\n": ""
    },
    "zed/crates/editor/src/git/blame.rs": {
        "Updated buffers. Regenerating blame data...": "",
        "Status of git repositories updated. Regenerating blame data...": "",
        "failed to get git blame data: {errors:?}": "",
        "git-blame": "",
        "/my-repo": "",
        ".git": "",
        "file.txt": "",
        "\n                    irrelevant contents\n                ": "",
        "Failed to blame \\\"file.txt\\\": failed to get blame for \\\"file.txt\\\"": "",
        "\n                    AAA Line 1\n                    BBB Line 2 - Modified 1\n                    CCC Line 3 - Modified 2\n                    modified in memory 1\n                    modified in memory 1\n                    DDD Line 4 - Modified 2\n                    EEE Line 5 - Modified 1\n                    FFF Line 6 - Modified 2\n                ": "",
        "1b1b1b": "",
        "0d0d0d": "",
        "3a3a3a": "",
        "\n                    Line 1\n                    Line 2\n                    Line 3\n                ": "",
        "X": "",
        "OPERATIONS": "",
        "invalid `OPERATIONS` variable": "",
        "MAX_EDITS_PER_OPERATION": "",
        "invalid `MAX_EDITS_PER_OPERATION` variable": "",
        "initial buffer text: {:?}": "",
        "initial blame entries: {:?}": "",
        "quiescing": "",
        "editing buffer": "",
        "buffer text: {:?}": "",
        "regenerating blame entries: {:?}": ""
    },
    "zed/crates/editor/src/clangd_ext.rs": {
        "C++": "",
        "C": "",
        "Unknown": "",
        "lsp ext switch source header proto request": "",
        "Switch source/header LSP request for path \\\"{source_file}\\\" failed": "",
        "file://": "",
        "Parsing file url \\\"{}\\\" returned from switch source/header failed": "",
        "Switch source/header could not open \\\"{goto}\\\" in workspace": ""
    },
    "zed/crates/editor/src/code_context_menus.rs": {
        "bug: completion selected_item >= entries.len(): {} >= {}": "",
        "completions": "",
        "multiline_docs": "",
        "code_actions_menu": "",
        "debug: ": "",
        "debug: {}": ""
    },
    "zed/crates/editor/src/display_map.rs": {
        " ": "",
        "DisplayPoint({}, {})": "",
        "OPERATIONS": "",
        "invalid `OPERATIONS` variable": "",
        "tab size: {}": "",
        "wrap width: {:?}": "",
        "buffer text: {:?}": "",
        "fold text: {:?}": "",
        "tab text: {:?}": "",
        "wrap text: {:?}": "",
        "block text: {:?}": "",
        "display text: {:?}": "",
        "setting wrap width to {:?}": "",
        "setting tab size to {:?}": "",
        "inserting block {:?} with height {}": "",
        "removing block ids {:?}": "",
        "unfolding ranges: {:?}": "",
        "folding ranges: {:?}": "",
        "row boundary before {:?}. reported buffer row boundary: {:?}": "",
        "display row boundary after {:?}. reported buffer row boundary: {:?}": "",
        "row boundary before {:?}. reported display row boundary: {:?}": "",
        "row boundary after {:?}. reported display row boundary: {:?}": "",
        "Moving from point {:?}": "",
        "Right {:?}": "",
        "Left {:?}": "",
        "one two three four five\\nsix seven eight": "",
        "Helvetica": "",
        "one two \\nthree four \\nfive\\nsix seven \\neight": "",
        "seven": "",
        "and ": "",
        "three four \\nfive\\nsix and \\nseven eight": "",
        "three \\nfour five\\nsix and \\nseven \\neight": "",
        "\\t": "",
        "    b   bbbbb": "",
        "c   ccccc": "",
        "a": "",
        "\\n\\na": "",
        "\\n\\n\\na": "",
        "b": "",
        "\\n\\n\\nab": "",
        "\n            fn outer() {}\n\n            mod module {\n                fn inner() {}\n            }": "",
        "mod.body": "",
        "fn.name": "",
        "Test": "",
        ".test": "",
        "\n                (mod_item name: (identifier) body: _ @mod.body)\n                (function_item name: (identifier) @fn.name)\n                ": "",
        "fn ": "",
        "outer": "",
        "() {}\\n\\nmod module ": "",
        "{\\n    fn ": "",
        "inner": "",
        "() {}\\n}": "",
        "    fn ": "",
        "out": "",
        "  fn ": "",
        "\n            const A: &str = ": "",
        ";\n            const B: &str = ": "",
        ";\n        ": "",
        "string": "",
        "punctuation": "",
        "keyword": "",
        "\n                (string_literal) @string\n                ": "",
        " @keyword\n                [": "",
        "] @punctuation\n                ": "",
        "Courier": "",
        "const": "",
        " A": "",
        " &str = ": "",
        "\\\"\\n    one\\n": "",
        "    two\\n    three\\n\\\"": "",
        " B": "",
        "\\\"four\\\"": "",
        "\n            struct A {\n                b: usize;\n            }\n            const c: usize = 1;\n        ": "",
        "hi": "",
        "struct A {\\n    b: usize;\\n": "",
        "\\nconst c: ": "",
        "usize": "",
        " = ": "",
        ";\\n": "",
        "abcde\\nfghij\\nklmno\\npqrst": "",
        "abcde\\n\\n\\n\\n\\npqrst": "",
        "point_to_display_point({:?}, Bias::Left)": "",
        "point_to_display_point({:?}, Bias::Right)": "",
        "display_point_to_point({:?}, Bias::Left)": "",
        "display_point_to_point({:?}, Bias::Right)": "",
        "fn \\n": "",
        "oute": "",
        "r": "",
        "() \\n{}\\n\\n": "",
        "{}\\n\\n": "",
        "⋯\\n": "",
        "  ": "",
        "i": "",
        "operator": "",
        "\n                ": "",
        " @operator\n                (string_literal) @string\n                ": "",
        "constˇ «a»«:» B = ": "",
        "const ": "",
        " B = ": "",
        "\\\"c ": "",
        "d": "",
        "ˇˇα": "",
        "ˇαˇ": "",
        "ˇˇ✋": "",
        "ˇ✋ˇ": "",
        "ˇˇ🍐": "",
        "ˇ🍐ˇ": "",
        "ˇˇ\\t": "",
        "ˇ\\tˇ": "",
        " ˇˇ\\t": "",
        " ˇ\\tˇ": "",
        "   ˇˇ\\t": "",
        "ˇˇ": "",
        "ˇaˇ": "",
        "aˇbˇ": "",
        "aˇαˇ": "",
        "aaa\\nbbb\\nccc\\nddd\\neee\\nfff\\nggg\\nhhh\\niii\\njjj\\nkkk\\nlll": "",
        "✅\\t\\tα\\nβ\\t\\n🏀β\\t\\tγ": "",
        "✅       α\\nβ   \\n🏀β      γ": "",
        "β   \\n🏀β      γ": "",
        "🏀β      γ": "",
        "✅\\t\\t": "",
        "✅       ": "",
        "β\\t": "",
        "β   ": "",
        "🏀β\\t\\t": "",
        "🏀β      ": "",
        "✅      ": "",
        "✅\\t": "",
        "✅ ": "",
        "aaa\\n\\t\\tbbb": ""
    },
    "zed/crates/editor/src/editor_tests.rs": {
        "editor1": "",
        "edited": "",
        "buffer edited": "",
        "editor2": "",
        "X": "",
        "cd": "",
        "12cd56": "",
        "e": "",
        "12cde6": "",
        "a": "",
        "b": "",
        "ab2cde6": "",
        "abcde": "",
        "à": "",
        "á": "",
        "ä": "",
        "äbcde": "",
        "ā": "",
        "ābcde": "",
        "è": "",
        "ābcdè": "",
        "ę": "",
        "ābcdę": "",
        "XYZ": "",
        "XYZbXYZdXYZ": "",
        "X1ZbX1ZdX1Z": "",
        "X2ZbX2ZdX2Z": "",
        "aaaaaa\\nbbbbbb\\ncccccc\\nddddddd\\n": "",
        "aaaaaa\\nbbbbbb\\ncccccc\\ndddddd\\n": "",
        "aaa bbb ccc ddd eee": "",
        "\n            one\n            two\n            threeˇ\n            four\n            fiveˇ\n        ": "",
        "\n                impl Foo {\n                    // Hello!\n\n                    fn a() {\n                        1\n                    }\n\n                    fn b() {\n                        2\n                    }\n\n                    fn c() {\n                        3\n                    }\n                }\n            ": "",
        "\n                impl Foo {\n                    // Hello!\n\n                    fn a() {\n                        1\n                    }\n\n                    fn b() {⋯\n                    }\n\n                    fn c() {⋯\n                    }\n                }\n            ": "",
        "\n                impl Foo {⋯\n                }\n            ": "",
        "\n                class Foo:\n                    # Hello!\n\n                    def a():\n                        print(1)\n\n                    def b():\n                        print(2)\n\n                    def c():\n                        print(3)\n            ": "",
        "\n                class Foo:\n                    # Hello!\n\n                    def a():\n                        print(1)\n\n                    def b():⋯\n\n                    def c():⋯\n            ": "",
        "\n                class Foo:⋯\n            ": "",
        "\n                class Foo:\n                    # Hello!\n\n                    def a():\n                        print(1)\n\n                    def b():\n                        print(2)\n\n\n                    def c():\n                        print(3)\n\n\n            ": "",
        "\n                class Foo:\n                    # Hello!\n\n                    def a():\n                        print(1)\n\n                    def b():⋯\n\n\n                    def c():⋯\n\n\n            ": "",
        "\n                class Foo:⋯\n\n\n            ": "",
        "\n                class Foo:\n                    # Hello!\n\n                    def a():\n                        print(1)\n\n                    def b():\n                        print(2)\n\n\n                class Bar:\n                    # World!\n\n                    def a():\n                        print(1)\n\n                    def b():\n                        print(2)\n\n\n            ": "",
        "\n                class Foo:\n                    # Hello!\n\n                    def a():⋯\n\n                    def b():⋯\n\n\n                class Bar:\n                    # World!\n\n                    def a():⋯\n\n                    def b():⋯\n\n\n            ": "",
        "\n                class Foo:⋯\n\n\n                class Bar:⋯\n\n\n            ": "",
        "\n                       class Foo:\n                           # Hello!\n\n                           def a():\n                              print(1)\n\n                           def b():\n                               p«riˇ»nt(2)\n\n\n                       class Bar:\n                           # World!\n\n                           def a():\n                               «ˇprint(1)\n\n                           def b():\n                               print(2)»\n\n\n                   ": "",
        "\n                class Foo:\n                    # Hello!\n\n                    def a():⋯\n\n                    def b():\n                        print(2)\n\n\n                class Bar:\n                    # World!\n\n                    def a():\n                        print(1)\n\n                    def b():\n                        print(2)\n\n\n            ": "",
        "\\t": "",
        "🟥🟧🟨🟩🟦🟪\\nabcde\\nαβγδε": "",
        "🟥🟧⋯🟦🟪\\nab⋯e\\nαβ⋯ε": "",
        "ab⋯e": "",
        "ab⋯": "",
        "ab": "",
        "α": "",
        "αβ": "",
        "αβ⋯": "",
        "αβ⋯ε": "",
        "ⓐⓑⓒⓓⓔ\\nabcd\\nαβγ\\nabcd\\nⓐⓑⓒⓓⓔ\\n": "",
        "abcd": "",
        "αβγ": "",
        "abc\\n  def": "",
        "ab\\n  de": "",
        "thequickbrownfox\\njumpedoverthelazydogs": "",
        "thequickbrownfox\\njumpedoverthelaz\\nydogs": "",
        "c\\n  f": "",
        "    hello\\nworld": "",
        "use std::str::{foo, bar}\\n\\n  {baz.qux()}": "",
        "use std::ˇstr::{foo, bar}\\n\\n  {ˇbaz.qux()}": "",
        "use stdˇ::str::{foo, bar}\\n\\nˇ  {baz.qux()}": "",
        "use ˇstd::str::{foo, bar}\\nˇ\\n  {baz.qux()}": "",
        "ˇuse std::str::{foo, barˇ}\\n\\n  {baz.qux()}": "",
        "ˇuse std::str::{foo, ˇbar}\\n\\n  {baz.qux()}": "",
        "useˇ std::str::{foo, barˇ}\\n\\n  {baz.qux()}": "",
        "use stdˇ::str::{foo, bar}ˇ\\n\\n  {baz.qux()}": "",
        "use std::ˇstr::{foo, bar}\\nˇ\\n  {baz.qux()}": "",
        "use std::«ˇs»tr::{foo, bar}\\n«ˇ\\n»  {baz.qux()}": "",
        "use std«ˇ::s»tr::{foo, bar«ˇ}\\n\\n»  {baz.qux()}": "",
        "use std::«ˇs»tr::{foo, bar}«ˇ\\n\\n»  {baz.qux()}": "",
        "use one::{\\n    two::three::four::five\\n};": "",
        "use one::{\\n    two::three::\\n    four::five\\n};": "",
        "ˇone\n        two\n\n        three\n        fourˇ\n        five\n\n        six": "",
        "one\n        two\n        ˇ\n        three\n        four\n        five\n        ˇ\n        six": "",
        "one\n        two\n\n        three\n        four\n        five\n        ˇ\n        sixˇ": "",
        "one\n        two\n\n        three\n        four\n        five\n\n        sixˇ": "",
        "one\n        two\n\n        three\n        four\n        five\n        ˇ\n        six": "",
        "one\n        two\n        ˇ\n        three\n        four\n        five\n\n        six": "",
        "ˇone\n        two\n\n        three\n        four\n        five\n\n        six": "",
        "ˇone\n        two\n        three\n        four\n        five\n        six\n        seven\n        eight\n        nine\n        ten\n        ": "",
        "ˇone\n            two\n            three\n            four\n            five\n            six\n            seven\n            eight\n            nine\n            ten\n        ": "",
        "\n        ˇone\n        two\n        threeˇ\n        four\n        five\n        six\n        seven\n        eight\n        nine\n        ten\n        ": "",
        "\n        one\n        two\n        three\n        ˇfour\n        five\n        sixˇ\n        seven\n        eight\n        nine\n        ten\n        ": "",
        "\n        one\n        two\n        three\n        four\n        five\n        six\n        ˇseven\n        eight\n        nineˇ\n        ten\n        ": "",
        "\n        one\n        two\n        three\n        four\n        five\n        six\n        seven\n        eight\n        nine\n        ˇten\n        ˇ": "",
        "one «two threeˇ» four": "",
        " four": "",
        "onˇe two t«hreˇ»e four": "",
        "ˇe two tˇe four": "",
        "e tˇwo te «fˇ»our": "",
        "e tˇ te ˇour": "",
        "here is some text    ˇwith a space": "",
        "here is some textˇwith a space": "",
        "here is some textˇ    with a space": "",
        "here is some ˇwith a space": "",
        "here is ˇwith a space": "",
        "here ˇwith a space": "",
        "ˇwith a space": "",
        "ˇ a space": "",
        "ˇ space": "",
        "ˇ": "",
        "\n                (": "",
        " @open ": "",
        " @close)\n                (": "",
        "#,\n        )\n        .unwrap(),\n    );\n\n    let mut cx = EditorTestContext::new(cx).await;\n    cx.update_buffer(|buffer, cx| buffer.set_language(Some(language), cx));\n\n    cx.set_state(r#": "",
        "// ˇCOMMENT": "",
        "#);\n    cx.update_editor(|editor, window, cx| {\n        editor.delete_to_previous_word_start(\n            &DeleteToPreviousWordStart {\n                ignore_newlines: true,\n                ignore_brackets: false,\n            },\n            window,\n            cx,\n        );\n    });\n    // Deletion stops before brackets if asked to not ignore them.\n    cx.assert_editor_state(r#": "",
        "ˇCOMMENT": "",
        "#);\n    cx.update_editor(|editor, window, cx| {\n        editor.delete_to_previous_word_start(\n            &DeleteToPreviousWordStart {\n                ignore_newlines: true,\n                ignore_brackets: false,\n            },\n            window,\n            cx,\n        );\n    });\n    // Deletion has to remove a single bracket and then stop again.\n    cx.assert_editor_state(r#": "",
        "macro!ˇCOMMENT": "",
        "#);\n\n    cx.update_editor(|editor, window, cx| {\n        editor.delete_to_previous_word_start(\n            &DeleteToPreviousWordStart {\n                ignore_newlines: true,\n                ignore_brackets: false,\n            },\n            window,\n            cx,\n        );\n    });\n    cx.assert_editor_state(r#": "",
        "#);\n\n    cx.update_editor(|editor, window, cx| {\n        editor.delete_to_next_word_end(\n            &DeleteToNextWordEnd {\n                ignore_newlines: true,\n                ignore_brackets: false,\n            },\n            window,\n            cx,\n        );\n    });\n    // Brackets on the right are not paired anymore, hence deletion does not stop at them\n    cx.assert_editor_state(r#": "",
        "macro!(": "",
        "macroˇCOMMENT": "",
        "#);\n}\n\n#[gpui::test]\nfn test_delete_to_previous_word_start_or_newline(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let editor = cx.add_window(|window, cx| {\n        let buffer = MultiBuffer::build_simple(": "",
        ", cx);\n        build_editor(buffer, window, cx)\n    });\n    let del_to_prev_word_start = DeleteToPreviousWordStart {\n        ignore_newlines: false,\n        ignore_brackets: false,\n    };\n    let del_to_prev_word_start_ignore_newlines = DeleteToPreviousWordStart {\n        ignore_newlines: true,\n        ignore_brackets: false,\n    };\n\n    _ = editor.update(cx, |editor, window, cx| {\n        editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n            s.select_display_ranges([\n                DisplayPoint::new(DisplayRow(3), 1)..DisplayPoint::new(DisplayRow(3), 1)\n            ])\n        });\n        editor.delete_to_previous_word_start(&del_to_prev_word_start, window, cx);\n        assert_eq!(editor.buffer.read(cx).read(cx).text(), ": "",
        ");\n        editor.delete_to_previous_word_start(&del_to_prev_word_start, window, cx);\n        assert_eq!(editor.buffer.read(cx).read(cx).text(), ": "",
        ");\n        editor.delete_to_previous_word_start(&del_to_prev_word_start_ignore_newlines, window, cx);\n        assert_eq!(editor.buffer.read(cx).read(cx).text(), ": "",
        ");\n    });\n}\n\n#[gpui::test]\nfn test_delete_to_next_word_end_or_newline(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let editor = cx.add_window(|window, cx| {\n        let buffer = MultiBuffer::build_simple(": "",
        ", cx);\n        build_editor(buffer, window, cx)\n    });\n    let del_to_next_word_end = DeleteToNextWordEnd {\n        ignore_newlines: false,\n        ignore_brackets: false,\n    };\n    let del_to_next_word_end_ignore_newlines = DeleteToNextWordEnd {\n        ignore_newlines: true,\n        ignore_brackets: false,\n    };\n\n    _ = editor.update(cx, |editor, window, cx| {\n        editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n            s.select_display_ranges([\n                DisplayPoint::new(DisplayRow(0), 0)..DisplayPoint::new(DisplayRow(0), 0)\n            ])\n        });\n        editor.delete_to_next_word_end(&del_to_next_word_end, window, cx);\n        assert_eq!(\n            editor.buffer.read(cx).read(cx).text(),\n            ": "",
        "\n        );\n        editor.delete_to_next_word_end(&del_to_next_word_end, window, cx);\n        assert_eq!(\n            editor.buffer.read(cx).read(cx).text(),\n            ": "",
        "\n        );\n        editor.delete_to_next_word_end(&del_to_next_word_end, window, cx);\n        assert_eq!(editor.buffer.read(cx).read(cx).text(), ": "",
        ");\n        editor.delete_to_next_word_end(&del_to_next_word_end_ignore_newlines, window, cx);\n        assert_eq!(editor.buffer.read(cx).read(cx).text(), ": "",
        ");\n    });\n}\n\n#[gpui::test]\nfn test_newline(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let editor = cx.add_window(|window, cx| {\n        let buffer = MultiBuffer::build_simple(": "",
        ", cx);\n        build_editor(buffer, window, cx)\n    });\n\n    _ = editor.update(cx, |editor, window, cx| {\n        editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n            s.select_display_ranges([\n                DisplayPoint::new(DisplayRow(0), 2)..DisplayPoint::new(DisplayRow(0), 2),\n                DisplayPoint::new(DisplayRow(1), 2)..DisplayPoint::new(DisplayRow(1), 2),\n                DisplayPoint::new(DisplayRow(1), 6)..DisplayPoint::new(DisplayRow(1), 6),\n            ])\n        });\n\n        editor.newline(&Newline, window, cx);\n        assert_eq!(editor.text(cx), ": "",
        ");\n    });\n}\n\n#[gpui::test]\nasync fn test_newline_yaml(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n    let yaml_language = languages::language(": "",
        ", tree_sitter_yaml::LANGUAGE.into());\n    cx.update_buffer(|buffer, cx| buffer.set_language(Some(yaml_language), cx));\n\n    // Object (between 2 fields)\n    cx.set_state(indoc! {": "",
        "});\n    cx.update_editor(|e, window, cx| e.newline(&Newline, window, cx));\n    cx.assert_editor_state(indoc! {": "",
        "});\n\n    // Object (first and single line)\n    cx.set_state(indoc! {": "",
        "});\n\n    // Array with objects (after first element)\n    cx.set_state(indoc! {": "",
        "});\n\n    // Array with objects and comment\n    cx.set_state(indoc! {": "",
        "});\n\n    // Array with objects (after second element)\n    cx.set_state(indoc! {": "",
        "});\n\n    // Array with strings (after first element)\n    cx.set_state(indoc! {": "",
        "});\n}\n\n#[gpui::test]\nfn test_newline_with_old_selections(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let editor = cx.add_window(|window, cx| {\n        let buffer = MultiBuffer::build_simple(\n            ": "",
        "\n            .unindent()\n            .as_str(),\n            cx,\n        );\n        let mut editor = build_editor(buffer, window, cx);\n        editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n            s.select_ranges([\n                Point::new(2, 4)..Point::new(2, 5),\n                Point::new(5, 4)..Point::new(5, 5),\n            ])\n        });\n        editor\n    });\n\n    _ = editor.update(cx, |editor, window, cx| {\n        // Edit the buffer directly, deleting ranges surrounding the editor's selections\n        editor.buffer.update(cx, |buffer, cx| {\n            buffer.edit(\n                [\n                    (Point::new(1, 2)..Point::new(3, 0), ": "",
        "),\n                    (Point::new(4, 2)..Point::new(6, 0), ": "",
        "),\n                ],\n                None,\n                cx,\n            );\n            assert_eq!(\n                buffer.read(cx).text(),\n                ": "",
        "\n                .unindent()\n            );\n        });\n        assert_eq!(\n            editor.selections.ranges(&editor.display_snapshot(cx)),\n            &[\n                Point::new(1, 2)..Point::new(1, 2),\n                Point::new(2, 2)..Point::new(2, 2),\n            ],\n        );\n\n        editor.newline(&Newline, window, cx);\n        assert_eq!(\n            editor.text(cx),\n            ": "",
        "\n            .unindent()\n        );\n\n        // The selections are moved after the inserted newlines\n        assert_eq!(\n            editor.selections.ranges(&editor.display_snapshot(cx)),\n            &[\n                Point::new(2, 0)..Point::new(2, 0),\n                Point::new(4, 0)..Point::new(4, 0),\n            ],\n        );\n    });\n}\n\n#[gpui::test]\nasync fn test_newline_above(cx: &mut TestAppContext) {\n    init_test(cx, |settings| {\n        settings.defaults.tab_size = NonZeroU32::new(4)\n    });\n\n    let language = Arc::new(\n        Language::new(\n            LanguageConfig::default(),\n            Some(tree_sitter_rust::LANGUAGE.into()),\n        )\n        .with_indents_query(r#": "",
        "#)\n        .unwrap(),\n    );\n\n    let mut cx = EditorTestContext::new(cx).await;\n    cx.update_buffer(|buffer, cx| buffer.set_language(Some(language), cx));\n    cx.set_state(indoc! {": "",
        "});\n\n    cx.update_editor(|e, window, cx| e.newline_above(&NewlineAbove, window, cx));\n    cx.assert_editor_state(indoc! {": "",
        "});\n}\n\n#[gpui::test]\nasync fn test_newline_below(cx: &mut TestAppContext) {\n    init_test(cx, |settings| {\n        settings.defaults.tab_size = NonZeroU32::new(4)\n    });\n\n    let language = Arc::new(\n        Language::new(\n            LanguageConfig::default(),\n            Some(tree_sitter_rust::LANGUAGE.into()),\n        )\n        .with_indents_query(r#": "",
        "});\n\n    cx.update_editor(|e, window, cx| e.newline_below(&NewlineBelow, window, cx));\n    cx.assert_editor_state(indoc! {": "",
        "});\n}\n\n#[gpui::test]\nasync fn test_newline_comments(cx: &mut TestAppContext) {\n    init_test(cx, |settings| {\n        settings.defaults.tab_size = NonZeroU32::new(4)\n    });\n\n    let language = Arc::new(Language::new(\n        LanguageConfig {\n            line_comments: vec![": "",
        ".into()],\n            ..LanguageConfig::default()\n        },\n        None,\n    ));\n    {\n        let mut cx = EditorTestContext::new(cx).await;\n        cx.update_buffer(|buffer, cx| buffer.set_language(Some(language), cx));\n        cx.set_state(indoc! {": "",
        "});\n\n        cx.update_editor(|e, window, cx| e.newline(&Newline, window, cx));\n        cx.assert_editor_state(indoc! {": "",
        "});\n        // Ensure that we add comment prefix when existing line contains space\n        cx.update_editor(|e, window, cx| e.newline(&Newline, window, cx));\n        cx.assert_editor_state(\n            indoc! {": "",
        "}\n            .replace(": "",
        ", ": "",
        ") // s is used as space placeholder to prevent format on save\n            .as_str(),\n        );\n        // Ensure that we add comment prefix when existing line does not contain space\n        cx.set_state(indoc! {": "",
        "});\n        cx.update_editor(|e, window, cx| e.newline(&Newline, window, cx));\n        cx.assert_editor_state(indoc! {": "",
        "});\n        // Ensure that if cursor is before the comment start, we do not actually insert a comment prefix.\n        cx.set_state(indoc! {": "",
        "});\n    }\n    // Ensure that comment continuations can be disabled.\n    update_test_language_settings(cx, |settings| {\n        settings.defaults.extend_comment_on_newline = Some(false);\n    });\n    let mut cx = EditorTestContext::new(cx).await;\n    cx.set_state(indoc! {": "",
        "});\n}\n\n#[gpui::test]\nasync fn test_newline_comments_with_multiple_delimiters(cx: &mut TestAppContext) {\n    init_test(cx, |settings| {\n        settings.defaults.tab_size = NonZeroU32::new(4)\n    });\n\n    let language = Arc::new(Language::new(\n        LanguageConfig {\n            line_comments: vec![": "",
        ".into(), ": "",
        "});\n\n        cx.set_state(indoc! {": "",
        "});\n    }\n}\n\n#[gpui::test]\nasync fn test_newline_documentation_comments(cx: &mut TestAppContext) {\n    init_test(cx, |settings| {\n        settings.defaults.tab_size = NonZeroU32::new(4)\n    });\n\n    let language = Arc::new(\n        Language::new(\n            LanguageConfig {\n                documentation_comment: Some(language::BlockCommentConfig {\n                    start: ": "",
        ".into(),\n                    end: ": "",
        ".into(),\n                    prefix: ": "",
        ".into(),\n                    tab_size: 1,\n                }),\n\n                ..LanguageConfig::default()\n            },\n            Some(tree_sitter_rust::LANGUAGE.into()),\n        )\n        .with_override_query(": "",
        ")\n        .unwrap(),\n    );\n\n    {\n        let mut cx = EditorTestContext::new(cx).await;\n        cx.update_buffer(|buffer, cx| buffer.set_language(Some(language), cx));\n        cx.set_state(indoc! {": "",
        "});\n        // Ensure that if cursor is before the comment start,\n        // we do not actually insert a comment prefix.\n        cx.set_state(indoc! {": "",
        "});\n        // Ensure that if cursor is between it doesn't add comment prefix.\n        cx.set_state(indoc! {": "",
        "});\n        // Ensure that if suffix exists on same line after cursor it adds new line.\n        cx.set_state(indoc! {": "",
        "});\n        // Ensure that if suffix exists on same line after cursor with space it adds new line.\n        cx.set_state(indoc! {": "",
        "});\n        cx.update_editor(|e, window, cx| e.newline(&Newline, window, cx));\n        cx.assert_editor_state(\n            indoc! {": "",
        ") // s is used as space placeholder to prevent format on save\n            .as_str(),\n        );\n        // Ensure that delimiter space is preserved when newline on already\n        // spaced delimiter.\n        cx.update_editor(|e, window, cx| e.newline(&Newline, window, cx));\n        cx.assert_editor_state(\n            indoc! {": "",
        ") // s is used as space placeholder to prevent format on save\n            .as_str(),\n        );\n        // Ensure that delimiter space is preserved when space is not\n        // on existing delimiter.\n        cx.set_state(indoc! {": "",
        "});\n        // Ensure that if suffix exists on same line after cursor it\n        // doesn't add extra new line if prefix is not on same line.\n        cx.set_state(indoc! {": "",
        "});\n        // Ensure that it detects suffix after existing prefix.\n        cx.set_state(indoc! {": "",
        "});\n        // Ensure that if suffix exists on same line before\n        // cursor it does not add comment prefix.\n        cx.set_state(indoc! {": "",
        "});\n\n        // Ensure that inline comment followed by code\n        // doesn't add comment prefix on newline\n        cx.set_state(indoc! {": "",
        "});\n\n        // Ensure that text after comment end tag\n        // doesn't add comment prefix on newline\n        cx.set_state(indoc! {": "",
        "});\n\n        // Ensure if not comment block it doesn't\n        // add comment prefix on newline\n        cx.set_state(indoc! {": "",
        "});\n}\n\n#[gpui::test]\nasync fn test_newline_comments_with_block_comment(cx: &mut TestAppContext) {\n    init_test(cx, |settings| {\n        settings.defaults.tab_size = NonZeroU32::new(4)\n    });\n\n    let lua_language = Arc::new(Language::new(\n        LanguageConfig {\n            line_comments: vec![": "",
        ".into()],\n            block_comment: Some(language::BlockCommentConfig {\n                start: ": "",
        ".into(),\n                prefix: ": "",
        ".into(),\n                end: ": "",
        ".into(),\n                tab_size: 0,\n            }),\n            ..LanguageConfig::default()\n        },\n        None,\n    ));\n\n    let mut cx = EditorTestContext::new(cx).await;\n    cx.update_buffer(|buffer, cx| buffer.set_language(Some(lua_language), cx));\n\n    // Line with line comment should extend\n    cx.set_state(indoc! {": "",
        "});\n\n    // Line with block comment that matches line comment should not extend\n    cx.set_state(indoc! {": "",
        "});\n}\n\n#[gpui::test]\nfn test_insert_with_old_selections(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let editor = cx.add_window(|window, cx| {\n        let buffer = MultiBuffer::build_simple(": "",
        ", cx);\n        let mut editor = build_editor(buffer, window, cx);\n        editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n            s.select_ranges([3..4, 11..12, 19..20])\n        });\n        editor\n    });\n\n    _ = editor.update(cx, |editor, window, cx| {\n        // Edit the buffer directly, deleting ranges surrounding the editor's selections\n        editor.buffer.update(cx, |buffer, cx| {\n            buffer.edit([(2..5, ": "",
        "), (10..13, ": "",
        "), (18..21, ": "",
        ")], None, cx);\n            assert_eq!(buffer.read(cx).text(), ": "",
        ".unindent());\n        });\n        assert_eq!(\n            editor.selections.ranges(&editor.display_snapshot(cx)),\n            &[2..2, 7..7, 12..12],\n        );\n\n        editor.insert(": "",
        ", window, cx);\n        assert_eq!(editor.text(cx), ": "",
        ");\n\n        // The selections are moved after the inserted characters\n        assert_eq!(\n            editor.selections.ranges(&editor.display_snapshot(cx)),\n            &[3..3, 9..9, 15..15],\n        );\n    });\n}\n\n#[gpui::test]\nasync fn test_tab(cx: &mut TestAppContext) {\n    init_test(cx, |settings| {\n        settings.defaults.tab_size = NonZeroU32::new(3)\n    });\n\n    let mut cx = EditorTestContext::new(cx).await;\n    cx.set_state(indoc! {": "",
        "});\n    cx.update_editor(|e, window, cx| e.tab(&Tab, window, cx));\n    cx.assert_editor_state(indoc! {": "",
        "});\n\n    cx.set_state(indoc! {": "",
        "});\n}\n\n#[gpui::test]\nasync fn test_tab_in_leading_whitespace_auto_indents_lines(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n    let language = Arc::new(\n        Language::new(\n            LanguageConfig::default(),\n            Some(tree_sitter_rust::LANGUAGE.into()),\n        )\n        .with_indents_query(r#": "",
        "#)\n        .unwrap(),\n    );\n    cx.update_buffer(|buffer, cx| buffer.set_language(Some(language), cx));\n\n    // test when all cursors are not at suggested indent\n    // then simply move to their suggested indent location\n    cx.set_state(indoc! {": "",
        "});\n\n    // test cursor already at suggested indent not moving when\n    // other cursors are yet to reach their suggested indents\n    cx.set_state(indoc! {": "",
        "});\n    // test when all cursors are at suggested indent then tab is inserted\n    cx.update_editor(|e, window, cx| e.tab(&Tab, window, cx));\n    cx.assert_editor_state(indoc! {": "",
        "});\n\n    // test when current indent is less than suggested indent,\n    // we adjust line to match suggested indent and move cursor to it\n    //\n    // when no other cursor is at word boundary, all of them should move\n    cx.set_state(indoc! {": "",
        "});\n\n    // test when current indent is less than suggested indent,\n    // we adjust line to match suggested indent and move cursor to it\n    //\n    // when some other cursor is at word boundary, it should not move\n    cx.set_state(indoc! {": "",
        "});\n\n    // test when current indent is more than suggested indent,\n    // we just move cursor to current indent instead of suggested indent\n    //\n    // when no other cursor is at word boundary, all of them should move\n    cx.set_state(indoc! {": "",
        "});\n\n    // test when current indent is more than suggested indent,\n    // we just move cursor to current indent instead of suggested indent\n    //\n    // when some other cursor is at word boundary, it doesn't move\n    cx.set_state(indoc! {": "",
        "});\n\n    // handle auto-indent when there are multiple cursors on the same line\n    cx.set_state(indoc! {": "",
        "});\n}\n\n#[gpui::test]\nasync fn test_tab_with_mixed_whitespace_txt(cx: &mut TestAppContext) {\n    init_test(cx, |settings| {\n        settings.defaults.tab_size = NonZeroU32::new(3)\n    });\n\n    let mut cx = EditorTestContext::new(cx).await;\n    cx.set_state(indoc! {": "",
        "});\n\n    cx.update_editor(|e, window, cx| e.tab(&Tab, window, cx));\n    cx.assert_editor_state(indoc! {": "",
        "});\n}\n\n#[gpui::test]\nasync fn test_tab_with_mixed_whitespace_rust(cx: &mut TestAppContext) {\n    init_test(cx, |settings| {\n        settings.defaults.tab_size = NonZeroU32::new(4)\n    });\n\n    let language = Arc::new(\n        Language::new(\n            LanguageConfig::default(),\n            Some(tree_sitter_rust::LANGUAGE.into()),\n        )\n        .with_indents_query(r#": "",
        "});\n}\n\n#[gpui::test]\nasync fn test_indent_outdent(cx: &mut TestAppContext) {\n    init_test(cx, |settings| {\n        settings.defaults.tab_size = NonZeroU32::new(4);\n    });\n\n    let mut cx = EditorTestContext::new(cx).await;\n\n    cx.set_state(indoc! {": "",
        "});\n\n    cx.update_editor(|e, window, cx| e.backtab(&Backtab, window, cx));\n    cx.assert_editor_state(indoc! {": "",
        "});\n\n    // select across line ending\n    cx.set_state(indoc! {": "",
        "});\n\n    // Ensure that indenting/outdenting works when the cursor is at column 0.\n    cx.set_state(indoc! {": "",
        "});\n    cx.update_editor(|e, window, cx| e.backtab(&Backtab, window, cx));\n    cx.assert_editor_state(indoc! {": "",
        "});\n}\n\n#[gpui::test]\nasync fn test_indent_yaml_comments_with_multiple_cursors(cx: &mut TestAppContext) {\n    // This is a regression test for issue #33761\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n    let yaml_language = languages::language(": "",
        ", tree_sitter_yaml::LANGUAGE.into());\n    cx.update_buffer(|buffer, cx| buffer.set_language(Some(yaml_language), cx));\n\n    cx.set_state(\n        r#": "",
        "#,\n    );\n\n    // Press tab to indent all lines\n    cx.update_editor(|e, window, cx| e.tab(&Tab, window, cx));\n\n    cx.assert_editor_state(\n        r#": "",
        "#,\n    );\n}\n\n#[gpui::test]\nasync fn test_indent_yaml_non_comments_with_multiple_cursors(cx: &mut TestAppContext) {\n    // This is a test to make sure our fix for issue #33761 didn't break anything\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n    let yaml_language = languages::language(": "",
        "#,\n    );\n}\n\n#[gpui::test]\nasync fn test_indent_outdent_with_hard_tabs(cx: &mut TestAppContext) {\n    init_test(cx, |settings| {\n        settings.defaults.hard_tabs = Some(true);\n    });\n\n    let mut cx = EditorTestContext::new(cx).await;\n\n    // select two ranges on one line\n    cx.set_state(indoc! {": "",
        "});\n\n    // select across a line ending\n    cx.set_state(indoc! {": "",
        "});\n}\n\n#[gpui::test]\nfn test_indent_outdent_with_excerpts(cx: &mut TestAppContext) {\n    init_test(cx, |settings| {\n        settings.languages.0.extend([\n            (\n                ": "",
        ".into(),\n                LanguageSettingsContent {\n                    tab_size: NonZeroU32::new(2),\n                    ..Default::default()\n                },\n            ),\n            (\n                ": "",
        ".into(),\n                LanguageSettingsContent {\n                    tab_size: NonZeroU32::new(4),\n                    ..Default::default()\n                },\n            ),\n        ]);\n    });\n\n    let toml_language = Arc::new(Language::new(\n        LanguageConfig {\n            name: ": "",
        ".into(),\n            ..Default::default()\n        },\n        None,\n    ));\n    let rust_language = Arc::new(Language::new(\n        LanguageConfig {\n            name: ": "",
        ".into(),\n            ..Default::default()\n        },\n        None,\n    ));\n\n    let toml_buffer =\n        cx.new(|cx| Buffer::local(": "",
        ", cx).with_language(toml_language, cx));\n    let rust_buffer =\n        cx.new(|cx| Buffer::local(": "",
        ", cx).with_language(rust_language, cx));\n    let multibuffer = cx.new(|cx| {\n        let mut multibuffer = MultiBuffer::new(ReadWrite);\n        multibuffer.push_excerpts(\n            toml_buffer.clone(),\n            [ExcerptRange::new(Point::new(0, 0)..Point::new(2, 0))],\n            cx,\n        );\n        multibuffer.push_excerpts(\n            rust_buffer.clone(),\n            [ExcerptRange::new(Point::new(0, 0)..Point::new(1, 0))],\n            cx,\n        );\n        multibuffer\n    });\n\n    cx.add_window(|window, cx| {\n        let mut editor = build_editor(multibuffer, window, cx);\n\n        assert_eq!(\n            editor.text(cx),\n            indoc! {": "",
        "}\n        );\n\n        select_ranges(\n            &mut editor,\n            indoc! {": "",
        "},\n            window,\n            cx,\n        );\n\n        editor.tab(&Tab, window, cx);\n        assert_text_with_selections(\n            &mut editor,\n            indoc! {": "",
        "},\n            cx,\n        );\n        editor.backtab(&Backtab, window, cx);\n        assert_text_with_selections(\n            &mut editor,\n            indoc! {": "",
        "},\n            cx,\n        );\n\n        editor\n    });\n}\n\n#[gpui::test]\nasync fn test_backspace(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n\n    // Basic backspace\n    cx.set_state(indoc! {": "",
        "});\n    cx.update_editor(|e, window, cx| e.backspace(&Backspace, window, cx));\n    cx.assert_editor_state(indoc! {": "",
        "});\n\n    // Test backspace inside and around indents\n    cx.set_state(indoc! {": "",
        "});\n}\n\n#[gpui::test]\nasync fn test_delete(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n    cx.set_state(indoc! {": "",
        "});\n    cx.update_editor(|e, window, cx| e.delete(&Delete, window, cx));\n    cx.assert_editor_state(indoc! {": "",
        "});\n}\n\n#[gpui::test]\nfn test_delete_line(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let editor = cx.add_window(|window, cx| {\n        let buffer = MultiBuffer::build_simple(": "",
        ", cx);\n        build_editor(buffer, window, cx)\n    });\n    _ = editor.update(cx, |editor, window, cx| {\n        editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n            s.select_display_ranges([\n                DisplayPoint::new(DisplayRow(0), 1)..DisplayPoint::new(DisplayRow(0), 1),\n                DisplayPoint::new(DisplayRow(1), 0)..DisplayPoint::new(DisplayRow(1), 1),\n                DisplayPoint::new(DisplayRow(3), 0)..DisplayPoint::new(DisplayRow(3), 0),\n            ])\n        });\n        editor.delete_line(&DeleteLine, window, cx);\n        assert_eq!(editor.display_text(cx), ": "",
        ");\n        assert_eq!(\n            display_ranges(editor, cx),\n            vec![\n                DisplayPoint::new(DisplayRow(0), 0)..DisplayPoint::new(DisplayRow(0), 0),\n                DisplayPoint::new(DisplayRow(0), 1)..DisplayPoint::new(DisplayRow(0), 1),\n            ]\n        );\n    });\n\n    let editor = cx.add_window(|window, cx| {\n        let buffer = MultiBuffer::build_simple(": "",
        ", cx);\n        build_editor(buffer, window, cx)\n    });\n    _ = editor.update(cx, |editor, window, cx| {\n        editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n            s.select_display_ranges([\n                DisplayPoint::new(DisplayRow(2), 0)..DisplayPoint::new(DisplayRow(0), 1)\n            ])\n        });\n        editor.delete_line(&DeleteLine, window, cx);\n        assert_eq!(editor.display_text(cx), ": "",
        ");\n        assert_eq!(\n            display_ranges(editor, cx),\n            vec![DisplayPoint::new(DisplayRow(0), 1)..DisplayPoint::new(DisplayRow(0), 1)]\n        );\n    });\n\n    let editor = cx.add_window(|window, cx| {\n        let buffer = MultiBuffer::build_simple(": "",
        ", cx);\n        build_editor(buffer, window, cx)\n    });\n    _ = editor.update(cx, |editor, window, cx| {\n        editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n            s.select_display_ranges([\n                DisplayPoint::new(DisplayRow(0), 1)..DisplayPoint::new(DisplayRow(2), 1)\n            ])\n        });\n        editor.delete_line(&DeleteLine, window, cx);\n        assert_eq!(editor.display_text(cx), ": "",
        ");\n        assert_eq!(\n            display_ranges(editor, cx),\n            vec![DisplayPoint::new(DisplayRow(0), 0)..DisplayPoint::new(DisplayRow(0), 0)]\n        );\n    });\n}\n\n#[gpui::test]\nfn test_join_lines_with_single_selection(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    cx.add_window(|window, cx| {\n        let buffer = MultiBuffer::build_simple(": "",
        ", cx);\n        let mut editor = build_editor(buffer.clone(), window, cx);\n        let buffer = buffer.read(cx).as_singleton().unwrap();\n\n        assert_eq!(\n            editor\n                .selections\n                .ranges::<Point>(&editor.display_snapshot(cx)),\n            &[Point::new(0, 0)..Point::new(0, 0)]\n        );\n\n        // When on single line, replace newline at end by space\n        editor.join_lines(&JoinLines, window, cx);\n        assert_eq!(buffer.read(cx).text(), ": "",
        ");\n        assert_eq!(\n            editor\n                .selections\n                .ranges::<Point>(&editor.display_snapshot(cx)),\n            &[Point::new(0, 3)..Point::new(0, 3)]\n        );\n\n        // When multiple lines are selected, remove newlines that are spanned by the selection\n        editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n            s.select_ranges([Point::new(0, 5)..Point::new(2, 2)])\n        });\n        editor.join_lines(&JoinLines, window, cx);\n        assert_eq!(buffer.read(cx).text(), ": "",
        ");\n        assert_eq!(\n            editor\n                .selections\n                .ranges::<Point>(&editor.display_snapshot(cx)),\n            &[Point::new(0, 11)..Point::new(0, 11)]\n        );\n\n        // Undo should be transactional\n        editor.undo(&Undo, window, cx);\n        assert_eq!(buffer.read(cx).text(), ": "",
        ");\n        assert_eq!(\n            editor\n                .selections\n                .ranges::<Point>(&editor.display_snapshot(cx)),\n            &[Point::new(0, 5)..Point::new(2, 2)]\n        );\n\n        // When joining an empty line don't insert a space\n        editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n            s.select_ranges([Point::new(2, 1)..Point::new(2, 2)])\n        });\n        editor.join_lines(&JoinLines, window, cx);\n        assert_eq!(buffer.read(cx).text(), ": "",
        ");\n        assert_eq!(\n            editor\n                .selections\n                .ranges::<Point>(&editor.display_snapshot(cx)),\n            [Point::new(2, 3)..Point::new(2, 3)]\n        );\n\n        // We can remove trailing newlines\n        editor.join_lines(&JoinLines, window, cx);\n        assert_eq!(buffer.read(cx).text(), ": "",
        ");\n        assert_eq!(\n            editor\n                .selections\n                .ranges::<Point>(&editor.display_snapshot(cx)),\n            [Point::new(2, 3)..Point::new(2, 3)]\n        );\n\n        // We don't blow up on the last line\n        editor.join_lines(&JoinLines, window, cx);\n        assert_eq!(buffer.read(cx).text(), ": "",
        ");\n        assert_eq!(\n            editor\n                .selections\n                .ranges::<Point>(&editor.display_snapshot(cx)),\n            [Point::new(2, 3)..Point::new(2, 3)]\n        );\n\n        // reset to test indentation\n        editor.buffer.update(cx, |buffer, cx| {\n            buffer.edit(\n                [\n                    (Point::new(1, 0)..Point::new(1, 2), ": "",
        "),\n                    (Point::new(2, 0)..Point::new(2, 3), ": "",
        "),\n                ],\n                None,\n                cx,\n            )\n        });\n\n        // We remove any leading spaces\n        assert_eq!(buffer.read(cx).text(), ": "",
        ");\n        editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n            s.select_ranges([Point::new(0, 1)..Point::new(0, 1)])\n        });\n        editor.join_lines(&JoinLines, window, cx);\n        assert_eq!(buffer.read(cx).text(), ": "",
        ");\n\n        // We don't insert a space for a line containing only spaces\n        editor.join_lines(&JoinLines, window, cx);\n        assert_eq!(buffer.read(cx).text(), ": "",
        ");\n\n        // We ignore any leading tabs\n        editor.join_lines(&JoinLines, window, cx);\n        assert_eq!(buffer.read(cx).text(), ": "",
        ");\n\n        editor\n    });\n}\n\n#[gpui::test]\nfn test_join_lines_with_multi_selection(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    cx.add_window(|window, cx| {\n        let buffer = MultiBuffer::build_simple(": "",
        ", cx);\n        let mut editor = build_editor(buffer.clone(), window, cx);\n        let buffer = buffer.read(cx).as_singleton().unwrap();\n\n        editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n            s.select_ranges([\n                Point::new(0, 2)..Point::new(1, 1),\n                Point::new(1, 2)..Point::new(1, 2),\n                Point::new(3, 1)..Point::new(3, 2),\n            ])\n        });\n\n        editor.join_lines(&JoinLines, window, cx);\n        assert_eq!(buffer.read(cx).text(), ": "",
        ");\n\n        assert_eq!(\n            editor\n                .selections\n                .ranges::<Point>(&editor.display_snapshot(cx)),\n            [\n                Point::new(0, 7)..Point::new(0, 7),\n                Point::new(1, 3)..Point::new(1, 3)\n            ]\n        );\n        editor\n    });\n}\n\n#[gpui::test]\nasync fn test_join_lines_with_git_diff_base(executor: BackgroundExecutor, cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n\n    let diff_base = r#": "",
        "#\n    .unindent();\n\n    cx.set_state(\n        &r#": "",
        "#\n        .unindent(),\n    );\n\n    cx.set_head_text(&diff_base);\n    executor.run_until_parked();\n\n    // Join lines\n    cx.update_editor(|editor, window, cx| {\n        editor.join_lines(&JoinLines, window, cx);\n    });\n    executor.run_until_parked();\n\n    cx.assert_editor_state(\n        &r#": "",
        "#\n        .unindent(),\n    );\n    // Join again\n    cx.update_editor(|editor, window, cx| {\n        editor.join_lines(&JoinLines, window, cx);\n    });\n    executor.run_until_parked();\n\n    cx.assert_editor_state(\n        &r#": "",
        "#\n        .unindent(),\n    );\n}\n\n#[gpui::test]\nasync fn test_custom_newlines_cause_no_false_positive_diffs(\n    executor: BackgroundExecutor,\n    cx: &mut TestAppContext,\n) {\n    init_test(cx, |_| {});\n    let mut cx = EditorTestContext::new(cx).await;\n    cx.set_state(": "",
        ");\n    cx.set_head_text(": "",
        ");\n    executor.run_until_parked();\n\n    cx.update_editor(|editor, window, cx| {\n        let snapshot = editor.snapshot(window, cx);\n        assert_eq!(\n            snapshot\n                .buffer_snapshot()\n                .diff_hunks_in_range(0..snapshot.buffer_snapshot().len())\n                .collect::<Vec<_>>(),\n            Vec::new(),\n            ": "",
        "\n        );\n    });\n}\n\n#[gpui::test]\nasync fn test_manipulate_immutable_lines_with_single_selection(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n\n    // Test sort_lines_case_insensitive()\n    cx.set_state(indoc! {": "",
        "});\n    cx.update_editor(|e, window, cx| {\n        e.sort_lines_case_insensitive(&SortLinesCaseInsensitive, window, cx)\n    });\n    cx.assert_editor_state(indoc! {": "",
        "});\n\n    // Test sort_lines_by_length()\n    //\n    // Demonstrates:\n    // - ∞ is 3 bytes UTF-8, but sorted by its char count (1)\n    // - sort is stable\n    cx.set_state(indoc! {": "",
        "});\n    cx.update_editor(|e, window, cx| e.sort_lines_by_length(&SortLinesByLength, window, cx));\n    cx.assert_editor_state(indoc! {": "",
        "});\n\n    // Test reverse_lines()\n    cx.set_state(indoc! {": "",
        "});\n    cx.update_editor(|e, window, cx| e.reverse_lines(&ReverseLines, window, cx));\n    cx.assert_editor_state(indoc! {": "",
        "});\n\n    // Skip testing shuffle_line()\n\n    // From here on out, test more complex cases of manipulate_immutable_lines() with a single driver method: sort_lines_case_sensitive()\n    // Since all methods calling manipulate_immutable_lines() are doing the exact same general thing (reordering lines)\n\n    // Don't manipulate when cursor is on single line, but expand the selection\n    cx.set_state(indoc! {": "",
        "});\n    cx.update_editor(|e, window, cx| {\n        e.sort_lines_case_sensitive(&SortLinesCaseSensitive, window, cx)\n    });\n    cx.assert_editor_state(indoc! {": "",
        "});\n\n    // Basic manipulate case\n    // Start selection moves to column 0\n    // End of selection shrinks to fit shorter line\n    cx.set_state(indoc! {": "",
        "});\n\n    // Manipulate case with newlines\n    cx.set_state(indoc! {": "",
        "});\n\n    // Adding new line\n    cx.set_state(indoc! {": "",
        "});\n    cx.update_editor(|e, window, cx| {\n        e.manipulate_immutable_lines(window, cx, |lines| lines.push(": "",
        "))\n    });\n    cx.assert_editor_state(indoc! {": "",
        "});\n\n    // Removing line\n    cx.set_state(indoc! {": "",
        "});\n    cx.update_editor(|e, window, cx| {\n        e.manipulate_immutable_lines(window, cx, |lines| {\n            lines.pop();\n        })\n    });\n    cx.assert_editor_state(indoc! {": "",
        "});\n\n    // Removing all lines\n    cx.set_state(indoc! {": "",
        "});\n    cx.update_editor(|e, window, cx| {\n        e.manipulate_immutable_lines(window, cx, |lines| {\n            lines.drain(..);\n        })\n    });\n    cx.assert_editor_state(indoc! {": "",
        "});\n}\n\n#[gpui::test]\nasync fn test_unique_lines_multi_selection(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n\n    // Consider continuous selection as single selection\n    cx.set_state(indoc! {": "",
        "});\n    cx.update_editor(|e, window, cx| {\n        e.unique_lines_case_sensitive(&UniqueLinesCaseSensitive, window, cx)\n    });\n    cx.assert_editor_state(indoc! {": "",
        "});\n    cx.update_editor(|e, window, cx| {\n        e.unique_lines_case_insensitive(&UniqueLinesCaseInsensitive, window, cx)\n    });\n    cx.assert_editor_state(indoc! {": "",
        "});\n\n    // Consider non continuous selection as distinct dedup operations\n    cx.set_state(indoc! {": "",
        "});\n}\n\n#[gpui::test]\nasync fn test_unique_lines_single_selection(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n\n    cx.set_state(indoc! {": "",
        "});\n}\n\n#[gpui::test]\nasync fn test_wrap_in_tag_single_selection(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n\n    let js_language = Arc::new(Language::new(\n        LanguageConfig {\n            name: ": "",
        ".into(),\n            wrap_characters: Some(language::WrapCharactersConfig {\n                start_prefix: ": "",
        ".into(),\n                start_suffix: ": "",
        ".into(),\n                end_prefix: ": "",
        ".into(),\n                end_suffix: ": "",
        ".into(),\n            }),\n            ..LanguageConfig::default()\n        },\n        None,\n    ));\n\n    cx.update_buffer(|buffer, cx| buffer.set_language(Some(js_language), cx));\n\n    cx.set_state(indoc! {": "",
        "});\n    cx.update_editor(|e, window, cx| e.wrap_selections_in_tag(&WrapSelectionsInTag, window, cx));\n    cx.assert_editor_state(indoc! {": "",
        "});\n}\n\n#[gpui::test]\nasync fn test_wrap_in_tag_multi_selection(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n\n    let js_language = Arc::new(Language::new(\n        LanguageConfig {\n            name: ": "",
        "});\n}\n\n#[gpui::test]\nasync fn test_wrap_in_tag_does_nothing_in_unsupported_languages(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n\n    let plaintext_language = Arc::new(Language::new(\n        LanguageConfig {\n            name: ": "",
        ".into(),\n            ..LanguageConfig::default()\n        },\n        None,\n    ));\n\n    cx.update_buffer(|buffer, cx| buffer.set_language(Some(plaintext_language), cx));\n\n    cx.set_state(indoc! {": "",
        "});\n}\n\n#[gpui::test]\nasync fn test_manipulate_immutable_lines_with_multi_selection(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n\n    // Manipulate with multiple selections on a single line\n    cx.set_state(indoc! {": "",
        "});\n\n    // Manipulate with multiple disjoin selections\n    cx.set_state(indoc! {": "",
        "});\n\n    // Adding lines on each selection\n    cx.set_state(indoc! {": "",
        "});\n\n    // Removing lines on each selection\n    cx.set_state(indoc! {": "",
        "});\n}\n\n#[gpui::test]\nasync fn test_convert_indentation_to_spaces(cx: &mut TestAppContext) {\n    init_test(cx, |settings| {\n        settings.defaults.tab_size = NonZeroU32::new(3)\n    });\n\n    let mut cx = EditorTestContext::new(cx).await;\n\n    // MULTI SELECTION\n    // Ln.1 ": "",
        " tests empty lines\n    // Ln.9 tests just leading whitespace\n    cx.set_state(indoc! {": "",
        "});\n    cx.update_editor(|e, window, cx| {\n        e.convert_indentation_to_spaces(&ConvertIndentationToSpaces, window, cx);\n    });\n    cx.assert_editor_state(\n        indoc! {": "",
        "}\n        .replace(": "",
        ")\n        .as_str(), // · used as placeholder to prevent format-on-save from removing whitespace\n    );\n\n    // Test on just a few lines, the others should remain unchanged\n    // Only lines (3, 5, 10, 11) should change\n    cx.set_state(\n        indoc! {": "",
        ")\n        .as_str(), // · used as placeholder to prevent format-on-save from removing whitespace\n    );\n    cx.update_editor(|e, window, cx| {\n        e.convert_indentation_to_spaces(&ConvertIndentationToSpaces, window, cx);\n    });\n    cx.assert_editor_state(\n        indoc! {": "",
        ")\n        .as_str(), // · used as placeholder to prevent format-on-save from removing whitespace\n    );\n\n    // SINGLE SELECTION\n    // Ln.1 ": "",
        ")\n        .as_str(), // · used as placeholder to prevent format-on-save from removing whitespace\n    );\n}\n\n#[gpui::test]\nasync fn test_convert_indentation_to_tabs(cx: &mut TestAppContext) {\n    init_test(cx, |settings| {\n        settings.defaults.tab_size = NonZeroU32::new(3)\n    });\n\n    let mut cx = EditorTestContext::new(cx).await;\n\n    // MULTI SELECTION\n    // Ln.1 ": "",
        " tests empty lines\n    // Ln.11 tests just leading whitespace\n    cx.set_state(indoc! {": "",
        "});\n    cx.update_editor(|e, window, cx| {\n        e.convert_indentation_to_tabs(&ConvertIndentationToTabs, window, cx);\n    });\n    cx.assert_editor_state(indoc! {": "",
        "});\n\n    // Test on just a few lines, the other should remain unchanged\n    // Only lines (4, 8, 11, 12) should change\n    cx.set_state(\n        indoc! {": "",
        ")\n        .as_str(), // · used as placeholder to prevent format-on-save from removing whitespace\n    );\n    cx.update_editor(|e, window, cx| {\n        e.convert_indentation_to_tabs(&ConvertIndentationToTabs, window, cx);\n    });\n    cx.assert_editor_state(\n        indoc! {": "",
        "});\n}\n\n#[gpui::test]\nasync fn test_toggle_case(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n\n    // If all lower case -> upper case\n    cx.set_state(indoc! {": "",
        "});\n    cx.update_editor(|e, window, cx| e.toggle_case(&ToggleCase, window, cx));\n    cx.assert_editor_state(indoc! {": "",
        "});\n\n    // If all upper case -> lower case\n    cx.set_state(indoc! {": "",
        "});\n\n    // If any upper case characters are identified -> lower case\n    // This matches JetBrains IDEs\n    cx.set_state(indoc! {": "",
        "});\n}\n\n#[gpui::test]\nasync fn test_convert_to_sentence_case(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n\n    cx.set_state(indoc! {": "",
        "});\n    cx.update_editor(|e, window, cx| {\n        e.convert_to_sentence_case(&ConvertToSentenceCase, window, cx)\n    });\n    cx.assert_editor_state(indoc! {": "",
        "});\n}\n\n#[gpui::test]\nasync fn test_manipulate_text(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n\n    // Test convert_to_upper_case()\n    cx.set_state(indoc! {": "",
        "});\n    cx.update_editor(|e, window, cx| e.convert_to_upper_case(&ConvertToUpperCase, window, cx));\n    cx.assert_editor_state(indoc! {": "",
        "});\n\n    // Test convert_to_lower_case()\n    cx.set_state(indoc! {": "",
        "});\n    cx.update_editor(|e, window, cx| e.convert_to_lower_case(&ConvertToLowerCase, window, cx));\n    cx.assert_editor_state(indoc! {": "",
        "});\n\n    // Test multiple line, single selection case\n    cx.set_state(indoc! {": "",
        "});\n    cx.update_editor(|e, window, cx| e.convert_to_title_case(&ConvertToTitleCase, window, cx));\n    cx.assert_editor_state(indoc! {": "",
        "});\n    cx.update_editor(|e, window, cx| {\n        e.convert_to_upper_camel_case(&ConvertToUpperCamelCase, window, cx)\n    });\n    cx.assert_editor_state(indoc! {": "",
        "});\n\n    // From here on out, test more complex cases of manipulate_text()\n\n    // Test no selection case - should affect words cursors are in\n    // Cursor at beginning, middle, and end of word\n    cx.set_state(indoc! {": "",
        "});\n\n    // Test multiple selections on a single line and across multiple lines\n    cx.set_state(indoc! {": "",
        "});\n\n    // Test case where text length grows\n    cx.set_state(indoc! {": "",
        "});\n\n    // Test to make sure we don't crash when text shrinks\n    cx.set_state(indoc! {": "",
        "});\n    cx.update_editor(|e, window, cx| {\n        e.convert_to_lower_camel_case(&ConvertToLowerCamelCase, window, cx)\n    });\n    cx.assert_editor_state(indoc! {": "",
        "});\n\n    // Test to make sure we all aware of the fact that each word can grow and shrink\n    // Final selections should be aware of this fact\n    cx.set_state(indoc! {": "",
        "});\n    cx.update_editor(|e, window, cx| {\n        e.convert_to_opposite_case(&ConvertToOppositeCase, window, cx)\n    });\n    cx.assert_editor_state(indoc! {": "",
        "});\n\n    // Test selections with `line_mode() = true`.\n    cx.update_editor(|editor, _window, _cx| editor.selections.set_line_mode(true));\n    cx.set_state(indoc! {": "",
        "});\n}\n\n#[gpui::test]\nfn test_duplicate_line(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let editor = cx.add_window(|window, cx| {\n        let buffer = MultiBuffer::build_simple(": "",
        ", cx);\n        build_editor(buffer, window, cx)\n    });\n    _ = editor.update(cx, |editor, window, cx| {\n        editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n            s.select_display_ranges([\n                DisplayPoint::new(DisplayRow(0), 0)..DisplayPoint::new(DisplayRow(0), 1),\n                DisplayPoint::new(DisplayRow(0), 2)..DisplayPoint::new(DisplayRow(0), 2),\n                DisplayPoint::new(DisplayRow(1), 0)..DisplayPoint::new(DisplayRow(1), 0),\n                DisplayPoint::new(DisplayRow(3), 0)..DisplayPoint::new(DisplayRow(3), 0),\n            ])\n        });\n        editor.duplicate_line_down(&DuplicateLineDown, window, cx);\n        assert_eq!(editor.display_text(cx), ": "",
        ");\n        assert_eq!(\n            display_ranges(editor, cx),\n            vec![\n                DisplayPoint::new(DisplayRow(1), 0)..DisplayPoint::new(DisplayRow(1), 1),\n                DisplayPoint::new(DisplayRow(1), 2)..DisplayPoint::new(DisplayRow(1), 2),\n                DisplayPoint::new(DisplayRow(3), 0)..DisplayPoint::new(DisplayRow(3), 0),\n                DisplayPoint::new(DisplayRow(6), 0)..DisplayPoint::new(DisplayRow(6), 0),\n            ]\n        );\n    });\n\n    let editor = cx.add_window(|window, cx| {\n        let buffer = MultiBuffer::build_simple(": "",
        ", cx);\n        build_editor(buffer, window, cx)\n    });\n    _ = editor.update(cx, |editor, window, cx| {\n        editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n            s.select_display_ranges([\n                DisplayPoint::new(DisplayRow(0), 1)..DisplayPoint::new(DisplayRow(1), 1),\n                DisplayPoint::new(DisplayRow(1), 2)..DisplayPoint::new(DisplayRow(2), 1),\n            ])\n        });\n        editor.duplicate_line_down(&DuplicateLineDown, window, cx);\n        assert_eq!(editor.display_text(cx), ": "",
        ");\n        assert_eq!(\n            display_ranges(editor, cx),\n            vec![\n                DisplayPoint::new(DisplayRow(3), 1)..DisplayPoint::new(DisplayRow(4), 1),\n                DisplayPoint::new(DisplayRow(4), 2)..DisplayPoint::new(DisplayRow(5), 1),\n            ]\n        );\n    });\n\n    // With `duplicate_line_up` the selections move to the duplicated lines,\n    // which are inserted above the original lines\n    let editor = cx.add_window(|window, cx| {\n        let buffer = MultiBuffer::build_simple(": "",
        ", cx);\n        build_editor(buffer, window, cx)\n    });\n    _ = editor.update(cx, |editor, window, cx| {\n        editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n            s.select_display_ranges([\n                DisplayPoint::new(DisplayRow(0), 0)..DisplayPoint::new(DisplayRow(0), 1),\n                DisplayPoint::new(DisplayRow(0), 2)..DisplayPoint::new(DisplayRow(0), 2),\n                DisplayPoint::new(DisplayRow(1), 0)..DisplayPoint::new(DisplayRow(1), 0),\n                DisplayPoint::new(DisplayRow(3), 0)..DisplayPoint::new(DisplayRow(3), 0),\n            ])\n        });\n        editor.duplicate_line_up(&DuplicateLineUp, window, cx);\n        assert_eq!(editor.display_text(cx), ": "",
        ");\n        assert_eq!(\n            display_ranges(editor, cx),\n            vec![\n                DisplayPoint::new(DisplayRow(0), 0)..DisplayPoint::new(DisplayRow(0), 1),\n                DisplayPoint::new(DisplayRow(0), 2)..DisplayPoint::new(DisplayRow(0), 2),\n                DisplayPoint::new(DisplayRow(2), 0)..DisplayPoint::new(DisplayRow(2), 0),\n                DisplayPoint::new(DisplayRow(5), 0)..DisplayPoint::new(DisplayRow(5), 0),\n            ]\n        );\n    });\n\n    let editor = cx.add_window(|window, cx| {\n        let buffer = MultiBuffer::build_simple(": "",
        ", cx);\n        build_editor(buffer, window, cx)\n    });\n    _ = editor.update(cx, |editor, window, cx| {\n        editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n            s.select_display_ranges([\n                DisplayPoint::new(DisplayRow(0), 1)..DisplayPoint::new(DisplayRow(1), 1),\n                DisplayPoint::new(DisplayRow(1), 2)..DisplayPoint::new(DisplayRow(2), 1),\n            ])\n        });\n        editor.duplicate_line_up(&DuplicateLineUp, window, cx);\n        assert_eq!(editor.display_text(cx), ": "",
        ");\n        assert_eq!(\n            display_ranges(editor, cx),\n            vec![\n                DisplayPoint::new(DisplayRow(0), 1)..DisplayPoint::new(DisplayRow(1), 1),\n                DisplayPoint::new(DisplayRow(1), 2)..DisplayPoint::new(DisplayRow(2), 1),\n            ]\n        );\n    });\n\n    let editor = cx.add_window(|window, cx| {\n        let buffer = MultiBuffer::build_simple(": "",
        ", cx);\n        build_editor(buffer, window, cx)\n    });\n    _ = editor.update(cx, |editor, window, cx| {\n        editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n            s.select_display_ranges([\n                DisplayPoint::new(DisplayRow(0), 1)..DisplayPoint::new(DisplayRow(1), 1),\n                DisplayPoint::new(DisplayRow(1), 2)..DisplayPoint::new(DisplayRow(2), 1),\n            ])\n        });\n        editor.duplicate_selection(&DuplicateSelection, window, cx);\n        assert_eq!(editor.display_text(cx), ": "",
        ");\n        assert_eq!(\n            display_ranges(editor, cx),\n            vec![\n                DisplayPoint::new(DisplayRow(0), 1)..DisplayPoint::new(DisplayRow(1), 1),\n                DisplayPoint::new(DisplayRow(2), 2)..DisplayPoint::new(DisplayRow(3), 1),\n            ]\n        );\n    });\n}\n\n#[gpui::test]\nfn test_move_line_up_down(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let editor = cx.add_window(|window, cx| {\n        let buffer = MultiBuffer::build_simple(&sample_text(10, 5, 'a'), cx);\n        build_editor(buffer, window, cx)\n    });\n    _ = editor.update(cx, |editor, window, cx| {\n        editor.fold_creases(\n            vec![\n                Crease::simple(Point::new(0, 2)..Point::new(1, 2), FoldPlaceholder::test()),\n                Crease::simple(Point::new(2, 3)..Point::new(4, 1), FoldPlaceholder::test()),\n                Crease::simple(Point::new(7, 0)..Point::new(8, 4), FoldPlaceholder::test()),\n            ],\n            true,\n            window,\n            cx,\n        );\n        editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n            s.select_display_ranges([\n                DisplayPoint::new(DisplayRow(0), 1)..DisplayPoint::new(DisplayRow(0), 1),\n                DisplayPoint::new(DisplayRow(3), 1)..DisplayPoint::new(DisplayRow(3), 1),\n                DisplayPoint::new(DisplayRow(3), 2)..DisplayPoint::new(DisplayRow(4), 3),\n                DisplayPoint::new(DisplayRow(5), 0)..DisplayPoint::new(DisplayRow(5), 2),\n            ])\n        });\n        assert_eq!(\n            editor.display_text(cx),\n            ": "",
        "\n        );\n\n        editor.move_line_up(&MoveLineUp, window, cx);\n        assert_eq!(\n            editor.display_text(cx),\n            ": "",
        "\n        );\n        assert_eq!(\n            display_ranges(editor, cx),\n            vec![\n                DisplayPoint::new(DisplayRow(0), 1)..DisplayPoint::new(DisplayRow(0), 1),\n                DisplayPoint::new(DisplayRow(2), 1)..DisplayPoint::new(DisplayRow(2), 1),\n                DisplayPoint::new(DisplayRow(2), 2)..DisplayPoint::new(DisplayRow(3), 3),\n                DisplayPoint::new(DisplayRow(4), 0)..DisplayPoint::new(DisplayRow(4), 2)\n            ]\n        );\n    });\n\n    _ = editor.update(cx, |editor, window, cx| {\n        editor.move_line_down(&MoveLineDown, window, cx);\n        assert_eq!(\n            editor.display_text(cx),\n            ": "",
        "\n        );\n        assert_eq!(\n            display_ranges(editor, cx),\n            vec![\n                DisplayPoint::new(DisplayRow(1), 1)..DisplayPoint::new(DisplayRow(1), 1),\n                DisplayPoint::new(DisplayRow(3), 1)..DisplayPoint::new(DisplayRow(3), 1),\n                DisplayPoint::new(DisplayRow(3), 2)..DisplayPoint::new(DisplayRow(4), 3),\n                DisplayPoint::new(DisplayRow(5), 0)..DisplayPoint::new(DisplayRow(5), 2)\n            ]\n        );\n    });\n\n    _ = editor.update(cx, |editor, window, cx| {\n        editor.move_line_down(&MoveLineDown, window, cx);\n        assert_eq!(\n            editor.display_text(cx),\n            ": "",
        "\n        );\n        assert_eq!(\n            display_ranges(editor, cx),\n            vec![\n                DisplayPoint::new(DisplayRow(2), 1)..DisplayPoint::new(DisplayRow(2), 1),\n                DisplayPoint::new(DisplayRow(3), 1)..DisplayPoint::new(DisplayRow(3), 1),\n                DisplayPoint::new(DisplayRow(3), 2)..DisplayPoint::new(DisplayRow(4), 3),\n                DisplayPoint::new(DisplayRow(5), 0)..DisplayPoint::new(DisplayRow(5), 2)\n            ]\n        );\n    });\n\n    _ = editor.update(cx, |editor, window, cx| {\n        editor.move_line_up(&MoveLineUp, window, cx);\n        assert_eq!(\n            editor.display_text(cx),\n            ": "",
        "\n        );\n        assert_eq!(\n            display_ranges(editor, cx),\n            vec![\n                DisplayPoint::new(DisplayRow(1), 1)..DisplayPoint::new(DisplayRow(1), 1),\n                DisplayPoint::new(DisplayRow(2), 1)..DisplayPoint::new(DisplayRow(2), 1),\n                DisplayPoint::new(DisplayRow(2), 2)..DisplayPoint::new(DisplayRow(3), 3),\n                DisplayPoint::new(DisplayRow(4), 0)..DisplayPoint::new(DisplayRow(4), 2)\n            ]\n        );\n    });\n}\n\n#[gpui::test]\nfn test_move_line_up_selection_at_end_of_fold(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n    let editor = cx.add_window(|window, cx| {\n        let buffer = MultiBuffer::build_simple(": "",
        ", cx);\n        build_editor(buffer, window, cx)\n    });\n    _ = editor.update(cx, |editor, window, cx| {\n        editor.fold_creases(\n            vec![Crease::simple(\n                Point::new(6, 4)..Point::new(7, 4),\n                FoldPlaceholder::test(),\n            )],\n            true,\n            window,\n            cx,\n        );\n        editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n            s.select_ranges([Point::new(7, 4)..Point::new(7, 4)])\n        });\n        assert_eq!(editor.display_text(cx), ": "",
        ");\n        editor.move_line_up(&MoveLineUp, window, cx);\n        let buffer_text = editor.buffer.read(cx).snapshot(cx).text();\n        assert_eq!(buffer_text, ": "",
        ");\n    });\n}\n\n#[gpui::test]\nfn test_move_line_up_down_with_blocks(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let editor = cx.add_window(|window, cx| {\n        let buffer = MultiBuffer::build_simple(&sample_text(10, 5, 'a'), cx);\n        build_editor(buffer, window, cx)\n    });\n    _ = editor.update(cx, |editor, window, cx| {\n        let snapshot = editor.buffer.read(cx).snapshot(cx);\n        editor.insert_blocks(\n            [BlockProperties {\n                style: BlockStyle::Fixed,\n                placement: BlockPlacement::Below(snapshot.anchor_after(Point::new(2, 0))),\n                height: Some(1),\n                render: Arc::new(|_| div().into_any()),\n                priority: 0,\n            }],\n            Some(Autoscroll::fit()),\n            cx,\n        );\n        editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n            s.select_ranges([Point::new(2, 0)..Point::new(2, 0)])\n        });\n        editor.move_line_down(&MoveLineDown, window, cx);\n    });\n}\n\n#[gpui::test]\nasync fn test_selections_and_replace_blocks(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n    cx.set_state(\n        &": "",
        "\n        .unindent(),\n    );\n\n    // Create a four-line block that replaces three lines of text.\n    cx.update_editor(|editor, window, cx| {\n        let snapshot = editor.snapshot(window, cx);\n        let snapshot = &snapshot.buffer_snapshot();\n        let placement = BlockPlacement::Replace(\n            snapshot.anchor_after(Point::new(1, 0))..=snapshot.anchor_after(Point::new(3, 0)),\n        );\n        editor.insert_blocks(\n            [BlockProperties {\n                placement,\n                height: Some(4),\n                style: BlockStyle::Sticky,\n                render: Arc::new(|_| gpui::div().into_any_element()),\n                priority: 0,\n            }],\n            None,\n            cx,\n        );\n    });\n\n    // Move down so that the cursor touches the block.\n    cx.update_editor(|editor, window, cx| {\n        editor.move_down(&Default::default(), window, cx);\n    });\n    cx.assert_editor_state(\n        &": "",
        "\n        .unindent(),\n    );\n\n    // Move down past the block.\n    cx.update_editor(|editor, window, cx| {\n        editor.move_down(&Default::default(), window, cx);\n    });\n    cx.assert_editor_state(\n        &": "",
        "\n        .unindent(),\n    );\n}\n\n#[gpui::test]\nfn test_transpose(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    _ = cx.add_window(|window, cx| {\n        let mut editor = build_editor(MultiBuffer::build_simple(": "",
        ", cx), window, cx);\n        editor.set_style(EditorStyle::default(), window, cx);\n        editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n            s.select_ranges([1..1])\n        });\n        editor.transpose(&Default::default(), window, cx);\n        assert_eq!(editor.text(cx), ": "",
        ");\n        assert_eq!(\n            editor.selections.ranges(&editor.display_snapshot(cx)),\n            [2..2]\n        );\n\n        editor.transpose(&Default::default(), window, cx);\n        assert_eq!(editor.text(cx), ": "",
        ");\n        assert_eq!(\n            editor.selections.ranges(&editor.display_snapshot(cx)),\n            [3..3]\n        );\n\n        editor.transpose(&Default::default(), window, cx);\n        assert_eq!(editor.text(cx), ": "",
        ");\n        assert_eq!(\n            editor.selections.ranges(&editor.display_snapshot(cx)),\n            [3..3]\n        );\n\n        editor\n    });\n\n    _ = cx.add_window(|window, cx| {\n        let mut editor = build_editor(MultiBuffer::build_simple(": "",
        ", cx), window, cx);\n        editor.set_style(EditorStyle::default(), window, cx);\n        editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n            s.select_ranges([3..3])\n        });\n        editor.transpose(&Default::default(), window, cx);\n        assert_eq!(editor.text(cx), ": "",
        ");\n        assert_eq!(\n            editor.selections.ranges(&editor.display_snapshot(cx)),\n            [3..3]\n        );\n\n        editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n            s.select_ranges([4..4])\n        });\n        editor.transpose(&Default::default(), window, cx);\n        assert_eq!(editor.text(cx), ": "",
        ");\n        assert_eq!(\n            editor.selections.ranges(&editor.display_snapshot(cx)),\n            [5..5]\n        );\n\n        editor.transpose(&Default::default(), window, cx);\n        assert_eq!(editor.text(cx), ": "",
        ");\n        assert_eq!(\n            editor.selections.ranges(&editor.display_snapshot(cx)),\n            [6..6]\n        );\n\n        editor.transpose(&Default::default(), window, cx);\n        assert_eq!(editor.text(cx), ": "",
        ");\n        assert_eq!(\n            editor.selections.ranges(&editor.display_snapshot(cx)),\n            [6..6]\n        );\n\n        editor\n    });\n\n    _ = cx.add_window(|window, cx| {\n        let mut editor = build_editor(MultiBuffer::build_simple(": "",
        ", cx), window, cx);\n        editor.set_style(EditorStyle::default(), window, cx);\n        editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n            s.select_ranges([1..1, 2..2, 4..4])\n        });\n        editor.transpose(&Default::default(), window, cx);\n        assert_eq!(editor.text(cx), ": "",
        ");\n        assert_eq!(\n            editor.selections.ranges(&editor.display_snapshot(cx)),\n            [2..2, 3..3, 5..5]\n        );\n\n        editor.transpose(&Default::default(), window, cx);\n        assert_eq!(editor.text(cx), ": "",
        ");\n        assert_eq!(\n            editor.selections.ranges(&editor.display_snapshot(cx)),\n            [3..3, 4..4, 6..6]\n        );\n\n        editor.transpose(&Default::default(), window, cx);\n        assert_eq!(editor.text(cx), ": "",
        ");\n        assert_eq!(\n            editor.selections.ranges(&editor.display_snapshot(cx)),\n            [4..4, 6..6]\n        );\n\n        editor.transpose(&Default::default(), window, cx);\n        assert_eq!(editor.text(cx), ": "",
        ");\n        assert_eq!(\n            editor.selections.ranges(&editor.display_snapshot(cx)),\n            [5..5, 6..6]\n        );\n\n        editor\n    });\n\n    _ = cx.add_window(|window, cx| {\n        let mut editor = build_editor(MultiBuffer::build_simple(": "",
        ", cx), window, cx);\n        editor.set_style(EditorStyle::default(), window, cx);\n        editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n            s.select_ranges([4..4])\n        });\n        editor.transpose(&Default::default(), window, cx);\n        assert_eq!(editor.text(cx), ": "",
        ");\n        assert_eq!(\n            editor.selections.ranges(&editor.display_snapshot(cx)),\n            [8..8]\n        );\n\n        editor.transpose(&Default::default(), window, cx);\n        assert_eq!(editor.text(cx), ": "",
        ");\n        assert_eq!(\n            editor.selections.ranges(&editor.display_snapshot(cx)),\n            [11..11]\n        );\n\n        editor.transpose(&Default::default(), window, cx);\n        assert_eq!(editor.text(cx), ": "",
        ");\n        assert_eq!(\n            editor.selections.ranges(&editor.display_snapshot(cx)),\n            [11..11]\n        );\n\n        editor\n    });\n}\n\n#[gpui::test]\nasync fn test_rewrap(cx: &mut TestAppContext) {\n    init_test(cx, |settings| {\n        settings.languages.0.extend([\n            (\n                ": "",
        ".into(),\n                LanguageSettingsContent {\n                    allow_rewrap: Some(language_settings::RewrapBehavior::Anywhere),\n                    preferred_line_length: Some(40),\n                    ..Default::default()\n                },\n            ),\n            (\n                ": "",
        ".into(),\n                LanguageSettingsContent {\n                    allow_rewrap: Some(language_settings::RewrapBehavior::InComments),\n                    preferred_line_length: Some(40),\n                    ..Default::default()\n                },\n            ),\n            (\n                ": "",
        ".into(),\n                LanguageSettingsContent {\n                    allow_rewrap: Some(language_settings::RewrapBehavior::InComments),\n                    preferred_line_length: Some(40),\n                    ..Default::default()\n                },\n            ),\n        ])\n    });\n\n    let mut cx = EditorTestContext::new(cx).await;\n\n    let cpp_language = Arc::new(Language::new(\n        LanguageConfig {\n            name: ": "",
        ".into(),\n            line_comments: vec![": "",
        ".into()],\n            ..LanguageConfig::default()\n        },\n        None,\n    ));\n    let python_language = Arc::new(Language::new(\n        LanguageConfig {\n            name: ": "",
        ".into()],\n            ..LanguageConfig::default()\n        },\n        None,\n    ));\n    let markdown_language = Arc::new(Language::new(\n        LanguageConfig {\n            name: ": "",
        ".into(),\n            rewrap_prefixes: vec![\n                regex::Regex::new(": "",
        ").unwrap(),\n                regex::Regex::new(": "",
        ").unwrap(),\n            ],\n            ..LanguageConfig::default()\n        },\n        None,\n    ));\n    let rust_language = Arc::new(\n        Language::new(\n            LanguageConfig {\n                name: ": "",
        ".into(),\n                line_comments: vec![": "",
        ".into()],\n                ..LanguageConfig::default()\n            },\n            Some(tree_sitter_rust::LANGUAGE.into()),\n        )\n        .with_override_query(": "",
        ")\n        .unwrap(),\n    );\n\n    let plaintext_language = Arc::new(Language::new(\n        LanguageConfig {\n            name: ": "",
        ".into(),\n            ..LanguageConfig::default()\n        },\n        None,\n    ));\n\n    // Test basic rewrapping of a long line with a cursor\n    assert_rewrap(\n        indoc! {": "",
        "},\n        indoc! {": "",
        "},\n        cpp_language.clone(),\n        &mut cx,\n    );\n\n    // Test rewrapping a full selection\n    assert_rewrap(\n        indoc! {": "",
        "\n        },\n        indoc! {": "",
        "\n        },\n        cpp_language.clone(),\n        &mut cx,\n    );\n\n    // Test multiple cursors on different lines within the same paragraph are preserved after rewrapping\n    assert_rewrap(\n        indoc! {": "",
        "},\n        cpp_language.clone(),\n        &mut cx,\n    );\n\n    // Test multiple cursors in different paragraphs trigger separate rewraps\n    assert_rewrap(\n        indoc! {": "",
        "},\n        cpp_language.clone(),\n        &mut cx,\n    );\n\n    // Test that change in comment prefix (e.g., `//` to `///`) trigger seperate rewraps\n    assert_rewrap(\n        indoc! {": "",
        "},\n        rust_language.clone(),\n        &mut cx,\n    );\n\n    // Test that change in indentation level trigger seperate rewraps\n    assert_rewrap(\n        indoc! {": "",
        "},\n        rust_language.clone(),\n        &mut cx,\n    );\n\n    // Test that different comment prefix characters (e.g., '#') are handled correctly\n    assert_rewrap(\n        indoc! {": "",
        "},\n        python_language,\n        &mut cx,\n    );\n\n    // Test rewrapping only affects comments, not code even when selected\n    assert_rewrap(\n        indoc! {": "",
        "},\n        rust_language.clone(),\n        &mut cx,\n    );\n\n    // Test that rewrapping works in Markdown documents where `allow_rewrap` is `Anywhere`\n    assert_rewrap(\n        indoc! {": "",
        "},\n        markdown_language.clone(),\n        &mut cx,\n    );\n\n    // Test that rewrapping boundary works and preserves relative indent for Markdown documents\n    assert_rewrap(\n        indoc! {": "",
        "},\n        markdown_language.clone(),\n        &mut cx,\n    );\n\n    // Test that rewrapping add indents for rewrapping boundary if not exists already.\n    assert_rewrap(\n        indoc! {": "",
        "},\n        markdown_language.clone(),\n        &mut cx,\n    );\n\n    // Test that rewrapping maintain indents even when they already exists.\n    assert_rewrap(\n        indoc! {": "",
        "},\n        markdown_language,\n        &mut cx,\n    );\n\n    // Test that rewrapping works in plain text where `allow_rewrap` is `Anywhere`\n    assert_rewrap(\n        indoc! {": "",
        "},\n        plaintext_language.clone(),\n        &mut cx,\n    );\n\n    // Test that non-commented code acts as a paragraph boundary within a selection\n    assert_rewrap(\n        indoc! {": "",
        "},\n        rust_language,\n        &mut cx,\n    );\n\n    // Test rewrapping multiple selections, including ones with blank lines or tabs\n    assert_rewrap(\n        indoc! {": "",
        "},\n        plaintext_language,\n        &mut cx,\n    );\n\n    // Test that an empty comment line acts as a paragraph boundary\n    assert_rewrap(\n        indoc! {": "",
        "},\n        cpp_language,\n        &mut cx,\n    );\n\n    #[track_caller]\n    fn assert_rewrap(\n        unwrapped_text: &str,\n        wrapped_text: &str,\n        language: Arc<Language>,\n        cx: &mut EditorTestContext,\n    ) {\n        cx.update_buffer(|buffer, cx| buffer.set_language(Some(language), cx));\n        cx.set_state(unwrapped_text);\n        cx.update_editor(|e, window, cx| e.rewrap(&Rewrap, window, cx));\n        cx.assert_editor_state(wrapped_text);\n    }\n}\n\n#[gpui::test]\nasync fn test_rewrap_block_comments(cx: &mut TestAppContext) {\n    init_test(cx, |settings| {\n        settings.languages.0.extend([(\n            ": "",
        ".into(),\n            LanguageSettingsContent {\n                allow_rewrap: Some(language_settings::RewrapBehavior::InComments),\n                preferred_line_length: Some(40),\n                ..Default::default()\n            },\n        )])\n    });\n\n    let mut cx = EditorTestContext::new(cx).await;\n\n    let rust_lang = Arc::new(\n        Language::new(\n            LanguageConfig {\n                name: ": "",
        ".into()],\n                block_comment: Some(BlockCommentConfig {\n                    start: ": "",
        ".into(),\n                    tab_size: 1,\n                }),\n                documentation_comment: Some(BlockCommentConfig {\n                    start: ": "",
        ")\n        .unwrap(),\n    );\n\n    // regular block comment\n    assert_rewrap(\n        indoc! {": "",
        "},\n        rust_lang.clone(),\n        &mut cx,\n    );\n\n    // indent is respected\n    assert_rewrap(\n        indoc! {": "",
        "},\n        rust_lang.clone(),\n        &mut cx,\n    );\n\n    // short block comments with inline delimiters\n    assert_rewrap(\n        indoc! {": "",
        "},\n        rust_lang.clone(),\n        &mut cx,\n    );\n\n    // multiline block comment with inline start/end delimiters\n    assert_rewrap(\n        indoc! {": "",
        "},\n        rust_lang.clone(),\n        &mut cx,\n    );\n\n    // block comment rewrap still respects paragraph bounds\n    assert_rewrap(\n        indoc! {": "",
        "},\n        rust_lang.clone(),\n        &mut cx,\n    );\n\n    // documentation comments\n    assert_rewrap(\n        indoc! {": "",
        "},\n        rust_lang.clone(),\n        &mut cx,\n    );\n\n    // different, adjacent comments\n    assert_rewrap(\n        indoc! {": "",
        "},\n        rust_lang.clone(),\n        &mut cx,\n    );\n\n    // selection w/ single short block comment\n    assert_rewrap(\n        indoc! {": "",
        "},\n        rust_lang.clone(),\n        &mut cx,\n    );\n\n    // rewrapping a single comment w/ abutting comments\n    assert_rewrap(\n        indoc! {": "",
        "},\n        rust_lang.clone(),\n        &mut cx,\n    );\n\n    // selection w/ non-abutting short block comments\n    assert_rewrap(\n        indoc! {": "",
        "},\n        rust_lang.clone(),\n        &mut cx,\n    );\n\n    // selection of multiline block comments\n    assert_rewrap(\n        indoc! {": "",
        "},\n        rust_lang.clone(),\n        &mut cx,\n    );\n\n    // partial selection of multiline block comments\n    assert_rewrap(\n        indoc! {": "",
        "},\n        rust_lang.clone(),\n        &mut cx,\n    );\n\n    // selection w/ abutting short block comments\n    // TODO: should not be combined; should rewrap as 2 comments\n    assert_rewrap(\n        indoc! {": "",
        "},\n        // desired behavior:\n        // indoc! {": "",
        "},\n        // actual behaviour:\n        indoc! {": "",
        "},\n        rust_lang.clone(),\n        &mut cx,\n    );\n\n    // TODO: same as above, but with delimiters on separate line\n    // assert_rewrap(\n    //     indoc! {": "",
        "},\n    //     // desired:\n    //     // indoc! {": "",
        "},\n    //     // actual: (but with trailing w/s on the empty lines)\n    //     indoc! {": "",
        "},\n    //     rust_lang.clone(),\n    //     &mut cx,\n    // );\n\n    // TODO these are unhandled edge cases; not correct, just documenting known issues\n    assert_rewrap(\n        indoc! {": "",
        "},\n        // desired:\n        // indoc! {": "",
        "},\n        // actual:\n        indoc! {": "",
        "},\n        rust_lang,\n        &mut cx,\n    );\n\n    #[track_caller]\n    fn assert_rewrap(\n        unwrapped_text: &str,\n        wrapped_text: &str,\n        language: Arc<Language>,\n        cx: &mut EditorTestContext,\n    ) {\n        cx.update_buffer(|buffer, cx| buffer.set_language(Some(language), cx));\n        cx.set_state(unwrapped_text);\n        cx.update_editor(|e, window, cx| e.rewrap(&Rewrap, window, cx));\n        cx.assert_editor_state(wrapped_text);\n    }\n}\n\n#[gpui::test]\nasync fn test_hard_wrap(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n    let mut cx = EditorTestContext::new(cx).await;\n\n    cx.update_buffer(|buffer, cx| buffer.set_language(Some(git_commit_lang()), cx));\n    cx.update_editor(|editor, _, cx| {\n        editor.set_hard_wrap(Some(14), cx);\n    });\n\n    cx.set_state(indoc!(\n        ": "",
        "\n    ));\n    cx.simulate_input(": "",
        ");\n    cx.run_until_parked();\n\n    cx.assert_editor_state(indoc!(\n        ": "",
        "\n    ));\n\n    cx.update_editor(|editor, window, cx| {\n        editor.newline(&Default::default(), window, cx);\n    });\n    cx.run_until_parked();\n    cx.assert_editor_state(indoc!(\n        ": "",
        "\n    ));\n\n    cx.simulate_input(": "",
        ");\n    cx.run_until_parked();\n    cx.assert_editor_state(indoc!(\n        ": "",
        "\n    ));\n\n    cx.update_editor(|editor, window, cx| {\n        editor.newline(&Default::default(), window, cx);\n    });\n    cx.run_until_parked();\n    cx.simulate_input(": "",
        "\n    ));\n}\n\n#[gpui::test]\nasync fn test_cut_line_ends(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n\n    cx.set_state(indoc! {": "",
        "});\n    cx.update_editor(|e, window, cx| e.cut_to_end_of_line(&CutToEndOfLine::default(), window, cx));\n    cx.assert_editor_state(indoc! {": "",
        "});\n    cx.update_editor(|e, window, cx| e.kill_ring_cut(&KillRingCut, window, cx));\n    cx.assert_editor_state(indoc! {": "",
        "});\n    cx.update_editor(|e, window, cx| e.cut(&Cut, window, cx));\n    cx.assert_editor_state(indoc! {": "",
        "});\n    cx.update_editor(|e, window, cx| {\n        e.cut_to_end_of_line(\n            &CutToEndOfLine {\n                stop_at_newlines: true,\n            },\n            window,\n            cx,\n        )\n    });\n    cx.assert_editor_state(indoc! {": "",
        "});\n}\n\n#[gpui::test]\nasync fn test_clipboard(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n\n    cx.set_state(": "",
        ");\n    cx.update_editor(|e, window, cx| e.cut(&Cut, window, cx));\n    cx.assert_editor_state(": "",
        ");\n\n    // Paste with three cursors. Each cursor pastes one slice of the clipboard text.\n    cx.set_state(": "",
        ");\n    cx.update_editor(|e, window, cx| e.paste(&Paste, window, cx));\n    cx.assert_editor_state(": "",
        ");\n\n    // Paste again but with only two cursors. Since the number of cursors doesn't\n    // match the number of slices in the clipboard, the entire clipboard text\n    // is pasted at each cursor.\n    cx.set_state(": "",
        ");\n    cx.update_editor(|e, window, cx| {\n        e.handle_input(": "",
        ", window, cx);\n        e.paste(&Paste, window, cx);\n        e.handle_input(": "",
        ", window, cx);\n    });\n    cx.assert_editor_state(\n        &([\n            ": "",
        ",\n            ": "",
        ",\n        ]\n        .join(": "",
        ")),\n    );\n\n    // Cut with three selections, one of which is full-line.\n    cx.set_state(indoc! {": "",
        "});\n\n    // Paste with three selections, noticing how the copied selection that was full-line\n    // gets inserted before the second cursor.\n    cx.set_state(indoc! {": "",
        "});\n    cx.update_editor(|e, window, cx| e.paste(&Paste, window, cx));\n    cx.assert_editor_state(indoc! {": "",
        "});\n\n    // Copy with a single cursor only, which writes the whole line into the clipboard.\n    cx.set_state(indoc! {": "",
        "});\n    cx.update_editor(|e, window, cx| e.copy(&Copy, window, cx));\n    assert_eq!(\n        cx.read_from_clipboard()\n            .and_then(|item| item.text().as_deref().map(str::to_string)),\n        Some(": "",
        ".to_string())\n    );\n\n    // Paste with three selections, noticing how the copied full-line selection is inserted\n    // before the empty selections but replaces the selection that is non-empty.\n    cx.set_state(indoc! {": "",
        "});\n}\n\n#[gpui::test]\nasync fn test_copy_trim(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n    cx.set_state(\n        r#": "",
        "#,\n    );\n    cx.update_editor(|e, window, cx| e.copy(&Copy, window, cx));\n    assert_eq!(\n        cx.read_from_clipboard()\n            .and_then(|item| item.text().as_deref().map(str::to_string)),\n        Some(\n            ": "",
        "\n                .to_string()\n        ),\n        ": "",
        ",\n    );\n    cx.update_editor(|e, window, cx| e.copy_and_trim(&CopyAndTrim, window, cx));\n    assert_eq!(\n        cx.read_from_clipboard()\n            .and_then(|item| item.text().as_deref().map(str::to_string)),\n        Some(\n            ": "",
        "\n    );\n\n    cx.set_state(\n        r#": "",
        "#,\n    );\n    cx.update_editor(|e, window, cx| e.copy_and_trim(&CopyAndTrim, window, cx));\n    assert_eq!(\n        cx.read_from_clipboard()\n            .and_then(|item| item.text().as_deref().map(str::to_string)),\n        Some(\n            ": "",
        "\n            .to_string()\n        ),\n        ": "",
        "\n    );\n}\n\n#[gpui::test]\nasync fn test_paste_multiline(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n    cx.update_buffer(|buffer, cx| buffer.set_language(Some(rust_lang()), cx));\n\n    // Cut an indented block, without the leading whitespace.\n    cx.set_state(indoc! {": "",
        "});\n\n    // Paste it at the same position.\n    cx.update_editor(|e, window, cx| e.paste(&Paste, window, cx));\n    cx.assert_editor_state(indoc! {": "",
        "});\n\n    // Paste it at a line with a lower indent level.\n    cx.set_state(indoc! {": "",
        "});\n\n    // Cut an indented block, with the leading whitespace.\n    cx.set_state(indoc! {": "",
        "});\n\n    // Paste it at a line with a higher indent level.\n    cx.set_state(indoc! {": "",
        "});\n\n    // Copy an indented block, starting mid-line\n    cx.set_state(indoc! {": "",
        "});\n    cx.update_editor(|e, window, cx| e.copy(&Copy, window, cx));\n\n    // Paste it on a line with a lower indent level\n    cx.update_editor(|e, window, cx| e.move_to_end(&Default::default(), window, cx));\n    cx.update_editor(|e, window, cx| e.paste(&Paste, window, cx));\n    cx.assert_editor_state(indoc! {": "",
        "});\n}\n\n#[gpui::test]\nasync fn test_paste_content_from_other_app(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    cx.write_to_clipboard(ClipboardItem::new_string(\n        ": "",
        ".into(),\n    ));\n\n    let mut cx = EditorTestContext::new(cx).await;\n    cx.update_buffer(|buffer, cx| buffer.set_language(Some(rust_lang()), cx));\n\n    cx.set_state(indoc! {": "",
        "});\n\n    cx.update_editor(|e, window, cx| e.paste(&Paste, window, cx));\n    cx.assert_editor_state(indoc! {": "",
        "});\n}\n\n#[gpui::test]\nfn test_select_all(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let editor = cx.add_window(|window, cx| {\n        let buffer = MultiBuffer::build_simple(": "",
        ", cx);\n        build_editor(buffer, window, cx)\n    });\n    _ = editor.update(cx, |editor, window, cx| {\n        editor.select_all(&SelectAll, window, cx);\n        assert_eq!(\n            display_ranges(editor, cx),\n            &[DisplayPoint::new(DisplayRow(0), 0)..DisplayPoint::new(DisplayRow(2), 3)]\n        );\n    });\n}\n\n#[gpui::test]\nfn test_select_line(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let editor = cx.add_window(|window, cx| {\n        let buffer = MultiBuffer::build_simple(&sample_text(6, 5, 'a'), cx);\n        build_editor(buffer, window, cx)\n    });\n    _ = editor.update(cx, |editor, window, cx| {\n        editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n            s.select_display_ranges([\n                DisplayPoint::new(DisplayRow(0), 0)..DisplayPoint::new(DisplayRow(0), 1),\n                DisplayPoint::new(DisplayRow(0), 2)..DisplayPoint::new(DisplayRow(0), 2),\n                DisplayPoint::new(DisplayRow(1), 0)..DisplayPoint::new(DisplayRow(1), 0),\n                DisplayPoint::new(DisplayRow(4), 2)..DisplayPoint::new(DisplayRow(4), 2),\n            ])\n        });\n        editor.select_line(&SelectLine, window, cx);\n        assert_eq!(\n            display_ranges(editor, cx),\n            vec![\n                DisplayPoint::new(DisplayRow(0), 0)..DisplayPoint::new(DisplayRow(2), 0),\n                DisplayPoint::new(DisplayRow(4), 0)..DisplayPoint::new(DisplayRow(5), 0),\n            ]\n        );\n    });\n\n    _ = editor.update(cx, |editor, window, cx| {\n        editor.select_line(&SelectLine, window, cx);\n        assert_eq!(\n            display_ranges(editor, cx),\n            vec![\n                DisplayPoint::new(DisplayRow(0), 0)..DisplayPoint::new(DisplayRow(3), 0),\n                DisplayPoint::new(DisplayRow(4), 0)..DisplayPoint::new(DisplayRow(5), 5),\n            ]\n        );\n    });\n\n    _ = editor.update(cx, |editor, window, cx| {\n        editor.select_line(&SelectLine, window, cx);\n        assert_eq!(\n            display_ranges(editor, cx),\n            vec![DisplayPoint::new(DisplayRow(0), 0)..DisplayPoint::new(DisplayRow(5), 5)]\n        );\n    });\n}\n\n#[gpui::test]\nasync fn test_split_selection_into_lines(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n    let mut cx = EditorTestContext::new(cx).await;\n\n    #[track_caller]\n    fn test(cx: &mut EditorTestContext, initial_state: &'static str, expected_state: &'static str) {\n        cx.set_state(initial_state);\n        cx.update_editor(|e, window, cx| {\n            e.split_selection_into_lines(&Default::default(), window, cx)\n        });\n        cx.assert_editor_state(expected_state);\n    }\n\n    // Selection starts and ends at the middle of lines, left-to-right\n    test(\n        &mut cx,\n        ": "",
        ",\n        ": "",
        ",\n    );\n    // Same thing, right-to-left\n    test(\n        &mut cx,\n        ": "",
        ",\n    );\n\n    // Whole buffer, left-to-right, last line *doesn't* end with newline\n    test(\n        &mut cx,\n        ": "",
        ",\n    );\n\n    // Whole buffer, left-to-right, last line ends with newline\n    test(\n        &mut cx,\n        ": "",
        ",\n    );\n\n    // Starts at the end of a line, ends at the start of another\n    test(\n        &mut cx,\n        ": "",
        ",\n    );\n}\n\n#[gpui::test]\nasync fn test_split_selection_into_lines_interacting_with_creases(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let editor = cx.add_window(|window, cx| {\n        let buffer = MultiBuffer::build_simple(&sample_text(9, 5, 'a'), cx);\n        build_editor(buffer, window, cx)\n    });\n\n    // setup\n    _ = editor.update(cx, |editor, window, cx| {\n        editor.fold_creases(\n            vec![\n                Crease::simple(Point::new(0, 2)..Point::new(1, 2), FoldPlaceholder::test()),\n                Crease::simple(Point::new(2, 3)..Point::new(4, 1), FoldPlaceholder::test()),\n                Crease::simple(Point::new(7, 0)..Point::new(8, 4), FoldPlaceholder::test()),\n            ],\n            true,\n            window,\n            cx,\n        );\n        assert_eq!(\n            editor.display_text(cx),\n            ": "",
        "\n        );\n    });\n\n    _ = editor.update(cx, |editor, window, cx| {\n        editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n            s.select_display_ranges([\n                DisplayPoint::new(DisplayRow(0), 0)..DisplayPoint::new(DisplayRow(0), 1),\n                DisplayPoint::new(DisplayRow(0), 2)..DisplayPoint::new(DisplayRow(0), 2),\n                DisplayPoint::new(DisplayRow(1), 0)..DisplayPoint::new(DisplayRow(1), 0),\n                DisplayPoint::new(DisplayRow(4), 4)..DisplayPoint::new(DisplayRow(4), 4),\n            ])\n        });\n        editor.split_selection_into_lines(&Default::default(), window, cx);\n        assert_eq!(\n            editor.display_text(cx),\n            ": "",
        "\n        );\n    });\n    EditorTestContext::for_editor(editor, cx)\n        .await\n        .assert_editor_state(": "",
        ");\n\n    _ = editor.update(cx, |editor, window, cx| {\n        editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n            s.select_display_ranges([\n                DisplayPoint::new(DisplayRow(5), 0)..DisplayPoint::new(DisplayRow(0), 1)\n            ])\n        });\n        editor.split_selection_into_lines(&Default::default(), window, cx);\n        assert_eq!(\n            editor.display_text(cx),\n            ": "",
        "\n        );\n        assert_eq!(\n            display_ranges(editor, cx),\n            [\n                DisplayPoint::new(DisplayRow(0), 5)..DisplayPoint::new(DisplayRow(0), 5),\n                DisplayPoint::new(DisplayRow(1), 5)..DisplayPoint::new(DisplayRow(1), 5),\n                DisplayPoint::new(DisplayRow(2), 5)..DisplayPoint::new(DisplayRow(2), 5),\n                DisplayPoint::new(DisplayRow(3), 5)..DisplayPoint::new(DisplayRow(3), 5),\n                DisplayPoint::new(DisplayRow(4), 5)..DisplayPoint::new(DisplayRow(4), 5),\n                DisplayPoint::new(DisplayRow(5), 5)..DisplayPoint::new(DisplayRow(5), 5),\n                DisplayPoint::new(DisplayRow(6), 5)..DisplayPoint::new(DisplayRow(6), 5)\n            ]\n        );\n    });\n    EditorTestContext::for_editor(editor, cx)\n        .await\n        .assert_editor_state(\n            ": "",
        ",\n        );\n}\n\n#[gpui::test]\nasync fn test_add_selection_above_below(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n\n    cx.set_state(indoc!(\n        r#": "",
        "#\n    ));\n\n    cx.update_editor(|editor, window, cx| {\n        editor.add_selection_above(&Default::default(), window, cx);\n    });\n\n    cx.assert_editor_state(indoc!(\n        r#": "",
        "#\n    ));\n\n    cx.update_editor(|editor, window, cx| {\n        editor.add_selection_below(&Default::default(), window, cx);\n    });\n\n    cx.assert_editor_state(indoc!(\n        r#": "",
        "#\n    ));\n\n    cx.update_editor(|editor, window, cx| {\n        editor.undo_selection(&Default::default(), window, cx);\n    });\n\n    cx.assert_editor_state(indoc!(\n        r#": "",
        "#\n    ));\n\n    cx.update_editor(|editor, window, cx| {\n        editor.redo_selection(&Default::default(), window, cx);\n    });\n\n    cx.assert_editor_state(indoc!(\n        r#": "",
        "#\n    ));\n\n    // change selections\n    cx.set_state(indoc!(\n        r#": "",
        "#\n    ));\n\n    // Change selections again\n    cx.set_state(indoc!(\n        r#": "",
        "#\n    ));\n\n    cx.update_editor(|editor, window, cx| {\n        editor.add_selection_below(&Default::default(), window, cx);\n    });\n    cx.assert_editor_state(indoc!(\n        r#": "",
        "#\n    ));\n    cx.update_editor(|editor, window, cx| {\n        editor.add_selection_above(&Default::default(), window, cx);\n    });\n\n    cx.assert_editor_state(indoc!(\n        r#": "",
        "#\n    ));\n}\n\n#[gpui::test]\nasync fn test_add_selection_above_below_multi_cursor(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n    let mut cx = EditorTestContext::new(cx).await;\n\n    cx.set_state(indoc!(\n        r#": "",
        "#\n    ));\n\n    cx.update_editor(|editor, window, cx| {\n        editor.add_selection_below(&Default::default(), window, cx);\n    });\n\n    // test multiple cursors expand in the same direction\n    cx.assert_editor_state(indoc!(\n        r#": "",
        "#\n    ));\n\n    cx.update_editor(|editor, window, cx| {\n        editor.add_selection_below(&Default::default(), window, cx);\n    });\n\n    cx.update_editor(|editor, window, cx| {\n        editor.add_selection_below(&Default::default(), window, cx);\n    });\n\n    // test multiple cursors expand below overflow\n    cx.assert_editor_state(indoc!(\n        r#": "",
        "#\n    ));\n\n    cx.update_editor(|editor, window, cx| {\n        editor.add_selection_above(&Default::default(), window, cx);\n    });\n\n    // test multiple cursors retrieves back correctly\n    cx.assert_editor_state(indoc!(\n        r#": "",
        "#\n    ));\n\n    cx.update_editor(|editor, window, cx| {\n        editor.add_selection_above(&Default::default(), window, cx);\n    });\n\n    cx.update_editor(|editor, window, cx| {\n        editor.add_selection_above(&Default::default(), window, cx);\n    });\n\n    // test multiple cursor groups maintain independent direction - first expands up, second shrinks above\n    cx.assert_editor_state(indoc!(\n        r#": "",
        "#\n    ));\n\n    cx.update_editor(|editor, window, cx| {\n        editor.undo_selection(&Default::default(), window, cx);\n    });\n\n    // test undo\n    cx.assert_editor_state(indoc!(\n        r#": "",
        "#\n    ));\n\n    cx.update_editor(|editor, window, cx| {\n        editor.redo_selection(&Default::default(), window, cx);\n    });\n\n    // test redo\n    cx.assert_editor_state(indoc!(\n        r#": "",
        "#\n    ));\n\n    cx.set_state(indoc!(\n        r#": "",
        "#\n    ));\n\n    cx.update_editor(|editor, window, cx| {\n        editor.add_selection_above(&Default::default(), window, cx);\n    });\n\n    // test multiple selections expand in the same direction\n    cx.assert_editor_state(indoc!(\n        r#": "",
        "#\n    ));\n\n    cx.update_editor(|editor, window, cx| {\n        editor.add_selection_above(&Default::default(), window, cx);\n    });\n\n    // test multiple selection upward overflow\n    cx.assert_editor_state(indoc!(\n        r#": "",
        "#\n    ));\n\n    cx.update_editor(|editor, window, cx| {\n        editor.add_selection_below(&Default::default(), window, cx);\n    });\n\n    // test multiple selection retrieves back correctly\n    cx.assert_editor_state(indoc!(\n        r#": "",
        "#\n    ));\n\n    cx.update_editor(|editor, window, cx| {\n        editor.add_selection_below(&Default::default(), window, cx);\n    });\n\n    // test multiple cursor groups maintain independent direction - first shrinks down, second expands below\n    cx.assert_editor_state(indoc!(\n        r#": "",
        "#\n    ));\n}\n\n#[gpui::test]\nasync fn test_add_selection_above_below_multi_cursor_existing_state(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n    let mut cx = EditorTestContext::new(cx).await;\n\n    cx.set_state(indoc!(\n        r#": "",
        "#\n    ));\n\n    cx.update_editor(|editor, window, cx| {\n        editor.add_selection_below(&Default::default(), window, cx);\n        editor.add_selection_below(&Default::default(), window, cx);\n        editor.add_selection_below(&Default::default(), window, cx);\n    });\n\n    // initial state with two multi cursor groups\n    cx.assert_editor_state(indoc!(\n        r#": "",
        "#\n    ));\n\n    // add single cursor in middle - simulate opt click\n    cx.update_editor(|editor, window, cx| {\n        let new_cursor_point = DisplayPoint::new(DisplayRow(2), 4);\n        editor.begin_selection(new_cursor_point, true, 1, window, cx);\n        editor.end_selection(window, cx);\n    });\n\n    cx.assert_editor_state(indoc!(\n        r#": "",
        "#\n    ));\n\n    cx.update_editor(|editor, window, cx| {\n        editor.add_selection_above(&Default::default(), window, cx);\n    });\n\n    // test new added selection expands above and existing selection shrinks\n    cx.assert_editor_state(indoc!(\n        r#": "",
        "#\n    ));\n\n    // intial state with two selection groups\n    cx.set_state(indoc!(\n        r#": "",
        "#\n    ));\n\n    cx.update_editor(|editor, window, cx| {\n        editor.add_selection_above(&Default::default(), window, cx);\n        editor.add_selection_above(&Default::default(), window, cx);\n    });\n\n    cx.assert_editor_state(indoc!(\n        r#": "",
        "#\n    ));\n\n    // add single selection in middle - simulate opt drag\n    cx.update_editor(|editor, window, cx| {\n        let new_cursor_point = DisplayPoint::new(DisplayRow(2), 3);\n        editor.begin_selection(new_cursor_point, true, 1, window, cx);\n        editor.update_selection(\n            DisplayPoint::new(DisplayRow(2), 4),\n            0,\n            gpui::Point::<f32>::default(),\n            window,\n            cx,\n        );\n        editor.end_selection(window, cx);\n    });\n\n    cx.assert_editor_state(indoc!(\n        r#": "",
        "#\n    ));\n\n    cx.update_editor(|editor, window, cx| {\n        editor.add_selection_below(&Default::default(), window, cx);\n    });\n\n    // test new added selection expands below, others shrinks from above\n    cx.assert_editor_state(indoc!(\n        r#": "",
        "#\n    ));\n}\n\n#[gpui::test]\nasync fn test_select_next(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n    let mut cx = EditorTestContext::new(cx).await;\n\n    // Enable case sensitive search.\n    update_test_editor_settings(&mut cx, |settings| {\n        let mut search_settings = SearchSettingsContent::default();\n        search_settings.case_sensitive = Some(true);\n        settings.search = Some(search_settings);\n    });\n\n    cx.set_state(": "",
        ");\n\n    cx.update_editor(|e, window, cx| e.select_next(&SelectNext::default(), window, cx))\n        .unwrap();\n    cx.assert_editor_state(": "",
        ");\n\n    cx.update_editor(|editor, window, cx| editor.undo_selection(&UndoSelection, window, cx));\n    cx.assert_editor_state(": "",
        ");\n\n    cx.update_editor(|editor, window, cx| editor.redo_selection(&RedoSelection, window, cx));\n    cx.assert_editor_state(": "",
        ");\n\n    // Test selection direction should be preserved\n    cx.set_state(": "",
        ");\n\n    // Test case sensitivity\n    cx.set_state(": "",
        ");\n    cx.update_editor(|e, window, cx| {\n        e.select_next(&SelectNext::default(), window, cx).unwrap();\n    });\n    cx.assert_editor_state(": "",
        ");\n\n    // Disable case sensitive search.\n    update_test_editor_settings(&mut cx, |settings| {\n        let mut search_settings = SearchSettingsContent::default();\n        search_settings.case_sensitive = Some(false);\n        settings.search = Some(search_settings);\n    });\n\n    cx.set_state(": "",
        ");\n    cx.update_editor(|e, window, cx| {\n        e.select_next(&SelectNext::default(), window, cx).unwrap();\n        e.select_next(&SelectNext::default(), window, cx).unwrap();\n    });\n    cx.assert_editor_state(": "",
        ");\n}\n\n#[gpui::test]\nasync fn test_select_all_matches(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n    let mut cx = EditorTestContext::new(cx).await;\n\n    // Enable case sensitive search.\n    update_test_editor_settings(&mut cx, |settings| {\n        let mut search_settings = SearchSettingsContent::default();\n        search_settings.case_sensitive = Some(true);\n        settings.search = Some(search_settings);\n    });\n\n    // Test caret-only selections\n    cx.set_state(": "",
        ");\n    cx.update_editor(|e, window, cx| e.select_all_matches(&SelectAllMatches, window, cx))\n        .unwrap();\n    cx.assert_editor_state(": "",
        ");\n\n    // Test left-to-right selections\n    cx.set_state(": "",
        ");\n\n    // Test right-to-left selections\n    cx.set_state(": "",
        ");\n\n    // Test selecting whitespace with caret selection\n    cx.set_state(": "",
        ");\n\n    // Test selecting whitespace with left-to-right selection\n    cx.set_state(": "",
        ");\n\n    // Test no matches with right-to-left selection\n    cx.set_state(": "",
        ");\n\n    // Test with a single word and clip_at_line_ends=true (#29823)\n    cx.set_state(": "",
        ");\n    cx.update_editor(|e, window, cx| {\n        e.set_clip_at_line_ends(true, cx);\n        e.select_all_matches(&SelectAllMatches, window, cx).unwrap();\n        e.set_clip_at_line_ends(false, cx);\n    });\n    cx.assert_editor_state(": "",
        ");\n    cx.update_editor(|e, window, cx| {\n        e.select_all_matches(&SelectAllMatches, window, cx).unwrap();\n    });\n    cx.assert_editor_state(": "",
        ");\n}\n\n#[gpui::test]\nasync fn test_select_all_matches_does_not_scroll(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n\n    let large_body_1 = ": "",
        ".repeat(200);\n    let large_body_2 = ": "",
        ".repeat(200);\n\n    cx.set_state(&format!(\n        ": "",
        "\n    ));\n    let initial_scroll_position = cx.update_editor(|editor, _, cx| {\n        let scroll_position = editor.scroll_position(cx);\n        assert!(scroll_position.y > 0.0, ": "",
        ");\n        scroll_position\n    });\n\n    cx.update_editor(|e, window, cx| e.select_all_matches(&SelectAllMatches, window, cx))\n        .unwrap();\n    cx.assert_editor_state(&format!(\n        ": "",
        "\n    ));\n    let scroll_position_after_selection =\n        cx.update_editor(|editor, _, cx| editor.scroll_position(cx));\n    assert_eq!(\n        initial_scroll_position, scroll_position_after_selection,\n        ": "",
        "\n    );\n}\n\n#[gpui::test]\nasync fn test_undo_format_scrolls_to_last_edit_pos(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorLspTestContext::new_rust(\n        lsp::ServerCapabilities {\n            document_formatting_provider: Some(lsp::OneOf::Left(true)),\n            ..Default::default()\n        },\n        cx,\n    )\n    .await;\n\n    cx.set_state(indoc! {": "",
        "});\n\n    // Make an edit\n    cx.update_editor(|editor, window, cx| {\n        editor.handle_input(": "",
        ", window, cx);\n    });\n\n    // Move cursor to a different position\n    cx.update_editor(|editor, window, cx| {\n        editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n            s.select_ranges([Point::new(4, 2)..Point::new(4, 2)]);\n        });\n    });\n\n    cx.assert_editor_state(indoc! {": "",
        "});\n\n    cx.lsp\n        .set_request_handler::<lsp::request::Formatting, _, _>(move |_, _| async move {\n            Ok(Some(vec![lsp::TextEdit::new(\n                lsp::Range::new(lsp::Position::new(0, 0), lsp::Position::new(0, 0)),\n                ": "",
        ".to_string(),\n            )]))\n        });\n\n    cx.update_editor(|editor, window, cx| editor.format(&Default::default(), window, cx))\n        .unwrap()\n        .await\n        .unwrap();\n\n    cx.assert_editor_state(indoc! {": "",
        "});\n\n    // Undo formatting\n    cx.update_editor(|editor, window, cx| {\n        editor.undo(&Default::default(), window, cx);\n    });\n\n    // Verify cursor moved back to position after edit\n    cx.assert_editor_state(indoc! {": "",
        "});\n}\n\n#[gpui::test]\nasync fn test_undo_edit_prediction_scrolls_to_edit_pos(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n\n    let provider = cx.new(|_| FakeEditPredictionProvider::default());\n    cx.update_editor(|editor, window, cx| {\n        editor.set_edit_prediction_provider(Some(provider.clone()), window, cx);\n    });\n\n    cx.set_state(indoc! {": "",
        "});\n\n    let snapshot = cx.buffer_snapshot();\n    let edit_position = snapshot.anchor_after(Point::new(2, 4));\n\n    cx.update(|_, cx| {\n        provider.update(cx, |provider, _| {\n            provider.set_edit_prediction(Some(edit_prediction::EditPrediction::Local {\n                id: None,\n                edits: vec![(edit_position..edit_position, ": "",
        ".into())],\n                edit_preview: None,\n            }))\n        })\n    });\n\n    cx.update_editor(|editor, window, cx| editor.update_visible_edit_prediction(window, cx));\n    cx.update_editor(|editor, window, cx| {\n        editor.accept_edit_prediction(&crate::AcceptEditPrediction, window, cx)\n    });\n\n    cx.assert_editor_state(indoc! {": "",
        "});\n\n    cx.update_editor(|editor, window, cx| {\n        editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n            s.select_ranges([Point::new(9, 2)..Point::new(9, 2)]);\n        });\n    });\n\n    cx.assert_editor_state(indoc! {": "",
        "});\n\n    cx.update_editor(|editor, window, cx| {\n        editor.undo(&Default::default(), window, cx);\n    });\n\n    cx.assert_editor_state(indoc! {": "",
        "});\n}\n\n#[gpui::test]\nasync fn test_select_next_with_multiple_carets(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n    cx.set_state(\n        r#": "",
        "#,\n    );\n\n    cx.update_editor(|e, window, cx| e.select_next(&SelectNext::default(), window, cx))\n        .unwrap();\n    cx.assert_editor_state(\n        r#": "",
        "#,\n    );\n\n    // noop for multiple selections with different contents\n    cx.update_editor(|e, window, cx| e.select_next(&SelectNext::default(), window, cx))\n        .unwrap();\n    cx.assert_editor_state(\n        r#": "",
        "#,\n    );\n\n    // Test last selection direction should be preserved\n    cx.set_state(\n        r#": "",
        "#,\n    );\n}\n\n#[gpui::test]\nasync fn test_select_previous_multibuffer(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx =\n        EditorTestContext::new_multibuffer(cx, [": "",
        "]);\n\n    cx.assert_editor_state(indoc! {": "",
        "});\n    cx.dispatch_action(SelectPrevious::default());\n    cx.assert_editor_state(indoc! {": "",
        "});\n}\n\n#[gpui::test]\nasync fn test_select_previous_with_single_caret(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n    cx.set_state(": "",
        ");\n\n    cx.update_editor(|e, window, cx| e.select_previous(&SelectPrevious::default(), window, cx))\n        .unwrap();\n    cx.assert_editor_state(": "",
        ");\n}\n\n#[gpui::test]\nasync fn test_select_previous_empty_buffer(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n    cx.set_state(": "",
        ");\n    cx.update_editor(|e, window, cx| e.select_previous(&SelectPrevious::default(), window, cx))\n        .unwrap();\n    cx.assert_editor_state(": "",
        ");\n}\n\n#[gpui::test]\nasync fn test_select_previous_with_multiple_carets(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n    cx.set_state(\n        r#": "",
        "#,\n    );\n\n    cx.update_editor(|e, window, cx| e.select_previous(&SelectPrevious::default(), window, cx))\n        .unwrap();\n    cx.assert_editor_state(\n        r#": "",
        "#,\n    );\n\n    // noop for multiple selections with different contents\n    cx.update_editor(|e, window, cx| e.select_previous(&SelectPrevious::default(), window, cx))\n        .unwrap();\n    cx.assert_editor_state(\n        r#": "",
        "#,\n    );\n}\n\n#[gpui::test]\nasync fn test_select_previous_with_single_selection(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n    let mut cx = EditorTestContext::new(cx).await;\n\n    // Enable case sensitive search.\n    update_test_editor_settings(&mut cx, |settings| {\n        let mut search_settings = SearchSettingsContent::default();\n        search_settings.case_sensitive = Some(true);\n        settings.search = Some(search_settings);\n    });\n\n    cx.set_state(": "",
        ");\n\n    cx.update_editor(|e, window, cx| e.select_previous(&SelectPrevious::default(), window, cx))\n        .unwrap();\n    // selection direction is preserved\n    cx.assert_editor_state(": "",
        ");\n    cx.update_editor(|e, window, cx| {\n        e.select_previous(&SelectPrevious::default(), window, cx)\n            .unwrap();\n        e.select_previous(&SelectPrevious::default(), window, cx)\n            .unwrap();\n    });\n    cx.assert_editor_state(": "",
        ");\n}\n\n#[gpui::test]\nasync fn test_select_larger_smaller_syntax_node(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let language = Arc::new(Language::new(\n        LanguageConfig::default(),\n        Some(tree_sitter_rust::LANGUAGE.into()),\n    ));\n\n    let text = r#": "",
        "text": "",
        "#\n    .unindent();\n\n    let buffer = cx.new(|cx| Buffer::local(text, cx).with_language(language, cx));\n    let buffer = cx.new(|cx| MultiBuffer::singleton(buffer, cx));\n    let (editor, cx) = cx.add_window_view(|window, cx| build_editor(buffer, window, cx));\n\n    editor\n        .condition::<crate::EditorEvent>(cx, |editor, cx| !editor.buffer.read(cx).is_parsing(cx))\n        .await;\n\n    editor.update_in(cx, |editor, window, cx| {\n        editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n            s.select_display_ranges([\n                DisplayPoint::new(DisplayRow(0), 25)..DisplayPoint::new(DisplayRow(0), 25),\n                DisplayPoint::new(DisplayRow(2), 24)..DisplayPoint::new(DisplayRow(2), 12),\n                DisplayPoint::new(DisplayRow(3), 18)..DisplayPoint::new(DisplayRow(3), 18),\n            ]);\n        });\n        editor.select_larger_syntax_node(&SelectLargerSyntaxNode, window, cx);\n    });\n    editor.update(cx, |editor, cx| {\n        assert_text_with_selections(\n            editor,\n            indoc! {r#": "",
        "«ˇtext»": "",
        "#},\n            cx,\n        );\n    });\n\n    editor.update_in(cx, |editor, window, cx| {\n        editor.select_larger_syntax_node(&SelectLargerSyntaxNode, window, cx);\n    });\n    editor.update(cx, |editor, cx| {\n        assert_text_with_selections(\n            editor,\n            indoc! {r#": "",
        "#},\n            cx,\n        );\n    });\n\n    editor.update_in(cx, |editor, window, cx| {\n        editor.select_larger_syntax_node(&SelectLargerSyntaxNode, window, cx);\n    });\n    assert_eq!(\n        editor.update(cx, |editor, cx| editor\n            .selections\n            .display_ranges(&editor.display_snapshot(cx))),\n        &[DisplayPoint::new(DisplayRow(5), 0)..DisplayPoint::new(DisplayRow(0), 0)]\n    );\n\n    // Trying to expand the selected syntax node one more time has no effect.\n    editor.update_in(cx, |editor, window, cx| {\n        editor.select_larger_syntax_node(&SelectLargerSyntaxNode, window, cx);\n    });\n    assert_eq!(\n        editor.update(cx, |editor, cx| editor\n            .selections\n            .display_ranges(&editor.display_snapshot(cx))),\n        &[DisplayPoint::new(DisplayRow(5), 0)..DisplayPoint::new(DisplayRow(0), 0)]\n    );\n\n    editor.update_in(cx, |editor, window, cx| {\n        editor.select_smaller_syntax_node(&SelectSmallerSyntaxNode, window, cx);\n    });\n    editor.update(cx, |editor, cx| {\n        assert_text_with_selections(\n            editor,\n            indoc! {r#": "",
        "#},\n            cx,\n        );\n    });\n\n    editor.update_in(cx, |editor, window, cx| {\n        editor.select_smaller_syntax_node(&SelectSmallerSyntaxNode, window, cx);\n    });\n    editor.update(cx, |editor, cx| {\n        assert_text_with_selections(\n            editor,\n            indoc! {r#": "",
        "teˇxt": "",
        "#},\n            cx,\n        );\n    });\n\n    // Trying to shrink the selected syntax node one more time has no effect.\n    editor.update_in(cx, |editor, window, cx| {\n        editor.select_smaller_syntax_node(&SelectSmallerSyntaxNode, window, cx);\n    });\n    editor.update_in(cx, |editor, _, cx| {\n        assert_text_with_selections(\n            editor,\n            indoc! {r#": "",
        "#},\n            cx,\n        );\n    });\n\n    // Ensure that we keep expanding the selection if the larger selection starts or ends within\n    // a fold.\n    editor.update_in(cx, |editor, window, cx| {\n        editor.fold_creases(\n            vec![\n                Crease::simple(\n                    Point::new(0, 21)..Point::new(0, 24),\n                    FoldPlaceholder::test(),\n                ),\n                Crease::simple(\n                    Point::new(3, 20)..Point::new(3, 22),\n                    FoldPlaceholder::test(),\n                ),\n            ],\n            true,\n            window,\n            cx,\n        );\n        editor.select_larger_syntax_node(&SelectLargerSyntaxNode, window, cx);\n    });\n    editor.update(cx, |editor, cx| {\n        assert_text_with_selections(\n            editor,\n            indoc! {r#": "",
        "#},\n            cx,\n        );\n    });\n}\n\n#[gpui::test]\nasync fn test_select_larger_syntax_node_for_cursor_at_end(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let language = Arc::new(Language::new(\n        LanguageConfig::default(),\n        Some(tree_sitter_rust::LANGUAGE.into()),\n    ));\n\n    let text = ": "",
        ";\n\n    let buffer = cx.new(|cx| Buffer::local(text, cx).with_language(language, cx));\n    let buffer = cx.new(|cx| MultiBuffer::singleton(buffer, cx));\n    let (editor, cx) = cx.add_window_view(|window, cx| build_editor(buffer, window, cx));\n\n    editor\n        .condition::<crate::EditorEvent>(cx, |editor, cx| !editor.buffer.read(cx).is_parsing(cx))\n        .await;\n\n    // Test case 1: Cursor at end of word\n    editor.update_in(cx, |editor, window, cx| {\n        editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n            s.select_display_ranges([\n                DisplayPoint::new(DisplayRow(0), 5)..DisplayPoint::new(DisplayRow(0), 5)\n            ]);\n        });\n    });\n    editor.update(cx, |editor, cx| {\n        assert_text_with_selections(editor, ": "",
        ", cx);\n    });\n    editor.update_in(cx, |editor, window, cx| {\n        editor.select_larger_syntax_node(&SelectLargerSyntaxNode, window, cx);\n    });\n    editor.update(cx, |editor, cx| {\n        assert_text_with_selections(editor, ": "",
        ", cx);\n    });\n\n    // Test case 2: Cursor at end of statement\n    editor.update_in(cx, |editor, window, cx| {\n        editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n            s.select_display_ranges([\n                DisplayPoint::new(DisplayRow(0), 11)..DisplayPoint::new(DisplayRow(0), 11)\n            ]);\n        });\n    });\n    editor.update(cx, |editor, cx| {\n        assert_text_with_selections(editor, ": "",
        ", cx);\n    });\n}\n\n#[gpui::test]\nasync fn test_select_larger_syntax_node_for_cursor_at_symbol(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let language = Arc::new(Language::new(\n        LanguageConfig {\n            name: ": "",
        ".into(),\n            ..Default::default()\n        },\n        Some(tree_sitter_typescript::LANGUAGE_TSX.into()),\n    ));\n\n    let text = r#": "",
        "value": "",
        "#\n    .unindent();\n\n    let buffer = cx.new(|cx| Buffer::local(text, cx).with_language(language, cx));\n    let buffer = cx.new(|cx| MultiBuffer::singleton(buffer, cx));\n    let (editor, cx) = cx.add_window_view(|window, cx| build_editor(buffer, window, cx));\n\n    editor\n        .condition::<crate::EditorEvent>(cx, |editor, cx| !editor.buffer.read(cx).is_parsing(cx))\n        .await;\n\n    // Test case 1: Cursor after '{'\n    editor.update_in(cx, |editor, window, cx| {\n        editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n            s.select_display_ranges([\n                DisplayPoint::new(DisplayRow(0), 9)..DisplayPoint::new(DisplayRow(0), 9)\n            ]);\n        });\n    });\n    editor.update(cx, |editor, cx| {\n        assert_text_with_selections(\n            editor,\n            indoc! {r#": "",
        "#},\n            cx,\n        );\n    });\n    editor.update_in(cx, |editor, window, cx| {\n        editor.select_larger_syntax_node(&SelectLargerSyntaxNode, window, cx);\n    });\n    editor.update(cx, |editor, cx| {\n        assert_text_with_selections(\n            editor,\n            indoc! {r#": "",
        "#},\n            cx,\n        );\n    });\n\n    // Test case 2: Cursor after ':'\n    editor.update_in(cx, |editor, window, cx| {\n        editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n            s.select_display_ranges([\n                DisplayPoint::new(DisplayRow(1), 8)..DisplayPoint::new(DisplayRow(1), 8)\n            ]);\n        });\n    });\n    editor.update(cx, |editor, cx| {\n        assert_text_with_selections(\n            editor,\n            indoc! {r#": "",
        "#},\n            cx,\n        );\n    });\n\n    // Test case 3: Cursor after ','\n    editor.update_in(cx, |editor, window, cx| {\n        editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n            s.select_display_ranges([\n                DisplayPoint::new(DisplayRow(1), 17)..DisplayPoint::new(DisplayRow(1), 17)\n            ]);\n        });\n    });\n    editor.update(cx, |editor, cx| {\n        assert_text_with_selections(\n            editor,\n            indoc! {r#": "",
        "#},\n            cx,\n        );\n    });\n\n    // Test case 4: Cursor after ';'\n    editor.update_in(cx, |editor, window, cx| {\n        editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n            s.select_display_ranges([\n                DisplayPoint::new(DisplayRow(2), 2)..DisplayPoint::new(DisplayRow(2), 2)\n            ]);\n        });\n    });\n    editor.update(cx, |editor, cx| {\n        assert_text_with_selections(\n            editor,\n            indoc! {r#": "",
        "#},\n            cx,\n        );\n    });\n}\n\n#[gpui::test]\nasync fn test_select_larger_smaller_syntax_node_for_string(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let language = Arc::new(Language::new(\n        LanguageConfig::default(),\n        Some(tree_sitter_rust::LANGUAGE.into()),\n    ));\n\n    let text = r#": "",
        "hello world": "",
        "#\n    .unindent();\n\n    let buffer = cx.new(|cx| Buffer::local(text, cx).with_language(language, cx));\n    let buffer = cx.new(|cx| MultiBuffer::singleton(buffer, cx));\n    let (editor, cx) = cx.add_window_view(|window, cx| build_editor(buffer, window, cx));\n\n    editor\n        .condition::<crate::EditorEvent>(cx, |editor, cx| !editor.buffer.read(cx).is_parsing(cx))\n        .await;\n\n    // Test 1: Cursor on a letter of a string word\n    editor.update_in(cx, |editor, window, cx| {\n        editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n            s.select_display_ranges([\n                DisplayPoint::new(DisplayRow(3), 17)..DisplayPoint::new(DisplayRow(3), 17)\n            ]);\n        });\n    });\n    editor.update_in(cx, |editor, window, cx| {\n        assert_text_with_selections(\n            editor,\n            indoc! {r#": "",
        "hˇello world": "",
        "#},\n            cx,\n        );\n        editor.select_larger_syntax_node(&SelectLargerSyntaxNode, window, cx);\n        assert_text_with_selections(\n            editor,\n            indoc! {r#": "",
        "«ˇhello» world": "",
        "#},\n            cx,\n        );\n    });\n\n    // Test 2: Partial selection within a word\n    editor.update_in(cx, |editor, window, cx| {\n        editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n            s.select_display_ranges([\n                DisplayPoint::new(DisplayRow(3), 17)..DisplayPoint::new(DisplayRow(3), 19)\n            ]);\n        });\n    });\n    editor.update_in(cx, |editor, window, cx| {\n        assert_text_with_selections(\n            editor,\n            indoc! {r#": "",
        "h«elˇ»lo world": "",
        "#},\n            cx,\n        );\n    });\n\n    // Test 3: Complete word already selected\n    editor.update_in(cx, |editor, window, cx| {\n        editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n            s.select_display_ranges([\n                DisplayPoint::new(DisplayRow(3), 16)..DisplayPoint::new(DisplayRow(3), 21)\n            ]);\n        });\n    });\n    editor.update_in(cx, |editor, window, cx| {\n        assert_text_with_selections(\n            editor,\n            indoc! {r#": "",
        "«helloˇ» world": "",
        "«hello worldˇ»": "",
        "#},\n            cx,\n        );\n    });\n\n    // Test 4: Selection spanning across words\n    editor.update_in(cx, |editor, window, cx| {\n        editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n            s.select_display_ranges([\n                DisplayPoint::new(DisplayRow(3), 19)..DisplayPoint::new(DisplayRow(3), 24)\n            ]);\n        });\n    });\n    editor.update_in(cx, |editor, window, cx| {\n        assert_text_with_selections(\n            editor,\n            indoc! {r#": "",
        "hel«lo woˇ»rld": "",
        "«ˇhello world»": "",
        "#},\n            cx,\n        );\n    });\n\n    // Test 5: Expansion beyond string\n    editor.update_in(cx, |editor, window, cx| {\n        editor.select_larger_syntax_node(&SelectLargerSyntaxNode, window, cx);\n        editor.select_larger_syntax_node(&SelectLargerSyntaxNode, window, cx);\n        assert_text_with_selections(\n            editor,\n            indoc! {r#": "",
        "#},\n            cx,\n        );\n    });\n}\n\n#[gpui::test]\nasync fn test_unwrap_syntax_nodes(cx: &mut gpui::TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n\n    let language = Arc::new(Language::new(\n        LanguageConfig::default(),\n        Some(tree_sitter_rust::LANGUAGE.into()),\n    ));\n\n    cx.update_buffer(|buffer, cx| {\n        buffer.set_language(Some(language), cx);\n    });\n\n    cx.set_state(indoc! { r#": "",
        "# });\n    cx.update_editor(|editor, window, cx| {\n        editor.unwrap_syntax_node(&UnwrapSyntaxNode, window, cx);\n    });\n\n    cx.assert_editor_state(indoc! { r#": "",
        "# });\n\n    cx.set_state(indoc! { r#": "",
        "# });\n\n    let buffer = cx.update_multibuffer(|multibuffer, _| multibuffer.as_singleton().unwrap());\n    let multi_buffer = cx.new(|_| MultiBuffer::new(Capability::ReadWrite));\n    cx.update(|_, cx| {\n        multi_buffer.update(cx, |multi_buffer, cx| {\n            multi_buffer.set_excerpts_for_path(\n                PathKey::for_buffer(&buffer, cx),\n                buffer,\n                [Point::new(1, 0)..Point::new(1, 0)],\n                3,\n                cx,\n            );\n        });\n    });\n\n    let editor2 = cx.new_window_entity(|window, cx| {\n        Editor::new(EditorMode::full(), multi_buffer, None, window, cx)\n    });\n\n    let mut cx = EditorTestContext::for_editor_in(editor2, &mut cx).await;\n    cx.update_editor(|editor, window, cx| {\n        editor.change_selections(SelectionEffects::default(), window, cx, |s| {\n            s.select_ranges([Point::new(3, 0)..Point::new(3, 0)]);\n        })\n    });\n\n    cx.assert_editor_state(indoc! { ": "",
        "});\n\n    cx.update_editor(|editor, window, cx| {\n        editor.unwrap_syntax_node(&UnwrapSyntaxNode, window, cx);\n    });\n\n    // Although we could potentially make the action work when the syntax node\n    // is half-hidden, it seems a bit dangerous as you can't easily tell what it\n    // did. Maybe we could also expand the excerpt to contain the range?\n    cx.assert_editor_state(indoc! { ": "",
        "});\n}\n\n#[gpui::test]\nasync fn test_fold_function_bodies(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let base_text = r#": "",
        "#\n    .unindent();\n\n    let text = r#": "",
        "#\n    .unindent();\n\n    let mut cx = EditorLspTestContext::new_rust(Default::default(), cx).await;\n    cx.set_state(&text);\n    cx.set_head_text(&base_text);\n    cx.update_editor(|editor, window, cx| {\n        editor.expand_all_diff_hunks(&Default::default(), window, cx);\n    });\n\n    cx.assert_state_with_diff(\n        ": "",
        "\n        .unindent(),\n    );\n\n    let expected_display_text = ": "",
        "\n    .unindent();\n\n    cx.update_editor(|editor, window, cx| {\n        editor.fold_function_bodies(&FoldFunctionBodies, window, cx);\n        assert_eq!(editor.display_text(cx), expected_display_text);\n    });\n}\n\n#[gpui::test]\nasync fn test_autoindent(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let language = Arc::new(\n        Language::new(\n            LanguageConfig {\n                brackets: BracketPairConfig {\n                    pairs: vec![\n                        BracketPair {\n                            start: ": "",
        ".to_string(),\n                            end: ": "",
        ".to_string(),\n                            close: false,\n                            surround: false,\n                            newline: true,\n                        },\n                        BracketPair {\n                            start: ": "",
        ".to_string(),\n                            close: false,\n                            surround: false,\n                            newline: true,\n                        },\n                    ],\n                    ..Default::default()\n                },\n                ..Default::default()\n            },\n            Some(tree_sitter_rust::LANGUAGE.into()),\n        )\n        .with_indents_query(\n            r#": "",
        "#,\n        )\n        .unwrap(),\n    );\n\n    let text = ": "",
        ";\n\n    let buffer = cx.new(|cx| Buffer::local(text, cx).with_language(language, cx));\n    let buffer = cx.new(|cx| MultiBuffer::singleton(buffer, cx));\n    let (editor, cx) = cx.add_window_view(|window, cx| build_editor(buffer, window, cx));\n    editor\n        .condition::<crate::EditorEvent>(cx, |editor, cx| !editor.buffer.read(cx).is_parsing(cx))\n        .await;\n\n    editor.update_in(cx, |editor, window, cx| {\n        editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n            s.select_ranges([5..5, 8..8, 9..9])\n        });\n        editor.newline(&Newline, window, cx);\n        assert_eq!(editor.text(cx), ": "",
        ");\n        assert_eq!(\n            editor.selections.ranges(&editor.display_snapshot(cx)),\n            &[\n                Point::new(1, 4)..Point::new(1, 4),\n                Point::new(3, 4)..Point::new(3, 4),\n                Point::new(5, 0)..Point::new(5, 0)\n            ]\n        );\n    });\n}\n\n#[gpui::test]\nasync fn test_autoindent_disabled(cx: &mut TestAppContext) {\n    init_test(cx, |settings| settings.defaults.auto_indent = Some(false));\n\n    let language = Arc::new(\n        Language::new(\n            LanguageConfig {\n                brackets: BracketPairConfig {\n                    pairs: vec![\n                        BracketPair {\n                            start: ": "",
        ";\n\n    let buffer = cx.new(|cx| Buffer::local(text, cx).with_language(language, cx));\n    let buffer = cx.new(|cx| MultiBuffer::singleton(buffer, cx));\n    let (editor, cx) = cx.add_window_view(|window, cx| build_editor(buffer, window, cx));\n    editor\n        .condition::<crate::EditorEvent>(cx, |editor, cx| !editor.buffer.read(cx).is_parsing(cx))\n        .await;\n\n    editor.update_in(cx, |editor, window, cx| {\n        editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n            s.select_ranges([5..5, 8..8, 9..9])\n        });\n        editor.newline(&Newline, window, cx);\n        assert_eq!(\n            editor.text(cx),\n            indoc!(\n                ": "",
        "\n            )\n        );\n        assert_eq!(\n            editor.selections.ranges(&editor.display_snapshot(cx)),\n            &[\n                Point::new(1, 0)..Point::new(1, 0),\n                Point::new(3, 0)..Point::new(3, 0),\n                Point::new(5, 0)..Point::new(5, 0)\n            ]\n        );\n    });\n}\n\n#[gpui::test]\nasync fn test_autoindent_disabled_with_nested_language(cx: &mut TestAppContext) {\n    init_test(cx, |settings| {\n        settings.defaults.auto_indent = Some(true);\n        settings.languages.0.insert(\n            ": "",
        ".into(),\n            LanguageSettingsContent {\n                auto_indent: Some(false),\n                ..Default::default()\n            },\n        );\n    });\n\n    let mut cx = EditorTestContext::new(cx).await;\n\n    let injected_language = Arc::new(\n        Language::new(\n            LanguageConfig {\n                brackets: BracketPairConfig {\n                    pairs: vec![\n                        BracketPair {\n                            start: ": "",
        ".to_string(),\n                            close: true,\n                            surround: false,\n                            newline: true,\n                        },\n                    ],\n                    ..Default::default()\n                },\n                name: ": "",
        ".into(),\n                ..Default::default()\n            },\n            Some(tree_sitter_python::LANGUAGE.into()),\n        )\n        .with_indents_query(\n            r#": "",
        "#,\n        )\n        .unwrap(),\n    );\n\n    let language = Arc::new(\n        Language::new(\n            LanguageConfig {\n                brackets: BracketPairConfig {\n                    pairs: vec![\n                        BracketPair {\n                            start: ": "",
        ".to_string(),\n                            close: true,\n                            surround: false,\n                            newline: true,\n                        },\n                    ],\n                    ..Default::default()\n                },\n                name: LanguageName::new(": "",
        "),\n                ..Default::default()\n            },\n            Some(tree_sitter_rust::LANGUAGE.into()),\n        )\n        .with_indents_query(\n            r#": "",
        "#,\n        )\n        .unwrap()\n        .with_injection_query(\n            r#": "",
        "python": "",
        "#,\n        )\n        .unwrap(),\n    );\n\n    cx.language_registry().add(injected_language);\n    cx.language_registry().add(language.clone());\n\n    cx.update_buffer(|buffer, cx| {\n        buffer.set_language(Some(language), cx);\n    });\n\n    cx.set_state(r#": "",
        "#);\n\n    cx.update_editor(|editor, window, cx| {\n        editor.newline(&Default::default(), window, cx);\n    });\n\n    cx.assert_editor_state(indoc!(\n        ": "",
        "\n    ));\n\n    cx.set_state(r#": "",
        "#);\n\n    cx.update_editor(|editor, window, cx| {\n        editor.newline(&Default::default(), window, cx);\n        editor.handle_input(": "",
        ", window, cx);\n        editor.handle_input(": "",
        ", window, cx);\n        editor.newline(&Default::default(), window, cx);\n        editor.handle_input(": "",
        ", window, cx);\n    });\n\n    cx.assert_editor_state(indoc!(\n        ": "",
        "\n    ));\n}\n\n#[gpui::test]\nasync fn test_autoindent_selections(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    {\n        let mut cx = EditorLspTestContext::new_rust(Default::default(), cx).await;\n        cx.set_state(indoc! {": "",
        "});\n\n        cx.update_editor(|editor, window, cx| {\n            editor.autoindent(&Default::default(), window, cx);\n        });\n\n        cx.assert_editor_state(indoc! {": "",
        "});\n    }\n\n    {\n        let mut cx = EditorTestContext::new_multibuffer(\n            cx,\n            [indoc! { ": "",
        "}],\n        );\n\n        let buffer = cx.update_editor(|editor, _, cx| {\n            let buffer = editor.buffer().update(cx, |buffer, _| {\n                buffer.all_buffers().iter().next().unwrap().clone()\n            });\n            buffer.update(cx, |buffer, cx| buffer.set_language(Some(rust_lang()), cx));\n            buffer\n        });\n\n        cx.run_until_parked();\n        cx.update_editor(|editor, window, cx| {\n            editor.select_all(&Default::default(), window, cx);\n            editor.autoindent(&Default::default(), window, cx)\n        });\n        cx.run_until_parked();\n\n        cx.update(|_, cx| {\n            assert_eq!(\n                buffer.read(cx).text(),\n                indoc! { ": "",
        " }\n            )\n        });\n    }\n}\n\n#[gpui::test]\nasync fn test_autoclose_and_auto_surround_pairs(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n\n    let language = Arc::new(Language::new(\n        LanguageConfig {\n            brackets: BracketPairConfig {\n                pairs: vec![\n                    BracketPair {\n                        start: ": "",
        ".to_string(),\n                        end: ": "",
        ".to_string(),\n                        close: true,\n                        surround: true,\n                        newline: true,\n                    },\n                    BracketPair {\n                        start: ": "",
        ".to_string(),\n                        close: false,\n                        surround: false,\n                        newline: true,\n                    },\n                    BracketPair {\n                        start: ": "",
        "\n            🏀ˇ\n            εˇ\n            ❤️ˇ\n        ": "",
        "\n            🏀{{{ˇ}}}\n            ε{{{ˇ}}}\n            ❤️{{{ˇ}}}\n        ": "",
        "\n            🏀{{{)ˇ}}}\n            ε{{{)ˇ}}}\n            ❤️{{{)ˇ}}}\n        ": "",
        "\n            🏀{{{)}}}}ˇ\n            ε{{{)}}}}ˇ\n            ❤️{{{)}}}}ˇ\n        ": "",
        "\n            ˇ\n            ˇ\n        ": "",
        "\n            /*ˇ */\n            /*ˇ */\n        ": "",
        "\n            /ˇ\n            ˇ\n        ": "",
        "\n            /*ˇ */\n            *ˇ\n        ": "",
        "autoclose_before": "",
        "ˇa b": "",
        "{ˇa b": "",
        "[ˇ": "",
        "«aˇ» b": "",
        "{«aˇ»} b": "",
        "a ˇ": "",
        "a \\\"ˇ\\\"": "",
        "a \\\"\\\"ˇ": "",
        "aˇ": "",
        "a\\\"ˇ": "",
        "{ˇ": "",
        "{\\\"ˇ\\\"": "",
        "a{ˇ}": "",
        "<ˇ": "",
        "<«aˇ»> b": "",
        "\n            ˇ\n            ˇ\n            ˇ\n        ": "",
        "\n            ˇ)}\n            ˇ)}\n            ˇ)}\n        ": "",
        "\n            )}ˇ\n            )}ˇ\n            )}ˇ\n        ": "",
        "\n            )}]ˇ]\n            )}]ˇ]\n            )}]ˇ]\n        ": "",
        "HTML": "",
        "\n            (script_element\n                (raw_text) @injection.content\n                (#set! injection.language ": "",
        "))\n            ": "",
        "JavaScript": "",
        " */": "",
        "\n            <body>ˇ\n                <script>\n                    var x = 1;ˇ\n                </script>\n            </body>ˇ\n        ": "",
        "\n            <body><aˇ>\n                <script>\n                    var x = 1;<aˇ\n                </script>\n            </body><aˇ>\n        ": "",
        " b=": "",
        "c": "",
        "\n            <body><a b={c(ˇ)}>\n                <script>\n                    var x = 1;<a b={c(ˇ)}\n                </script>\n            </body><a b={c(ˇ)}>\n        ": "",
        "d": "",
        "\n            <body><a b={c()d}ˇ>\n                <script>\n                    var x = 1;<a b={c()d}ˇ\n                </script>\n            </body><a b={c()d}ˇ>\n        ": "",
        "\n            <body><a b={c()d}>ˇ\n                <script>\n                    var x = 1;<a b={c()d}>ˇ\n                </script>\n            </body><a b={c()d}>ˇ\n        ": "",
        "\n            <body><ˇ>\n                <script>\n                    var x = 1;<ˇ\n                </script>\n            </body><ˇ>\n        ": "",
        "\n            <body>/*ˇ\n                <script>\n                    var x = 1;/*ˇ */\n                </script>\n            </body>/*ˇ\n        ": "",
        "start": "",
        "end": "",
        "close": "",
        "newline": "",
        "not_in": "",
        "string": "",
        "(string_literal) @string": "",
        "\n            let x = ˇ\n        ": "",
        "\n            let x = ": "",
        "\n        ": "",
        "ˇ\n        ": "",
        " ": "",
        "ˇ ": "",
        "#\n        .unindent(),\n    );\n\n    // Inserting a closing quotation mark at the position of an automatically-inserted quotation\n    // mark. Nothing is inserted.\n    cx.update_editor(|editor, window, cx| {\n        editor.move_right(&Default::default(), window, cx);\n        editor.handle_input(": "",
        "#\n        .unindent(),\n    );\n}\n\n#[gpui::test]\nasync fn test_surround_with_pair(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let language = Arc::new(Language::new(\n        LanguageConfig {\n            brackets: BracketPairConfig {\n                pairs: vec![\n                    BracketPair {\n                        start: ": "",
        ".to_string(),\n                        close: true,\n                        surround: true,\n                        ..Default::default()\n                    },\n                ],\n                ..Default::default()\n            },\n            ..Default::default()\n        },\n        Some(tree_sitter_rust::LANGUAGE.into()),\n    ));\n\n    let text = r#": "",
        "#\n    .unindent();\n\n    let buffer = cx.new(|cx| Buffer::local(text, cx).with_language(language, cx));\n    let buffer = cx.new(|cx| MultiBuffer::singleton(buffer, cx));\n    let (editor, cx) = cx.add_window_view(|window, cx| build_editor(buffer, window, cx));\n    editor\n        .condition::<crate::EditorEvent>(cx, |editor, cx| !editor.buffer.read(cx).is_parsing(cx))\n        .await;\n\n    editor.update_in(cx, |editor, window, cx| {\n        editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n            s.select_display_ranges([\n                DisplayPoint::new(DisplayRow(0), 0)..DisplayPoint::new(DisplayRow(0), 1),\n                DisplayPoint::new(DisplayRow(1), 0)..DisplayPoint::new(DisplayRow(1), 1),\n                DisplayPoint::new(DisplayRow(2), 0)..DisplayPoint::new(DisplayRow(2), 1),\n            ])\n        });\n\n        editor.handle_input(": "",
        ", window, cx);\n        assert_eq!(\n            editor.text(cx),\n            ": "",
        "\n            .unindent()\n        );\n        assert_eq!(\n            display_ranges(editor, cx),\n            [\n                DisplayPoint::new(DisplayRow(0), 3)..DisplayPoint::new(DisplayRow(0), 4),\n                DisplayPoint::new(DisplayRow(1), 3)..DisplayPoint::new(DisplayRow(1), 4),\n                DisplayPoint::new(DisplayRow(2), 3)..DisplayPoint::new(DisplayRow(2), 4)\n            ]\n        );\n\n        editor.undo(&Undo, window, cx);\n        editor.undo(&Undo, window, cx);\n        editor.undo(&Undo, window, cx);\n        assert_eq!(\n            editor.text(cx),\n            ": "",
        "\n            .unindent()\n        );\n        assert_eq!(\n            display_ranges(editor, cx),\n            [\n                DisplayPoint::new(DisplayRow(0), 0)..DisplayPoint::new(DisplayRow(0), 1),\n                DisplayPoint::new(DisplayRow(1), 0)..DisplayPoint::new(DisplayRow(1), 1),\n                DisplayPoint::new(DisplayRow(2), 0)..DisplayPoint::new(DisplayRow(2), 1)\n            ]\n        );\n\n        // Ensure inserting the first character of a multi-byte bracket pair\n        // doesn't surround the selections with the bracket.\n        editor.handle_input(": "",
        "\n            .unindent()\n        );\n        assert_eq!(\n            display_ranges(editor, cx),\n            [\n                DisplayPoint::new(DisplayRow(0), 1)..DisplayPoint::new(DisplayRow(0), 1),\n                DisplayPoint::new(DisplayRow(1), 1)..DisplayPoint::new(DisplayRow(1), 1),\n                DisplayPoint::new(DisplayRow(2), 1)..DisplayPoint::new(DisplayRow(2), 1)\n            ]\n        );\n\n        editor.undo(&Undo, window, cx);\n        assert_eq!(\n            editor.text(cx),\n            ": "",
        "\n            .unindent()\n        );\n        assert_eq!(\n            display_ranges(editor, cx),\n            [\n                DisplayPoint::new(DisplayRow(0), 0)..DisplayPoint::new(DisplayRow(0), 1),\n                DisplayPoint::new(DisplayRow(1), 0)..DisplayPoint::new(DisplayRow(1), 1),\n                DisplayPoint::new(DisplayRow(2), 0)..DisplayPoint::new(DisplayRow(2), 1)\n            ]\n        );\n\n        // Ensure inserting the last character of a multi-byte bracket pair\n        // doesn't surround the selections with the bracket.\n        editor.handle_input(": "",
        "\n            .unindent()\n        );\n        assert_eq!(\n            display_ranges(editor, cx),\n            [\n                DisplayPoint::new(DisplayRow(0), 1)..DisplayPoint::new(DisplayRow(0), 1),\n                DisplayPoint::new(DisplayRow(1), 1)..DisplayPoint::new(DisplayRow(1), 1),\n                DisplayPoint::new(DisplayRow(2), 1)..DisplayPoint::new(DisplayRow(2), 1)\n            ]\n        );\n    });\n}\n\n#[gpui::test]\nasync fn test_delete_autoclose_pair(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let language = Arc::new(Language::new(\n        LanguageConfig {\n            brackets: BracketPairConfig {\n                pairs: vec![BracketPair {\n                    start: ": "",
        ".to_string(),\n                    end: ": "",
        ".to_string(),\n                    close: true,\n                    surround: true,\n                    newline: true,\n                }],\n                ..Default::default()\n            },\n            autoclose_before: ": "",
        ".to_string(),\n            ..Default::default()\n        },\n        Some(tree_sitter_rust::LANGUAGE.into()),\n    ));\n\n    let text = r#": "",
        "#\n    .unindent();\n\n    let buffer = cx.new(|cx| Buffer::local(text, cx).with_language(language, cx));\n    let buffer = cx.new(|cx| MultiBuffer::singleton(buffer, cx));\n    let (editor, cx) = cx.add_window_view(|window, cx| build_editor(buffer, window, cx));\n    editor\n        .condition::<crate::EditorEvent>(cx, |editor, cx| !editor.buffer.read(cx).is_parsing(cx))\n        .await;\n\n    editor.update_in(cx, |editor, window, cx| {\n        editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n            s.select_ranges([\n                Point::new(0, 1)..Point::new(0, 1),\n                Point::new(1, 1)..Point::new(1, 1),\n                Point::new(2, 1)..Point::new(2, 1),\n            ])\n        });\n\n        editor.handle_input(": "",
        "\n            .unindent()\n        );\n        assert_eq!(\n            editor\n                .selections\n                .ranges::<Point>(&editor.display_snapshot(cx)),\n            [\n                Point::new(0, 4)..Point::new(0, 4),\n                Point::new(1, 4)..Point::new(1, 4),\n                Point::new(2, 4)..Point::new(2, 4)\n            ]\n        );\n\n        editor.backspace(&Default::default(), window, cx);\n        editor.backspace(&Default::default(), window, cx);\n        assert_eq!(\n            editor.text(cx),\n            ": "",
        "\n            .unindent()\n        );\n        assert_eq!(\n            editor\n                .selections\n                .ranges::<Point>(&editor.display_snapshot(cx)),\n            [\n                Point::new(0, 2)..Point::new(0, 2),\n                Point::new(1, 2)..Point::new(1, 2),\n                Point::new(2, 2)..Point::new(2, 2)\n            ]\n        );\n\n        editor.delete_to_previous_word_start(&Default::default(), window, cx);\n        assert_eq!(\n            editor.text(cx),\n            ": "",
        "\n            .unindent()\n        );\n        assert_eq!(\n            editor\n                .selections\n                .ranges::<Point>(&editor.display_snapshot(cx)),\n            [\n                Point::new(0, 1)..Point::new(0, 1),\n                Point::new(1, 1)..Point::new(1, 1),\n                Point::new(2, 1)..Point::new(2, 1)\n            ]\n        );\n    });\n}\n\n#[gpui::test]\nasync fn test_always_treat_brackets_as_autoclosed_delete(cx: &mut TestAppContext) {\n    init_test(cx, |settings| {\n        settings.defaults.always_treat_brackets_as_autoclosed = Some(true);\n    });\n\n    let mut cx = EditorTestContext::new(cx).await;\n\n    let language = Arc::new(Language::new(\n        LanguageConfig {\n            brackets: BracketPairConfig {\n                pairs: vec![\n                    BracketPair {\n                        start: ": "",
        ".to_string(),\n                        close: false,\n                        surround: true,\n                        newline: true,\n                    },\n                ],\n                ..Default::default()\n            },\n            autoclose_before: ": "",
        ".to_string(),\n            ..Default::default()\n        },\n        Some(tree_sitter_rust::LANGUAGE.into()),\n    ));\n\n    cx.language_registry().add(language.clone());\n    cx.update_buffer(|buffer, cx| {\n        buffer.set_language(Some(language), cx);\n    });\n\n    cx.set_state(\n        &": "",
        "\n        .unindent(),\n    );\n\n    cx.update_editor(|editor, window, cx| {\n        editor.backspace(&Default::default(), window, cx);\n        editor.backspace(&Default::default(), window, cx);\n    });\n\n    cx.assert_editor_state(\n        &": "",
        "\n        .unindent(),\n    );\n\n    cx.update_editor(|editor, window, cx| {\n        editor.handle_input(": "",
        ", window, cx);\n        editor.move_right(&MoveRight, window, cx);\n        editor.move_right(&MoveRight, window, cx);\n        editor.move_left(&MoveLeft, window, cx);\n        editor.move_left(&MoveLeft, window, cx);\n        editor.backspace(&Default::default(), window, cx);\n    });\n\n    cx.assert_editor_state(\n        &": "",
        "\n        .unindent(),\n    );\n\n    cx.update_editor(|editor, window, cx| {\n        editor.backspace(&Default::default(), window, cx);\n    });\n\n    cx.assert_editor_state(\n        &": "",
        "\n        .unindent(),\n    );\n}\n\n#[gpui::test]\nasync fn test_auto_replace_emoji_shortcode(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let language = Arc::new(Language::new(\n        LanguageConfig::default(),\n        Some(tree_sitter_rust::LANGUAGE.into()),\n    ));\n\n    let buffer = cx.new(|cx| Buffer::local(": "",
        ", cx).with_language(language, cx));\n    let buffer = cx.new(|cx| MultiBuffer::singleton(buffer, cx));\n    let (editor, cx) = cx.add_window_view(|window, cx| build_editor(buffer, window, cx));\n    editor\n        .condition::<crate::EditorEvent>(cx, |editor, cx| !editor.buffer.read(cx).is_parsing(cx))\n        .await;\n\n    editor.update_in(cx, |editor, window, cx| {\n        editor.set_auto_replace_emoji_shortcode(true);\n\n        editor.handle_input(": "",
        ".unindent());\n\n        editor.handle_input(": "",
        ".unindent());\n\n        // Ensure shortcode gets replaced when it is part of a word that only consists of emojis\n        editor.handle_input(": "",
        ".unindent());\n\n        // Ensure shortcode does not get replaced when it is part of a word\n        editor.handle_input(": "",
        ".unindent());\n\n        editor.set_auto_replace_emoji_shortcode(false);\n\n        // Ensure shortcode does not get replaced when auto replace is off\n        editor.handle_input(": "",
        ".unindent()\n        );\n\n        editor.handle_input(": "",
        ".unindent()\n        );\n    });\n}\n\n#[gpui::test]\nasync fn test_snippet_placeholder_choices(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let (text, insertion_ranges) = marked_text_ranges(\n        indoc! {": "",
        "},\n        false,\n    );\n\n    let buffer = cx.update(|cx| MultiBuffer::build_simple(&text, cx));\n    let (editor, cx) = cx.add_window_view(|window, cx| build_editor(buffer, window, cx));\n\n    _ = editor.update_in(cx, |editor, window, cx| {\n        let snippet = Snippet::parse(": "",
        ").unwrap();\n\n        editor\n            .insert_snippet(&insertion_ranges, snippet, window, cx)\n            .unwrap();\n\n        fn assert(editor: &mut Editor, cx: &mut Context<Editor>, marked_text: &str) {\n            let (expected_text, selection_ranges) = marked_text_ranges(marked_text, false);\n            assert_eq!(editor.text(cx), expected_text);\n            assert_eq!(\n                editor\n                    .selections\n                    .ranges::<usize>(&editor.display_snapshot(cx)),\n                selection_ranges\n            );\n        }\n\n        assert(\n            editor,\n            cx,\n            indoc! {": "",
        "},\n        );\n\n        assert!(editor.context_menu_visible(), ": "",
        ");\n    });\n}\n\n#[gpui::test]\nasync fn test_snippet_tabstop_navigation_with_placeholders(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    fn assert_state(editor: &mut Editor, cx: &mut Context<Editor>, marked_text: &str) {\n        let (expected_text, selection_ranges) = marked_text_ranges(marked_text, false);\n        assert_eq!(editor.text(cx), expected_text);\n        assert_eq!(\n            editor\n                .selections\n                .ranges::<usize>(&editor.display_snapshot(cx)),\n            selection_ranges\n        );\n    }\n\n    let (text, insertion_ranges) = marked_text_ranges(\n        indoc! {": "",
        ").unwrap();\n\n        editor\n            .insert_snippet(&insertion_ranges, snippet, window, cx)\n            .unwrap();\n\n        assert_state(\n            editor,\n            cx,\n            indoc! {": "",
        "},\n        );\n\n        assert!(\n            editor.context_menu_visible(),\n            ": "",
        "\n        );\n\n        editor.next_snippet_tabstop(&NextSnippetTabstop, window, cx);\n\n        assert_state(\n            editor,\n            cx,\n            indoc! {": "",
        "},\n        );\n\n        assert!(\n            !editor.context_menu_visible(),\n            ": "",
        "},\n        );\n\n        editor.next_snippet_tabstop(&NextSnippetTabstop, window, cx);\n\n        assert_state(\n            editor,\n            cx,\n            indoc! {": "",
        "},\n        );\n    });\n\n    _ = editor.update_in(cx, |editor, window, cx| {\n        editor.select_all(&SelectAll, window, cx);\n        editor.backspace(&Backspace, window, cx);\n\n        let snippet = Snippet::parse(": "",
        ").unwrap();\n        let insertion_ranges = editor\n            .selections\n            .all(&editor.display_snapshot(cx))\n            .iter()\n            .map(|s| s.range())\n            .collect::<Vec<_>>();\n\n        editor\n            .insert_snippet(&insertion_ranges, snippet, window, cx)\n            .unwrap();\n\n        assert_state(editor, cx, ": "",
        ");\n\n        assert!(\n            editor.context_menu_visible(),\n            ": "",
        "\n        );\n\n        editor.next_snippet_tabstop(&NextSnippetTabstop, window, cx);\n\n        assert_state(editor, cx, ": "",
        ");\n\n        editor.previous_snippet_tabstop(&PreviousSnippetTabstop, window, cx);\n\n        assert_state(editor, cx, ": "",
        "\n        );\n\n        editor.previous_snippet_tabstop(&PreviousSnippetTabstop, window, cx);\n\n        assert_state(editor, cx, ": "",
        ");\n    });\n}\n\n#[gpui::test]\nasync fn test_snippets(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n\n    cx.set_state(indoc! {": "",
        "});\n\n    cx.update_editor(|editor, window, cx| {\n        let snippet = Snippet::parse(": "",
        ").unwrap();\n        let insertion_ranges = editor\n            .selections\n            .all(&editor.display_snapshot(cx))\n            .iter()\n            .map(|s| s.range())\n            .collect::<Vec<_>>();\n        editor\n            .insert_snippet(&insertion_ranges, snippet, window, cx)\n            .unwrap();\n    });\n\n    cx.assert_editor_state(indoc! {": "",
        "});\n\n    // Can't move earlier than the first tab stop\n    cx.update_editor(|editor, window, cx| {\n        assert!(!editor.move_to_prev_snippet_tabstop(window, cx))\n    });\n    cx.assert_editor_state(indoc! {": "",
        "});\n\n    cx.update_editor(|editor, window, cx| assert!(editor.move_to_next_snippet_tabstop(window, cx)));\n    cx.assert_editor_state(indoc! {": "",
        "});\n\n    cx.update_editor(|editor, window, cx| assert!(editor.move_to_prev_snippet_tabstop(window, cx)));\n    cx.assert_editor_state(indoc! {": "",
        "});\n    cx.update_editor(|editor, window, cx| assert!(editor.move_to_next_snippet_tabstop(window, cx)));\n    cx.assert_editor_state(indoc! {": "",
        "});\n\n    // As soon as the last tab stop is reached, snippet state is gone\n    cx.update_editor(|editor, window, cx| {\n        assert!(!editor.move_to_prev_snippet_tabstop(window, cx))\n    });\n    cx.assert_editor_state(indoc! {": "",
        "});\n}\n\n#[gpui::test]\nasync fn test_snippet_indentation(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n\n    cx.update_editor(|editor, window, cx| {\n        let snippet = Snippet::parse(indoc! {": "",
        "})\n        .unwrap();\n        let insertion_ranges = editor\n            .selections\n            .all(&editor.display_snapshot(cx))\n            .iter()\n            .map(|s| s.range())\n            .collect::<Vec<_>>();\n        editor\n            .insert_snippet(&insertion_ranges, snippet, window, cx)\n            .unwrap();\n    });\n\n    cx.assert_editor_state(indoc! {": "",
        "});\n}\n\n#[gpui::test]\nasync fn test_document_format_during_save(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let fs = FakeFs::new(cx.executor());\n    fs.insert_file(path!(": "",
        "), Default::default()).await;\n\n    let project = Project::test(fs, [path!(": "",
        ").as_ref()], cx).await;\n\n    let language_registry = project.read_with(cx, |project, _| project.languages().clone());\n    language_registry.add(rust_lang());\n    let mut fake_servers = language_registry.register_fake_lsp(\n        ": "",
        ",\n        FakeLspAdapter {\n            capabilities: lsp::ServerCapabilities {\n                document_formatting_provider: Some(lsp::OneOf::Left(true)),\n                ..Default::default()\n            },\n            ..Default::default()\n        },\n    );\n\n    let buffer = project\n        .update(cx, |project, cx| {\n            project.open_local_buffer(path!(": "",
        "), cx)\n        })\n        .await\n        .unwrap();\n\n    let buffer = cx.new(|cx| MultiBuffer::singleton(buffer, cx));\n    let (editor, cx) = cx.add_window_view(|window, cx| {\n        build_editor_with_project(project.clone(), buffer, window, cx)\n    });\n    editor.update_in(cx, |editor, window, cx| {\n        editor.set_text(": "",
        ", window, cx)\n    });\n    assert!(cx.read(|cx| editor.is_dirty(cx)));\n\n    cx.executor().start_waiting();\n    let fake_server = fake_servers.next().await.unwrap();\n\n    {\n        fake_server.set_request_handler::<lsp::request::Formatting, _, _>(\n            move |params, _| async move {\n                assert_eq!(\n                    params.text_document.uri,\n                    lsp::Uri::from_file_path(path!(": "",
        ")).unwrap()\n                );\n                assert_eq!(params.options.tab_size, 4);\n                Ok(Some(vec![lsp::TextEdit::new(\n                    lsp::Range::new(lsp::Position::new(0, 3), lsp::Position::new(1, 0)),\n                    ": "",
        ".to_string(),\n                )]))\n            },\n        );\n        let save = editor\n            .update_in(cx, |editor, window, cx| {\n                editor.save(\n                    SaveOptions {\n                        format: true,\n                        autosave: false,\n                    },\n                    project.clone(),\n                    window,\n                    cx,\n                )\n            })\n            .unwrap();\n        cx.executor().start_waiting();\n        save.await;\n\n        assert_eq!(\n            editor.update(cx, |editor, cx| editor.text(cx)),\n            ": "",
        "\n        );\n        assert!(!cx.read(|cx| editor.is_dirty(cx)));\n    }\n\n    {\n        editor.update_in(cx, |editor, window, cx| {\n            editor.set_text(": "",
        ", window, cx)\n        });\n        assert!(cx.read(|cx| editor.is_dirty(cx)));\n\n        // Ensure we can still save even if formatting hangs.\n        fake_server.set_request_handler::<lsp::request::Formatting, _, _>(\n            move |params, _| async move {\n                assert_eq!(\n                    params.text_document.uri,\n                    lsp::Uri::from_file_path(path!(": "",
        ")).unwrap()\n                );\n                futures::future::pending::<()>().await;\n                unreachable!()\n            },\n        );\n        let save = editor\n            .update_in(cx, |editor, window, cx| {\n                editor.save(\n                    SaveOptions {\n                        format: true,\n                        autosave: false,\n                    },\n                    project.clone(),\n                    window,\n                    cx,\n                )\n            })\n            .unwrap();\n        cx.executor().advance_clock(super::FORMAT_TIMEOUT);\n        cx.executor().start_waiting();\n        save.await;\n        assert_eq!(\n            editor.update(cx, |editor, cx| editor.text(cx)),\n            ": "",
        "\n        );\n    }\n\n    // Set rust language override and assert overridden tabsize is sent to language server\n    update_test_language_settings(cx, |settings| {\n        settings.languages.0.insert(\n            ": "",
        ".into(),\n            LanguageSettingsContent {\n                tab_size: NonZeroU32::new(8),\n                ..Default::default()\n            },\n        );\n    });\n\n    {\n        editor.update_in(cx, |editor, window, cx| {\n            editor.set_text(": "",
        ", window, cx)\n        });\n        assert!(cx.read(|cx| editor.is_dirty(cx)));\n        let _formatting_request_signal = fake_server\n            .set_request_handler::<lsp::request::Formatting, _, _>(move |params, _| async move {\n                assert_eq!(\n                    params.text_document.uri,\n                    lsp::Uri::from_file_path(path!(": "",
        ")).unwrap()\n                );\n                assert_eq!(params.options.tab_size, 8);\n                Ok(Some(vec![]))\n            });\n        let save = editor\n            .update_in(cx, |editor, window, cx| {\n                editor.save(\n                    SaveOptions {\n                        format: true,\n                        autosave: false,\n                    },\n                    project.clone(),\n                    window,\n                    cx,\n                )\n            })\n            .unwrap();\n        cx.executor().start_waiting();\n        save.await;\n    }\n}\n\n#[gpui::test]\nasync fn test_redo_after_noop_format(cx: &mut TestAppContext) {\n    init_test(cx, |settings| {\n        settings.defaults.ensure_final_newline_on_save = Some(false);\n    });\n\n    let fs = FakeFs::new(cx.executor());\n    fs.insert_file(path!(": "",
        "), ": "",
        ".into()).await;\n\n    let project = Project::test(fs, [path!(": "",
        ").as_ref()], cx).await;\n\n    let buffer = project\n        .update(cx, |project, cx| {\n            project.open_local_buffer(path!(": "",
        "), cx)\n        })\n        .await\n        .unwrap();\n\n    let buffer = cx.new(|cx| MultiBuffer::singleton(buffer, cx));\n    let (editor, cx) = cx.add_window_view(|window, cx| {\n        build_editor_with_project(project.clone(), buffer, window, cx)\n    });\n    editor.update_in(cx, |editor, window, cx| {\n        editor.change_selections(SelectionEffects::default(), window, cx, |s| {\n            s.select_ranges([0..0])\n        });\n    });\n    assert!(!cx.read(|cx| editor.is_dirty(cx)));\n\n    editor.update_in(cx, |editor, window, cx| {\n        editor.handle_input(": "",
        ", window, cx)\n    });\n    cx.run_until_parked();\n    save(&editor, &project, cx).await;\n    assert_eq!(": "",
        ", editor.read_with(cx, |editor, cx| editor.text(cx)));\n\n    editor.update_in(cx, |editor, window, cx| {\n        editor.undo(&Default::default(), window, cx);\n    });\n    save(&editor, &project, cx).await;\n    assert_eq!(": "",
        ", editor.read_with(cx, |editor, cx| editor.text(cx)));\n\n    editor.update_in(cx, |editor, window, cx| {\n        editor.redo(&Default::default(), window, cx);\n    });\n    cx.run_until_parked();\n    assert_eq!(": "",
        ", editor.read_with(cx, |editor, cx| editor.text(cx)));\n\n    async fn save(editor: &Entity<Editor>, project: &Entity<Project>, cx: &mut VisualTestContext) {\n        let save = editor\n            .update_in(cx, |editor, window, cx| {\n                editor.save(\n                    SaveOptions {\n                        format: true,\n                        autosave: false,\n                    },\n                    project.clone(),\n                    window,\n                    cx,\n                )\n            })\n            .unwrap();\n        cx.executor().start_waiting();\n        save.await;\n        assert!(!cx.read(|cx| editor.is_dirty(cx)));\n    }\n}\n\n#[gpui::test]\nasync fn test_multibuffer_format_during_save(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let cols = 4;\n    let rows = 10;\n    let sample_text_1 = sample_text(rows, cols, 'a');\n    assert_eq!(\n        sample_text_1,\n        ": "",
        "\n    );\n    let sample_text_2 = sample_text(rows, cols, 'l');\n    assert_eq!(\n        sample_text_2,\n        ": "",
        "\n    );\n    let sample_text_3 = sample_text(rows, cols, 'v');\n    assert_eq!(\n        sample_text_3,\n        ": "",
        "\n    );\n\n    let fs = FakeFs::new(cx.executor());\n    fs.insert_tree(\n        path!(": "",
        "),\n        json!({\n            ": "",
        ": sample_text_1,\n            ": "",
        ": sample_text_2,\n            ": "",
        ": sample_text_3,\n        }),\n    )\n    .await;\n\n    let project = Project::test(fs, [path!(": "",
        ").as_ref()], cx).await;\n    let workspace = cx.add_window(|window, cx| Workspace::test_new(project.clone(), window, cx));\n    let cx = &mut VisualTestContext::from_window(*workspace.deref(), cx);\n\n    let language_registry = project.read_with(cx, |project, _| project.languages().clone());\n    language_registry.add(rust_lang());\n    let mut fake_servers = language_registry.register_fake_lsp(\n        ": "",
        ",\n        FakeLspAdapter {\n            capabilities: lsp::ServerCapabilities {\n                document_formatting_provider: Some(lsp::OneOf::Left(true)),\n                ..Default::default()\n            },\n            ..Default::default()\n        },\n    );\n\n    let worktree = project.update(cx, |project, cx| {\n        let mut worktrees = project.worktrees(cx).collect::<Vec<_>>();\n        assert_eq!(worktrees.len(), 1);\n        worktrees.pop().unwrap()\n    });\n    let worktree_id = worktree.update(cx, |worktree, _| worktree.id());\n\n    let buffer_1 = project\n        .update(cx, |project, cx| {\n            project.open_buffer((worktree_id, rel_path(": "",
        ")), cx)\n        })\n        .await\n        .unwrap();\n    let buffer_2 = project\n        .update(cx, |project, cx| {\n            project.open_buffer((worktree_id, rel_path(": "",
        ")), cx)\n        })\n        .await\n        .unwrap();\n    let buffer_3 = project\n        .update(cx, |project, cx| {\n            project.open_buffer((worktree_id, rel_path(": "",
        ")), cx)\n        })\n        .await\n        .unwrap();\n\n    let multi_buffer = cx.new(|cx| {\n        let mut multi_buffer = MultiBuffer::new(ReadWrite);\n        multi_buffer.push_excerpts(\n            buffer_1.clone(),\n            [\n                ExcerptRange::new(Point::new(0, 0)..Point::new(3, 0)),\n                ExcerptRange::new(Point::new(5, 0)..Point::new(7, 0)),\n                ExcerptRange::new(Point::new(9, 0)..Point::new(10, 4)),\n            ],\n            cx,\n        );\n        multi_buffer.push_excerpts(\n            buffer_2.clone(),\n            [\n                ExcerptRange::new(Point::new(0, 0)..Point::new(3, 0)),\n                ExcerptRange::new(Point::new(5, 0)..Point::new(7, 0)),\n                ExcerptRange::new(Point::new(9, 0)..Point::new(10, 4)),\n            ],\n            cx,\n        );\n        multi_buffer.push_excerpts(\n            buffer_3.clone(),\n            [\n                ExcerptRange::new(Point::new(0, 0)..Point::new(3, 0)),\n                ExcerptRange::new(Point::new(5, 0)..Point::new(7, 0)),\n                ExcerptRange::new(Point::new(9, 0)..Point::new(10, 4)),\n            ],\n            cx,\n        );\n        multi_buffer\n    });\n    let multi_buffer_editor = cx.new_window_entity(|window, cx| {\n        Editor::new(\n            EditorMode::full(),\n            multi_buffer,\n            Some(project.clone()),\n            window,\n            cx,\n        )\n    });\n\n    multi_buffer_editor.update_in(cx, |editor, window, cx| {\n        editor.change_selections(\n            SelectionEffects::scroll(Autoscroll::Next),\n            window,\n            cx,\n            |s| s.select_ranges(Some(1..2)),\n        );\n        editor.insert(": "",
        ", window, cx);\n    });\n    assert!(cx.read(|cx| multi_buffer_editor.is_dirty(cx)));\n    multi_buffer_editor.update_in(cx, |editor, window, cx| {\n        editor.change_selections(\n            SelectionEffects::scroll(Autoscroll::Next),\n            window,\n            cx,\n            |s| s.select_ranges(Some(60..70)),\n        );\n        editor.insert(": "",
        ", window, cx);\n    });\n    assert!(cx.read(|cx| multi_buffer_editor.is_dirty(cx)));\n\n    // First two buffers should be edited, but not the third one.\n    assert_eq!(\n        multi_buffer_editor.update(cx, |editor, cx| editor.text(cx)),\n        ": "",
        ",\n    );\n    buffer_1.update(cx, |buffer, _| {\n        assert!(buffer.is_dirty());\n        assert_eq!(\n            buffer.text(),\n            ": "",
        ",\n        )\n    });\n    buffer_2.update(cx, |buffer, _| {\n        assert!(buffer.is_dirty());\n        assert_eq!(\n            buffer.text(),\n            ": "",
        ",\n        )\n    });\n    buffer_3.update(cx, |buffer, _| {\n        assert!(!buffer.is_dirty());\n        assert_eq!(buffer.text(), sample_text_3,)\n    });\n    cx.executor().run_until_parked();\n\n    cx.executor().start_waiting();\n    let save = multi_buffer_editor\n        .update_in(cx, |editor, window, cx| {\n            editor.save(\n                SaveOptions {\n                    format: true,\n                    autosave: false,\n                },\n                project.clone(),\n                window,\n                cx,\n            )\n        })\n        .unwrap();\n\n    let fake_server = fake_servers.next().await.unwrap();\n    fake_server\n        .server\n        .on_request::<lsp::request::Formatting, _, _>(move |params, _| async move {\n            Ok(Some(vec![lsp::TextEdit::new(\n                lsp::Range::new(lsp::Position::new(0, 3), lsp::Position::new(1, 0)),\n                format!(": "",
        ", params.text_document.uri),\n            )]))\n        })\n        .detach();\n    save.await;\n\n    // After multibuffer saving, only first two buffers should be reformatted, but not the third one (as it was not dirty).\n    assert!(cx.read(|cx| !multi_buffer_editor.is_dirty(cx)));\n    assert_eq!(\n        multi_buffer_editor.update(cx, |editor, cx| editor.text(cx)),\n        uri!(\n            ": "",
        "\n        ),\n    );\n    buffer_1.update(cx, |buffer, _| {\n        assert!(!buffer.is_dirty());\n        assert_eq!(\n            buffer.text(),\n            uri!(": "",
        "),\n        )\n    });\n    buffer_2.update(cx, |buffer, _| {\n        assert!(!buffer.is_dirty());\n        assert_eq!(\n            buffer.text(),\n            uri!(": "",
        "),\n        )\n    });\n    buffer_3.update(cx, |buffer, _| {\n        assert!(!buffer.is_dirty());\n        assert_eq!(buffer.text(), sample_text_3,)\n    });\n}\n\n#[gpui::test]\nasync fn test_autosave_with_dirty_buffers(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let fs = FakeFs::new(cx.executor());\n    fs.insert_tree(\n        path!(": "",
        ": ": "",
        "hello\\\"); }": "",
        "file2.rs": "",
        "fn test() { println!(\\\"test\\\"); }": "",
        "file3.rs": "",
        "fn other() { println!(\\\"other\\\"); }\\n": "",
        "/dir": "",
        "file1.rs": "",
        "// edited": "",
        "Buffer 1 was dirty, so it should have been written once during autosave": "",
        "Buffer 2 was clean, so it should not have been written during autosave": "",
        "Buffer 3 was clean, so it should not have been written during autosave": "",
        "Buffer 1 should only have been written once total (during autosave, not manual save)": "",
        "Buffer 2 should not have been written at all": "",
        "Buffer 3 should not have been written at all": "",
        "one\\ntwo\\nthree\\n": "",
        "one, two\\nthree\\n": "",
        "Should not be invoked": "",
        "something_new\\n": "",
        "code-action-1": "",
        "code-action-2": "",
        "one  \\ntwo   \\nthree": "",
        "the-command-for-code-action-1": "",
        "applied-formatting\\n": "",
        "Expected code action request": "",
        "applied-code-action-1-edit\\n": "",
        "applied-code-action-2-edit\\n": "",
        "Unexpected code action request: {:?}": "",
        "applied-code-action-1-command\\n": "",
        "\n                applied-code-action-2-edit\n                applied-code-action-1-command\n                applied-code-action-1-edit\n                applied-formatting\n                one\n                two\n                three\n            ": "",
        "\n                applied-code-action-1-edit\n                applied-formatting\n                one\n                two\n                three\n            ": "",
        "edited\\n": "",
        "\n                applied-code-action-1-command\n                applied-code-action-1-edit\n                applied-formatting\n                one\n                two\n                three\n                edited\n            ": "",
        "\n                applied-code-action-1-command\n                applied-code-action-1-edit\n                applied-formatting\n                one\n                two\n                three\n            ": "",
        "TypeScript": "",
        "ts": "",
        "import { a } from 'module';\\nimport { b } from 'module';\\n\\nconst x = a;\\n": "",
        "Organize Imports": "",
        "import { a } from 'module';\\n\\nconst x = a;\\n": "",
        "\n        one.twoˇ\n    ": "",
        "\\n    ": "",
        "\n        one\n            .twoˇ\n    ": "",
        "one ": "",
        "twoˇ": "",
        "three ": "",
        "four": "",
        "one": "",
        "three": "",
        "\n            fn main() {\n                sampleˇ\n            }\n        ": "",
        "\n            fn main() {\n                sample(ˇ)\n            }\n        ": "",
        "fn sample(param1: u8, param2: u8)": "",
        "param1: u8": "",
        "param2: u8": "",
        "\n        fn main() {\n            sample(ˇ);\n        }\n\n        fn sample(param1: u8, param2: u8) {}\n    ": "",
        "\n        fn main() {\n            sample(param1, param2ˇ);\n        }\n\n        fn sample(param1: u8, param2: u8) {}\n    ": "",
        "\n        fn main() {\n            sample(param1, «ˇparam2»);\n        }\n\n        fn sample(param1: u8, param2: u8) {}\n    ": "",
        "\n        fn main() {\n            sample(param1, ˇparam2);\n        }\n\n        fn sample(param1: u8, param2: u8) {}\n    ": "",
        "\n        fn main() {\n            overloadedˇ\n        }\n    ": "",
        "fn overloaded(x: i32)": "",
        "x: i32": "",
        "fn overloaded(x: i32, y: i32)": "",
        "y: i32": "",
        "fn overloaded(x: i32, y: i32, z: i32)": "",
        "z: i32": "",
        "Start of word matches completion text": "",
        "before ediˇ after": "",
        "before <edi|> after": "",
        "editor": "",
        "before editorˇ after": "",
        "Accept same text at the middle of the word": "",
        "before ediˇtor after": "",
        "before <edi|tor> after": "",
        "before editorˇtor after": "",
        "End of word matches completion text -- cursor at end": "",
        "before torˇ after": "",
        "before <tor|> after": "",
        "End of word matches completion text -- cursor at start": "",
        "before ˇtor after": "",
        "before <|tor> after": "",
        "Prepend text containing whitespace": "",
        "pˇfield: bool": "",
        "<p|field>: bool": "",
        "pub ": "",
        "pub ˇfield: bool": "",
        "pub ˇ: bool": "",
        "Add element to start of list": "",
        "[element_ˇelement_2]": "",
        "[<element_|element_2>]": "",
        "element_1": "",
        "[element_1ˇelement_2]": "",
        "[element_1ˇ]": "",
        "Add element to start of list -- first and second elements are equal": "",
        "[elˇelement]": "",
        "[<el|element>]": "",
        "element": "",
        "[elementˇelement]": "",
        "[elementˇ]": "",
        "Ends with matching suffix": "",
        "SubˇError": "",
        "<Sub|Error>": "",
        "SubscriptionError": "",
        "SubscriptionErrorˇError": "",
        "SubscriptionErrorˇ": "",
        "Suffix is a subsequence -- contiguous": "",
        "SubˇErr": "",
        "<Sub|Err>": "",
        "SubscriptionErrorˇErr": "",
        "Suffix is a subsequence -- non-contiguous -- replace intended": "",
        "Suˇscrirr": "",
        "<Su|scrirr>": "",
        "SubscriptionErrorˇscrirr": "",
        "Suffix is a subsequence -- non-contiguous -- replace unintended": "",
        "foo(indˇix)": "",
        "foo(<ind|ix>)": "",
        "node_index": "",
        "foo(node_indexˇix)": "",
        "foo(node_indexˇ)": "",
        "Replace range ends before cursor - should extend to cursor": "",
        "before editˇo after": "",
        "before <{ed}>it|o after": "",
        "before editorˇo after": "",
        "Uses label for suffix matching": "",
        "editor()": "",
        "before editor()ˇtor after": "",
        "before editor()ˇ after": "",
        "Case insensitive subsequence and suffix matching": "",
        "before EDiˇtoR after": "",
        "before <EDi|toR> after": "",
        "before editorˇtoR after": "",
        "run = {:?}, mode = {lsp_insert_mode:.?}": "",
        "to_offset": "",
        "\n        1. buf.to_offˇsuffix\n        2. buf.to_offˇsuf\n        3. buf.to_offˇfix\n        4. buf.to_offˇ\n        5. into_offˇensive\n        6. ˇsuffix\n        7. let ˇ //\n        8. aaˇzz\n        9. buf.to_off«zzzzzˇ»suffix\n        10. buf.«ˇzzzzz»suffix\n        11. to_off«ˇzzzzz»\n\n        buf.to_offˇsuffix  // newest cursor\n    ": "",
        "\n        1. buf.to_offsuffix\n        2. buf.to_offsuf\n        3. buf.to_offfix\n        4. buf.to_off\n        5. into_offensive\n        6. suffix\n        7. let  //\n        8. aazz\n        9. buf.to_offzzzzzsuffix\n        10. buf.zzzzzsuffix\n        11. to_offzzzzz\n\n        buf.<to_off|suffix>  // newest cursor\n    ": "",
        "\n        1. buf.to_offsetˇ\n        2. buf.to_offsetˇsuf\n        3. buf.to_offsetˇfix\n        4. buf.to_offsetˇ\n        5. into_offsetˇensive\n        6. to_offsetˇsuffix\n        7. let to_offsetˇ //\n        8. aato_offsetˇzz\n        9. buf.to_offsetˇ\n        10. buf.to_offsetˇsuffix\n        11. to_offsetˇ\n\n        buf.to_offsetˇ  // newest cursor\n    ": "",
        "foo_and_bar": "",
        "\n        1. ooanbˇ\n        2. zooanbˇ\n        3. ooanbˇz\n        4. zooanbˇz\n        5. ooanˇ\n        6. oanbˇ\n\n        ooanbˇ\n    ": "",
        "\n        1. ooanb\n        2. zooanb\n        3. ooanbz\n        4. zooanbz\n        5. ooan\n        6. oanb\n\n        <ooanb|>\n    ": "",
        "\n        1. foo_and_barˇ\n        2. zfoo_and_barˇ\n        3. foo_and_barˇz\n        4. zfoo_and_barˇz\n        5. ooanfoo_and_barˇ\n        6. oanbfoo_and_barˇ\n\n        foo_and_barˇ\n    ": "",
        "\n        1. ooˇanb\n        2. zooˇanb\n        3. ooˇanbz\n        4. zooˇanbz\n\n        ooˇanb\n    ": "",
        "\n        1. ooanb\n        2. zooanb\n        3. ooanbz\n        4. zooanbz\n\n        <oo|anb>\n    ": "",
        "\n        1. foo_and_barˇ\n        2. zfoo_and_barˇ\n        3. foo_and_barˇz\n        4. zfoo_and_barˇz\n\n        foo_and_barˇ\n    ": "",
        "\n        fn main() {\n            10.satu;\n\n            //\n            // separate cursors so they open in different excerpts (manually reproducible)\n            //\n\n            10.satu20;\n        }\n    ": "",
        "\n        fn main() {\n            10.satuˇ;\n\n            //\n\n            //\n\n            10.satuˇ20;\n        }\n    ": "",
        "\n        fn main() {\n            10.saturating_sub()ˇ;\n\n            //\n\n            //\n\n            10.saturating_sub()ˇ;\n        }\n    ": "",
        "/a": "",
        "main.rs": "",
        "saturating_sub()": "",
        "\n        oneˇ\n        two\n        three\n    ": "",
        "\n            one.|<>\n            two\n            three\n        ": "",
        "first_completion": "",
        "second_completion": "",
        "test signature": "",
        "foo: u8": "",
        "No signature help was called for": "",
        "No signature help should be shown when completions menu is open": "",
        "\n        one.second_completionˇ\n        two\n        three\n    ": "",
        "\n                    one.second_ˇcompletion\n                    two\n                    threeˇ\n                ": "",
        "overlapping additional edit": "",
        "\n                    one.second_completion\n                    two\n                    threeˇ\n                ": "",
        "\\nadditional edit": "",
        "\n        one.second_completionˇ\n        two\n        three\n        additional edit\n    ": "",
        "\n        one.second_completion\n        twoˇ\n        threeˇ\n        additional edit\n    ": "",
        "s": "",
        "\n        one.second_completion\n        two sˇ\n        three sˇ\n        additional edit\n    ": "",
        "\n            one.second_completion\n            two s\n            three <s|>\n            additional edit\n        ": "",
        "fourth_completion": "",
        "fifth_completion": "",
        "sixth_completion": "",
        "i": "",
        "\n            one.second_completion\n            two si\n            three <si|>\n            additional edit\n        ": "",
        "\n        one.second_completion\n        two sixth_completionˇ\n        three sixth_completionˇ\n        additional edit\n    ": "",
        "editorˇ": "",
        "c l o": "",
        "editor.cloˇ": "",
        "editor.<clo|>": "",
        "clobber": "",
        "editor.clobberˇ": "",
        "objˇ": "",
        "obj.|<>": "",
        "abc": "",
        "obj.ˇ": "",
        "obj.aˇ": "",
        "obj.abˇ": "",
        "obj.abcˇ": "",
        "obj.aˇb": "",
        "obj.<ab|>a": "",
        "obj.abˇb": "",
        "obj.<a|>b": "",
        "obj.ˇb": "",
        "first": "",
        "last": "",
        "When LSP server is fast to reply, no fallback word completions are used": "",
        "expected completion menu to be open": "",
        "two": "",
        "When LSP server is slow, document words can be shown instead, if configured accordingly": "",
        "ˇ\n        first\n        last\n        second\n    ": "",
        "second": "",
        "Word completions that has the same edit as the any of the LSP ones, should not be proposed": "",
        "LSP completions should not be queried when dealing with word completions": "",
        "`ShowWordCompletions` action should show word completions": "",
        "l": "",
        "After showing word completions, further editing should filter them and not query the LSP": "",
        "ˇ\n        0_usize\n        let\n        33\n        4.5f32\n    ": "",
        "let": "",
        "With no digits in the completion query, no digits should be in the word completions": "",
        "3ˇ\n        0_usize\n        let\n        3\n        33.35f32\n    ": "",
        "35f32": "",
        ");\n        } else {\n            panic!(": "",
        ");\n        }\n    });\n}\n\n#[gpui::test]\nasync fn test_word_completions_do_not_show_before_threshold(cx: &mut TestAppContext) {\n    init_test(cx, |language_settings| {\n        language_settings.defaults.completions = Some(CompletionSettingsContent {\n            words: Some(WordsCompletionMode::Enabled),\n            words_min_length: Some(3),\n            lsp_insert_mode: Some(LspInsertMode::Insert),\n            ..Default::default()\n        });\n    });\n\n    let mut cx = EditorLspTestContext::new_rust(lsp::ServerCapabilities::default(), cx).await;\n    cx.set_state(indoc! {": "",
        "});\n    cx.simulate_keystroke(": "",
        ");\n    cx.executor().run_until_parked();\n    cx.update_editor(|editor, _, _| {\n        if editor.context_menu.borrow_mut().is_some() {\n            panic!(\n                ": "",
        "\n            );\n        }\n    });\n\n    cx.update_editor(|editor, window, cx| {\n        editor.show_word_completions(&ShowWordCompletions, window, cx);\n    });\n    cx.executor().run_until_parked();\n    cx.update_editor(|editor, window, cx| {\n        if let Some(CodeContextMenu::Completions(menu)) = editor.context_menu.borrow_mut().as_ref()\n        {\n            assert_eq!(completion_menu_entries(menu), &[": "",
        "], ": "",
        ");\n        }\n\n        editor.cancel(&Cancel, window, cx);\n    });\n    cx.update_editor(|editor, _, _| {\n        if editor.context_menu.borrow_mut().is_some() {\n            panic!(": "",
        ");\n        }\n    });\n\n    cx.simulate_keystroke(": "",
        "\n            );\n        }\n    });\n\n    cx.simulate_keystroke(": "",
        ");\n    cx.executor().run_until_parked();\n    cx.update_editor(|editor, _, _| {\n        if let Some(CodeContextMenu::Completions(menu)) = editor.context_menu.borrow_mut().as_ref()\n        {\n            assert_eq!(completion_menu_entries(menu), &[": "",
        ");\n        }\n    });\n}\n\n#[gpui::test]\nasync fn test_word_completions_disabled(cx: &mut TestAppContext) {\n    init_test(cx, |language_settings| {\n        language_settings.defaults.completions = Some(CompletionSettingsContent {\n            words: Some(WordsCompletionMode::Enabled),\n            words_min_length: Some(0),\n            lsp_insert_mode: Some(LspInsertMode::Insert),\n            ..Default::default()\n        });\n    });\n\n    let mut cx = EditorLspTestContext::new_rust(lsp::ServerCapabilities::default(), cx).await;\n    cx.update_editor(|editor, _, _| {\n        editor.disable_word_completions();\n    });\n    cx.set_state(indoc! {": "",
        "\n            );\n        }\n    });\n\n    cx.update_editor(|editor, window, cx| {\n        editor.show_word_completions(&ShowWordCompletions, window, cx);\n    });\n    cx.executor().run_until_parked();\n    cx.update_editor(|editor, _, _| {\n        if editor.context_menu.borrow_mut().is_some() {\n            panic!(\n                ": "",
        "\n            );\n        }\n    });\n}\n\n#[gpui::test]\nasync fn test_word_completions_disabled_with_no_provider(cx: &mut TestAppContext) {\n    init_test(cx, |language_settings| {\n        language_settings.defaults.completions = Some(CompletionSettingsContent {\n            words: Some(WordsCompletionMode::Disabled),\n            words_min_length: Some(0),\n            lsp_insert_mode: Some(LspInsertMode::Insert),\n            ..Default::default()\n        });\n    });\n\n    let mut cx = EditorLspTestContext::new_rust(lsp::ServerCapabilities::default(), cx).await;\n    cx.update_editor(|editor, _, _| {\n        editor.set_completion_provider(None);\n    });\n    cx.set_state(indoc! {": "",
        ");\n    cx.executor().run_until_parked();\n    cx.update_editor(|editor, _, _| {\n        if editor.context_menu.borrow_mut().is_some() {\n            panic!(": "",
        ");\n        }\n    });\n}\n\nfn gen_text_edit(params: &CompletionParams, text: &str) -> Option<lsp::CompletionTextEdit> {\n    let position = || lsp::Position {\n        line: params.text_document_position.position.line,\n        character: params.text_document_position.position.character,\n    };\n    Some(lsp::CompletionTextEdit::Edit(lsp::TextEdit {\n        range: lsp::Range {\n            start: position(),\n            end: position(),\n        },\n        new_text: text.to_string(),\n    }))\n}\n\n#[gpui::test]\nasync fn test_multiline_completion(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let fs = FakeFs::new(cx.executor());\n    fs.insert_tree(\n        path!(": "",
        ",\n        }),\n    )\n    .await;\n\n    let project = Project::test(fs, [path!(": "",
        ").as_ref()], cx).await;\n    let language_registry = project.read_with(cx, |project, _| project.languages().clone());\n    let typescript_language = Arc::new(Language::new(\n        LanguageConfig {\n            name: ": "",
        ".into(),\n            matcher: LanguageMatcher {\n                path_suffixes: vec![": "",
        ".to_string()],\n                ..LanguageMatcher::default()\n            },\n            line_comments: vec![": "",
        ".into()],\n            ..LanguageConfig::default()\n        },\n        Some(tree_sitter_typescript::LANGUAGE_TYPESCRIPT.into()),\n    ));\n    language_registry.add(typescript_language.clone());\n    let mut fake_servers = language_registry.register_fake_lsp(\n        ": "",
        ",\n        FakeLspAdapter {\n            capabilities: lsp::ServerCapabilities {\n                completion_provider: Some(lsp::CompletionOptions {\n                    trigger_characters: Some(vec![": "",
        ".to_string(), ": "",
        ".to_string()]),\n                    ..lsp::CompletionOptions::default()\n                }),\n                signature_help_provider: Some(lsp::SignatureHelpOptions::default()),\n                ..lsp::ServerCapabilities::default()\n            },\n            // Emulate vtsls label generation\n            label_for_completion: Some(Box::new(|item, _| {\n                let text = if let Some(description) = item\n                    .label_details\n                    .as_ref()\n                    .and_then(|label_details| label_details.description.as_ref())\n                {\n                    format!(": "",
        ", item.label, description)\n                } else if let Some(detail) = &item.detail {\n                    format!(": "",
        ", item.label, detail)\n                } else {\n                    item.label.clone()\n                };\n                Some(language::CodeLabel::plain(text, None))\n            })),\n            ..FakeLspAdapter::default()\n        },\n    );\n    let workspace = cx.add_window(|window, cx| Workspace::test_new(project.clone(), window, cx));\n    let cx = &mut VisualTestContext::from_window(*workspace, cx);\n    let worktree_id = workspace\n        .update(cx, |workspace, _window, cx| {\n            workspace.project().update(cx, |project, cx| {\n                project.worktrees(cx).next().unwrap().read(cx).id()\n            })\n        })\n        .unwrap();\n    let _buffer = project\n        .update(cx, |project, cx| {\n            project.open_local_buffer_with_lsp(path!(": "",
        "), cx)\n        })\n        .await\n        .unwrap();\n    let editor = workspace\n        .update(cx, |workspace, window, cx| {\n            workspace.open_path((worktree_id, rel_path(": "",
        ")), None, true, window, cx)\n        })\n        .unwrap()\n        .await\n        .unwrap()\n        .downcast::<Editor>()\n        .unwrap();\n    let fake_server = fake_servers.next().await.unwrap();\n\n    let multiline_label = ": "",
        ";\n    let multiline_label_2 = ": "",
        ";\n    let multiline_detail = ": "",
        "issuer\\\"`\\n\\t\\tSubjectSerialNumber\\\"`\\n}}": "",
        "d\\ne\\nf\\n": "",
        "g\\nh\\ni\\n": "",
        "new_text_1": "",
        "single line label 1": "",
        "new_text_2": "",
        "single line label 2": "",
        "new_text_3": "",
        "Label with many     spaces and \\t but without newlines": "",
        "Details with many     spaces and \\t but without newlines": "",
        "new_text_4": "",
        "StickyHeaderExcerpt { excerpt, next_excerpt_controls_present, next_buffer_row, }: StickyHeaderExcerpt<'_>,": "",
        "single line label 1 []struct { SignerId struct { Issuer string `json:\\\"issuer\\\"` SubjectSerialNumber\\\"` }}": "",
        "single line label 2 d e f ": "",
        "a b c g h i ": "",
        "Label with many     spaces and \\t but without newlines Details with many     spaces and \\t but without newlines": "",
        "Completion items should have their labels without newlines, also replacing excessive whitespaces. Completion items without newlines should not be altered.": "",
        "Adjusted completion items should still keep their filter ranges for the entire label. Item: {completion:?}": "",
        "variableˇ": "",
        "expected PageDown to select the last item from the context menu": "",
        "expected completion menu to stay open after PageDown": "",
        "expected PageUp to select the first item from the context menu": "",
        "expected completion menu to stay open after PageUp": "",
        "unsafe": "",
        "fn a() {}\\n  nˇ": "",
        "n": "",
        "fn a() {}\\n  unsafeˇ": "",
        "#ifndef BAR_H\n#define BAR_H\n\n#include <stdbool.h>\n\nint fn_branch(bool do_branch1, bool do_branch2);\n\n#endif // BAR_H\nˇ": "",
        "#ifndef BAR_H\n#define BAR_H\n\n#include <stdbool.h>\n\nint fn_branch(bool do_branch1, bool do_branch2);\n\n#endif // BAR_H\n#inˇ": "",
        "header": "",
        " include": "",
        "include \\\"$0\\\"": "",
        "40b67681include": "",
        "include": "",
        "#ifndef BAR_H\n#define BAR_H\n\n#include <stdbool.h>\n\nint fn_branch(bool do_branch1, bool do_branch2);\n\n#endif // BAR_H\n#include \\\"ˇ\\\"": "",
        "AGL/": "",
        "40b67681AGL/": "",
        "#ifndef BAR_H\n#define BAR_H\n\n#include <stdbool.h>\n\nint fn_branch(bool do_branch1, bool do_branch2);\n\n#endif // BAR_H\n#include ": "",
        "##,\n    );\n\n    cx.update_editor(|editor, window, cx| {\n        editor.handle_input(": "",
        "fn main() { let a = 2ˇ; }": "",
        "Some": "",
        "Wrap the expression in an `Option::Some`": "",
        "```rust\\nSome(2)\\n```": "",
        "Some(2)": "",
        "fn main() { let a = 2.ˇ; }": "",
        "S o m": "",
        "fn main() { let a = 2.Somˇ; }": "",
        "With the completions menu open, only one LSP request should happen per input": "",
        "// ": "",
        "//! ": "",
        "/// ": "",
        "\n        fn a() {\n            «//b();\n            ˇ»// «c();\n            //ˇ»  d();\n        }\n    ": "",
        "\n        fn a() {\n            «b();\n            c();\n            ˇ» d();\n        }\n    ": "",
        "\n        fn a() {\n            // «b();\n            // c();\n            ˇ»//  d();\n        }\n    ": "",
        "\n        fn a() {\n            // b();\n            «// c();\n        ˇ»    //  d();\n        }\n    ": "",
        "\n        fn a() {\n            // b();\n            «c();\n        ˇ»    //  d();\n        }\n    ": "",
        "\n        fn a() {\n            a();\n            b();\n        ˇ\n        }\n    ": "",
        "\n        fn a() {\n            a();\n            b();\n        //•ˇ\n        }\n    ": "",
        "\n        fn a() {\n            «a();\n\n            c();ˇ»\n        }\n    ": "",
        "\n        fn a() {\n            // «a();\n\n            // c();ˇ»\n        }\n    ": "",
        "\n        fn a() {\n            «// a();\n            /// b();\n            //! c();ˇ»\n        }\n    ": "",
        "\n        fn a() {\n            «a();\n            b();\n            c();ˇ»\n        }\n    ": "",
        "\n        fn a() {\n        //    «b();\n        //    c();\n        //    ˇ» d();\n        }\n    ": "",
        "\n        fn a() {\n        //    b();\n        //    «c();\n        ˇ»//     d();\n        }\n    ": "",
        "\n        fn a() {\n        //    b();\n            «c();\n        ˇ»//     d();\n        }\n    ": "",
        "\n        fn a() {\n            a();\n            b();\n        //ˇ\n        }\n    ": "",
        "\n        fn a() {\n        //    «a();\n\n        //    c();ˇ»\n        }\n    ": "",
        "\n        fn a() {\n        //    «a();\n        ///    b();\n        //!    c();ˇ»\n        }\n    ": "",
        "fn a() {\n             ˇdog();\n             cat();\n        }": "",
        "fn a() {\n             // dog();\n             catˇ();\n        }": "",
        "fn a() {\n             «dog()ˇ»;\n             cat();\n        }": "",
        "fn a() {\n             // «dog()ˇ»;\n             cat();\n        }": "",
        "fn a() {\n             ˇdˇog();\n             cat();\n        }": "",
        "fn a() {\n             // dog();\n             catˇ(ˇ);\n        }": "",
        "fn a() {\n             ˇdˇog«()ˇ»;\n             cat();\n        }": "",
        "fn a() {\n             // ˇdˇog«()ˇ»;\n             cat();\n        }": "",
        "fn a() {\n             ˇdog();\n\n             cat();\n        }": "",
        "fn a() {\n             // dog();\n        ˇ\n             cat();\n        }": "",
        "fn a() {\n         ˇ    dog();\n             cat();\n        }": "",
        "fn a() {\n             // dog();\n         ˇ    cat();\n        }": "",
        "<!-- ": "",
        " -->": "",
        "\n            <p>A</p>ˇ\n            <p>B</p>ˇ\n            <p>C</p>ˇ\n        ": "",
        "\n            <!-- <p>A</p>ˇ -->\n            <!-- <p>B</p>ˇ -->\n            <!-- <p>C</p>ˇ -->\n        ": "",
        "\n            <p>A«</p>\n            <p>ˇ»B</p>ˇ\n            <p>C«</p>\n            <p>ˇ»D</p>ˇ\n        ": "",
        "\n            <!-- <p>A«</p>\n            <p>ˇ»B</p>ˇ -->\n            <!-- <p>C«</p>\n            <p>ˇ»D</p>ˇ -->\n        ": "",
        "\n            ˇ<script>\n                ˇvar x = new Y();\n            ˇ</script>\n        ": "",
        "\n            <!-- ˇ<script> -->\n                // ˇvar x = new Y();\n            <!-- ˇ</script> -->\n        ": "",
        "aaaa\\nbbbb": "",
        "Xaaaa\\nXbbbb": "",
        "Xa\\nbbb": "",
        "X\\nbb": "",
        "\n            [aaaa\n            (bbbb]\n            cccc)": "",
        "\n                aaaa\n                bˇbbb\n                bˇbbˇb\n                cccc": "",
        "\n                aaaa\n                bXˇbbXb\n                bXˇbbXˇb\n                cccc": "",
        "\n                aaaa\n                bX\n                ˇbbX\n                b\n                bX\n                ˇbbX\n                ˇb\n                cccc": "",
        "aaaa\\nbbbb\\nbbbb\\ncccc": "",
        "/* ": "",
        "{   }\\n": "",
        "  x\\n": "",
        "  /*   */\\n": "",
        "x\\n": "",
        "{{} }\\n": "",
        "{ \\n": "",
        "}\\n": "",
        "  /* \\n": "",
        "  \\n": "",
        "  */\\n": "",
        "{{} \\n": "",
        "abc\\ndef\\nghi\\njkl\\n": "",
        "mno\\npqr\\nstu\\nvwx\\n": "",
        "b.txt": "",
        "a.txt": "",
        "\n        ˇfn func(abc def: i32) -> u32 {\n        }\n    ": "",
        "/root/file": "",
        "\n        fn func(abc def: i32) -> ˇu32 {\n        }\n    ": "",
        "\n        fn func(abc ˇdef: i32) -> u32 {\n        }\n    ": "",
        "\n        fn func(abcˇ def: i32) -> u32 {\n        }\n    ": "",
        "\n        use some::mod;\n\n        const A: u32 = 42;\n\n        fn main() {\n            println!(": "",
        ");\n\n            println!(": "",
        ");\n        }\n        ": "",
        "\n        use some::modified;\n\n        ˇ\n        fn main() {\n            println!(": "",
        ");\n            println!(": "",
        "\n        ˇuse some::modified;\n\n\n        fn main() {\n            println!(": "",
        "\n        use some::modified;\n\n\n        fn main() {\n        ˇ    println!(": "",
        "HelloWorld": "",
        "Hello": "",
        "World": "",
        "hello_world": "",
        "hello_": "",
        "world": "",
        "_hello_world_": "",
        "_": "",
        "world_": "",
        "Hello_World": "",
        "Hello_": "",
        "helloWOrld": "",
        "hello": "",
        "WOrld": "",
        "helloworld": "",
        ":do_the_thing": "",
        "do_": "",
        "the_": "",
        "thing": "",
        "console.logˇ(var);": "",
        "console.log(var)ˇ;": "",
        "console.log(ˇvar);": "",
        "console.log(varˇ);": "",
        "console.log('foo', [1, 2, 3]ˇ);": "",
        "console.log(ˇ'foo', [1, 2, 3]);": "",
        "let result = curried_fun()ˇ();": "",
        "let result = curried_fun()()ˇ;": "",
        "\n            function test() {\n                console.log('test')ˇ\n            }": "",
        "\n            function test() {\n                console.logˇ('test')\n            }": "",
        "fn main() { let a = 5; }": "",
        "other.rs": "",
        "// Test file": "",
        "fn main() { let a = {5}; }": "",
        "No extra braces from on type formatting should appear in the buffer": "",
        "fn c() {\\n    d()ˇ\\n}\\n": "",
        "fn c() {\\n    d()\\n        .\\n}\\n": "",
        "OnTypeFormatting should triggered after autoindent applied": "",
        "fn c() {\\n    d()\\n        .ˇ\\n}\\n": "",
        "test language server": "",
        "testOptionValue": "",
        "Should not restart LSP server on an unrelated change": "",
        "Some other server name": "",
        "some other init value": "",
        "Should not restart LSP server on an unrelated LSP settings change": "",
        "anotherInitValue": "",
        "Should restart LSP server on a related LSP settings change": "",
        "Should not restart LSP server on a related LSP settings change that is the same": "",
        "Should restart LSP server on another related LSP settings change": "",
        "some": "",
        "fffffff2": "",
        "fn main() { let a = 2.Some(2)ˇ; }": "",
        "fn main() { let a = Some(2)ˇ; }": "",
        "method id()": "",
        "id": "",
        ".id": "",
        "other": "",
        ".other": "",
        "Should have the context menu deployed": "",
        "Should show the completions menu": "",
        "Now resolved!": "",
        "Docs": "",
        "method id() Now resolved!": "",
        "Should update first completion label, but not second as the filter text did not match.": "",
        "\n        struct TestStruct {\n            field: i32\n        }\n\n        fn mainˇ() {\n            let unused_var = 42;\n            let test_struct = TestStruct { field: 42 };\n        }\n    ": "",
        "\n        struct TestStruct {\n            field: i32\n        }\n\n        «fn main»() {\n            let unused_var = 42;\n            let test_struct = TestStruct { field: 42 };\n        }\n    ": "",
        "Function documentation": "",
        "Remove unused variable": "",
        "Hover popover should be hidden when code action menu is shown": "",
        "main": "",
        "() -> ()": "",
        "TestStruct": "",
        "struct TestStruct": "",
        "Hover popover should be hidden when completion menu is shown": "",
        "Unexpected completion item {unresolved_request:?}": "",
        "No task returned": "",
        "Completion failed": "",
        "Should always resolve once despite multiple selections": "",
        "Should always resolve once after multiple selections and applying the completion": "",
        "fn main() { let a = ??.other; }": "",
        "Should use resolved data when applying the completion": "",
        "abs": "",
        "very": "",
        "special": "",
        "item_{}": "",
        "default": "",
        "data": "",
        "should have the completions menu": "",
        "Expected to have the completions menu": "",
        "Items sent for resolve should be unchanged modulo resolve `data` filled with default if missing": "",
        "jsx": "",
        "(jsx_self_closing_element) @element": "",
        "bg-blue": "",
        "bg-red": "",
        "bg-yellow": "",
        "<p class=": "",
        " />": "",
        "test_plugin": "",
        "Test prettier formatting was not applied to the original buffer text": "",
        "Autoformatting (via test prettier) was not applied to the original buffer text": "",
        "\n        struct Row;\n        struct Row1;\n        struct Row2;\n\n        struct Row4;\n        struct Row5;\n        struct Row6;\n\n        struct Row8;\n        struct Row9;\n        struct Row10;": "",
        "struct Row;\n                   struct Row1;\n                   struct Row1.1;\n                   struct Row1.2;\n                   struct Row2;ˇ\n\n                   struct Row4;\n                   struct Row5;\n                   struct Row6;\n\n                   struct Row8;\n                   ˇstruct Row9;\n                   struct Row9.1;\n                   struct Row9.2;\n                   struct Row9.3;\n                   struct Row10;": "",
        "struct Row;\n                   struct Row1;\n                   struct Row2;\n                   struct Row2.1;\n                   struct Row2.2;\n                   «ˇ\n                   struct Row4;\n                   struct» Row5;\n                   «struct Row6;\n                   ˇ»\n                   struct Row9.1;\n                   struct Row9.2;\n                   struct Row9.3;\n                   struct Row8;\n                   struct Row9;\n                   struct Row10;": "",
        "struct Row;\n                   ˇ// something on the top\n                   struct Row1;\n                   struct Row2;\n                   struct Roˇw3.1;\n                   struct Row2.2;\n                   struct Row2.3;ˇ\n\n                   struct Row4;\n                   struct ˇRow5.1;\n                   struct Row5.2;\n                   struct «Rowˇ»5.3;\n                   struct Row5;\n                   struct Row6;\n                   ˇ\n                   struct Row9.1;\n                   struct «Rowˇ»9.2;\n                   struct «ˇRow»9.3;\n                   struct Row8;\n                   struct Row9;\n                   «ˇ// something on bottom»\n                   struct Row10;": "",
        "struct Row;\n                   ˇstruct Row1;\n                   struct Row2;\n                   ˇ\n                   struct Row4;\n                   ˇstruct Row5;\n                   struct Row6;\n                   ˇ\n                   ˇstruct Row8;\n                   struct Row9;\n                   ˇstruct Row10;": "",
        "struct Row;\n                   struct Row1;\n                   struct Row33;\n                   ˇ\n                   struct Row4;\n                   struct Row5;\n                   struct Row6;\n                   ˇ\n                   struct Row99;\n                   struct Row9;\n                   struct Row10;": "",
        "struct Row;\n                   struct Row1;\n                   struct Row33;\n                   «ˇ\n                   struct Row4;\n                   struct» Row5;\n                   «struct Row6;\n                   ˇ»\n                   struct Row99;\n                   struct Row9;\n                   struct Row10;": "",
        "ˇstruct Row1.1;\n                   struct Row1;\n                   «ˇstr»uct Row22;\n\n                   struct ˇRow44;\n                   struct Row5;\n                   struct «Rˇ»ow66;ˇ\n\n                   «struˇ»ct Row88;\n                   struct Row9;\n                   struct Row1011;ˇ": "",
        "struct Row;\n                   ˇstruct Row1;\n                   struct Row2;\n                   ˇ\n                   struct Row4;\n                   ˇstruct Row5;\n                   struct Row6;\n                   ˇ\n                   struct Row8;\n                   ˇstruct Row9;\n                   struct Row10;ˇ": "",
        "\n        one\n\n        two\n        three\n        ": "",
        "\\nˇ\\n": "",
        "\n\n        - two\n        - threeˇ\n        +\n        ": "",
        "struct Row;\nstruct Row1;\nstruct Row2;\n\nstruct Row4;\nstruct Row5;\nstruct Row6;\n\nstruct Row8;\nstruct Row9;\nstruct Row10;": "",
        "struct Row;\n                   struct Row2;\n\n                   ˇstruct Row4;\n                   struct Row5;\n                   struct Row6;\n                   ˇ\n                   struct Row8;\n                   struct Row10;": "",
        "struct Row;\n                   struct Row2;\n\n                   «ˇstruct Row4;\n                   struct» Row5;\n                   «struct Row6;\n                   ˇ»\n                   struct Row8;\n                   struct Row10;": "",
        "struct Row;\n                   ˇstruct Row2;\n\n                   struct Row4;\n                   struct Row5;\n                   struct Row6;\n\n                   struct Row8;ˇ\n                   struct Row10;": "",
        "struct Row;\n                   struct Row1;\n                   ˇstruct Row2;\n\n                   struct Row4;\n                   struct Row5;\n                   struct Row6;\n\n                   struct Row8;ˇ\n                   struct Row9;\n                   struct Row10;": "",
        "struct Row;\n                   struct Row2«ˇ;\n                   struct Row4;\n                   struct» Row5;\n                   «struct Row6;\n\n                   struct Row8;ˇ»\n                   struct Row10;": "",
        "struct Row;\n                   struct Row1;\n                   struct Row2«ˇ;\n\n                   struct Row4;\n                   struct» Row5;\n                   «struct Row6;\n\n                   struct Row8;ˇ»\n                   struct Row9;\n                   struct Row10;": "",
        "aaaa\\nbbbb\\ncccc\\ndddd\\neeee\\nffff\\ngggg\\nhhhh\\niiii\\njjjj": "",
        "llll\\nmmmm\\nnnnn\\noooo\\npppp\\nqqqq\\nrrrr\\nssss\\ntttt\\nuuuu": "",
        "vvvv\\nwwww\\nxxxx\\nyyyy\\nzzzz\\n{{{{\\n||||\\n}}}}\\n~~~~\\n\\u{7f}\\u{7f}\\u{7f}\\u{7f}": "",
        "Xaaa\\nXbbb\\nXccc\\n\\nXfff\\nXggg\\n\\nXjjj\\nXlll\\nXmmm\\nXnnn\\n\\nXqqq\\nXrrr\\n\\nXuuu\\nXvvv\\nXwww\\nXxxx\\n\\nX{{{\\nX|||\\n\\nX\\u{7f}\\u{7f}\\u{7f}": "",
        "aaaa\\nbbbb\\ncccc\\ndddd\\neeee\\nffff\\ngggg\\nhhhh\\niiii\\njjjj\\n\\n\\nllll\\nmmmm\\nnnnn\\noooo\\npppp\\nqqqq\\nrrrr\\nssss\\ntttt\\nuuuu\\n\\n\\nvvvv\\nwwww\\nxxxx\\nyyyy\\nzzzz\\n{{{{\\n||||\\n}}}}\\n~~~~\\n\\u{7f}\\u{7f}\\u{7f}\\u{7f}\\n\\n": "",
        "aaaa\\nbbbb\\ncccc\\ndddd\\neeee\\nffff\\ngggg\\nhhhh\\niiii\\njjjj\\n\\n\\nXlll\\nXmmm\\nXnnn\\n\\nXqqq\\nXrrr\\n\\nXuuu\\nXvvv\\nXwww\\nXxxx\\n\\nX{{{\\nX|||\\n\\nX\\u{7f}\\u{7f}\\u{7f}": "",
        "Xlll\\nXmmm\\nXnnn\\nXooo\\nXppp\\nXqqq\\nXrrr\\nXsss\\nXttt\\nXuuu": "",
        "Xvvv\\nXwww\\nXxxx\\nXyyy\\nXzzz\\nX{{{\\nX|||\\nX}}}\\nX~~~\\nX\\u{7f}\\u{7f}\\u{7f}": "",
        "X{}": "",
        "lib.rs": "",
        "active item should be None before the first item is added": "",
        "should have an active item after adding the multi buffer": "",
        "A multi buffer was expected to active after adding": "",
        "should have an active item after navigating into the 1st buffer": "",
        "Should navigate into the 1st buffer and activate it": "",
        "New active item should be a singleton buffer": "",
        "should have navigated into an editor for the 1st buffer": "",
        "should have an active item after navigating back": "",
        "Should navigate back to the multi buffer": "",
        "should have an active item after navigating into the 2nd buffer": "",
        "Should navigate away from the multibuffer": "",
        "Should navigate into the 2nd buffer and activate it": "",
        "should have navigated into an editor": "",
        "should have an active item after navigating back from the 2nd buffer": "",
        "Should navigate back from the 2nd buffer to the multi buffer": "",
        "should have an active item after navigating into the 3rd buffer": "",
        "Should navigate into the 3rd buffer and activate it": "",
        "should have an active item after navigating back from the 3rd buffer": "",
        "Should navigate back from the 3rd buffer to the multi buffer": "",
        "\n          use some::modified;\n\n\n          fn main() {\n        -     println!(": "",
        ");\n        + ˇ    println!(": "",
        ");\n\n              println!(": "",
        ");\n              println!(": "",
        ");\n          }\n        ": "",
        "\n        - use some::mod;\n        + ˇuse some::modified;\n\n\n          fn main() {\n        -     println!(": "",
        ");\n        +     println!(": "",
        ");\n\n        +     println!(": "",
        "\n        - use some::mod;\n        + use some::modified;\n\n        - const A: u32 = 42;\n          ˇ\n          fn main() {\n        -     println!(": "",
        "\n          use some::modified;\n\n          ˇ\n          fn main() {\n              println!(": "",
        "\n        use some::mod1;\n        use some::mod2;\n\n        const A: u32 = 42;\n        const B: u32 = 42;\n        const C: u32 = 42;\n\n        fn main() {\n            println!(": "",
        "\n        use some::mod2;\n\n        const A: u32 = 42;\n        const C: u32 = 42;\n\n        fn main(ˇ) {\n            //println!(": "",
        ");\n            //\n            //\n        }\n        ": "",
        "\n        - use some::mod1;\n          use some::mod2;\n\n          const A: u32 = 42;\n        - const B: u32 = 42;\n          const C: u32 = 42;\n\n          fn main(ˇ) {\n        -     println!(": "",
        ");\n        +     //println!(": "",
        ");\n        +     //\n        +     //\n          }\n        ": "",
        "new diff base!": "",
        "\n        - new diff base!\n        + use some::mod2;\n        +\n        + const A: u32 = 42;\n        + const C: u32 = 42;\n        +\n        + fn main(ˇ) {\n        +     //println!(": "",
        ");\n        +\n        +     println!(": "",
        ");\n        +     //\n        +     //\n        + }\n        ": "",
        "aaa\\nbbb\\nccc\\nddd\\neee\\nfff\\nggg\\nhhh\\niii\\njjj": "",
        "aaa\\nccc\\nddd\\neee\\nfff\\nggg\\nhhh\\niii\\njjj": "",
        "lll\\nmmm\\nnnn\\nooo\\nppp\\nqqq\\nrrr\\nsss\\nttt\\nuuu": "",
        "lll\\nmmm\\nNNN\\nooo\\nppp\\nqqq\\nrrr\\nsss\\nttt\\nuuu": "",
        "111\\n222\\n333\\n444\\n555\\n777\\n888\\n999\\n000\\n!!!": "",
        "111\\n222\\n333\\n444\\n555\\n666\\n777\\n888\\n999\\n000\\n!!!": "",
        "\n            ˇaaa\n            ccc\n            ddd\n\n            ggg\n            hhh\n\n\n            lll\n            mmm\n            NNN\n\n            qqq\n            rrr\n\n            uuu\n            111\n            222\n            333\n\n            666\n            777\n\n            000\n            !!!": "",
        "\n            «aaa\n          - bbb\n            ccc\n            ddd\n\n            ggg\n            hhh\n\n\n            lll\n            mmm\n          - nnn\n          + NNN\n\n            qqq\n            rrr\n\n            uuu\n            111\n            222\n            333\n\n          + 666\n            777\n\n            000\n            !!!ˇ»": "",
        "aaa\\nbbb\\nccc\\nddd\\neee\\nfff\\nggg\\n": "",
        "aaa\\nBBB\\nBB2\\nccc\\nDDD\\nEEE\\nfff\\nggg\\nhhh\\niii\\n": "",
        "\n            ˇaaa\n          - bbb\n          + BBB\n\n          - ddd\n          - eee\n          + DDD\n          + EEE\n            fff\n\n            iii\n        ": "",
        "\n        use some::mod1;\n        use some::mod2;\n\n        const A: u32 = 42;\n\n        fn main() {\n            println!(": "",
        "\n        use some::mod1;\n        use some::mod2;\n\n        const A: u32 = 42;\n        const B: u32 = 42;\n        const C: u32 = 42;\n        ˇ\n\n        fn main() {\n            println!(": "",
        "\n        use some::mod1;\n        use some::mod2;\n\n        const A: u32 = 42;\n      + const B: u32 = 42;\n      + const C: u32 = 42;\n      + ˇ\n\n        fn main() {\n            println!(": "",
        ");\n        }\n      ": "",
        "const D: u32 = 42;\\n": "",
        "\n        use some::mod1;\n        use some::mod2;\n\n        const A: u32 = 42;\n      + const B: u32 = 42;\n      + const C: u32 = 42;\n      + const D: u32 = 42;\n      + ˇ\n\n        fn main() {\n            println!(": "",
        "const E: u32 = 42;\\n": "",
        "\n        use some::mod1;\n        use some::mod2;\n\n        const A: u32 = 42;\n      + const B: u32 = 42;\n      + const C: u32 = 42;\n      + const D: u32 = 42;\n      + const E: u32 = 42;\n      + ˇ\n\n        fn main() {\n            println!(": "",
        "\n        use some::mod1;\n        use some::mod2;\n\n        const A: u32 = 42;\n      + const B: u32 = 42;\n      + const C: u32 = 42;\n      + const D: u32 = 42;\n      + const E: u32 = 42;\n        ˇ\n        fn main() {\n            println!(": "",
        "\n        use some::mod1;\n        use some::mod2;\n\n        const A: u32 = 42;\n      + const B: u32 = 42;\n        ˇ\n        fn main() {\n            println!(": "",
        "\n        ˇ\n        fn main() {\n            println!(": "",
        "\n        one\n        two\n        three\n        four\n        five\n        ": "",
        "\n        one\n        ˇthree\n        five\n    ": "",
        "\n        one\n      - two\n        ˇthree\n      - four\n        five\n    ": "",
        "\n        one\n        ˇTWO\n        three\n        four\n        five\n    ": "",
        "\n            one\n          - two\n          + ˇTWO\n            three\n            four\n            five\n        ": "",
        "\n            one\n            ˇTWO\n            three\n            four\n            five\n        ": "",
        "\n        use some::mod1;\n        use some::mod2;\n\n        const A: u32 = 42;\n        const B: u32 = 42;\n        const C: u32 = 42;\n\n\n        fn main() {\n            println!(": "",
        ");\n        }\n    ": "",
        "\n        use some::mod1;\n        use some::mod2;\n\n        ˇconst B: u32 = 42;\n        const C: u32 = 42;\n\n\n        fn main() {\n            println!(": "",
        "\n        use some::mod1;\n        use some::mod2;\n\n      - const A: u32 = 42;\n        ˇconst B: u32 = 42;\n        const C: u32 = 42;\n\n\n        fn main() {\n            println!(": "",
        "\n        use some::mod1;\n        use some::mod2;\n\n      - const A: u32 = 42;\n      - const B: u32 = 42;\n        ˇconst C: u32 = 42;\n\n\n        fn main() {\n            println!(": "",
        "\n        use some::mod1;\n        use some::mod2;\n\n      - const A: u32 = 42;\n      - const B: u32 = 42;\n      - const C: u32 = 42;\n        ˇ\n\n        fn main() {\n            println!(": "",
        "replacement": "",
        "\n        use some::mod1;\n        use some::mod2;\n\n      - const A: u32 = 42;\n      - const B: u32 = 42;\n      - const C: u32 = 42;\n      -\n      + replacementˇ\n\n        fn main() {\n            println!(": "",
        "\n        one\n        two\n        three\n        four\n        five\n    ": "",
        "\n        one\n        two\n        fˇour\n        five\n        ": "",
        "\n          one\n          two\n        - three\n          fˇour\n          five\n        ": "",
        "\n          one\n          two\n        - threeˇ\n        - four\n        + our\n          five\n        ": "",
        "\n        use some::mod1;\n        use some::mod2;\n\n        const A: u32 = 42;\n        const B: u32 = 42;\n        const C: u32 = 42;\n        const D: u32 = 42;\n\n\n        fn main() {\n            println!(": "",
        ");\n        }": "",
        "\n        use some::mod1;\n        use some::mod2;\n\n        const A: u32 = 42;\n        const B: u32 = 42;\n        const C: u32 = 43ˇ\n        const D: u32 = 42;\n\n\n        fn main() {\n            println!(": "",
        "\n        use some::mod1;\n        use some::mod2;\n\n        const A: u32 = 42;\n        const B: u32 = 42;\n      - const C: u32 = 42;\n      + const C: u32 = 43ˇ\n        const D: u32 = 42;\n\n\n        fn main() {\n            println!(": "",
        "\\nnew_line\\n": "",
        "\n        use some::mod1;\n        use some::mod2;\n\n        const A: u32 = 42;\n        const B: u32 = 42;\n      - const C: u32 = 42;\n      + const C: u32 = 43\n      + new_line\n      + ˇ\n        const D: u32 = 42;\n\n\n        fn main() {\n            println!(": "",
        "\n            ˇfn main() {\n                println!(": "",
        ");\n            }\n        ": "",
        "\n            + ˇfn main() {\n            +     println!(": "",
        ");\n            + }\n        ": "",
        "Active indent guide indices do not match": "",
        "Indent guides do not match": "",
        "\n        fn main() {\n            let a = 1;\n        }": "",
        "\n        fn main() {\n            let a = 1;\n            let b = 2;\n        }": "",
        "\n        fn main() {\n            let a = 1;\n            if a == 3 {\n                let b = 2;\n            } else {\n                let c = 3;\n            }\n        }": "",
        "\n        fn main() {\n            let a = 1;\n                let b = 2;\n            let c = 3;\n        }": "",
        "\n        fn main() {\n            let a = 1;\n\n            let c = 3;\n        }": "",
        "\n        fn main() {\n            let a = 1;\n\n            let c = 3;\n\n            if a == 3 {\n                let b = 2;\n            } else {\n                let c = 3;\n            }\n        }": "",
        "\n        fn main() {\n            if a {\n                b(\n                    c,\n                    d,\n                )\n            } else {\n                e(\n                    f\n                )\n            }\n        }": "",
        "\n            fn main() {\n                if a {\n                    b(⋯\n                    )\n                } else {\n                    e(\n                        f\n                    )\n                }\n            }": "",
        "\n        block1\n            block2\n                block3\n                    block4\n            block2\n        block1\n        block1": "",
        "\n        block1\n            block2\n                block3\n\n        block1\n        block1": "",
        "\n        function component() {\n        \\treturn (\n        \\t\\t\\t\n        \\t\\t<div>\n        \\t\\t\\t<abc></abc>\n        \\t\\t</div>\n        \\t)\n        }": "",
        "\n        function component() {\n        \\treturn (\n        \\t\n        \\t\\t<div>\n        \\t\\t\\t<abc></abc>\n        \\t\\t</div>\n        \\t)\n        }": "",
        "\n        block1\n\n\n\n            block2\n        ": "",
        "\n        def a:\n        \\tb = 3\n        \\tif True:\n        \\t\\tc = 4\n        \\t\\td = 5\n        \\tprint(b)\n        ": "",
        "\n    fn main() {\n        let a = 1;\n    }": "",
        "\n    fn main() {\n        if 1 == 2 {\n            let a = 1;\n        }\n    }": "",
        "\n    fn main() {\n        let a = 1;\n\n        let b = 2;\n    }": "",
        "\n    def m:\n        a = 1\n        pass": "",
        "\n        impl A {\n            fn b() {\n                0;\n                3;\n                5;\n                6;\n                7;\n            }\n        }\n        ": "",
        "\n        impl A {\n            fn b() {\n                0;\n                1;\n                2;\n                3;\n                4;\n            }\n            fn c() {\n                5;\n                6;\n                7;\n            }\n        }\n        ": "",
        "\n          impl A {\n              fn b() {\n                  0;\n        -         1;\n        -         2;\n                  3;\n        -         4;\n        -     }\n        -     fn c() {\n                  5;\n                  6;\n                  7;\n              }\n          }\n          ˇ": "",
        "\n        a\n        b\n        c\n        ": "",
        "\n        ˇA\n        b\n        C\n        ": "",
        "\n        - a\n        + ˇA\n          b\n        - c\n        + C\n        ": "",
        "\n          ˇA\n          b\n        - c\n        + C\n        ": "",
        "\n        - a\n        + ˇA\n          b\n          C\n        ": "",
        "\n        ˇA\n        b\n        ": "",
        "\n        - ˇa\n        + A\n          b\n        ": "",
        "\n            - ˇa\n            + A\n              b\n            - c\n            ": "",
        "\n        ˇb\n        c\n        ": "",
        "\n        - a\n          ˇb\n          c\n        ": "",
        "\n          ˇb\n          c\n        ": "",
        "/test": "",
        ".git": "",
        "file-1": "",
        "ONE\\n": "",
        "file-2": "",
        "TWO\\n": "",
        "file-3": "",
        "THREE\\n": "",
        "one\\n": "",
        "two\\n": "",
        "three\\n": "",
        "deadbeef": "",
        "/test/file-{}": "",
        "\n        one\n        TWO\n        ˇTHREE\n        FOUR\n        five\n    ": "",
        "\n        one\n        TWO\n        THREE\n        FOUR\n        five\n    ": "",
        "\n        one\n        TWO\n        ˇTHREE-HUNDRED\n        FOUR\n        five\n    ": "",
        "\n        one\n        TWO\n        THREE-HUNDRED\n        FOUR\n        five\n    ": "",
        "ˇone\n        two\n\n        three\n        fourˇ\n        five\n\n        siˇx": "",
        "AAAA": "",
        "AAAAˇone\n        two\n\n        three\n        fourAAAAˇ\n        five\n\n        siAAAAˇx": "",
        "let foo = 1;\nlet foo = 2;\nlet foo = 3;\nlet fooˇ = 4;\nlet foo = 5;\nlet foo = 6;\nlet foo = 7;\nlet foo = 8;\nlet foo = 9;\nlet foo = 10;\nlet foo = 11;\nlet foo = 12;\nlet foo = 13;\nlet foo = 14;\nlet foo = 15;": "",
        "Default next scroll direction is center": "",
        "After center, next scroll direction should be top": "",
        "After top, next scroll direction should be bottom": "",
        "After bottom, scrolling should start over": "",
        "Scrolling continues if retriggered fast enough": "",
        "If scrolling is not triggered fast enough, it should reset": "",
        "fn one() {\n            let mut a = ˇtwo();\n        }\n\n        fn two() {}": "",
        "Failed to navigate to definition": "",
        "Should have navigated to definition from the GetDefinition response": "",
        "fn one() {\n            let mut a = two();\n        }\n\n        fn «twoˇ»() {}": "",
        "Initially, only one, test, editor should be open in the workspace": "",
        "Asserted len is 1": "",
        "Failed to navigate to lookup references": "",
        "Should have navigated to references as a fallback after empty GoToDefinition response": "",
        "After falling back to references search, we open a new editor with the results": "",
        "Should have one non-test editor now": "",
        "fn one() {\\n    let mut a = two();\\n}": "",
        "Should use the range from the references response and not the GoToDefinition one": "",
        "fn one() {\n        let mut a = ˇtwo();\n    }\n\n    fn two() {}": "",
        "Should not call for references with no go to definition fallback": "",
        "Should have called the go_to_definition handler": "",
        "After unsuccessful fallback, no other editor should have been opened": "",
        "\n        fn one() {\n            let mut a = two();\n        }\n\n        fn ˇtwo() {}": "",
        "Failed to navigate to references": "",
        "Should have navigated to references from the FindAllReferences response": "",
        "fn one() {\n            let mut a = two();\n        }\n\n        fn ˇtwo() {}": "",
        "We should have opened a new multibuffer": "",
        "should have re-used the previous multibuffer": "",
        "fn one() {\n            let mut a = ˇtwo();\n        }\n        fn three() {}\n        fn two() {}": "",
        "fn one() {\n                let mut a = ˇtwo();\n            }\n            fn three() {}\n            fn two() {}": "",
        "should have used a new multibuffer as offsets changed": "",
        "\n        #[cfg(test)]\n        mod tests() {\n            #[test]\n            fn runnable_1() {\n                let a = 1;\n            }\n\n            #[test]\n            fn runnable_2() {\n                let a = 1;\n                let b = 2;\n            }\n        }\n    ": "",
        "Should find task for cursor inside runnable_1": "",
        "Should find task when cursor is on function name": "",
        "vvvv\\nwwww\\nxxxx\\nyyyy\\nzzzz\\n1111\\n2222\\n3333\\n4444\\n5555": "",
        "first.rs": "",
        "second.rs": "",
        "third.rs": "",
        "\\n\\naaaa\\nbbbb\\ncccc\\n\\n\\nffff\\ngggg\\n\\n\\njjjj\\n\\n\\nllll\\nmmmm\\nnnnn\\n\\n\\nqqqq\\nrrrr\\n\\n\\nuuuu\\n\\n\\nvvvv\\nwwww\\nxxxx\\n\\n\\n1111\\n2222\\n\\n\\n5555": "",
        "\\n\\n\\n\\nllll\\nmmmm\\nnnnn\\n\\n\\nqqqq\\nrrrr\\n\\n\\nuuuu\\n\\n\\nvvvv\\nwwww\\nxxxx\\n\\n\\n1111\\n2222\\n\\n\\n5555": "",
        "After folding the first buffer, its text should not be displayed": "",
        "\\n\\n\\n\\n\\n\\nvvvv\\nwwww\\nxxxx\\n\\n\\n1111\\n2222\\n\\n\\n5555": "",
        "After folding the second buffer, its text should not be displayed": "",
        "\\n\\n\\n\\n\\n": "",
        "After folding the third buffer, its text should not be displayed": "",
        "\\n\\n\\n\\nllll\\nmmmm\\nnnnn\\n\\n\\nqqqq\\nrrrr\\n\\n\\nuuuu\\n\\n": "",
        "After unfolding the second buffer, its text should be displayed": "",
        "bbbb": "",
        "B": "",
        "\\n\\naaaa\\nBbbbb\\ncccc\\n\\n\\nffff\\ngggg\\n\\n\\njjjj\\n\\n\\nllll\\nmmmm\\nnnnn\\n\\n\\nqqqq\\nrrrr\\n\\n\\nuuuu\\n\\n": "",
        "After unfolding the first buffer, its and 2nd buffer's text should be displayed": "",
        "\\n\\naaaa\\nBbbbb\\ncccc\\n\\n\\nffff\\ngggg\\n\\n\\njjjj\\n\\n\\nllll\\nmmmm\\nnnnn\\n\\n\\nqqqq\\nrrrr\\n\\n\\nuuuu\\n\\n\\nvvvv\\nwwww\\nxxxx\\n\\n\\n1111\\n2222\\n\\n\\n5555": "",
        "After unfolding the all buffers, all original text should be displayed": "",
        "1111\\n2222\\n3333": "",
        "4444\\n5555\\n6666": "",
        "7777\\n8888\\n9999": "",
        "\\n\\n1111\\n2222\\n3333\\n\\n\\n4444\\n5555\\n6666\\n\\n\\n7777\\n8888\\n9999": "",
        "\\n\\n\\n\\n4444\\n5555\\n6666\\n\\n\\n7777\\n8888\\n9999": "",
        "\\n\\n\\n\\n\\n\\n7777\\n8888\\n9999": "",
        "\\n\\n\\n\\n4444\\n5555\\n6666\\n\\n": "",
        "\\n\\n1111\\n2222\\n3333\\n\\n\\n4444\\n5555\\n6666\\n\\n": "",
        "After unfolding the first buffer, its text should be displayed": "",
        "After unfolding all buffers, all original text should be displayed": "",
        "\\n\\n{sample_text}": "",
        "keymaps/default-linux.json": "",
        "a0\\nb0\\nc0\\nd0\\ne0\\n": "",
        "a1\\nb1\\nc1\\nd1\\ne1\\n": "",
        "a2\\nb2\\nc2\\nd2\\ne2\\n": "",
        "a3\\nb3\\nc3\\nd3\\ne3\\n": "",
        "\n        [EXCERPT]\n        ˇ[FOLDED]\n        [EXCERPT]\n        a1\n        b1\n        [EXCERPT]\n        [FOLDED]\n        [EXCERPT]\n        [FOLDED]\n        ": "",
        "down": "",
        "\n        [EXCERPT]\n        [FOLDED]\n        [EXCERPT]\n        ˇa1\n        b1\n        [EXCERPT]\n        [FOLDED]\n        [EXCERPT]\n        [FOLDED]\n        ": "",
        "\n        [EXCERPT]\n        [FOLDED]\n        [EXCERPT]\n        a1\n        ˇb1\n        [EXCERPT]\n        [FOLDED]\n        [EXCERPT]\n        [FOLDED]\n        ": "",
        "\n        [EXCERPT]\n        [FOLDED]\n        [EXCERPT]\n        a1\n        b1\n        ˇ[EXCERPT]\n        [FOLDED]\n        [EXCERPT]\n        [FOLDED]\n        ": "",
        "\n        [EXCERPT]\n        [FOLDED]\n        [EXCERPT]\n        a1\n        b1\n        [EXCERPT]\n        ˇ[FOLDED]\n        [EXCERPT]\n        [FOLDED]\n        ": "",
        "\n            [EXCERPT]\n            [FOLDED]\n            [EXCERPT]\n            a1\n            b1\n            [EXCERPT]\n            [FOLDED]\n            [EXCERPT]\n            ˇ[FOLDED]\n            ": "",
        "up": "",
        "\n            [EXCERPT]\n            ˇ[FOLDED]\n            [EXCERPT]\n            a1\n            b1\n            [EXCERPT]\n            [FOLDED]\n            [EXCERPT]\n            [FOLDED]\n            ": "",
        "Hello, world!": "",
        " beautiful": "",
        "Hello, beautiful world!": "",
        "This is a test.": "",
        "That": "",
        "That is a test.": "",
        "Greetings": "",
        " and universe": "",
        "Greetings, world and universe!": "",
        "First line\\nSecond line\\nThird line\\nFourth line": "",
        "modified": "",
        "New third line": "",
        " updated": "",
        "Second modified\\nNew third line\\nFourth updated line": "",
        " digital": "",
        "hello Earth!!": "",
        "\n        struct Fˇoo {}\n    ": "",
        "Prepare rename was not started": "",
        "Prepare rename failed": "",
        "FooRenamed": "",
        "Confirm rename was not started": "",
        "Confirm rename failed": "",
        "\n        struct FooRenamedˇ {}\n    ": "",
        "\n            (": "",
        " @close)\n            (": "",
        "#,\n        )\n        .unwrap(),\n    );\n    cx.update_buffer(|buffer, cx| buffer.set_language(Some(language), cx));\n\n    cx.set_state(indoc! {": "",
        "});\n}\n\n#[gpui::test(iterations = 10)]\nasync fn test_apply_code_lens_actions_with_commands(cx: &mut gpui::TestAppContext) {\n    init_test(cx, |_| {});\n\n    let fs = FakeFs::new(cx.executor());\n    fs.insert_tree(\n        path!(": "",
        ").as_ref()], cx).await;\n    let workspace = cx.add_window(|window, cx| Workspace::test_new(project.clone(), window, cx));\n    let cx = &mut VisualTestContext::from_window(*workspace.deref(), cx);\n\n    let language_registry = project.read_with(cx, |project, _| project.languages().clone());\n    language_registry.add(Arc::new(Language::new(\n        LanguageConfig {\n            name: ": "",
        ".to_string()],\n                ..Default::default()\n            },\n            ..Default::default()\n        },\n        Some(tree_sitter_typescript::LANGUAGE_TYPESCRIPT.into()),\n    )));\n    let mut fake_language_servers = language_registry.register_fake_lsp(\n        ": "",
        ",\n        FakeLspAdapter {\n            capabilities: lsp::ServerCapabilities {\n                code_lens_provider: Some(lsp::CodeLensOptions {\n                    resolve_provider: Some(true),\n                }),\n                execute_command_provider: Some(lsp::ExecuteCommandOptions {\n                    commands: vec![": "",
        ".to_string()],\n                    ..lsp::ExecuteCommandOptions::default()\n                }),\n                ..lsp::ServerCapabilities::default()\n            },\n            ..FakeLspAdapter::default()\n        },\n    );\n\n    let editor = workspace\n        .update(cx, |workspace, window, cx| {\n            workspace.open_abs_path(\n                PathBuf::from(path!(": "",
        ")),\n                OpenOptions::default(),\n                window,\n                cx,\n            )\n        })\n        .unwrap()\n        .await\n        .unwrap()\n        .downcast::<Editor>()\n        .unwrap();\n    cx.executor().run_until_parked();\n\n    let fake_server = fake_language_servers.next().await.unwrap();\n\n    let buffer = editor.update(cx, |editor, cx| {\n        editor\n            .buffer()\n            .read(cx)\n            .as_singleton()\n            .expect(": "",
        ")\n    });\n\n    let buffer_snapshot = buffer.update(cx, |buffer, _| buffer.snapshot());\n    let anchor = buffer_snapshot.anchor_at(0, text::Bias::Left);\n    drop(buffer_snapshot);\n    let actions = cx\n        .update_window(*workspace, |_, window, cx| {\n            project.code_actions(&buffer, anchor..anchor, window, cx)\n        })\n        .unwrap();\n\n    fake_server\n        .set_request_handler::<lsp::request::CodeLensRequest, _, _>(|_, _| async move {\n            Ok(Some(vec![\n                lsp::CodeLens {\n                    range: lsp::Range::default(),\n                    command: Some(lsp::Command {\n                        title: ": "",
        ".to_owned(),\n                        command: ": "",
        ".to_owned(),\n                        arguments: None,\n                    }),\n                    data: None,\n                },\n                lsp::CodeLens {\n                    range: lsp::Range::default(),\n                    command: Some(lsp::Command {\n                        title: ": "",
        ".to_owned(),\n                        arguments: None,\n                    }),\n                    data: None,\n                },\n                lsp::CodeLens {\n                    range: lsp::Range {\n                        start: lsp::Position {\n                            line: 1,\n                            character: 1,\n                        },\n                        end: lsp::Position {\n                            line: 1,\n                            character: 1,\n                        },\n                    },\n                    command: Some(lsp::Command {\n                        title: ": "",
        ".to_owned(),\n                        arguments: None,\n                    }),\n                    data: None,\n                },\n            ]))\n        })\n        .next()\n        .await;\n\n    let actions = actions.await.unwrap();\n    assert_eq!(\n        actions.len(),\n        1,\n        ": "",
        "\n    );\n    let action = actions[0].clone();\n    let apply = project.update(cx, |project, cx| {\n        project.apply_code_action(buffer.clone(), action, true, cx)\n    });\n\n    // Resolving the code action does not populate its edits. In absence of\n    // edits, we must execute the given command.\n    fake_server.set_request_handler::<lsp::request::CodeLensResolve, _, _>(\n        |mut lens, _| async move {\n            let lens_command = lens.command.as_mut().expect(": "",
        ");\n            assert_eq!(lens_command.title, ": "",
        ");\n            lens_command.arguments = Some(vec![json!(": "",
        ")]);\n            Ok(lens)\n        },\n    );\n\n    // While executing the command, the language server sends the editor\n    // a `workspaceEdit` request.\n    fake_server\n        .set_request_handler::<lsp::request::ExecuteCommand, _, _>({\n            let fake = fake_server.clone();\n            move |params, _| {\n                assert_eq!(params.command, ": "",
        ");\n                let fake = fake.clone();\n                async move {\n                    fake.server\n                        .request::<lsp::request::ApplyWorkspaceEdit>(\n                            lsp::ApplyWorkspaceEditParams {\n                                label: None,\n                                edit: lsp::WorkspaceEdit {\n                                    changes: Some(\n                                        [(\n                                            lsp::Uri::from_file_path(path!(": "",
        ")).unwrap(),\n                                            vec![lsp::TextEdit {\n                                                range: lsp::Range::new(\n                                                    lsp::Position::new(0, 0),\n                                                    lsp::Position::new(0, 0),\n                                                ),\n                                                new_text: ": "",
        ".into(),\n                                            }],\n                                        )]\n                                        .into_iter()\n                                        .collect(),\n                                    ),\n                                    ..lsp::WorkspaceEdit::default()\n                                },\n                            },\n                        )\n                        .await\n                        .into_response()\n                        .unwrap();\n                    Ok(Some(json!(null)))\n                }\n            }\n        })\n        .next()\n        .await;\n\n    // Applying the code lens command returns a project transaction containing the edits\n    // sent by the language server in its `workspaceEdit` request.\n    let transaction = apply.await.unwrap();\n    assert!(transaction.0.contains_key(&buffer));\n    buffer.update(cx, |buffer, cx| {\n        assert_eq!(buffer.text(), ": "",
        ");\n        buffer.undo(cx);\n        assert_eq!(buffer.text(), ": "",
        ");\n    });\n\n    let actions_after_edits = cx\n        .update_window(*workspace, |_, window, cx| {\n            project.code_actions(&buffer, anchor..anchor, window, cx)\n        })\n        .unwrap()\n        .await\n        .unwrap();\n    assert_eq!(\n        actions, actions_after_edits,\n        ": "",
        "\n    );\n\n    let _responses =\n        fake_server.set_request_handler::<lsp::request::CodeLensRequest, _, _>(|_, _| async move {\n            panic!(": "",
        ");\n        });\n    editor.update_in(cx, |editor, window, cx| {\n        editor.select_all(&SelectAll, window, cx);\n    });\n    cx.executor().run_until_parked();\n    let new_actions = cx\n        .update_window(*workspace, |_, window, cx| {\n            project.code_actions(&buffer, anchor..anchor, window, cx)\n        })\n        .unwrap()\n        .await\n        .unwrap();\n    assert_eq!(\n        actions, new_actions,\n        ": "",
        "\n    );\n}\n\n#[gpui::test]\nasync fn test_editor_restore_data_different_in_panes(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let fs = FakeFs::new(cx.executor());\n    let main_text = r#": "",
        "#;\n    let lib_text = ": "",
        ";\n    fs.insert_tree(\n        path!(": "",
        ": lib_text,\n            ": "",
        ": main_text,\n        }),\n    )\n    .await;\n\n    let project = Project::test(fs, [path!(": "",
        ").as_ref()], cx).await;\n    let (workspace, cx) =\n        cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n    let worktree_id = workspace.update(cx, |workspace, cx| {\n        workspace.project().update(cx, |project, cx| {\n            project.worktrees(cx).next().unwrap().read(cx).id()\n        })\n    });\n\n    let expected_ranges = vec![\n        Point::new(0, 0)..Point::new(0, 0),\n        Point::new(1, 0)..Point::new(1, 1),\n        Point::new(2, 0)..Point::new(2, 2),\n        Point::new(3, 0)..Point::new(3, 3),\n    ];\n\n    let pane_1 = workspace.update(cx, |workspace, _| workspace.active_pane().clone());\n    let editor_1 = workspace\n        .update_in(cx, |workspace, window, cx| {\n            workspace.open_path(\n                (worktree_id, rel_path(": "",
        ")),\n                Some(pane_1.downgrade()),\n                true,\n                window,\n                cx,\n            )\n        })\n        .unwrap()\n        .await\n        .downcast::<Editor>()\n        .unwrap();\n    pane_1.update(cx, |pane, cx| {\n        let open_editor = pane.active_item().unwrap().downcast::<Editor>().unwrap();\n        open_editor.update(cx, |editor, cx| {\n            assert_eq!(\n                editor.display_text(cx),\n                main_text,\n                ": "",
        ",\n            );\n            assert_eq!(\n                editor\n                    .selections\n                    .all::<Point>(&editor.display_snapshot(cx))\n                    .into_iter()\n                    .map(|s| s.range())\n                    .collect::<Vec<_>>(),\n                vec![Point::zero()..Point::zero()],\n                ": "",
        ",\n            );\n        })\n    });\n    editor_1.update_in(cx, |editor, window, cx| {\n        editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n            s.select_ranges(expected_ranges.clone());\n        });\n    });\n\n    let pane_2 = workspace.update_in(cx, |workspace, window, cx| {\n        workspace.split_pane(pane_1.clone(), SplitDirection::Right, window, cx)\n    });\n    let editor_2 = workspace\n        .update_in(cx, |workspace, window, cx| {\n            workspace.open_path(\n                (worktree_id, rel_path(": "",
        ")),\n                Some(pane_2.downgrade()),\n                true,\n                window,\n                cx,\n            )\n        })\n        .unwrap()\n        .await\n        .downcast::<Editor>()\n        .unwrap();\n    pane_2.update(cx, |pane, cx| {\n        let open_editor = pane.active_item().unwrap().downcast::<Editor>().unwrap();\n        open_editor.update(cx, |editor, cx| {\n            assert_eq!(\n                editor.display_text(cx),\n                main_text,\n                ": "",
        ",\n            );\n        })\n    });\n\n    editor_2.update_in(cx, |editor, window, cx| {\n        editor.fold_ranges(expected_ranges.clone(), false, window, cx);\n    });\n\n    let _other_editor_1 = workspace\n        .update_in(cx, |workspace, window, cx| {\n            workspace.open_path(\n                (worktree_id, rel_path(": "",
        ")),\n                Some(pane_1.downgrade()),\n                true,\n                window,\n                cx,\n            )\n        })\n        .unwrap()\n        .await\n        .downcast::<Editor>()\n        .unwrap();\n    pane_1\n        .update_in(cx, |pane, window, cx| {\n            pane.close_other_items(&CloseOtherItems::default(), None, window, cx)\n        })\n        .await\n        .unwrap();\n    drop(editor_1);\n    pane_1.update(cx, |pane, cx| {\n        pane.active_item()\n            .unwrap()\n            .downcast::<Editor>()\n            .unwrap()\n            .update(cx, |editor, cx| {\n                assert_eq!(\n                    editor.display_text(cx),\n                    lib_text,\n                    ": "",
        ",\n                );\n            });\n        assert_eq!(pane.items().count(), 1, ": "",
        ");\n    });\n\n    let _other_editor_2 = workspace\n        .update_in(cx, |workspace, window, cx| {\n            workspace.open_path(\n                (worktree_id, rel_path(": "",
        ")),\n                Some(pane_2.downgrade()),\n                true,\n                window,\n                cx,\n            )\n        })\n        .unwrap()\n        .await\n        .downcast::<Editor>()\n        .unwrap();\n    pane_2\n        .update_in(cx, |pane, window, cx| {\n            pane.close_other_items(&CloseOtherItems::default(), None, window, cx)\n        })\n        .await\n        .unwrap();\n    drop(editor_2);\n    pane_2.update(cx, |pane, cx| {\n        let open_editor = pane.active_item().unwrap().downcast::<Editor>().unwrap();\n        open_editor.update(cx, |editor, cx| {\n            assert_eq!(\n                editor.display_text(cx),\n                lib_text,\n                ": "",
        ",\n            );\n        });\n        assert_eq!(\n            pane.items().count(),\n            1,\n            ": "",
        ",\n        );\n    });\n\n    let _editor_1_reopened = workspace\n        .update_in(cx, |workspace, window, cx| {\n            workspace.open_path(\n                (worktree_id, rel_path(": "",
        ")),\n                Some(pane_1.downgrade()),\n                true,\n                window,\n                cx,\n            )\n        })\n        .unwrap()\n        .await\n        .downcast::<Editor>()\n        .unwrap();\n    let _editor_2_reopened = workspace\n        .update_in(cx, |workspace, window, cx| {\n            workspace.open_path(\n                (worktree_id, rel_path(": "",
        ")),\n                Some(pane_2.downgrade()),\n                true,\n                window,\n                cx,\n            )\n        })\n        .unwrap()\n        .await\n        .downcast::<Editor>()\n        .unwrap();\n    pane_1.update(cx, |pane, cx| {\n        let open_editor = pane.active_item().unwrap().downcast::<Editor>().unwrap();\n        open_editor.update(cx, |editor, cx| {\n            assert_eq!(\n                editor.display_text(cx),\n                main_text,\n                ": "",
        ",\n            );\n            assert_eq!(\n                editor\n                    .selections\n                    .all::<Point>(&editor.display_snapshot(cx))\n                    .into_iter()\n                    .map(|s| s.range())\n                    .collect::<Vec<_>>(),\n                expected_ranges,\n                ": "",
        ",\n            );\n        })\n    });\n    pane_2.update(cx, |pane, cx| {\n        let open_editor = pane.active_item().unwrap().downcast::<Editor>().unwrap();\n        open_editor.update(cx, |editor, cx| {\n            assert_eq!(\n                editor.display_text(cx),\n                r#": "",
        "#,\n                ": "",
        ",\n            );\n        })\n    });\n}\n\n#[gpui::test]\nasync fn test_editor_does_not_restore_data_when_turned_off(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let fs = FakeFs::new(cx.executor());\n    let main_text = r#": "",
        ").as_ref()], cx).await;\n    let (workspace, cx) =\n        cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n    let worktree_id = workspace.update(cx, |workspace, cx| {\n        workspace.project().update(cx, |project, cx| {\n            project.worktrees(cx).next().unwrap().read(cx).id()\n        })\n    });\n\n    let pane = workspace.update(cx, |workspace, _| workspace.active_pane().clone());\n    let editor = workspace\n        .update_in(cx, |workspace, window, cx| {\n            workspace.open_path(\n                (worktree_id, rel_path(": "",
        ")),\n                Some(pane.downgrade()),\n                true,\n                window,\n                cx,\n            )\n        })\n        .unwrap()\n        .await\n        .downcast::<Editor>()\n        .unwrap();\n    pane.update(cx, |pane, cx| {\n        let open_editor = pane.active_item().unwrap().downcast::<Editor>().unwrap();\n        open_editor.update(cx, |editor, cx| {\n            assert_eq!(\n                editor.display_text(cx),\n                main_text,\n                ": "",
        ",\n            );\n        })\n    });\n    editor.update_in(cx, |editor, window, cx| {\n        editor.fold_ranges(vec![Point::new(0, 0)..Point::new(0, 0)], false, window, cx);\n    });\n\n    cx.update_global(|store: &mut SettingsStore, cx| {\n        store.update_user_settings(cx, |s| {\n            s.workspace.restore_on_file_reopen = Some(false);\n        });\n    });\n    editor.update_in(cx, |editor, window, cx| {\n        editor.fold_ranges(\n            vec![\n                Point::new(1, 0)..Point::new(1, 1),\n                Point::new(2, 0)..Point::new(2, 2),\n                Point::new(3, 0)..Point::new(3, 3),\n            ],\n            false,\n            window,\n            cx,\n        );\n    });\n    pane.update_in(cx, |pane, window, cx| {\n        pane.close_all_items(&CloseAllItems::default(), window, cx)\n    })\n    .await\n    .unwrap();\n    pane.update(cx, |pane, _| {\n        assert!(pane.active_item().is_none());\n    });\n    cx.update_global(|store: &mut SettingsStore, cx| {\n        store.update_user_settings(cx, |s| {\n            s.workspace.restore_on_file_reopen = Some(true);\n        });\n    });\n\n    let _editor_reopened = workspace\n        .update_in(cx, |workspace, window, cx| {\n            workspace.open_path(\n                (worktree_id, rel_path(": "",
        "\n            );\n        })\n    });\n}\n\n#[gpui::test]\nasync fn test_hide_mouse_context_menu_on_modal_opened(cx: &mut TestAppContext) {\n    struct EmptyModalView {\n        focus_handle: gpui::FocusHandle,\n    }\n    impl EventEmitter<DismissEvent> for EmptyModalView {}\n    impl Render for EmptyModalView {\n        fn render(&mut self, _: &mut Window, _: &mut Context<'_, Self>) -> impl IntoElement {\n            div()\n        }\n    }\n    impl Focusable for EmptyModalView {\n        fn focus_handle(&self, _cx: &App) -> gpui::FocusHandle {\n            self.focus_handle.clone()\n        }\n    }\n    impl workspace::ModalView for EmptyModalView {}\n    fn new_empty_modal_view(cx: &App) -> EmptyModalView {\n        EmptyModalView {\n            focus_handle: cx.focus_handle(),\n        }\n    }\n\n    init_test(cx, |_| {});\n\n    let fs = FakeFs::new(cx.executor());\n    let project = Project::test(fs, [], cx).await;\n    let workspace = cx.add_window(|window, cx| Workspace::test_new(project.clone(), window, cx));\n    let buffer = cx.update(|cx| MultiBuffer::build_simple(": "",
        ", cx));\n    let cx = &mut VisualTestContext::from_window(*workspace.deref(), cx);\n    let editor = cx.new_window_entity(|window, cx| {\n        Editor::new(\n            EditorMode::full(),\n            buffer,\n            Some(project.clone()),\n            window,\n            cx,\n        )\n    });\n    workspace\n        .update(cx, |workspace, window, cx| {\n            workspace.add_item_to_active_pane(Box::new(editor.clone()), None, true, window, cx);\n        })\n        .unwrap();\n    editor.update_in(cx, |editor, window, cx| {\n        editor.open_context_menu(&OpenContextMenu, window, cx);\n        assert!(editor.mouse_context_menu.is_some());\n    });\n    workspace\n        .update(cx, |workspace, window, cx| {\n            workspace.toggle_modal(window, cx, |_, cx| new_empty_modal_view(cx));\n        })\n        .unwrap();\n    cx.read(|cx| {\n        assert!(editor.read(cx).mouse_context_menu.is_none());\n    });\n}\n\nfn set_linked_edit_ranges(\n    opening: (Point, Point),\n    closing: (Point, Point),\n    editor: &mut Editor,\n    cx: &mut Context<Editor>,\n) {\n    let Some((buffer, _)) = editor\n        .buffer\n        .read(cx)\n        .text_anchor_for_position(editor.selections.newest_anchor().start, cx)\n    else {\n        panic!(": "",
        ");\n    };\n    let buffer = buffer.read(cx);\n    let buffer_id = buffer.remote_id();\n    let opening_range = buffer.anchor_before(opening.0)..buffer.anchor_after(opening.1);\n    let closing_range = buffer.anchor_before(closing.0)..buffer.anchor_after(closing.1);\n    let mut linked_ranges = HashMap::default();\n    linked_ranges.insert(buffer_id, vec![(opening_range, vec![closing_range])]);\n    editor.linked_edit_ranges = LinkedEditingRanges(linked_ranges);\n}\n\n#[gpui::test]\nasync fn test_html_linked_edits_on_completion(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let fs = FakeFs::new(cx.executor());\n    fs.insert_file(path!(": "",
        "), Default::default())\n        .await;\n\n    let project = Project::test(fs, [path!(": "",
        ").as_ref()], cx).await;\n\n    let language_registry = project.read_with(cx, |project, _| project.languages().clone());\n    let html_language = Arc::new(Language::new(\n        LanguageConfig {\n            name: ": "",
        ".to_string()],\n                ..LanguageMatcher::default()\n            },\n            brackets: BracketPairConfig {\n                pairs: vec![BracketPair {\n                    start: ": "",
        ".into(),\n                    close: true,\n                    ..Default::default()\n                }],\n                ..Default::default()\n            },\n            ..Default::default()\n        },\n        Some(tree_sitter_html::LANGUAGE.into()),\n    ));\n    language_registry.add(html_language);\n    let mut fake_servers = language_registry.register_fake_lsp(\n        ": "",
        ",\n        FakeLspAdapter {\n            capabilities: lsp::ServerCapabilities {\n                completion_provider: Some(lsp::CompletionOptions {\n                    resolve_provider: Some(true),\n                    ..Default::default()\n                }),\n                ..Default::default()\n            },\n            ..Default::default()\n        },\n    );\n\n    let workspace = cx.add_window(|window, cx| Workspace::test_new(project.clone(), window, cx));\n    let cx = &mut VisualTestContext::from_window(*workspace, cx);\n\n    let worktree_id = workspace\n        .update(cx, |workspace, _window, cx| {\n            workspace.project().update(cx, |project, cx| {\n                project.worktrees(cx).next().unwrap().read(cx).id()\n            })\n        })\n        .unwrap();\n    project\n        .update(cx, |project, cx| {\n            project.open_local_buffer_with_lsp(path!(": "",
        ")), None, true, window, cx)\n        })\n        .unwrap()\n        .await\n        .unwrap()\n        .downcast::<Editor>()\n        .unwrap();\n\n    let fake_server = fake_servers.next().await.unwrap();\n    editor.update_in(cx, |editor, window, cx| {\n        editor.set_text(": "",
        ", window, cx);\n        editor.change_selections(SelectionEffects::no_scroll(), window, cx, |selections| {\n            selections.select_ranges([Point::new(0, 3)..Point::new(0, 3)]);\n        });\n        set_linked_edit_ranges(\n            (Point::new(0, 1), Point::new(0, 3)),\n            (Point::new(0, 6), Point::new(0, 8)),\n            editor,\n            cx,\n        );\n    });\n    let mut completion_handle =\n        fake_server.set_request_handler::<lsp::request::Completion, _, _>(move |_, _| async move {\n            Ok(Some(lsp::CompletionResponse::Array(vec![\n                lsp::CompletionItem {\n                    label: ": "",
        ".to_string(),\n                    text_edit: Some(lsp::CompletionTextEdit::InsertAndReplace(\n                        lsp::InsertReplaceEdit {\n                            new_text: ": "",
        ".to_string(),\n                            insert: lsp::Range::new(\n                                lsp::Position::new(0, 1),\n                                lsp::Position::new(0, 3),\n                            ),\n                            replace: lsp::Range::new(\n                                lsp::Position::new(0, 1),\n                                lsp::Position::new(0, 3),\n                            ),\n                        },\n                    )),\n                    ..Default::default()\n                },\n            ])))\n        });\n    editor.update_in(cx, |editor, window, cx| {\n        editor.show_completions(&ShowCompletions, window, cx);\n    });\n    cx.run_until_parked();\n    completion_handle.next().await.unwrap();\n    editor.update(cx, |editor, _| {\n        assert!(\n            editor.context_menu_visible(),\n            ": "",
        "\n        );\n    });\n    editor.update_in(cx, |editor, window, cx| {\n        editor.confirm_completion(&ConfirmCompletion::default(), window, cx)\n    });\n    cx.executor().run_until_parked();\n    editor.update(cx, |editor, cx| {\n        assert_eq!(editor.text(cx), ": "",
        ");\n    });\n}\n\n#[gpui::test]\nasync fn test_linked_edits_on_typing_punctuation(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n    let language = Arc::new(Language::new(\n        LanguageConfig {\n            name: ": "",
        ".into(),\n                    close: true,\n                    ..Default::default()\n                }],\n                ..Default::default()\n            },\n            linked_edit_characters: HashSet::from_iter(['.']),\n            ..Default::default()\n        },\n        Some(tree_sitter_typescript::LANGUAGE_TSX.into()),\n    ));\n    cx.update_buffer(|buffer, cx| buffer.set_language(Some(language), cx));\n\n    // Test typing > does not extend linked pair\n    cx.set_state(": "",
        ");\n    cx.update_editor(|editor, _, cx| {\n        set_linked_edit_ranges(\n            (Point::new(0, 1), Point::new(0, 4)),\n            (Point::new(0, 11), Point::new(0, 14)),\n            editor,\n            cx,\n        );\n    });\n    cx.update_editor(|editor, window, cx| {\n        editor.handle_input(": "",
        ", window, cx);\n    });\n    cx.assert_editor_state(": "",
        ");\n\n    // Test typing . do extend linked pair\n    cx.set_state(": "",
        ");\n    cx.update_editor(|editor, _, cx| {\n        set_linked_edit_ranges(\n            (Point::new(0, 1), Point::new(0, 9)),\n            (Point::new(0, 12), Point::new(0, 20)),\n            editor,\n            cx,\n        );\n    });\n    cx.update_editor(|editor, window, cx| {\n        editor.handle_input(": "",
        ");\n    cx.update_editor(|editor, _, cx| {\n        set_linked_edit_ranges(\n            (Point::new(0, 1), Point::new(0, 10)),\n            (Point::new(0, 13), Point::new(0, 21)),\n            editor,\n            cx,\n        );\n    });\n    cx.update_editor(|editor, window, cx| {\n        editor.handle_input(": "",
        ");\n}\n\n#[gpui::test]\nasync fn test_invisible_worktree_servers(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let fs = FakeFs::new(cx.executor());\n    fs.insert_tree(\n        path!(": "",
        ": {\n                ": "",
        ",\n            },\n            ": "",
        ": {\n                    ": "",
        ",\n                }\n            }\n        }),\n    )\n    .await;\n\n    let project = Project::test(fs, [path!(": "",
        ").as_ref()], cx).await;\n    let language_registry = project.read_with(cx, |project, _| project.languages().clone());\n    language_registry.add(rust_lang());\n    let _fake_servers = language_registry.register_fake_lsp(\n        ": "",
        ",\n        FakeLspAdapter {\n            ..FakeLspAdapter::default()\n        },\n    );\n    let (workspace, cx) =\n        cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n    let worktree_id = workspace.update(cx, |workspace, cx| {\n        workspace.project().update(cx, |project, cx| {\n            project.worktrees(cx).next().unwrap().read(cx).id()\n        })\n    });\n\n    let assert_language_servers_count =\n        |expected: usize, context: &str, cx: &mut VisualTestContext| {\n            project.update(cx, |project, cx| {\n                let current = project\n                    .lsp_store()\n                    .read(cx)\n                    .as_local()\n                    .unwrap()\n                    .language_servers\n                    .len();\n                assert_eq!(expected, current, ": "",
        ");\n            });\n        };\n\n    assert_language_servers_count(\n        0,\n        ": "",
        ",\n        cx,\n    );\n    let pane = workspace.update(cx, |workspace, _| workspace.active_pane().clone());\n    let main_editor = workspace\n        .update_in(cx, |workspace, window, cx| {\n            workspace.open_path(\n                (worktree_id, rel_path(": "",
        ")),\n                Some(pane.downgrade()),\n                true,\n                window,\n                cx,\n            )\n        })\n        .unwrap()\n        .await\n        .downcast::<Editor>()\n        .unwrap();\n    pane.update(cx, |pane, cx| {\n        let open_editor = pane.active_item().unwrap().downcast::<Editor>().unwrap();\n        open_editor.update(cx, |editor, cx| {\n            assert_eq!(\n                editor.display_text(cx),\n                ": "",
        ",\n                ": "",
        ",\n            );\n        });\n        assert_eq!(open_editor, main_editor);\n    });\n    assert_language_servers_count(1, ": "",
        ", cx);\n\n    let external_editor = workspace\n        .update_in(cx, |workspace, window, cx| {\n            workspace.open_abs_path(\n                PathBuf::from(": "",
        "),\n                OpenOptions::default(),\n                window,\n                cx,\n            )\n        })\n        .await\n        .expect(": "",
        ")\n        .downcast::<Editor>()\n        .expect(": "",
        ");\n    pane.update(cx, |pane, cx| {\n        let open_editor = pane.active_item().unwrap().downcast::<Editor>().unwrap();\n        open_editor.update(cx, |editor, cx| {\n            assert_eq!(\n                editor.display_text(cx),\n                ": "",
        ",\n            );\n        });\n        assert_eq!(open_editor, external_editor);\n    });\n    assert_language_servers_count(\n        1,\n        ": "",
        ",\n        cx,\n    );\n\n    pane.update_in(cx, |pane, window, cx| {\n        pane.close_active_item(&CloseActiveItem::default(), window, cx)\n    })\n    .await\n    .unwrap();\n    pane.update_in(cx, |pane, window, cx| {\n        pane.navigate_backward(&Default::default(), window, cx);\n    });\n    cx.run_until_parked();\n    pane.update(cx, |pane, cx| {\n        let open_editor = pane.active_item().unwrap().downcast::<Editor>().unwrap();\n        open_editor.update(cx, |editor, cx| {\n            assert_eq!(\n                editor.display_text(cx),\n                ": "",
        ",\n            );\n        });\n    });\n    assert_language_servers_count(\n        1,\n        ": "",
        ",\n        cx,\n    );\n\n    cx.update(|_, cx| {\n        workspace::reload(cx);\n    });\n    assert_language_servers_count(\n        1,\n        ": "",
        ",\n        cx,\n    );\n}\n\n#[gpui::test]\nasync fn test_tab_in_leading_whitespace_auto_indents_for_python(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n    let language = languages::language(": "",
        ", tree_sitter_python::LANGUAGE.into());\n    cx.update_buffer(|buffer, cx| buffer.set_language(Some(language), cx));\n\n    // test cursor move to start of each line on tab\n    // for `if`, `elif`, `else`, `while`, `with` and `for`\n    cx.set_state(indoc! {": "",
        "});\n    // test relative indent is preserved when tab\n    // for `if`, `elif`, `else`, `while`, `with` and `for`\n    cx.update_editor(|e, window, cx| e.tab(&Tab, window, cx));\n    cx.assert_editor_state(indoc! {": "",
        "});\n\n    // test cursor move to start of each line on tab\n    // for `try`, `except`, `else`, `finally`, `match` and `def`\n    cx.set_state(indoc! {": "",
        "});\n    // test relative indent is preserved when tab\n    // for `try`, `except`, `else`, `finally`, `match` and `def`\n    cx.update_editor(|e, window, cx| e.tab(&Tab, window, cx));\n    cx.assert_editor_state(indoc! {": "",
        "});\n}\n\n#[gpui::test]\nasync fn test_outdent_after_input_for_python(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n    let language = languages::language(": "",
        ", tree_sitter_python::LANGUAGE.into());\n    cx.update_buffer(|buffer, cx| buffer.set_language(Some(language), cx));\n\n    // test `else` auto outdents when typed inside `if` block\n    cx.set_state(indoc! {": "",
        "});\n    cx.update_editor(|editor, window, cx| {\n        editor.handle_input(": "",
        ", window, cx);\n    });\n    cx.assert_editor_state(indoc! {": "",
        "});\n\n    // test `except` auto outdents when typed inside `try` block\n    cx.set_state(indoc! {": "",
        "});\n\n    // test `else` auto outdents when typed inside `except` block\n    cx.set_state(indoc! {": "",
        "});\n\n    // test `finally` auto outdents when typed inside `else` block\n    cx.set_state(indoc! {": "",
        "});\n\n    // test `else` does not outdents when typed inside `except` block right after for block\n    cx.set_state(indoc! {": "",
        "});\n\n    // test `finally` auto outdents when typed inside `else` block right after for block\n    cx.set_state(indoc! {": "",
        "});\n\n    // test `except` outdents to inner ": "",
        " block\n    cx.set_state(indoc! {": "",
        "});\n\n    // test `except` outdents to outer ": "",
        "});\n\n    // test `else` stays at correct indent when typed after `for` block\n    cx.set_state(indoc! {": "",
        "});\n\n    // test does not outdent on typing after line with square brackets\n    cx.set_state(indoc! {": "",
        "});\n\n    // test does not outdent on typing : after case keyword\n    cx.set_state(indoc! {": "",
        "});\n}\n\n#[gpui::test]\nasync fn test_indent_on_newline_for_python(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n    update_test_language_settings(cx, |settings| {\n        settings.defaults.extend_comment_on_newline = Some(false);\n    });\n    let mut cx = EditorTestContext::new(cx).await;\n    let language = languages::language(": "",
        ", tree_sitter_python::LANGUAGE.into());\n    cx.update_buffer(|buffer, cx| buffer.set_language(Some(language), cx));\n\n    // test correct indent after newline on comment\n    cx.set_state(indoc! {": "",
        "});\n    cx.update_editor(|editor, window, cx| {\n        editor.newline(&Newline, window, cx);\n    });\n    cx.assert_editor_state(indoc! {": "",
        "});\n\n    // test correct indent after newline in brackets\n    cx.set_state(indoc! {": "",
        "});\n    cx.update_editor(|editor, window, cx| {\n        editor.newline(&Newline, window, cx);\n    });\n    cx.run_until_parked();\n    cx.assert_editor_state(indoc! {": "",
        "});\n\n    // do not indent after empty lists or dictionaries\n    cx.set_state(indoc! {": "",
        "});\n}\n\n#[gpui::test]\nasync fn test_tab_in_leading_whitespace_auto_indents_for_bash(cx: &mut TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n    let language = languages::language(": "",
        ", tree_sitter_bash::LANGUAGE.into());\n    cx.update_buffer(|buffer, cx| buffer.set_language(Some(language), cx));\n\n    // test cursor move to start of each line on tab\n    // for `if`, `elif`, `else`, `while`, `for`, `case` and `function`\n    cx.set_state(indoc! {": "",
        "$item\\\" ]; do\n        ˇ            if [ \\\"$value\\\" -gt 10 ]; then\n        ˇ                continue\n        ˇ            elif [ \\\"$value\\\" -lt 0 ]; then\n        ˇ                break\n        ˇ            else\n        ˇ                echo \\\"$item\\\"\n        ˇ            fi\n        ˇ        done\n        ˇ    done\n        ˇ}\n    ": "",
        "\n        function main() {\n            ˇfor item in $items; do\n                ˇwhile [ -n \\\"$item\\\" ]; do\n                    ˇif [ \\\"$value\\\" -gt 10 ]; then\n                        ˇcontinue\n                    ˇelif [ \\\"$value\\\" -lt 0 ]; then\n                        ˇbreak\n                    ˇelse\n                        ˇecho \\\"$item\\\"\n                    ˇfi\n                ˇdone\n            ˇdone\n        ˇ}\n    ": "",
        "\n        function main() {\n                ˇfor item in $items; do\n                    ˇwhile [ -n \\\"$item\\\" ]; do\n                        ˇif [ \\\"$value\\\" -gt 10 ]; then\n                            ˇcontinue\n                        ˇelif [ \\\"$value\\\" -lt 0 ]; then\n                            ˇbreak\n                        ˇelse\n                            ˇecho \\\"$item\\\"\n                        ˇfi\n                    ˇdone\n                ˇdone\n            ˇ}\n    ": "",
        "\n        function handle() {\n        ˇ    case \\\"$1\\\" in\n        ˇ        start)\n        ˇ            echo \\\"a\\\"\n        ˇ            ;;\n        ˇ        stop)\n        ˇ            echo \\\"b\\\"\n        ˇ            ;;\n        ˇ        *)\n        ˇ            echo \\\"c\\\"\n        ˇ            ;;\n        ˇ    esac\n        ˇ}\n    ": "",
        "\n        function handle() {\n            ˇcase \\\"$1\\\" in\n                ˇstart)\n                    ˇecho \\\"a\\\"\n                    ˇ;;\n                ˇstop)\n                    ˇecho \\\"b\\\"\n                    ˇ;;\n                ˇ*)\n                    ˇecho \\\"c\\\"\n                    ˇ;;\n            ˇesac\n        ˇ}\n    ": "",
        "bash": "",
        "\n        function main() {\n        ˇ    for item in $items; do\n        ˇ        while [ -n \\\"$item\\\" ]; do\n        ˇ            if [ \\\"$value\\\" -gt 10 ]; then\n        ˇ                continue\n        ˇ            elif [ \\\"$value\\\" -lt 0 ]; then\n        ˇ                break\n        ˇ            else\n        ˇ                echo \\\"$item\\\"\n        ˇ            fi\n        ˇ        done\n        ˇ    done\n        ˇ}\n    ": "",
        "\n        function main() {\n        #ˇ    for item in $items; do\n        #ˇ        while [ -n \\\"$item\\\" ]; do\n        #ˇ            if [ \\\"$value\\\" -gt 10 ]; then\n        #ˇ                continue\n        #ˇ            elif [ \\\"$value\\\" -lt 0 ]; then\n        #ˇ                break\n        #ˇ            else\n        #ˇ                echo \\\"$item\\\"\n        #ˇ            fi\n        #ˇ        done\n        #ˇ    done\n        #ˇ}\n    ": "",
        "\n        if [ \\\"$1\\\" = \\\"test\\\" ]; then\n            echo \\\"foo bar\\\"\n            ˇ\n    ": "",
        "else": "",
        "\n        if [ \\\"$1\\\" = \\\"test\\\" ]; then\n            echo \\\"foo bar\\\"\n        elseˇ\n    ": "",
        "elif": "",
        "\n        if [ \\\"$1\\\" = \\\"test\\\" ]; then\n            echo \\\"foo bar\\\"\n        elifˇ\n    ": "",
        "\n        if [ \\\"$1\\\" = \\\"test\\\" ]; then\n            echo \\\"foo bar\\\"\n        else\n            echo \\\"bar baz\\\"\n            ˇ\n    ": "",
        "fi": "",
        "\n        if [ \\\"$1\\\" = \\\"test\\\" ]; then\n            echo \\\"foo bar\\\"\n        else\n            echo \\\"bar baz\\\"\n        fiˇ\n    ": "",
        "\n        while read line; do\n            echo \\\"$line\\\"\n            ˇ\n    ": "",
        "done": "",
        "\n        while read line; do\n            echo \\\"$line\\\"\n        doneˇ\n    ": "",
        "\n        for file in *.txt; do\n            cat \\\"$file\\\"\n            ˇ\n    ": "",
        "\n        for file in *.txt; do\n            cat \\\"$file\\\"\n        doneˇ\n    ": "",
        "\n        case \\\"$1\\\" in\n            start)\n                echo \\\"foo bar\\\"\n                ;;\n            stop)\n                echo \\\"bar baz\\\"\n                ;;\n            ˇ\n    ": "",
        "esac": "",
        "\n        case \\\"$1\\\" in\n            start)\n                echo \\\"foo bar\\\"\n                ;;\n            stop)\n                echo \\\"bar baz\\\"\n                ;;\n        esacˇ\n    ": "",
        "\n        case \\\"$1\\\" in\n            start)\n                echo \\\"foo bar\\\"\n                ;;\n                ˇ\n    ": "",
        "\n        case \\\"$1\\\" in\n            start)\n                echo \\\"foo bar\\\"\n                ;;\n            *)ˇ\n    ": "",
        "\n        if [ \\\"$1\\\" = \\\"test\\\" ]; then\n            echo \\\"outer if\\\"\n            if [ \\\"$2\\\" = \\\"debug\\\" ]; then\n                echo \\\"inner if\\\"\n                ˇ\n    ": "",
        "\n        if [ \\\"$1\\\" = \\\"test\\\" ]; then\n            echo \\\"outer if\\\"\n            if [ \\\"$2\\\" = \\\"debug\\\" ]; then\n                echo \\\"inner if\\\"\n            fiˇ\n    ": "",
        "\n        # COMMENT:ˇ\n    ": "",
        "\n        # COMMENT:\n        ˇ\n    ": "",
        "\n\n        if [ \\\"$1\\\" = \\\"test\\\" ]; thenˇ\n    ": "",
        "\n\n        if [ \\\"$1\\\" = \\\"test\\\" ]; then\n            ˇ\n    ": "",
        "\n        if [ \\\"$1\\\" = \\\"test\\\" ]; then\n        elseˇ\n    ": "",
        "\n        if [ \\\"$1\\\" = \\\"test\\\" ]; then\n        else\n            ˇ\n    ": "",
        "\n        if [ \\\"$1\\\" = \\\"test\\\" ]; then\n        elifˇ\n    ": "",
        "\n        if [ \\\"$1\\\" = \\\"test\\\" ]; then\n        elif\n            ˇ\n    ": "",
        "\n        for file in *.txt; doˇ\n    ": "",
        "\n        for file in *.txt; do\n            ˇ\n    ": "",
        "\n        case \\\"$1\\\" in\n            start)ˇ\n    ": "",
        "\n        case \\\"$1\\\" in\n            start)\n                ˇ\n    ": "",
        "\n        case \\\"$1\\\" in\n            start)\n                ;;\n            *)ˇ\n    ": "",
        "\n        case \\\"$1\\\" in\n            start)\n                ;;\n            *)\n                ˇ\n    ": "",
        "\n        function test() {ˇ}\n    ": "",
        "\n        function test() {\n            ˇ\n        }\n    ": "",
        "\n        echo \\\"test\\\";ˇ\n    ": "",
        "\n        echo \\\"test\\\";\n        ˇ\n    ": "",
        "Assert selections are {}": "",
        "Expected completions menu": "",
        "marker `|` position doesn't match": "",
        "created a singleton buffer": "",
        "Opening file should trigger diagnostic request": "",
        "should have sent the first diagnostics pull request": "",
        "Editing should trigger diagnostic request": "",
        "Cursor movement should not trigger diagnostic request": "",
        "x": "",
        "Multiple rapid edits should be debounced (got {final_requests} requests)": "",
        "\n        ˇaaaa\n        bbbb\n        cccc\n        dddd\n        eeee\n        ffff\n        gggg\n        hhhh": "",
        "Should have 3 cursors after adding 2 below": "",
        "Should have 4 cursors after moving and adding another": "",
        "ˇThis is a very long line that will be wrapped when soft wrapping is enabled\n           Second line here": "",
        "rust-analyzer": "",
        "not-rust-analyzer": "",
        "Should not be called": "",
        "Should query for colors once per editor open": "",
        "Should have an initial inlay": "",
        "Should have one pane with one editor": "",
        "Should have two panes after splitting": "",
        "Should have opened an editor in each split": "",
        "test deals with singleton buffers": "",
        "test buffese should have a file": "",
        "Both editors should be opened for the same file": "",
        "dirty": "",
        "Should query for colors once per save (deduplicated) and once per formatting after save": "",
        "After saving and closing all editors, no extra requests should be made": "",
        "Should close all editors": "",
        "Should have reopened the editor again after navigating back": "",
        "Should be an editor": "",
        "Cache should be reused on buffer close and reopen": "",
        "dirty_again": "",
        "Should query for colors once per save only, as formatting was not requested": "",
        "Should clear all colors when the server returns an empty response": "",
        "oops\\n\\nwow\\n": "",
        "oops⋯⋯wow⋯": "",
        "oop⋯wow⋯": "",
        "/root1": "",
        "one.pdf": "",
        "\n        fn outer() {\n            if condition {\n                let a = 1;\n            }\n            let b = 2;\n        }\n\n        fn another() {\n            let c = 3;\n        }\n    ": "",
        "let a = 1;": "",
        "Should have one selection": "",
        "let b = 2;": "",
        "Should have one selection after next": "",
        "Next sibling selection should be different": "",
        "Should have one selection after function next": "",
        "Should have one selection after prev": "",
        "Previous sibling selection should be different from next": "",
        "let ˇvariable = 42;\nlet another = variable + 1;\nlet result = variable * 2;": "",
        "variable": "",
        "let variable = 42;\nlet another = ˇvariable + 1;\nlet result = variable * 2;": "",
        "let variable = 42;\nlet another = variable + 1;\nlet result = ˇvariable * 2;": "",
        "Hello, «editorˇ».\\nZed is «ˇgreat» (see this link: ˇ)": "",
        "Hello, [editor]({url})ˇ.\\nZed is [great]({url})ˇ (see this link: {url}ˇ)": "",
        "Hello, editor.\\nZed is great (see this link: )\\n«{url}ˇ»": "",
        "Hello, «editorˇ».\\nZed is «ˇgreat» (see this link: ˇ)\\n{url}": "",
        "Hello, [editor]({url})ˇ.\\nZed is [great]({url})ˇ (see this link: {url}ˇ)\\n{url}": "",
        "Please visit zed's homepage: «https://www.apple.comˇ»": "",
        "Please visit zed's homepage: {url}ˇ": "",
        "Awesome": "",
        "Hello, «editorˇ».\\nZed is «ˇgreat»": "",
        "Hello, {text}ˇ.\\nZed is {text}ˇ": "",
        "// Hello, «editorˇ».\\n// Zed is «ˇgreat» (see this link: ˇ)": "",
        "// Hello, {url}ˇ.\\n// Zed is {url}ˇ (see this link: {url}ˇ)": "",
        "this will embed -> link": "",
        "this will replace -> link": "",
        "this will embed -> [link]({url})ˇ\\nthis will replace -> {url}ˇ": "",
        "/project": "",
        "# First Document\\nSome content here.": "",
        "Plain text content for second file.": "",
        "hello!": "",
        "world!": "",
        "line1\\nline2": "",
        "line1\\nline2\\nline2": "",
        "Duplicating last line upward should create duplicate above, not on same line": "",
        "Selection should move to the duplicated line": "",
        "line1\\nline2ˇ": "",
        "line2\\n": "",
        "Copying a line without trailing newline should include a newline": "",
        "line1\\nˇ": "",
        "line1\\nline2\\nˇ": "",
        "end_of_input": "",
        "ˇline1\\nline2": "",
        "line1ˇ\\nline2": "",
        "\n            ˇfn foo() {\n                let abc = 123;\n            }\n            struct Bar;\n            impl Bar {\n                fn new() -> Self {\n                    Self\n                }\n            }\n            fn baz() {\n            }\n        ": "",
        "\n            fn foo() {\n                let ˇabc = 123;\n                let x = abc + 1;\n                let y = abc + 2;\n                let z = abc + 2;\n            }\n        ": "",
        "\n            fn foo() {\n                let abc = 123;\n                let x = ˇabc + 1;\n                let y = abc + 2;\n                let z = abc + 2;\n            }\n        ": "",
        "\n            fn foo() {\n                let abc = 123;\n                let x = abc + 1;\n                let y = ˇabc + 2;\n                let z = abc + 2;\n            }\n        ": "",
        "\n            fn foo() {\n                let abc = 123;\n                let x = abc + 1;\n                let y = abc + 2;\n                let z = ˇabc + 2;\n            }\n        ": "",
        "\n        fn foo() {\n            let aˇbc = 123;\n            let x = abc + 1;\n            let y = abc + 2;\n            let z = abc + 2;\n        }\n    ": "",
        "1\\n2\\n3\\n": "",
        "\n        [EXCERPT]\n        ˇ1\n        2\n        3\n        [EXCERPT]\n        1\n        2\n        3\n        ": "",
        "\n        [EXCERPT]\n        1\n        2ˇ\n        3\n        [EXCERPT]\n        1\n        2\n        3\n        ": "",
        "\n        [EXCERPT]\n        1\n        2ˇ\n        3\n        [EXCERPT]\n        1\n        2ˇ\n        3\n        ": "",
        "\n        [EXCERPT]\n        1\n        Xˇ\n        3\n        [EXCERPT]\n        1\n        Xˇ\n        3\n        ": "",
        "\n        [EXCERPT]\n        1\n        2ˇ\n        3\n        [EXCERPT]\n        [FOLDED]\n        ": "",
        "Y": "",
        "\n        [EXCERPT]\n        1\n        Yˇ\n        3\n        [EXCERPT]\n        1\n        2\n        3\n        ": "",
        "\n        [EXCERPT]\n        [FOLDED]\n        [EXCERPT]\n        1\n        2ˇ\n        3\n        ": "",
        "Z": "",
        "\n        [EXCERPT]\n        1\n        2\n        3\n        [EXCERPT]\n        1\n        Zˇ\n        3\n        ": "",
        "\n        [EXCERPT]\n        ˇ[FOLDED]\n        [EXCERPT]\n        [FOLDED]\n        ": "",
        "W": "",
        "\n        [EXCERPT]\n        Wˇ1\n        2\n        3\n        [EXCERPT]\n        1\n        Z\n        3\n        ": ""
    },
    "zed/crates/editor/src/editor.rs": {
        "edit_prediction": "",
        "edit_prediction_conflict": "",
        "Editor Saved": "",
        "Editor Opened": "",
        "Editor Closed": "",
        "hint": "",
        "selected": "",
        "what you mostly want": "",
        "jump": "",
        "SelectionHistory::insert_transaction called with empty selections. Caller: {}": "",
        "wordwise": "",
        "done": "",
        "Providing a display map for a new editor is only intended for the minimap and might have unintended side effects otherwise!": "",
        "Rename": "",
        "Editor": "",
        "single_line": "",
        "auto_height": "",
        "minimap": "",
        "full": "",
        "jupyter": "",
        "mode": "",
        "renaming": "",
        "in_snippet": "",
        "has_previous_tabstop": "",
        "has_next_tabstop": "",
        "menu": "",
        "showing_completions": "",
        "showing_code_actions": "",
        "showing_signature_help": "",
        "extension": "",
        "multibuffer": "",
        "copilot_suggestion": "",
        "selection_mode": "",
        "end_of_input": "",
        "Failed to create buffer": "",
        "The remote instance of Zed does not support this yet. It must be upgraded to {}": "",
        "required": "",
        "the latest version": "",
        "\n                            )\n                        })\n                        .log_err();\n                });\n            }\n        }\n\n        cx.notify();\n    }\n\n    fn folds_did_change(&mut self, cx: &mut Context<Self>) {\n        use text::ToOffset as _;\n        use text::ToPoint as _;\n\n        if self.mode.is_minimap()\n            || WorkspaceSettings::get(None, cx).restore_on_startup == RestoreOnStartupBehavior::None\n        {\n            return;\n        }\n\n        if !self.buffer().read(cx).is_singleton() {\n            return;\n        }\n\n        let display_snapshot = self\n            .display_map\n            .update(cx, |display_map, cx| display_map.snapshot(cx));\n        let Some((.., snapshot)) = display_snapshot.buffer_snapshot().as_singleton() else {\n            return;\n        };\n        let inmemory_folds = display_snapshot\n            .folds_in_range(0..display_snapshot.buffer_snapshot().len())\n            .map(|fold| {\n                fold.range.start.text_anchor.to_point(&snapshot)\n                    ..fold.range.end.text_anchor.to_point(&snapshot)\n            })\n            .collect();\n        self.update_restoration_data(cx, |data| {\n            data.folds = inmemory_folds;\n        });\n\n        let Some(workspace_id) = self.workspace_serialization_id(cx) else {\n            return;\n        };\n        let background_executor = cx.background_executor().clone();\n        let editor_id = cx.entity().entity_id().as_u64() as ItemId;\n        let db_folds = display_snapshot\n            .folds_in_range(0..display_snapshot.buffer_snapshot().len())\n            .map(|fold| {\n                (\n                    fold.range.start.text_anchor.to_offset(&snapshot),\n                    fold.range.end.text_anchor.to_offset(&snapshot),\n                )\n            })\n            .collect();\n        self.serialize_folds = cx.background_spawn(async move {\n            background_executor.timer(SERIALIZATION_THROTTLE_TIME).await;\n            DB.save_editor_folds(editor_id, workspace_id, db_folds)\n                .await\n                .with_context(|| {\n                    format!(\n                        ": "",
        "\n                    )\n                })\n                .log_err();\n        });\n    }\n\n    pub fn sync_selections(\n        &mut self,\n        other: Entity<Editor>,\n        cx: &mut Context<Self>,\n    ) -> gpui::Subscription {\n        let other_selections = other.read(cx).selections.disjoint_anchors().to_vec();\n        if !other_selections.is_empty() {\n            self.selections\n                .change_with(&self.display_snapshot(cx), |selections| {\n                    selections.select_anchors(other_selections);\n                });\n        }\n\n        let other_subscription = cx.subscribe(&other, |this, other, other_evt, cx| {\n            if let EditorEvent::SelectionsChanged { local: true } = other_evt {\n                let other_selections = other.read(cx).selections.disjoint_anchors().to_vec();\n                if other_selections.is_empty() {\n                    return;\n                }\n                let snapshot = this.display_snapshot(cx);\n                this.selections.change_with(&snapshot, |selections| {\n                    selections.select_anchors(other_selections);\n                });\n            }\n        });\n\n        let this_subscription = cx.subscribe_self::<EditorEvent>(move |this, this_evt, cx| {\n            if let EditorEvent::SelectionsChanged { local: true } = this_evt {\n                let these_selections = this.selections.disjoint_anchors().to_vec();\n                if these_selections.is_empty() {\n                    return;\n                }\n                other.update(cx, |other_editor, cx| {\n                    let snapshot = other_editor.display_snapshot(cx);\n                    other_editor\n                        .selections\n                        .change_with(&snapshot, |selections| {\n                            selections.select_anchors(these_selections);\n                        })\n                });\n            }\n        });\n\n        Subscription::join(other_subscription, this_subscription)\n    }\n\n    fn unfold_buffers_with_selections(&mut self, cx: &mut Context<Self>) {\n        if self.buffer().read(cx).is_singleton() {\n            return;\n        }\n        let snapshot = self.buffer.read(cx).snapshot(cx);\n        let buffer_ids: HashSet<BufferId> = self\n            .selections\n            .disjoint_anchor_ranges()\n            .flat_map(|range| snapshot.buffer_ids_for_range(range))\n            .collect();\n        for buffer_id in buffer_ids {\n            self.unfold_buffer(buffer_id, cx);\n        }\n    }\n\n    /// Changes selections using the provided mutation function. Changes to `self.selections` occur\n    /// immediately, but when run within `transact` or `with_selection_effects_deferred` other\n    /// effects of selection change occur at the end of the transaction.\n    pub fn change_selections<R>(\n        &mut self,\n        effects: SelectionEffects,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n        change: impl FnOnce(&mut MutableSelectionsCollection<'_, '_>) -> R,\n    ) -> R {\n        let snapshot = self.display_snapshot(cx);\n        if let Some(state) = &mut self.deferred_selection_effects_state {\n            state.effects.scroll = effects.scroll.or(state.effects.scroll);\n            state.effects.completions = effects.completions;\n            state.effects.nav_history = effects.nav_history.or(state.effects.nav_history);\n            let (changed, result) = self.selections.change_with(&snapshot, change);\n            state.changed |= changed;\n            return result;\n        }\n        let mut state = DeferredSelectionEffectsState {\n            changed: false,\n            effects,\n            old_cursor_position: self.selections.newest_anchor().head(),\n            history_entry: SelectionHistoryEntry {\n                selections: self.selections.disjoint_anchors_arc(),\n                select_next_state: self.select_next_state.clone(),\n                select_prev_state: self.select_prev_state.clone(),\n                add_selections_state: self.add_selections_state.clone(),\n            },\n        };\n        let (changed, result) = self.selections.change_with(&snapshot, change);\n        state.changed = state.changed || changed;\n        if self.defer_selection_effects {\n            self.deferred_selection_effects_state = Some(state);\n        } else {\n            self.apply_selection_effects(state, window, cx);\n        }\n        result\n    }\n\n    /// Defers the effects of selection change, so that the effects of multiple calls to\n    /// `change_selections` are applied at the end. This way these intermediate states aren't added\n    /// to selection history and the state of popovers based on selection position aren't\n    /// erroneously updated.\n    pub fn with_selection_effects_deferred<R>(\n        &mut self,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n        update: impl FnOnce(&mut Self, &mut Window, &mut Context<Self>) -> R,\n    ) -> R {\n        let already_deferred = self.defer_selection_effects;\n        self.defer_selection_effects = true;\n        let result = update(self, window, cx);\n        if !already_deferred {\n            self.defer_selection_effects = false;\n            if let Some(state) = self.deferred_selection_effects_state.take() {\n                self.apply_selection_effects(state, window, cx);\n            }\n        }\n        result\n    }\n\n    fn apply_selection_effects(\n        &mut self,\n        state: DeferredSelectionEffectsState,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if state.changed {\n            self.selection_history.push(state.history_entry);\n\n            if let Some(autoscroll) = state.effects.scroll {\n                self.request_autoscroll(autoscroll, cx);\n            }\n\n            let old_cursor_position = &state.old_cursor_position;\n\n            self.selections_did_change(true, old_cursor_position, state.effects, window, cx);\n\n            if self.should_open_signature_help_automatically(old_cursor_position, cx) {\n                self.show_signature_help(&ShowSignatureHelp, window, cx);\n            }\n        }\n    }\n\n    pub fn edit<I, S, T>(&mut self, edits: I, cx: &mut Context<Self>)\n    where\n        I: IntoIterator<Item = (Range<S>, T)>,\n        S: ToOffset,\n        T: Into<Arc<str>>,\n    {\n        if self.read_only(cx) {\n            return;\n        }\n\n        self.buffer\n            .update(cx, |buffer, cx| buffer.edit(edits, None, cx));\n    }\n\n    pub fn edit_with_autoindent<I, S, T>(&mut self, edits: I, cx: &mut Context<Self>)\n    where\n        I: IntoIterator<Item = (Range<S>, T)>,\n        S: ToOffset,\n        T: Into<Arc<str>>,\n    {\n        if self.read_only(cx) {\n            return;\n        }\n\n        self.buffer.update(cx, |buffer, cx| {\n            buffer.edit(edits, self.autoindent_mode.clone(), cx)\n        });\n    }\n\n    pub fn edit_with_block_indent<I, S, T>(\n        &mut self,\n        edits: I,\n        original_indent_columns: Vec<Option<u32>>,\n        cx: &mut Context<Self>,\n    ) where\n        I: IntoIterator<Item = (Range<S>, T)>,\n        S: ToOffset,\n        T: Into<Arc<str>>,\n    {\n        if self.read_only(cx) {\n            return;\n        }\n\n        self.buffer.update(cx, |buffer, cx| {\n            buffer.edit(\n                edits,\n                Some(AutoindentMode::Block {\n                    original_indent_columns,\n                }),\n                cx,\n            )\n        });\n    }\n\n    fn select(&mut self, phase: SelectPhase, window: &mut Window, cx: &mut Context<Self>) {\n        self.hide_context_menu(window, cx);\n\n        match phase {\n            SelectPhase::Begin {\n                position,\n                add,\n                click_count,\n            } => self.begin_selection(position, add, click_count, window, cx),\n            SelectPhase::BeginColumnar {\n                position,\n                goal_column,\n                reset,\n                mode,\n            } => self.begin_columnar_selection(position, goal_column, reset, mode, window, cx),\n            SelectPhase::Extend {\n                position,\n                click_count,\n            } => self.extend_selection(position, click_count, window, cx),\n            SelectPhase::Update {\n                position,\n                goal_column,\n                scroll_delta,\n            } => self.update_selection(position, goal_column, scroll_delta, window, cx),\n            SelectPhase::End => self.end_selection(window, cx),\n        }\n    }\n\n    fn extend_selection(\n        &mut self,\n        position: DisplayPoint,\n        click_count: usize,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n        let tail = self.selections.newest::<usize>(&display_map).tail();\n        let click_count = click_count.max(match self.selections.select_mode() {\n            SelectMode::Character => 1,\n            SelectMode::Word(_) => 2,\n            SelectMode::Line(_) => 3,\n            SelectMode::All => 4,\n        });\n        self.begin_selection(position, false, click_count, window, cx);\n\n        let tail_anchor = display_map.buffer_snapshot().anchor_before(tail);\n\n        let current_selection = match self.selections.select_mode() {\n            SelectMode::Character | SelectMode::All => tail_anchor..tail_anchor,\n            SelectMode::Word(range) | SelectMode::Line(range) => range.clone(),\n        };\n\n        let mut pending_selection = self\n            .selections\n            .pending_anchor()\n            .cloned()\n            .expect(": "",
        ");\n\n        if pending_selection\n            .start\n            .cmp(&current_selection.start, display_map.buffer_snapshot())\n            == Ordering::Greater\n        {\n            pending_selection.start = current_selection.start;\n        }\n        if pending_selection\n            .end\n            .cmp(&current_selection.end, display_map.buffer_snapshot())\n            == Ordering::Less\n        {\n            pending_selection.end = current_selection.end;\n            pending_selection.reversed = true;\n        }\n\n        let mut pending_mode = self.selections.pending_mode().unwrap();\n        match &mut pending_mode {\n            SelectMode::Word(range) | SelectMode::Line(range) => *range = current_selection,\n            _ => {}\n        }\n\n        let effects = if EditorSettings::get_global(cx).autoscroll_on_clicks {\n            SelectionEffects::scroll(Autoscroll::fit())\n        } else {\n            SelectionEffects::no_scroll()\n        };\n\n        self.change_selections(effects, window, cx, |s| {\n            s.set_pending(pending_selection.clone(), pending_mode);\n            s.set_is_extending(true);\n        });\n    }\n\n    fn begin_selection(\n        &mut self,\n        position: DisplayPoint,\n        add: bool,\n        click_count: usize,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if !self.focus_handle.is_focused(window) {\n            self.last_focused_descendant = None;\n            window.focus(&self.focus_handle);\n        }\n\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n        let buffer = display_map.buffer_snapshot();\n        let position = display_map.clip_point(position, Bias::Left);\n\n        let start;\n        let end;\n        let mode;\n        let mut auto_scroll;\n        match click_count {\n            1 => {\n                start = buffer.anchor_before(position.to_point(&display_map));\n                end = start;\n                mode = SelectMode::Character;\n                auto_scroll = true;\n            }\n            2 => {\n                let position = display_map\n                    .clip_point(position, Bias::Left)\n                    .to_offset(&display_map, Bias::Left);\n                let (range, _) = buffer.surrounding_word(position, None);\n                start = buffer.anchor_before(range.start);\n                end = buffer.anchor_before(range.end);\n                mode = SelectMode::Word(start..end);\n                auto_scroll = true;\n            }\n            3 => {\n                let position = display_map\n                    .clip_point(position, Bias::Left)\n                    .to_point(&display_map);\n                let line_start = display_map.prev_line_boundary(position).0;\n                let next_line_start = buffer.clip_point(\n                    display_map.next_line_boundary(position).0 + Point::new(1, 0),\n                    Bias::Left,\n                );\n                start = buffer.anchor_before(line_start);\n                end = buffer.anchor_before(next_line_start);\n                mode = SelectMode::Line(start..end);\n                auto_scroll = true;\n            }\n            _ => {\n                start = buffer.anchor_before(0);\n                end = buffer.anchor_before(buffer.len());\n                mode = SelectMode::All;\n                auto_scroll = false;\n            }\n        }\n        auto_scroll &= EditorSettings::get_global(cx).autoscroll_on_clicks;\n\n        let point_to_delete: Option<usize> = {\n            let selected_points: Vec<Selection<Point>> =\n                self.selections.disjoint_in_range(start..end, &display_map);\n\n            if !add || click_count > 1 {\n                None\n            } else if !selected_points.is_empty() {\n                Some(selected_points[0].id)\n            } else {\n                let clicked_point_already_selected =\n                    self.selections.disjoint_anchors().iter().find(|selection| {\n                        selection.start.to_point(buffer) == start.to_point(buffer)\n                            || selection.end.to_point(buffer) == end.to_point(buffer)\n                    });\n\n                clicked_point_already_selected.map(|selection| selection.id)\n            }\n        };\n\n        let selections_count = self.selections.count();\n        let effects = if auto_scroll {\n            SelectionEffects::default()\n        } else {\n            SelectionEffects::no_scroll()\n        };\n\n        self.change_selections(effects, window, cx, |s| {\n            if let Some(point_to_delete) = point_to_delete {\n                s.delete(point_to_delete);\n\n                if selections_count == 1 {\n                    s.set_pending_anchor_range(start..end, mode);\n                }\n            } else {\n                if !add {\n                    s.clear_disjoint();\n                }\n\n                s.set_pending_anchor_range(start..end, mode);\n            }\n        });\n    }\n\n    fn begin_columnar_selection(\n        &mut self,\n        position: DisplayPoint,\n        goal_column: u32,\n        reset: bool,\n        mode: ColumnarMode,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if !self.focus_handle.is_focused(window) {\n            self.last_focused_descendant = None;\n            window.focus(&self.focus_handle);\n        }\n\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n\n        if reset {\n            let pointer_position = display_map\n                .buffer_snapshot()\n                .anchor_before(position.to_point(&display_map));\n\n            self.change_selections(\n                SelectionEffects::scroll(Autoscroll::newest()),\n                window,\n                cx,\n                |s| {\n                    s.clear_disjoint();\n                    s.set_pending_anchor_range(\n                        pointer_position..pointer_position,\n                        SelectMode::Character,\n                    );\n                },\n            );\n        };\n\n        let tail = self.selections.newest::<Point>(&display_map).tail();\n        let selection_anchor = display_map.buffer_snapshot().anchor_before(tail);\n        self.columnar_selection_state = match mode {\n            ColumnarMode::FromMouse => Some(ColumnarSelectionState::FromMouse {\n                selection_tail: selection_anchor,\n                display_point: if reset {\n                    if position.column() != goal_column {\n                        Some(DisplayPoint::new(position.row(), goal_column))\n                    } else {\n                        None\n                    }\n                } else {\n                    None\n                },\n            }),\n            ColumnarMode::FromSelection => Some(ColumnarSelectionState::FromSelection {\n                selection_tail: selection_anchor,\n            }),\n        };\n\n        if !reset {\n            self.select_columns(position, goal_column, &display_map, window, cx);\n        }\n    }\n\n    fn update_selection(\n        &mut self,\n        position: DisplayPoint,\n        goal_column: u32,\n        scroll_delta: gpui::Point<f32>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n\n        if self.columnar_selection_state.is_some() {\n            self.select_columns(position, goal_column, &display_map, window, cx);\n        } else if let Some(mut pending) = self.selections.pending_anchor().cloned() {\n            let buffer = display_map.buffer_snapshot();\n            let head;\n            let tail;\n            let mode = self.selections.pending_mode().unwrap();\n            match &mode {\n                SelectMode::Character => {\n                    head = position.to_point(&display_map);\n                    tail = pending.tail().to_point(buffer);\n                }\n                SelectMode::Word(original_range) => {\n                    let offset = display_map\n                        .clip_point(position, Bias::Left)\n                        .to_offset(&display_map, Bias::Left);\n                    let original_range = original_range.to_offset(buffer);\n\n                    let head_offset = if buffer.is_inside_word(offset, None)\n                        || original_range.contains(&offset)\n                    {\n                        let (word_range, _) = buffer.surrounding_word(offset, None);\n                        if word_range.start < original_range.start {\n                            word_range.start\n                        } else {\n                            word_range.end\n                        }\n                    } else {\n                        offset\n                    };\n\n                    head = head_offset.to_point(buffer);\n                    if head_offset <= original_range.start {\n                        tail = original_range.end.to_point(buffer);\n                    } else {\n                        tail = original_range.start.to_point(buffer);\n                    }\n                }\n                SelectMode::Line(original_range) => {\n                    let original_range = original_range.to_point(display_map.buffer_snapshot());\n\n                    let position = display_map\n                        .clip_point(position, Bias::Left)\n                        .to_point(&display_map);\n                    let line_start = display_map.prev_line_boundary(position).0;\n                    let next_line_start = buffer.clip_point(\n                        display_map.next_line_boundary(position).0 + Point::new(1, 0),\n                        Bias::Left,\n                    );\n\n                    if line_start < original_range.start {\n                        head = line_start\n                    } else {\n                        head = next_line_start\n                    }\n\n                    if head <= original_range.start {\n                        tail = original_range.end;\n                    } else {\n                        tail = original_range.start;\n                    }\n                }\n                SelectMode::All => {\n                    return;\n                }\n            };\n\n            if head < tail {\n                pending.start = buffer.anchor_before(head);\n                pending.end = buffer.anchor_before(tail);\n                pending.reversed = true;\n            } else {\n                pending.start = buffer.anchor_before(tail);\n                pending.end = buffer.anchor_before(head);\n                pending.reversed = false;\n            }\n\n            self.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n                s.set_pending(pending.clone(), mode);\n            });\n        } else {\n            log::error!(": "",
        ");\n            return;\n        }\n\n        self.apply_scroll_delta(scroll_delta, window, cx);\n        cx.notify();\n    }\n\n    fn end_selection(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n        self.columnar_selection_state.take();\n        if let Some(pending_mode) = self.selections.pending_mode() {\n            let selections = self.selections.all::<usize>(&self.display_snapshot(cx));\n            self.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n                s.select(selections);\n                s.clear_pending();\n                if s.is_extending() {\n                    s.set_is_extending(false);\n                } else {\n                    s.set_select_mode(pending_mode);\n                }\n            });\n        }\n    }\n\n    fn select_columns(\n        &mut self,\n        head: DisplayPoint,\n        goal_column: u32,\n        display_map: &DisplaySnapshot,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let Some(columnar_state) = self.columnar_selection_state.as_ref() else {\n            return;\n        };\n\n        let tail = match columnar_state {\n            ColumnarSelectionState::FromMouse {\n                selection_tail,\n                display_point,\n            } => display_point.unwrap_or_else(|| selection_tail.to_display_point(display_map)),\n            ColumnarSelectionState::FromSelection { selection_tail } => {\n                selection_tail.to_display_point(display_map)\n            }\n        };\n\n        let start_row = cmp::min(tail.row(), head.row());\n        let end_row = cmp::max(tail.row(), head.row());\n        let start_column = cmp::min(tail.column(), goal_column);\n        let end_column = cmp::max(tail.column(), goal_column);\n        let reversed = start_column < tail.column();\n\n        let selection_ranges = (start_row.0..=end_row.0)\n            .map(DisplayRow)\n            .filter_map(|row| {\n                if (matches!(columnar_state, ColumnarSelectionState::FromMouse { .. })\n                    || start_column <= display_map.line_len(row))\n                    && !display_map.is_block_line(row)\n                {\n                    let start = display_map\n                        .clip_point(DisplayPoint::new(row, start_column), Bias::Left)\n                        .to_point(display_map);\n                    let end = display_map\n                        .clip_point(DisplayPoint::new(row, end_column), Bias::Right)\n                        .to_point(display_map);\n                    if reversed {\n                        Some(end..start)\n                    } else {\n                        Some(start..end)\n                    }\n                } else {\n                    None\n                }\n            })\n            .collect::<Vec<_>>();\n        if selection_ranges.is_empty() {\n            return;\n        }\n\n        let ranges = match columnar_state {\n            ColumnarSelectionState::FromMouse { .. } => {\n                let mut non_empty_ranges = selection_ranges\n                    .iter()\n                    .filter(|selection_range| selection_range.start != selection_range.end)\n                    .peekable();\n                if non_empty_ranges.peek().is_some() {\n                    non_empty_ranges.cloned().collect()\n                } else {\n                    selection_ranges\n                }\n            }\n            _ => selection_ranges,\n        };\n\n        self.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n            s.select_ranges(ranges);\n        });\n        cx.notify();\n    }\n\n    pub fn has_non_empty_selection(&self, snapshot: &DisplaySnapshot) -> bool {\n        self.selections\n            .all_adjusted(snapshot)\n            .iter()\n            .any(|selection| !selection.is_empty())\n    }\n\n    pub fn has_pending_nonempty_selection(&self) -> bool {\n        let pending_nonempty_selection = match self.selections.pending_anchor() {\n            Some(Selection { start, end, .. }) => start != end,\n            None => false,\n        };\n\n        pending_nonempty_selection\n            || (self.columnar_selection_state.is_some()\n                && self.selections.disjoint_anchors().len() > 1)\n    }\n\n    pub fn has_pending_selection(&self) -> bool {\n        self.selections.pending_anchor().is_some() || self.columnar_selection_state.is_some()\n    }\n\n    pub fn cancel(&mut self, _: &Cancel, window: &mut Window, cx: &mut Context<Self>) {\n        self.selection_mark_mode = false;\n        self.selection_drag_state = SelectionDragState::None;\n\n        if self.dismiss_menus_and_popups(true, window, cx) {\n            cx.notify();\n            return;\n        }\n        if self.clear_expanded_diff_hunks(cx) {\n            cx.notify();\n            return;\n        }\n        if self.show_git_blame_gutter {\n            self.show_git_blame_gutter = false;\n            cx.notify();\n            return;\n        }\n\n        if self.mode.is_full()\n            && self.change_selections(Default::default(), window, cx, |s| s.try_cancel())\n        {\n            cx.notify();\n            return;\n        }\n\n        cx.propagate();\n    }\n\n    pub fn dismiss_menus_and_popups(\n        &mut self,\n        is_user_requested: bool,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> bool {\n        if self.take_rename(false, window, cx).is_some() {\n            return true;\n        }\n\n        if self.hide_blame_popover(true, cx) {\n            return true;\n        }\n\n        if hide_hover(self, cx) {\n            return true;\n        }\n\n        if self.hide_signature_help(cx, SignatureHelpHiddenBy::Escape) {\n            return true;\n        }\n\n        if self.hide_context_menu(window, cx).is_some() {\n            return true;\n        }\n\n        if self.mouse_context_menu.take().is_some() {\n            return true;\n        }\n\n        if is_user_requested && self.discard_edit_prediction(true, cx) {\n            return true;\n        }\n\n        if self.snippet_stack.pop().is_some() {\n            return true;\n        }\n\n        if self.mode.is_full() && matches!(self.active_diagnostics, ActiveDiagnostic::Group(_)) {\n            self.dismiss_diagnostics(cx);\n            return true;\n        }\n\n        false\n    }\n\n    fn linked_editing_ranges_for(\n        &self,\n        selection: Range<text::Anchor>,\n        cx: &App,\n    ) -> Option<HashMap<Entity<Buffer>, Vec<Range<text::Anchor>>>> {\n        if self.linked_edit_ranges.is_empty() {\n            return None;\n        }\n        let ((base_range, linked_ranges), buffer_snapshot, buffer) =\n            selection.end.buffer_id.and_then(|end_buffer_id| {\n                if selection.start.buffer_id != Some(end_buffer_id) {\n                    return None;\n                }\n                let buffer = self.buffer.read(cx).buffer(end_buffer_id)?;\n                let snapshot = buffer.read(cx).snapshot();\n                self.linked_edit_ranges\n                    .get(end_buffer_id, selection.start..selection.end, &snapshot)\n                    .map(|ranges| (ranges, snapshot, buffer))\n            })?;\n        use text::ToOffset as TO;\n        // find offset from the start of current range to current cursor position\n        let start_byte_offset = TO::to_offset(&base_range.start, &buffer_snapshot);\n\n        let start_offset = TO::to_offset(&selection.start, &buffer_snapshot);\n        let start_difference = start_offset - start_byte_offset;\n        let end_offset = TO::to_offset(&selection.end, &buffer_snapshot);\n        let end_difference = end_offset - start_byte_offset;\n        // Current range has associated linked ranges.\n        let mut linked_edits = HashMap::<_, Vec<_>>::default();\n        for range in linked_ranges.iter() {\n            let start_offset = TO::to_offset(&range.start, &buffer_snapshot);\n            let end_offset = start_offset + end_difference;\n            let start_offset = start_offset + start_difference;\n            if start_offset > buffer_snapshot.len() || end_offset > buffer_snapshot.len() {\n                continue;\n            }\n            if self.selections.disjoint_anchor_ranges().any(|s| {\n                if s.start.buffer_id != selection.start.buffer_id\n                    || s.end.buffer_id != selection.end.buffer_id\n                {\n                    return false;\n                }\n                TO::to_offset(&s.start.text_anchor, &buffer_snapshot) <= end_offset\n                    && TO::to_offset(&s.end.text_anchor, &buffer_snapshot) >= start_offset\n            }) {\n                continue;\n            }\n            let start = buffer_snapshot.anchor_after(start_offset);\n            let end = buffer_snapshot.anchor_after(end_offset);\n            linked_edits\n                .entry(buffer.clone())\n                .or_default()\n                .push(start..end);\n        }\n        Some(linked_edits)\n    }\n\n    pub fn handle_input(&mut self, text: &str, window: &mut Window, cx: &mut Context<Self>) {\n        let text: Arc<str> = text.into();\n\n        if self.read_only(cx) {\n            return;\n        }\n\n        self.hide_mouse_cursor(HideMouseCursorOrigin::TypingAction, cx);\n\n        self.unfold_buffers_with_selections(cx);\n\n        let selections = self.selections.all_adjusted(&self.display_snapshot(cx));\n        let mut bracket_inserted = false;\n        let mut edits = Vec::new();\n        let mut linked_edits = HashMap::<_, Vec<_>>::default();\n        let mut new_selections = Vec::with_capacity(selections.len());\n        let mut new_autoclose_regions = Vec::new();\n        let snapshot = self.buffer.read(cx).read(cx);\n        let mut clear_linked_edit_ranges = false;\n\n        for (selection, autoclose_region) in\n            self.selections_with_autoclose_regions(selections, &snapshot)\n        {\n            if let Some(scope) = snapshot.language_scope_at(selection.head()) {\n                // Determine if the inserted text matches the opening or closing\n                // bracket of any of this language's bracket pairs.\n                let mut bracket_pair = None;\n                let mut is_bracket_pair_start = false;\n                let mut is_bracket_pair_end = false;\n                if !text.is_empty() {\n                    let mut bracket_pair_matching_end = None;\n                    // `text` can be empty when a user is using IME (e.g. Chinese Wubi Simplified)\n                    //  and they are removing the character that triggered IME popup.\n                    for (pair, enabled) in scope.brackets() {\n                        if !pair.close && !pair.surround {\n                            continue;\n                        }\n\n                        if enabled && pair.start.ends_with(text.as_ref()) {\n                            let prefix_len = pair.start.len() - text.len();\n                            let preceding_text_matches_prefix = prefix_len == 0\n                                || (selection.start.column >= (prefix_len as u32)\n                                    && snapshot.contains_str_at(\n                                        Point::new(\n                                            selection.start.row,\n                                            selection.start.column - (prefix_len as u32),\n                                        ),\n                                        &pair.start[..prefix_len],\n                                    ));\n                            if preceding_text_matches_prefix {\n                                bracket_pair = Some(pair.clone());\n                                is_bracket_pair_start = true;\n                                break;\n                            }\n                        }\n                        if pair.end.as_str() == text.as_ref() && bracket_pair_matching_end.is_none()\n                        {\n                            // take first bracket pair matching end, but don't break in case a later bracket\n                            // pair matches start\n                            bracket_pair_matching_end = Some(pair.clone());\n                        }\n                    }\n                    if let Some(end) = bracket_pair_matching_end\n                        && bracket_pair.is_none()\n                    {\n                        bracket_pair = Some(end);\n                        is_bracket_pair_end = true;\n                    }\n                }\n\n                if let Some(bracket_pair) = bracket_pair {\n                    let snapshot_settings = snapshot.language_settings_at(selection.start, cx);\n                    let autoclose = self.use_autoclose && snapshot_settings.use_autoclose;\n                    let auto_surround =\n                        self.use_auto_surround && snapshot_settings.use_auto_surround;\n                    if selection.is_empty() {\n                        if is_bracket_pair_start {\n                            // If the inserted text is a suffix of an opening bracket and the\n                            // selection is preceded by the rest of the opening bracket, then\n                            // insert the closing bracket.\n                            let following_text_allows_autoclose = snapshot\n                                .chars_at(selection.start)\n                                .next()\n                                .is_none_or(|c| scope.should_autoclose_before(c));\n\n                            let preceding_text_allows_autoclose = selection.start.column == 0\n                                || snapshot\n                                    .reversed_chars_at(selection.start)\n                                    .next()\n                                    .is_none_or(|c| {\n                                        bracket_pair.start != bracket_pair.end\n                                            || !snapshot\n                                                .char_classifier_at(selection.start)\n                                                .is_word(c)\n                                    });\n\n                            let is_closing_quote = if bracket_pair.end == bracket_pair.start\n                                && bracket_pair.start.len() == 1\n                            {\n                                let target = bracket_pair.start.chars().next().unwrap();\n                                let current_line_count = snapshot\n                                    .reversed_chars_at(selection.start)\n                                    .take_while(|&c| c != '\\n')\n                                    .filter(|&c| c == target)\n                                    .count();\n                                current_line_count % 2 == 1\n                            } else {\n                                false\n                            };\n\n                            if autoclose\n                                && bracket_pair.close\n                                && following_text_allows_autoclose\n                                && preceding_text_allows_autoclose\n                                && !is_closing_quote\n                            {\n                                let anchor = snapshot.anchor_before(selection.end);\n                                new_selections.push((selection.map(|_| anchor), text.len()));\n                                new_autoclose_regions.push((\n                                    anchor,\n                                    text.len(),\n                                    selection.id,\n                                    bracket_pair.clone(),\n                                ));\n                                edits.push((\n                                    selection.range(),\n                                    format!(": "",
        ", text, bracket_pair.end).into(),\n                                ));\n                                bracket_inserted = true;\n                                continue;\n                            }\n                        }\n\n                        if let Some(region) = autoclose_region {\n                            // If the selection is followed by an auto-inserted closing bracket,\n                            // then don't insert that closing bracket again; just move the selection\n                            // past the closing bracket.\n                            let should_skip = selection.end == region.range.end.to_point(&snapshot)\n                                && text.as_ref() == region.pair.end.as_str()\n                                && snapshot.contains_str_at(region.range.end, text.as_ref());\n                            if should_skip {\n                                let anchor = snapshot.anchor_after(selection.end);\n                                new_selections\n                                    .push((selection.map(|_| anchor), region.pair.end.len()));\n                                continue;\n                            }\n                        }\n\n                        let always_treat_brackets_as_autoclosed = snapshot\n                            .language_settings_at(selection.start, cx)\n                            .always_treat_brackets_as_autoclosed;\n                        if always_treat_brackets_as_autoclosed\n                            && is_bracket_pair_end\n                            && snapshot.contains_str_at(selection.end, text.as_ref())\n                        {\n                            // Otherwise, when `always_treat_brackets_as_autoclosed` is set to `true\n                            // and the inserted text is a closing bracket and the selection is followed\n                            // by the closing bracket then move the selection past the closing bracket.\n                            let anchor = snapshot.anchor_after(selection.end);\n                            new_selections.push((selection.map(|_| anchor), text.len()));\n                            continue;\n                        }\n                    }\n                    // If an opening bracket is 1 character long and is typed while\n                    // text is selected, then surround that text with the bracket pair.\n                    else if auto_surround\n                        && bracket_pair.surround\n                        && is_bracket_pair_start\n                        && bracket_pair.start.chars().count() == 1\n                    {\n                        edits.push((selection.start..selection.start, text.clone()));\n                        edits.push((\n                            selection.end..selection.end,\n                            bracket_pair.end.as_str().into(),\n                        ));\n                        bracket_inserted = true;\n                        new_selections.push((\n                            Selection {\n                                id: selection.id,\n                                start: snapshot.anchor_after(selection.start),\n                                end: snapshot.anchor_before(selection.end),\n                                reversed: selection.reversed,\n                                goal: selection.goal,\n                            },\n                            0,\n                        ));\n                        continue;\n                    }\n                }\n            }\n\n            if self.auto_replace_emoji_shortcode\n                && selection.is_empty()\n                && text.as_ref().ends_with(':')\n                && let Some(possible_emoji_short_code) =\n                    Self::find_possible_emoji_shortcode_at_position(&snapshot, selection.start)\n                && !possible_emoji_short_code.is_empty()\n                && let Some(emoji) = emojis::get_by_shortcode(&possible_emoji_short_code)\n            {\n                let emoji_shortcode_start = Point::new(\n                    selection.start.row,\n                    selection.start.column - possible_emoji_short_code.len() as u32 - 1,\n                );\n\n                // Remove shortcode from buffer\n                edits.push((\n                    emoji_shortcode_start..selection.start,\n                    ": "",
        ".to_string().into(),\n                ));\n                new_selections.push((\n                    Selection {\n                        id: selection.id,\n                        start: snapshot.anchor_after(emoji_shortcode_start),\n                        end: snapshot.anchor_before(selection.start),\n                        reversed: selection.reversed,\n                        goal: selection.goal,\n                    },\n                    0,\n                ));\n\n                // Insert emoji\n                let selection_start_anchor = snapshot.anchor_after(selection.start);\n                new_selections.push((selection.map(|_| selection_start_anchor), 0));\n                edits.push((selection.start..selection.end, emoji.to_string().into()));\n\n                continue;\n            }\n\n            // If not handling any auto-close operation, then just replace the selected\n            // text with the given input and move the selection to the end of the\n            // newly inserted text.\n            let anchor = snapshot.anchor_after(selection.end);\n            if !self.linked_edit_ranges.is_empty() {\n                let start_anchor = snapshot.anchor_before(selection.start);\n\n                let is_word_char = text.chars().next().is_none_or(|char| {\n                    let classifier = snapshot\n                        .char_classifier_at(start_anchor.to_offset(&snapshot))\n                        .scope_context(Some(CharScopeContext::LinkedEdit));\n                    classifier.is_word(char)\n                });\n\n                if is_word_char {\n                    if let Some(ranges) = self\n                        .linked_editing_ranges_for(start_anchor.text_anchor..anchor.text_anchor, cx)\n                    {\n                        for (buffer, edits) in ranges {\n                            linked_edits\n                                .entry(buffer.clone())\n                                .or_default()\n                                .extend(edits.into_iter().map(|range| (range, text.clone())));\n                        }\n                    }\n                } else {\n                    clear_linked_edit_ranges = true;\n                }\n            }\n\n            new_selections.push((selection.map(|_| anchor), 0));\n            edits.push((selection.start..selection.end, text.clone()));\n        }\n\n        drop(snapshot);\n\n        self.transact(window, cx, |this, window, cx| {\n            if clear_linked_edit_ranges {\n                this.linked_edit_ranges.clear();\n            }\n            let initial_buffer_versions =\n                jsx_tag_auto_close::construct_initial_buffer_versions_map(this, &edits, cx);\n\n            this.buffer.update(cx, |buffer, cx| {\n                buffer.edit(edits, this.autoindent_mode.clone(), cx);\n            });\n            for (buffer, edits) in linked_edits {\n                buffer.update(cx, |buffer, cx| {\n                    let snapshot = buffer.snapshot();\n                    let edits = edits\n                        .into_iter()\n                        .map(|(range, text)| {\n                            use text::ToPoint as TP;\n                            let end_point = TP::to_point(&range.end, &snapshot);\n                            let start_point = TP::to_point(&range.start, &snapshot);\n                            (start_point..end_point, text)\n                        })\n                        .sorted_by_key(|(range, _)| range.start);\n                    buffer.edit(edits, None, cx);\n                })\n            }\n            let new_anchor_selections = new_selections.iter().map(|e| &e.0);\n            let new_selection_deltas = new_selections.iter().map(|e| e.1);\n            let map = this.display_map.update(cx, |map, cx| map.snapshot(cx));\n            let new_selections =\n                resolve_selections_wrapping_blocks::<usize, _>(new_anchor_selections, &map)\n                    .zip(new_selection_deltas)\n                    .map(|(selection, delta)| Selection {\n                        id: selection.id,\n                        start: selection.start + delta,\n                        end: selection.end + delta,\n                        reversed: selection.reversed,\n                        goal: SelectionGoal::None,\n                    })\n                    .collect::<Vec<_>>();\n\n            let mut i = 0;\n            for (position, delta, selection_id, pair) in new_autoclose_regions {\n                let position = position.to_offset(map.buffer_snapshot()) + delta;\n                let start = map.buffer_snapshot().anchor_before(position);\n                let end = map.buffer_snapshot().anchor_after(position);\n                while let Some(existing_state) = this.autoclose_regions.get(i) {\n                    match existing_state\n                        .range\n                        .start\n                        .cmp(&start, map.buffer_snapshot())\n                    {\n                        Ordering::Less => i += 1,\n                        Ordering::Greater => break,\n                        Ordering::Equal => {\n                            match end.cmp(&existing_state.range.end, map.buffer_snapshot()) {\n                                Ordering::Less => i += 1,\n                                Ordering::Equal => break,\n                                Ordering::Greater => break,\n                            }\n                        }\n                    }\n                }\n                this.autoclose_regions.insert(\n                    i,\n                    AutocloseRegion {\n                        selection_id,\n                        range: start..end,\n                        pair,\n                    },\n                );\n            }\n\n            let had_active_edit_prediction = this.has_active_edit_prediction();\n            this.change_selections(\n                SelectionEffects::scroll(Autoscroll::fit()).completions(false),\n                window,\n                cx,\n                |s| s.select(new_selections),\n            );\n\n            if !bracket_inserted\n                && let Some(on_type_format_task) =\n                    this.trigger_on_type_formatting(text.to_string(), window, cx)\n            {\n                on_type_format_task.detach_and_log_err(cx);\n            }\n\n            let editor_settings = EditorSettings::get_global(cx);\n            if bracket_inserted\n                && (editor_settings.auto_signature_help\n                    || editor_settings.show_signature_help_after_edits)\n            {\n                this.show_signature_help(&ShowSignatureHelp, window, cx);\n            }\n\n            let trigger_in_words =\n                this.show_edit_predictions_in_menu() || !had_active_edit_prediction;\n            if this.hard_wrap.is_some() {\n                let latest: Range<Point> = this.selections.newest(&map).range();\n                if latest.is_empty()\n                    && this\n                        .buffer()\n                        .read(cx)\n                        .snapshot(cx)\n                        .line_len(MultiBufferRow(latest.start.row))\n                        == latest.start.column\n                {\n                    this.rewrap_impl(\n                        RewrapOptions {\n                            override_language_settings: true,\n                            preserve_existing_whitespace: true,\n                        },\n                        cx,\n                    )\n                }\n            }\n            this.trigger_completion_on_input(&text, trigger_in_words, window, cx);\n            refresh_linked_ranges(this, window, cx);\n            this.refresh_edit_prediction(true, false, window, cx);\n            jsx_tag_auto_close::handle_from(this, initial_buffer_versions, window, cx);\n        });\n    }\n\n    fn find_possible_emoji_shortcode_at_position(\n        snapshot: &MultiBufferSnapshot,\n        position: Point,\n    ) -> Option<String> {\n        let mut chars = Vec::new();\n        let mut found_colon = false;\n        for char in snapshot.reversed_chars_at(position).take(100) {\n            // Found a possible emoji shortcode in the middle of the buffer\n            if found_colon {\n                if char.is_whitespace() {\n                    chars.reverse();\n                    return Some(chars.iter().collect());\n                }\n                // If the previous character is not a whitespace, we are in the middle of a word\n                // and we only want to complete the shortcode if the word is made up of other emojis\n                let mut containing_word = String::new();\n                for ch in snapshot\n                    .reversed_chars_at(position)\n                    .skip(chars.len() + 1)\n                    .take(100)\n                {\n                    if ch.is_whitespace() {\n                        break;\n                    }\n                    containing_word.push(ch);\n                }\n                let containing_word = containing_word.chars().rev().collect::<String>();\n                if util::word_consists_of_emojis(containing_word.as_str()) {\n                    chars.reverse();\n                    return Some(chars.iter().collect());\n                }\n            }\n\n            if char.is_whitespace() || !char.is_ascii() {\n                return None;\n            }\n            if char == ':' {\n                found_colon = true;\n            } else {\n                chars.push(char);\n            }\n        }\n        // Found a possible emoji shortcode at the beginning of the buffer\n        chars.reverse();\n        Some(chars.iter().collect())\n    }\n\n    pub fn newline(&mut self, _: &Newline, window: &mut Window, cx: &mut Context<Self>) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::TypingAction, cx);\n        self.transact(window, cx, |this, window, cx| {\n            let (edits_with_flags, selection_info): (Vec<_>, Vec<_>) = {\n                let selections = this.selections.all::<usize>(&this.display_snapshot(cx));\n                let multi_buffer = this.buffer.read(cx);\n                let buffer = multi_buffer.snapshot(cx);\n                selections\n                    .iter()\n                    .map(|selection| {\n                        let start_point = selection.start.to_point(&buffer);\n                        let mut existing_indent =\n                            buffer.indent_size_for_line(MultiBufferRow(start_point.row));\n                        existing_indent.len = cmp::min(existing_indent.len, start_point.column);\n                        let start = selection.start;\n                        let end = selection.end;\n                        let selection_is_empty = start == end;\n                        let language_scope = buffer.language_scope_at(start);\n                        let (\n                            comment_delimiter,\n                            doc_delimiter,\n                            insert_extra_newline,\n                            indent_on_newline,\n                            indent_on_extra_newline,\n                        ) = if let Some(language) = &language_scope {\n                            let mut insert_extra_newline =\n                                insert_extra_newline_brackets(&buffer, start..end, language)\n                                    || insert_extra_newline_tree_sitter(&buffer, start..end);\n\n                            // Comment extension on newline is allowed only for cursor selections\n                            let comment_delimiter = maybe!({\n                                if !selection_is_empty {\n                                    return None;\n                                }\n\n                                if !multi_buffer.language_settings(cx).extend_comment_on_newline {\n                                    return None;\n                                }\n\n                                let delimiters = language.line_comment_prefixes();\n                                let max_len_of_delimiter =\n                                    delimiters.iter().map(|delimiter| delimiter.len()).max()?;\n                                let (snapshot, range) =\n                                    buffer.buffer_line_for_row(MultiBufferRow(start_point.row))?;\n\n                                let num_of_whitespaces = snapshot\n                                    .chars_for_range(range.clone())\n                                    .take_while(|c| c.is_whitespace())\n                                    .count();\n                                let comment_candidate = snapshot\n                                    .chars_for_range(range.clone())\n                                    .skip(num_of_whitespaces)\n                                    .take(max_len_of_delimiter)\n                                    .collect::<String>();\n                                let (delimiter, trimmed_len) = delimiters\n                                    .iter()\n                                    .filter_map(|delimiter| {\n                                        let prefix = delimiter.trim_end();\n                                        if comment_candidate.starts_with(prefix) {\n                                            Some((delimiter, prefix.len()))\n                                        } else {\n                                            None\n                                        }\n                                    })\n                                    .max_by_key(|(_, len)| *len)?;\n\n                                if let Some(BlockCommentConfig {\n                                    start: block_start, ..\n                                }) = language.block_comment()\n                                {\n                                    let block_start_trimmed = block_start.trim_end();\n                                    if block_start_trimmed.starts_with(delimiter.trim_end()) {\n                                        let line_content = snapshot\n                                            .chars_for_range(range)\n                                            .skip(num_of_whitespaces)\n                                            .take(block_start_trimmed.len())\n                                            .collect::<String>();\n\n                                        if line_content.starts_with(block_start_trimmed) {\n                                            return None;\n                                        }\n                                    }\n                                }\n\n                                let cursor_is_placed_after_comment_marker =\n                                    num_of_whitespaces + trimmed_len <= start_point.column as usize;\n                                if cursor_is_placed_after_comment_marker {\n                                    Some(delimiter.clone())\n                                } else {\n                                    None\n                                }\n                            });\n\n                            let mut indent_on_newline = IndentSize::spaces(0);\n                            let mut indent_on_extra_newline = IndentSize::spaces(0);\n\n                            let doc_delimiter = maybe!({\n                                if !selection_is_empty {\n                                    return None;\n                                }\n\n                                if !multi_buffer.language_settings(cx).extend_comment_on_newline {\n                                    return None;\n                                }\n\n                                let BlockCommentConfig {\n                                    start: start_tag,\n                                    end: end_tag,\n                                    prefix: delimiter,\n                                    tab_size: len,\n                                } = language.documentation_comment()?;\n                                let is_within_block_comment = buffer\n                                    .language_scope_at(start_point)\n                                    .is_some_and(|scope| scope.override_name() == Some(": "",
        "));\n                                if !is_within_block_comment {\n                                    return None;\n                                }\n\n                                let (snapshot, range) =\n                                    buffer.buffer_line_for_row(MultiBufferRow(start_point.row))?;\n\n                                let num_of_whitespaces = snapshot\n                                    .chars_for_range(range.clone())\n                                    .take_while(|c| c.is_whitespace())\n                                    .count();\n\n                                // It is safe to use a column from MultiBufferPoint in context of a single buffer ranges, because we're only ever looking at a single line at a time.\n                                let column = start_point.column;\n                                let cursor_is_after_start_tag = {\n                                    let start_tag_len = start_tag.len();\n                                    let start_tag_line = snapshot\n                                        .chars_for_range(range.clone())\n                                        .skip(num_of_whitespaces)\n                                        .take(start_tag_len)\n                                        .collect::<String>();\n                                    if start_tag_line.starts_with(start_tag.as_ref()) {\n                                        num_of_whitespaces + start_tag_len <= column as usize\n                                    } else {\n                                        false\n                                    }\n                                };\n\n                                let cursor_is_after_delimiter = {\n                                    let delimiter_trim = delimiter.trim_end();\n                                    let delimiter_line = snapshot\n                                        .chars_for_range(range.clone())\n                                        .skip(num_of_whitespaces)\n                                        .take(delimiter_trim.len())\n                                        .collect::<String>();\n                                    if delimiter_line.starts_with(delimiter_trim) {\n                                        num_of_whitespaces + delimiter_trim.len() <= column as usize\n                                    } else {\n                                        false\n                                    }\n                                };\n\n                                let cursor_is_before_end_tag_if_exists = {\n                                    let mut char_position = 0u32;\n                                    let mut end_tag_offset = None;\n\n                                    'outer: for chunk in snapshot.text_for_range(range) {\n                                        if let Some(byte_pos) = chunk.find(&**end_tag) {\n                                            let chars_before_match =\n                                                chunk[..byte_pos].chars().count() as u32;\n                                            end_tag_offset =\n                                                Some(char_position + chars_before_match);\n                                            break 'outer;\n                                        }\n                                        char_position += chunk.chars().count() as u32;\n                                    }\n\n                                    if let Some(end_tag_offset) = end_tag_offset {\n                                        let cursor_is_before_end_tag = column <= end_tag_offset;\n                                        if cursor_is_after_start_tag {\n                                            if cursor_is_before_end_tag {\n                                                insert_extra_newline = true;\n                                            }\n                                            let cursor_is_at_start_of_end_tag =\n                                                column == end_tag_offset;\n                                            if cursor_is_at_start_of_end_tag {\n                                                indent_on_extra_newline.len = *len;\n                                            }\n                                        }\n                                        cursor_is_before_end_tag\n                                    } else {\n                                        true\n                                    }\n                                };\n\n                                if (cursor_is_after_start_tag || cursor_is_after_delimiter)\n                                    && cursor_is_before_end_tag_if_exists\n                                {\n                                    if cursor_is_after_start_tag {\n                                        indent_on_newline.len = *len;\n                                    }\n                                    Some(delimiter.clone())\n                                } else {\n                                    None\n                                }\n                            });\n\n                            (\n                                comment_delimiter,\n                                doc_delimiter,\n                                insert_extra_newline,\n                                indent_on_newline,\n                                indent_on_extra_newline,\n                            )\n                        } else {\n                            (\n                                None,\n                                None,\n                                false,\n                                IndentSize::default(),\n                                IndentSize::default(),\n                            )\n                        };\n\n                        let prevent_auto_indent = doc_delimiter.is_some();\n                        let delimiter = comment_delimiter.or(doc_delimiter);\n\n                        let capacity_for_delimiter =\n                            delimiter.as_deref().map(str::len).unwrap_or_default();\n                        let mut new_text = String::with_capacity(\n                            1 + capacity_for_delimiter\n                                + existing_indent.len as usize\n                                + indent_on_newline.len as usize\n                                + indent_on_extra_newline.len as usize,\n                        );\n                        new_text.push('\\n');\n                        new_text.extend(existing_indent.chars());\n                        new_text.extend(indent_on_newline.chars());\n\n                        if let Some(delimiter) = &delimiter {\n                            new_text.push_str(delimiter);\n                        }\n\n                        if insert_extra_newline {\n                            new_text.push('\\n');\n                            new_text.extend(existing_indent.chars());\n                            new_text.extend(indent_on_extra_newline.chars());\n                        }\n\n                        let anchor = buffer.anchor_after(end);\n                        let new_selection = selection.map(|_| anchor);\n                        (\n                            ((start..end, new_text), prevent_auto_indent),\n                            (insert_extra_newline, new_selection),\n                        )\n                    })\n                    .unzip()\n            };\n\n            let mut auto_indent_edits = Vec::new();\n            let mut edits = Vec::new();\n            for (edit, prevent_auto_indent) in edits_with_flags {\n                if prevent_auto_indent {\n                    edits.push(edit);\n                } else {\n                    auto_indent_edits.push(edit);\n                }\n            }\n            if !edits.is_empty() {\n                this.edit(edits, cx);\n            }\n            if !auto_indent_edits.is_empty() {\n                this.edit_with_autoindent(auto_indent_edits, cx);\n            }\n\n            let buffer = this.buffer.read(cx).snapshot(cx);\n            let new_selections = selection_info\n                .into_iter()\n                .map(|(extra_newline_inserted, new_selection)| {\n                    let mut cursor = new_selection.end.to_point(&buffer);\n                    if extra_newline_inserted {\n                        cursor.row -= 1;\n                        cursor.column = buffer.line_len(MultiBufferRow(cursor.row));\n                    }\n                    new_selection.map(|_| cursor)\n                })\n                .collect();\n\n            this.change_selections(Default::default(), window, cx, |s| s.select(new_selections));\n            this.refresh_edit_prediction(true, false, window, cx);\n        });\n    }\n\n    pub fn newline_above(&mut self, _: &NewlineAbove, window: &mut Window, cx: &mut Context<Self>) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::TypingAction, cx);\n\n        let buffer = self.buffer.read(cx);\n        let snapshot = buffer.snapshot(cx);\n\n        let mut edits = Vec::new();\n        let mut rows = Vec::new();\n\n        for (rows_inserted, selection) in self\n            .selections\n            .all_adjusted(&self.display_snapshot(cx))\n            .into_iter()\n            .enumerate()\n        {\n            let cursor = selection.head();\n            let row = cursor.row;\n\n            let start_of_line = snapshot.clip_point(Point::new(row, 0), Bias::Left);\n\n            let newline = ": "",
        ".to_string();\n            edits.push((start_of_line..start_of_line, newline));\n\n            rows.push(row + rows_inserted as u32);\n        }\n\n        self.transact(window, cx, |editor, window, cx| {\n            editor.edit(edits, cx);\n\n            editor.change_selections(Default::default(), window, cx, |s| {\n                let mut index = 0;\n                s.move_cursors_with(|map, _, _| {\n                    let row = rows[index];\n                    index += 1;\n\n                    let point = Point::new(row, 0);\n                    let boundary = map.next_line_boundary(point).1;\n                    let clipped = map.clip_point(boundary, Bias::Left);\n\n                    (clipped, SelectionGoal::None)\n                });\n            });\n\n            let mut indent_edits = Vec::new();\n            let multibuffer_snapshot = editor.buffer.read(cx).snapshot(cx);\n            for row in rows {\n                let indents = multibuffer_snapshot.suggested_indents(row..row + 1, cx);\n                for (row, indent) in indents {\n                    if indent.len == 0 {\n                        continue;\n                    }\n\n                    let text = match indent.kind {\n                        IndentKind::Space => ": "",
        ".repeat(indent.len as usize),\n                        IndentKind::Tab => ": "",
        ".repeat(indent.len as usize),\n                    };\n                    let point = Point::new(row.0, 0);\n                    indent_edits.push((point..point, text));\n                }\n            }\n            editor.edit(indent_edits, cx);\n        });\n    }\n\n    pub fn newline_below(&mut self, _: &NewlineBelow, window: &mut Window, cx: &mut Context<Self>) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::TypingAction, cx);\n\n        let buffer = self.buffer.read(cx);\n        let snapshot = buffer.snapshot(cx);\n\n        let mut edits = Vec::new();\n        let mut rows = Vec::new();\n        let mut rows_inserted = 0;\n\n        for selection in self.selections.all_adjusted(&self.display_snapshot(cx)) {\n            let cursor = selection.head();\n            let row = cursor.row;\n\n            let point = Point::new(row + 1, 0);\n            let start_of_line = snapshot.clip_point(point, Bias::Left);\n\n            let newline = ": "",
        ".to_string();\n            edits.push((start_of_line..start_of_line, newline));\n\n            rows_inserted += 1;\n            rows.push(row + rows_inserted);\n        }\n\n        self.transact(window, cx, |editor, window, cx| {\n            editor.edit(edits, cx);\n\n            editor.change_selections(Default::default(), window, cx, |s| {\n                let mut index = 0;\n                s.move_cursors_with(|map, _, _| {\n                    let row = rows[index];\n                    index += 1;\n\n                    let point = Point::new(row, 0);\n                    let boundary = map.next_line_boundary(point).1;\n                    let clipped = map.clip_point(boundary, Bias::Left);\n\n                    (clipped, SelectionGoal::None)\n                });\n            });\n\n            let mut indent_edits = Vec::new();\n            let multibuffer_snapshot = editor.buffer.read(cx).snapshot(cx);\n            for row in rows {\n                let indents = multibuffer_snapshot.suggested_indents(row..row + 1, cx);\n                for (row, indent) in indents {\n                    if indent.len == 0 {\n                        continue;\n                    }\n\n                    let text = match indent.kind {\n                        IndentKind::Space => ": "",
        ".repeat(indent.len as usize),\n                    };\n                    let point = Point::new(row.0, 0);\n                    indent_edits.push((point..point, text));\n                }\n            }\n            editor.edit(indent_edits, cx);\n        });\n    }\n\n    pub fn insert(&mut self, text: &str, window: &mut Window, cx: &mut Context<Self>) {\n        let autoindent = text.is_empty().not().then(|| AutoindentMode::Block {\n            original_indent_columns: Vec::new(),\n        });\n        self.insert_with_autoindent_mode(text, autoindent, window, cx);\n    }\n\n    fn insert_with_autoindent_mode(\n        &mut self,\n        text: &str,\n        autoindent_mode: Option<AutoindentMode>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if self.read_only(cx) {\n            return;\n        }\n\n        let text: Arc<str> = text.into();\n        self.transact(window, cx, |this, window, cx| {\n            let old_selections = this.selections.all_adjusted(&this.display_snapshot(cx));\n            let selection_anchors = this.buffer.update(cx, |buffer, cx| {\n                let anchors = {\n                    let snapshot = buffer.read(cx);\n                    old_selections\n                        .iter()\n                        .map(|s| {\n                            let anchor = snapshot.anchor_after(s.head());\n                            s.map(|_| anchor)\n                        })\n                        .collect::<Vec<_>>()\n                };\n                buffer.edit(\n                    old_selections\n                        .iter()\n                        .map(|s| (s.start..s.end, text.clone())),\n                    autoindent_mode,\n                    cx,\n                );\n                anchors\n            });\n\n            this.change_selections(Default::default(), window, cx, |s| {\n                s.select_anchors(selection_anchors);\n            });\n\n            cx.notify();\n        });\n    }\n\n    fn trigger_completion_on_input(\n        &mut self,\n        text: &str,\n        trigger_in_words: bool,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let completions_source = self\n            .context_menu\n            .borrow()\n            .as_ref()\n            .and_then(|menu| match menu {\n                CodeContextMenu::Completions(completions_menu) => Some(completions_menu.source),\n                CodeContextMenu::CodeActions(_) => None,\n            });\n\n        match completions_source {\n            Some(CompletionsMenuSource::Words { .. }) => {\n                self.open_or_update_completions_menu(\n                    Some(CompletionsMenuSource::Words {\n                        ignore_threshold: false,\n                    }),\n                    None,\n                    trigger_in_words,\n                    window,\n                    cx,\n                );\n            }\n            _ => self.open_or_update_completions_menu(\n                None,\n                Some(text.to_owned()).filter(|x| !x.is_empty()),\n                true,\n                window,\n                cx,\n            ),\n        }\n    }\n\n    /// If any empty selections is touching the start of its innermost containing autoclose\n    /// region, expand it to select the brackets.\n    fn select_autoclose_pair(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n        let selections = self.selections.all::<usize>(&self.display_snapshot(cx));\n        let buffer = self.buffer.read(cx).read(cx);\n        let new_selections = self\n            .selections_with_autoclose_regions(selections, &buffer)\n            .map(|(mut selection, region)| {\n                if !selection.is_empty() {\n                    return selection;\n                }\n\n                if let Some(region) = region {\n                    let mut range = region.range.to_offset(&buffer);\n                    if selection.start == range.start && range.start >= region.pair.start.len() {\n                        range.start -= region.pair.start.len();\n                        if buffer.contains_str_at(range.start, &region.pair.start)\n                            && buffer.contains_str_at(range.end, &region.pair.end)\n                        {\n                            range.end += region.pair.end.len();\n                            selection.start = range.start;\n                            selection.end = range.end;\n\n                            return selection;\n                        }\n                    }\n                }\n\n                let always_treat_brackets_as_autoclosed = buffer\n                    .language_settings_at(selection.start, cx)\n                    .always_treat_brackets_as_autoclosed;\n\n                if !always_treat_brackets_as_autoclosed {\n                    return selection;\n                }\n\n                if let Some(scope) = buffer.language_scope_at(selection.start) {\n                    for (pair, enabled) in scope.brackets() {\n                        if !enabled || !pair.close {\n                            continue;\n                        }\n\n                        if buffer.contains_str_at(selection.start, &pair.end) {\n                            let pair_start_len = pair.start.len();\n                            if buffer.contains_str_at(\n                                selection.start.saturating_sub(pair_start_len),\n                                &pair.start,\n                            ) {\n                                selection.start -= pair_start_len;\n                                selection.end += pair.end.len();\n\n                                return selection;\n                            }\n                        }\n                    }\n                }\n\n                selection\n            })\n            .collect();\n\n        drop(buffer);\n        self.change_selections(SelectionEffects::no_scroll(), window, cx, |selections| {\n            selections.select(new_selections)\n        });\n    }\n\n    /// Iterate the given selections, and for each one, find the smallest surrounding\n    /// autoclose region. This uses the ordering of the selections and the autoclose\n    /// regions to avoid repeated comparisons.\n    fn selections_with_autoclose_regions<'a, D: ToOffset + Clone>(\n        &'a self,\n        selections: impl IntoIterator<Item = Selection<D>>,\n        buffer: &'a MultiBufferSnapshot,\n    ) -> impl Iterator<Item = (Selection<D>, Option<&'a AutocloseRegion>)> {\n        let mut i = 0;\n        let mut regions = self.autoclose_regions.as_slice();\n        selections.into_iter().map(move |selection| {\n            let range = selection.start.to_offset(buffer)..selection.end.to_offset(buffer);\n\n            let mut enclosing = None;\n            while let Some(pair_state) = regions.get(i) {\n                if pair_state.range.end.to_offset(buffer) < range.start {\n                    regions = &regions[i + 1..];\n                    i = 0;\n                } else if pair_state.range.start.to_offset(buffer) > range.end {\n                    break;\n                } else {\n                    if pair_state.selection_id == selection.id {\n                        enclosing = Some(pair_state);\n                    }\n                    i += 1;\n                }\n            }\n\n            (selection, enclosing)\n        })\n    }\n\n    /// Remove any autoclose regions that no longer contain their selection or have invalid anchors in ranges.\n    fn invalidate_autoclose_regions(\n        &mut self,\n        mut selections: &[Selection<Anchor>],\n        buffer: &MultiBufferSnapshot,\n    ) {\n        self.autoclose_regions.retain(|state| {\n            if !state.range.start.is_valid(buffer) || !state.range.end.is_valid(buffer) {\n                return false;\n            }\n\n            let mut i = 0;\n            while let Some(selection) = selections.get(i) {\n                if selection.end.cmp(&state.range.start, buffer).is_lt() {\n                    selections = &selections[1..];\n                    continue;\n                }\n                if selection.start.cmp(&state.range.end, buffer).is_gt() {\n                    break;\n                }\n                if selection.id == state.selection_id {\n                    return true;\n                } else {\n                    i += 1;\n                }\n            }\n            false\n        });\n    }\n\n    fn completion_query(buffer: &MultiBufferSnapshot, position: impl ToOffset) -> Option<String> {\n        let offset = position.to_offset(buffer);\n        let (word_range, kind) =\n            buffer.surrounding_word(offset, Some(CharScopeContext::Completion));\n        if offset > word_range.start && kind == Some(CharKind::Word) {\n            Some(\n                buffer\n                    .text_for_range(word_range.start..offset)\n                    .collect::<String>(),\n            )\n        } else {\n            None\n        }\n    }\n\n    pub fn visible_excerpts(\n        &self,\n        cx: &mut Context<Editor>,\n    ) -> HashMap<ExcerptId, (Entity<Buffer>, clock::Global, Range<usize>)> {\n        let Some(project) = self.project() else {\n            return HashMap::default();\n        };\n        let project = project.read(cx);\n        let multi_buffer = self.buffer().read(cx);\n        let multi_buffer_snapshot = multi_buffer.snapshot(cx);\n        let multi_buffer_visible_start = self\n            .scroll_manager\n            .anchor()\n            .anchor\n            .to_point(&multi_buffer_snapshot);\n        let multi_buffer_visible_end = multi_buffer_snapshot.clip_point(\n            multi_buffer_visible_start\n                + Point::new(self.visible_line_count().unwrap_or(0.).ceil() as u32, 0),\n            Bias::Left,\n        );\n        multi_buffer_snapshot\n            .range_to_buffer_ranges(multi_buffer_visible_start..multi_buffer_visible_end)\n            .into_iter()\n            .filter(|(_, excerpt_visible_range, _)| !excerpt_visible_range.is_empty())\n            .filter_map(|(buffer, excerpt_visible_range, excerpt_id)| {\n                let buffer_file = project::File::from_dyn(buffer.file())?;\n                let buffer_worktree = project.worktree_for_id(buffer_file.worktree_id(cx), cx)?;\n                let worktree_entry = buffer_worktree\n                    .read(cx)\n                    .entry_for_id(buffer_file.project_entry_id()?)?;\n                if worktree_entry.is_ignored {\n                    None\n                } else {\n                    Some((\n                        excerpt_id,\n                        (\n                            multi_buffer.buffer(buffer.remote_id()).unwrap(),\n                            buffer.version().clone(),\n                            excerpt_visible_range,\n                        ),\n                    ))\n                }\n            })\n            .collect()\n    }\n\n    pub fn text_layout_details(&self, window: &mut Window) -> TextLayoutDetails {\n        TextLayoutDetails {\n            text_system: window.text_system().clone(),\n            editor_style: self.style.clone().unwrap(),\n            rem_size: window.rem_size(),\n            scroll_anchor: self.scroll_manager.anchor(),\n            visible_rows: self.visible_line_count(),\n            vertical_scroll_margin: self.scroll_manager.vertical_scroll_margin,\n        }\n    }\n\n    fn trigger_on_type_formatting(\n        &self,\n        input: String,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<Task<Result<()>>> {\n        if input.len() != 1 {\n            return None;\n        }\n\n        let project = self.project()?;\n        let position = self.selections.newest_anchor().head();\n        let (buffer, buffer_position) = self\n            .buffer\n            .read(cx)\n            .text_anchor_for_position(position, cx)?;\n\n        let settings = language_settings::language_settings(\n            buffer\n                .read(cx)\n                .language_at(buffer_position)\n                .map(|l| l.name()),\n            buffer.read(cx).file(),\n            cx,\n        );\n        if !settings.use_on_type_format {\n            return None;\n        }\n\n        // OnTypeFormatting returns a list of edits, no need to pass them between Zed instances,\n        // hence we do LSP request & edit on host side only — add formats to host's history.\n        let push_to_lsp_host_history = true;\n        // If this is not the host, append its history with new edits.\n        let push_to_client_history = project.read(cx).is_via_collab();\n\n        let on_type_formatting = project.update(cx, |project, cx| {\n            project.on_type_format(\n                buffer.clone(),\n                buffer_position,\n                input,\n                push_to_lsp_host_history,\n                cx,\n            )\n        });\n        Some(cx.spawn_in(window, async move |editor, cx| {\n            if let Some(transaction) = on_type_formatting.await? {\n                if push_to_client_history {\n                    buffer\n                        .update(cx, |buffer, _| {\n                            buffer.push_transaction(transaction, Instant::now());\n                            buffer.finalize_last_transaction();\n                        })\n                        .ok();\n                }\n                editor.update(cx, |editor, cx| {\n                    editor.refresh_document_highlights(cx);\n                })?;\n            }\n            Ok(())\n        }))\n    }\n\n    pub fn show_word_completions(\n        &mut self,\n        _: &ShowWordCompletions,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.open_or_update_completions_menu(\n            Some(CompletionsMenuSource::Words {\n                ignore_threshold: true,\n            }),\n            None,\n            false,\n            window,\n            cx,\n        );\n    }\n\n    pub fn show_completions(\n        &mut self,\n        _: &ShowCompletions,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.open_or_update_completions_menu(None, None, false, window, cx);\n    }\n\n    fn open_or_update_completions_menu(\n        &mut self,\n        requested_source: Option<CompletionsMenuSource>,\n        trigger: Option<String>,\n        trigger_in_words: bool,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if self.pending_rename.is_some() {\n            return;\n        }\n\n        let completions_source = self\n            .context_menu\n            .borrow()\n            .as_ref()\n            .and_then(|menu| match menu {\n                CodeContextMenu::Completions(completions_menu) => Some(completions_menu.source),\n                CodeContextMenu::CodeActions(_) => None,\n            });\n\n        let multibuffer_snapshot = self.buffer.read(cx).read(cx);\n\n        // Typically `start` == `end`, but with snippet tabstop choices the default choice is\n        // inserted and selected. To handle that case, the start of the selection is used so that\n        // the menu starts with all choices.\n        let position = self\n            .selections\n            .newest_anchor()\n            .start\n            .bias_right(&multibuffer_snapshot);\n        if position.diff_base_anchor.is_some() {\n            return;\n        }\n        let buffer_position = multibuffer_snapshot.anchor_before(position);\n        let Some(buffer) = buffer_position\n            .buffer_id\n            .and_then(|buffer_id| self.buffer.read(cx).buffer(buffer_id))\n        else {\n            return;\n        };\n        let buffer_snapshot = buffer.read(cx).snapshot();\n\n        let query: Option<Arc<String>> =\n            Self::completion_query(&multibuffer_snapshot, buffer_position)\n                .map(|query| query.into());\n\n        drop(multibuffer_snapshot);\n\n        // Hide the current completions menu when query is empty. Without this, cached\n        // completions from before the trigger char may be reused (#32774).\n        if query.is_none() {\n            let menu_is_open = matches!(\n                self.context_menu.borrow().as_ref(),\n                Some(CodeContextMenu::Completions(_))\n            );\n            if menu_is_open {\n                self.hide_context_menu(window, cx);\n            }\n        }\n\n        let mut ignore_word_threshold = false;\n        let provider = match requested_source {\n            Some(CompletionsMenuSource::Normal) | None => self.completion_provider.clone(),\n            Some(CompletionsMenuSource::Words { ignore_threshold }) => {\n                ignore_word_threshold = ignore_threshold;\n                None\n            }\n            Some(CompletionsMenuSource::SnippetChoices)\n            | Some(CompletionsMenuSource::SnippetsOnly) => {\n                log::error!(": "",
        ");\n                None\n            }\n        };\n\n        let sort_completions = provider\n            .as_ref()\n            .is_some_and(|provider| provider.sort_completions());\n\n        let filter_completions = provider\n            .as_ref()\n            .is_none_or(|provider| provider.filter_completions());\n\n        let was_snippets_only = matches!(\n            completions_source,\n            Some(CompletionsMenuSource::SnippetsOnly)\n        );\n\n        if let Some(CodeContextMenu::Completions(menu)) = self.context_menu.borrow_mut().as_mut() {\n            if filter_completions {\n                menu.filter(query.clone(), provider.clone(), window, cx);\n            }\n            // When `is_incomplete` is false, no need to re-query completions when the current query\n            // is a suffix of the initial query.\n            let was_complete = !menu.is_incomplete;\n            if was_complete && !was_snippets_only {\n                // If the new query is a suffix of the old query (typing more characters) and\n                // the previous result was complete, the existing completions can be filtered.\n                //\n                // Note that this is always true for snippet completions.\n                let query_matches = match (&menu.initial_query, &query) {\n                    (Some(initial_query), Some(query)) => query.starts_with(initial_query.as_ref()),\n                    (None, _) => true,\n                    _ => false,\n                };\n                if query_matches {\n                    let position_matches = if menu.initial_position == position {\n                        true\n                    } else {\n                        let snapshot = self.buffer.read(cx).read(cx);\n                        menu.initial_position.to_offset(&snapshot) == position.to_offset(&snapshot)\n                    };\n                    if position_matches {\n                        return;\n                    }\n                }\n            }\n        };\n\n        let Anchor {\n            excerpt_id: buffer_excerpt_id,\n            text_anchor: buffer_position,\n            ..\n        } = buffer_position;\n\n        let (word_replace_range, word_to_exclude) = if let (word_range, Some(CharKind::Word)) =\n            buffer_snapshot.surrounding_word(buffer_position, None)\n        {\n            let word_to_exclude = buffer_snapshot\n                .text_for_range(word_range.clone())\n                .collect::<String>();\n            (\n                buffer_snapshot.anchor_before(word_range.start)\n                    ..buffer_snapshot.anchor_after(buffer_position),\n                Some(word_to_exclude),\n            )\n        } else {\n            (buffer_position..buffer_position, None)\n        };\n\n        let language = buffer_snapshot\n            .language_at(buffer_position)\n            .map(|language| language.name());\n\n        let completion_settings = language_settings(language.clone(), buffer_snapshot.file(), cx)\n            .completions\n            .clone();\n\n        let show_completion_documentation = buffer_snapshot\n            .settings_at(buffer_position, cx)\n            .show_completion_documentation;\n\n        // The document can be large, so stay in reasonable bounds when searching for words,\n        // otherwise completion pop-up might be slow to appear.\n        const WORD_LOOKUP_ROWS: u32 = 5_000;\n        let buffer_row = text::ToPoint::to_point(&buffer_position, &buffer_snapshot).row;\n        let min_word_search = buffer_snapshot.clip_point(\n            Point::new(buffer_row.saturating_sub(WORD_LOOKUP_ROWS), 0),\n            Bias::Left,\n        );\n        let max_word_search = buffer_snapshot.clip_point(\n            Point::new(buffer_row + WORD_LOOKUP_ROWS, 0).min(buffer_snapshot.max_point()),\n            Bias::Right,\n        );\n        let word_search_range = buffer_snapshot.point_to_offset(min_word_search)\n            ..buffer_snapshot.point_to_offset(max_word_search);\n\n        let skip_digits = query\n            .as_ref()\n            .is_none_or(|query| !query.chars().any(|c| c.is_digit(10)));\n\n        let load_provider_completions = provider.as_ref().is_some_and(|provider| {\n            trigger.as_ref().is_none_or(|trigger| {\n                provider.is_completion_trigger(\n                    &buffer,\n                    position.text_anchor,\n                    trigger,\n                    trigger_in_words,\n                    completions_source.is_some(),\n                    cx,\n                )\n            })\n        });\n\n        let provider_responses = if let Some(provider) = &provider\n            && load_provider_completions\n        {\n            let trigger_character =\n                trigger.filter(|trigger| buffer.read(cx).completion_triggers().contains(trigger));\n            let completion_context = CompletionContext {\n                trigger_kind: match &trigger_character {\n                    Some(_) => CompletionTriggerKind::TRIGGER_CHARACTER,\n                    None => CompletionTriggerKind::INVOKED,\n                },\n                trigger_character,\n            };\n\n            provider.completions(\n                buffer_excerpt_id,\n                &buffer,\n                buffer_position,\n                completion_context,\n                window,\n                cx,\n            )\n        } else {\n            Task::ready(Ok(Vec::new()))\n        };\n\n        let load_word_completions = if !self.word_completions_enabled {\n            false\n        } else if requested_source\n            == Some(CompletionsMenuSource::Words {\n                ignore_threshold: true,\n            })\n        {\n            true\n        } else {\n            load_provider_completions\n                && completion_settings.words != WordsCompletionMode::Disabled\n                && (ignore_word_threshold || {\n                    let words_min_length = completion_settings.words_min_length;\n                    // check whether word has at least `words_min_length` characters\n                    let query_chars = query.iter().flat_map(|q| q.chars());\n                    query_chars.take(words_min_length).count() == words_min_length\n                })\n        };\n\n        let mut words = if load_word_completions {\n            cx.background_spawn(async move {\n                buffer_snapshot.words_in_range(WordsQuery {\n                    fuzzy_contents: None,\n                    range: word_search_range,\n                    skip_digits,\n                })\n            })\n        } else {\n            Task::ready(BTreeMap::default())\n        };\n\n        let snippets = if let Some(provider) = &provider\n            && provider.show_snippets()\n            && let Some(project) = self.project()\n        {\n            project.update(cx, |project, cx| {\n                snippet_completions(project, &buffer, buffer_position, cx)\n            })\n        } else {\n            Task::ready(Ok(CompletionResponse {\n                completions: Vec::new(),\n                display_options: Default::default(),\n                is_incomplete: false,\n            }))\n        };\n\n        let snippet_sort_order = EditorSettings::get_global(cx).snippet_sort_order;\n\n        let id = post_inc(&mut self.next_completion_id);\n        let task = cx.spawn_in(window, async move |editor, cx| {\n            let Ok(()) = editor.update(cx, |this, _| {\n                this.completion_tasks.retain(|(task_id, _)| *task_id >= id);\n            }) else {\n                return;\n            };\n\n            // TODO: Ideally completions from different sources would be selectively re-queried, so\n            // that having one source with `is_incomplete: true` doesn't cause all to be re-queried.\n            let mut completions = Vec::new();\n            let mut is_incomplete = false;\n            let mut display_options: Option<CompletionDisplayOptions> = None;\n            if let Some(provider_responses) = provider_responses.await.log_err()\n                && !provider_responses.is_empty()\n            {\n                for response in provider_responses {\n                    completions.extend(response.completions);\n                    is_incomplete = is_incomplete || response.is_incomplete;\n                    match display_options.as_mut() {\n                        None => {\n                            display_options = Some(response.display_options);\n                        }\n                        Some(options) => options.merge(&response.display_options),\n                    }\n                }\n                if completion_settings.words == WordsCompletionMode::Fallback {\n                    words = Task::ready(BTreeMap::default());\n                }\n            }\n            let display_options = display_options.unwrap_or_default();\n\n            let mut words = words.await;\n            if let Some(word_to_exclude) = &word_to_exclude {\n                words.remove(word_to_exclude);\n            }\n            for lsp_completion in &completions {\n                words.remove(&lsp_completion.new_text);\n            }\n            completions.extend(words.into_iter().map(|(word, word_range)| Completion {\n                replace_range: word_replace_range.clone(),\n                new_text: word.clone(),\n                label: CodeLabel::plain(word, None),\n                icon_path: None,\n                documentation: None,\n                source: CompletionSource::BufferWord {\n                    word_range,\n                    resolved: false,\n                },\n                insert_text_mode: Some(InsertTextMode::AS_IS),\n                confirm: None,\n            }));\n\n            completions.extend(\n                snippets\n                    .await\n                    .into_iter()\n                    .flat_map(|response| response.completions),\n            );\n\n            let menu = if completions.is_empty() {\n                None\n            } else {\n                let Ok((mut menu, matches_task)) = editor.update(cx, |editor, cx| {\n                    let languages = editor\n                        .workspace\n                        .as_ref()\n                        .and_then(|(workspace, _)| workspace.upgrade())\n                        .map(|workspace| workspace.read(cx).app_state().languages.clone());\n                    let menu = CompletionsMenu::new(\n                        id,\n                        requested_source.unwrap_or(if load_provider_completions {\n                            CompletionsMenuSource::Normal\n                        } else {\n                            CompletionsMenuSource::SnippetsOnly\n                        }),\n                        sort_completions,\n                        show_completion_documentation,\n                        position,\n                        query.clone(),\n                        is_incomplete,\n                        buffer.clone(),\n                        completions.into(),\n                        display_options,\n                        snippet_sort_order,\n                        languages,\n                        language,\n                        cx,\n                    );\n\n                    let query = if filter_completions { query } else { None };\n                    let matches_task = if let Some(query) = query {\n                        menu.do_async_filtering(query, cx)\n                    } else {\n                        Task::ready(menu.unfiltered_matches())\n                    };\n                    (menu, matches_task)\n                }) else {\n                    return;\n                };\n\n                let matches = matches_task.await;\n\n                let Ok(()) = editor.update_in(cx, |editor, window, cx| {\n                    // Newer menu already set, so exit.\n                    if let Some(CodeContextMenu::Completions(prev_menu)) =\n                        editor.context_menu.borrow().as_ref()\n                        && prev_menu.id > id\n                    {\n                        return;\n                    };\n\n                    // Only valid to take prev_menu because it the new menu is immediately set\n                    // below, or the menu is hidden.\n                    if let Some(CodeContextMenu::Completions(prev_menu)) =\n                        editor.context_menu.borrow_mut().take()\n                    {\n                        let position_matches =\n                            if prev_menu.initial_position == menu.initial_position {\n                                true\n                            } else {\n                                let snapshot = editor.buffer.read(cx).read(cx);\n                                prev_menu.initial_position.to_offset(&snapshot)\n                                    == menu.initial_position.to_offset(&snapshot)\n                            };\n                        if position_matches {\n                            // Preserve markdown cache before `set_filter_results` because it will\n                            // try to populate the documentation cache.\n                            menu.preserve_markdown_cache(prev_menu);\n                        }\n                    };\n\n                    menu.set_filter_results(matches, provider, window, cx);\n                }) else {\n                    return;\n                };\n\n                menu.visible().then_some(menu)\n            };\n\n            editor\n                .update_in(cx, |editor, window, cx| {\n                    if editor.focus_handle.is_focused(window)\n                        && let Some(menu) = menu\n                    {\n                        *editor.context_menu.borrow_mut() =\n                            Some(CodeContextMenu::Completions(menu));\n\n                        crate::hover_popover::hide_hover(editor, cx);\n                        if editor.show_edit_predictions_in_menu() {\n                            editor.update_visible_edit_prediction(window, cx);\n                        } else {\n                            editor.discard_edit_prediction(false, cx);\n                        }\n\n                        cx.notify();\n                        return;\n                    }\n\n                    if editor.completion_tasks.len() <= 1 {\n                        // If there are no more completion tasks and the last menu was empty, we should hide it.\n                        let was_hidden = editor.hide_context_menu(window, cx).is_none();\n                        // If it was already hidden and we don't show edit predictions in the menu,\n                        // we should also show the edit prediction when available.\n                        if was_hidden && editor.show_edit_predictions_in_menu() {\n                            editor.update_visible_edit_prediction(window, cx);\n                        }\n                    }\n                })\n                .ok();\n        });\n\n        self.completion_tasks.push((id, task));\n    }\n\n    #[cfg(feature = ": "",
        ")]\n    pub fn current_completions(&self) -> Option<Vec<project::Completion>> {\n        let menu = self.context_menu.borrow();\n        if let CodeContextMenu::Completions(menu) = menu.as_ref()? {\n            let completions = menu.completions.borrow();\n            Some(completions.to_vec())\n        } else {\n            None\n        }\n    }\n\n    pub fn with_completions_menu_matching_id<R>(\n        &self,\n        id: CompletionId,\n        f: impl FnOnce(Option<&mut CompletionsMenu>) -> R,\n    ) -> R {\n        let mut context_menu = self.context_menu.borrow_mut();\n        let Some(CodeContextMenu::Completions(completions_menu)) = &mut *context_menu else {\n            return f(None);\n        };\n        if completions_menu.id != id {\n            return f(None);\n        }\n        f(Some(completions_menu))\n    }\n\n    pub fn confirm_completion(\n        &mut self,\n        action: &ConfirmCompletion,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<Task<Result<()>>> {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::TypingAction, cx);\n        self.do_completion(action.item_ix, CompletionIntent::Complete, window, cx)\n    }\n\n    pub fn confirm_completion_insert(\n        &mut self,\n        _: &ConfirmCompletionInsert,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<Task<Result<()>>> {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::TypingAction, cx);\n        self.do_completion(None, CompletionIntent::CompleteWithInsert, window, cx)\n    }\n\n    pub fn confirm_completion_replace(\n        &mut self,\n        _: &ConfirmCompletionReplace,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<Task<Result<()>>> {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::TypingAction, cx);\n        self.do_completion(None, CompletionIntent::CompleteWithReplace, window, cx)\n    }\n\n    pub fn compose_completion(\n        &mut self,\n        action: &ComposeCompletion,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<Task<Result<()>>> {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::TypingAction, cx);\n        self.do_completion(action.item_ix, CompletionIntent::Compose, window, cx)\n    }\n\n    fn do_completion(\n        &mut self,\n        item_ix: Option<usize>,\n        intent: CompletionIntent,\n        window: &mut Window,\n        cx: &mut Context<Editor>,\n    ) -> Option<Task<Result<()>>> {\n        use language::ToOffset as _;\n\n        let CodeContextMenu::Completions(completions_menu) = self.hide_context_menu(window, cx)?\n        else {\n            return None;\n        };\n\n        let candidate_id = {\n            let entries = completions_menu.entries.borrow();\n            let mat = entries.get(item_ix.unwrap_or(completions_menu.selected_item))?;\n            if self.show_edit_predictions_in_menu() {\n                self.discard_edit_prediction(true, cx);\n            }\n            mat.candidate_id\n        };\n\n        let completion = completions_menu\n            .completions\n            .borrow()\n            .get(candidate_id)?\n            .clone();\n        cx.stop_propagation();\n\n        let buffer_handle = completions_menu.buffer.clone();\n\n        let CompletionEdit {\n            new_text,\n            snippet,\n            replace_range,\n        } = process_completion_for_edit(\n            &completion,\n            intent,\n            &buffer_handle,\n            &completions_menu.initial_position.text_anchor,\n            cx,\n        );\n\n        let buffer = buffer_handle.read(cx);\n        let snapshot = self.buffer.read(cx).snapshot(cx);\n        let newest_anchor = self.selections.newest_anchor();\n        let replace_range_multibuffer = {\n            let mut excerpt = snapshot.excerpt_containing(newest_anchor.range()).unwrap();\n            excerpt.map_range_from_buffer(replace_range.clone())\n        };\n        if snapshot.buffer_id_for_anchor(newest_anchor.head()) != Some(buffer.remote_id()) {\n            return None;\n        }\n\n        let old_text = buffer\n            .text_for_range(replace_range.clone())\n            .collect::<String>();\n        let lookbehind = newest_anchor\n            .start\n            .text_anchor\n            .to_offset(buffer)\n            .saturating_sub(replace_range.start);\n        let lookahead = replace_range\n            .end\n            .saturating_sub(newest_anchor.end.text_anchor.to_offset(buffer));\n        let prefix = &old_text[..old_text.len().saturating_sub(lookahead)];\n        let suffix = &old_text[lookbehind.min(old_text.len())..];\n\n        let selections = self.selections.all::<usize>(&self.display_snapshot(cx));\n        let mut ranges = Vec::new();\n        let mut linked_edits = HashMap::<_, Vec<_>>::default();\n\n        for selection in &selections {\n            let range = if selection.id == newest_anchor.id {\n                replace_range_multibuffer.clone()\n            } else {\n                let mut range = selection.range();\n\n                // if prefix is present, don't duplicate it\n                if snapshot.contains_str_at(range.start.saturating_sub(lookbehind), prefix) {\n                    range.start = range.start.saturating_sub(lookbehind);\n\n                    // if suffix is also present, mimic the newest cursor and replace it\n                    if selection.id != newest_anchor.id\n                        && snapshot.contains_str_at(range.end, suffix)\n                    {\n                        range.end += lookahead;\n                    }\n                }\n                range\n            };\n\n            ranges.push(range.clone());\n\n            if !self.linked_edit_ranges.is_empty() {\n                let start_anchor = snapshot.anchor_before(range.start);\n                let end_anchor = snapshot.anchor_after(range.end);\n                if let Some(ranges) = self\n                    .linked_editing_ranges_for(start_anchor.text_anchor..end_anchor.text_anchor, cx)\n                {\n                    for (buffer, edits) in ranges {\n                        linked_edits\n                            .entry(buffer.clone())\n                            .or_default()\n                            .extend(edits.into_iter().map(|range| (range, new_text.to_owned())));\n                    }\n                }\n            }\n        }\n\n        let common_prefix_len = old_text\n            .chars()\n            .zip(new_text.chars())\n            .take_while(|(a, b)| a == b)\n            .map(|(a, _)| a.len_utf8())\n            .sum::<usize>();\n\n        cx.emit(EditorEvent::InputHandled {\n            utf16_range_to_replace: None,\n            text: new_text[common_prefix_len..].into(),\n        });\n\n        self.transact(window, cx, |editor, window, cx| {\n            if let Some(mut snippet) = snippet {\n                snippet.text = new_text.to_string();\n                editor\n                    .insert_snippet(&ranges, snippet, window, cx)\n                    .log_err();\n            } else {\n                editor.buffer.update(cx, |multi_buffer, cx| {\n                    let auto_indent = match completion.insert_text_mode {\n                        Some(InsertTextMode::AS_IS) => None,\n                        _ => editor.autoindent_mode.clone(),\n                    };\n                    let edits = ranges.into_iter().map(|range| (range, new_text.as_str()));\n                    multi_buffer.edit(edits, auto_indent, cx);\n                });\n            }\n            for (buffer, edits) in linked_edits {\n                buffer.update(cx, |buffer, cx| {\n                    let snapshot = buffer.snapshot();\n                    let edits = edits\n                        .into_iter()\n                        .map(|(range, text)| {\n                            use text::ToPoint as TP;\n                            let end_point = TP::to_point(&range.end, &snapshot);\n                            let start_point = TP::to_point(&range.start, &snapshot);\n                            (start_point..end_point, text)\n                        })\n                        .sorted_by_key(|(range, _)| range.start);\n                    buffer.edit(edits, None, cx);\n                })\n            }\n\n            editor.refresh_edit_prediction(true, false, window, cx);\n        });\n        self.invalidate_autoclose_regions(&self.selections.disjoint_anchors_arc(), &snapshot);\n\n        let show_new_completions_on_confirm = completion\n            .confirm\n            .as_ref()\n            .is_some_and(|confirm| confirm(intent, window, cx));\n        if show_new_completions_on_confirm {\n            self.open_or_update_completions_menu(None, None, false, window, cx);\n        }\n\n        let provider = self.completion_provider.as_ref()?;\n        drop(completion);\n        let apply_edits = provider.apply_additional_edits_for_completion(\n            buffer_handle,\n            completions_menu.completions.clone(),\n            candidate_id,\n            true,\n            cx,\n        );\n\n        let editor_settings = EditorSettings::get_global(cx);\n        if editor_settings.show_signature_help_after_edits || editor_settings.auto_signature_help {\n            // After the code completion is finished, users often want to know what signatures are needed.\n            // so we should automatically call signature_help\n            self.show_signature_help(&ShowSignatureHelp, window, cx);\n        }\n\n        Some(cx.foreground_executor().spawn(async move {\n            apply_edits.await?;\n            Ok(())\n        }))\n    }\n\n    pub fn toggle_code_actions(\n        &mut self,\n        action: &ToggleCodeActions,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let quick_launch = action.quick_launch;\n        let mut context_menu = self.context_menu.borrow_mut();\n        if let Some(CodeContextMenu::CodeActions(code_actions)) = context_menu.as_ref() {\n            if code_actions.deployed_from == action.deployed_from {\n                // Toggle if we're selecting the same one\n                *context_menu = None;\n                cx.notify();\n                return;\n            } else {\n                // Otherwise, clear it and start a new one\n                *context_menu = None;\n                cx.notify();\n            }\n        }\n        drop(context_menu);\n        let snapshot = self.snapshot(window, cx);\n        let deployed_from = action.deployed_from.clone();\n        let action = action.clone();\n        self.completion_tasks.clear();\n        self.discard_edit_prediction(false, cx);\n\n        let multibuffer_point = match &action.deployed_from {\n            Some(CodeActionSource::Indicator(row)) | Some(CodeActionSource::RunMenu(row)) => {\n                DisplayPoint::new(*row, 0).to_point(&snapshot)\n            }\n            _ => self\n                .selections\n                .newest::<Point>(&snapshot.display_snapshot)\n                .head(),\n        };\n        let Some((buffer, buffer_row)) = snapshot\n            .buffer_snapshot()\n            .buffer_line_for_row(MultiBufferRow(multibuffer_point.row))\n            .and_then(|(buffer_snapshot, range)| {\n                self.buffer()\n                    .read(cx)\n                    .buffer(buffer_snapshot.remote_id())\n                    .map(|buffer| (buffer, range.start.row))\n            })\n        else {\n            return;\n        };\n        let buffer_id = buffer.read(cx).remote_id();\n        let tasks = self\n            .tasks\n            .get(&(buffer_id, buffer_row))\n            .map(|t| Arc::new(t.to_owned()));\n\n        if !self.focus_handle.is_focused(window) {\n            return;\n        }\n        let project = self.project.clone();\n\n        let code_actions_task = match deployed_from {\n            Some(CodeActionSource::RunMenu(_)) => Task::ready(None),\n            _ => self.code_actions(buffer_row, window, cx),\n        };\n\n        let runnable_task = match deployed_from {\n            Some(CodeActionSource::Indicator(_)) => Task::ready(Ok(Default::default())),\n            _ => {\n                let mut task_context_task = Task::ready(None);\n                if let Some(tasks) = &tasks\n                    && let Some(project) = project\n                {\n                    task_context_task =\n                        Self::build_tasks_context(&project, &buffer, buffer_row, tasks, cx);\n                }\n\n                cx.spawn_in(window, {\n                    let buffer = buffer.clone();\n                    async move |editor, cx| {\n                        let task_context = task_context_task.await;\n\n                        let resolved_tasks =\n                            tasks\n                                .zip(task_context.clone())\n                                .map(|(tasks, task_context)| ResolvedTasks {\n                                    templates: tasks.resolve(&task_context).collect(),\n                                    position: snapshot.buffer_snapshot().anchor_before(Point::new(\n                                        multibuffer_point.row,\n                                        tasks.column,\n                                    )),\n                                });\n                        let debug_scenarios = editor\n                            .update(cx, |editor, cx| {\n                                editor.debug_scenarios(&resolved_tasks, &buffer, cx)\n                            })?\n                            .await;\n                        anyhow::Ok((resolved_tasks, debug_scenarios, task_context))\n                    }\n                })\n            }\n        };\n\n        cx.spawn_in(window, async move |editor, cx| {\n            let (resolved_tasks, debug_scenarios, task_context) = runnable_task.await?;\n            let code_actions = code_actions_task.await;\n            let spawn_straight_away = quick_launch\n                && resolved_tasks\n                    .as_ref()\n                    .is_some_and(|tasks| tasks.templates.len() == 1)\n                && code_actions\n                    .as_ref()\n                    .is_none_or(|actions| actions.is_empty())\n                && debug_scenarios.is_empty();\n\n            editor.update_in(cx, |editor, window, cx| {\n                crate::hover_popover::hide_hover(editor, cx);\n                let actions = CodeActionContents::new(\n                    resolved_tasks,\n                    code_actions,\n                    debug_scenarios,\n                    task_context.unwrap_or_default(),\n                );\n\n                // Don't show the menu if there are no actions available\n                if actions.is_empty() {\n                    cx.notify();\n                    return Task::ready(Ok(()));\n                }\n\n                *editor.context_menu.borrow_mut() =\n                    Some(CodeContextMenu::CodeActions(CodeActionsMenu {\n                        buffer,\n                        actions,\n                        selected_item: Default::default(),\n                        scroll_handle: UniformListScrollHandle::default(),\n                        deployed_from,\n                    }));\n                cx.notify();\n                if spawn_straight_away\n                    && let Some(task) = editor.confirm_code_action(\n                        &ConfirmCodeAction { item_ix: Some(0) },\n                        window,\n                        cx,\n                    )\n                {\n                    return task;\n                }\n\n                Task::ready(Ok(()))\n            })\n        })\n        .detach_and_log_err(cx);\n    }\n\n    fn debug_scenarios(\n        &mut self,\n        resolved_tasks: &Option<ResolvedTasks>,\n        buffer: &Entity<Buffer>,\n        cx: &mut App,\n    ) -> Task<Vec<task::DebugScenario>> {\n        maybe!({\n            let project = self.project()?;\n            let dap_store = project.read(cx).dap_store();\n            let mut scenarios = vec![];\n            let resolved_tasks = resolved_tasks.as_ref()?;\n            let buffer = buffer.read(cx);\n            let language = buffer.language()?;\n            let file = buffer.file();\n            let debug_adapter = language_settings(language.name().into(), file, cx)\n                .debuggers\n                .first()\n                .map(SharedString::from)\n                .or_else(|| language.config().debuggers.first().map(SharedString::from))?;\n\n            dap_store.update(cx, |dap_store, cx| {\n                for (_, task) in &resolved_tasks.templates {\n                    let maybe_scenario = dap_store.debug_scenario_for_build_task(\n                        task.original_task().clone(),\n                        debug_adapter.clone().into(),\n                        task.display_label().to_owned().into(),\n                        cx,\n                    );\n                    scenarios.push(maybe_scenario);\n                }\n            });\n            Some(cx.background_spawn(async move {\n                futures::future::join_all(scenarios)\n                    .await\n                    .into_iter()\n                    .flatten()\n                    .collect::<Vec<_>>()\n            }))\n        })\n        .unwrap_or_else(|| Task::ready(vec![]))\n    }\n\n    fn code_actions(\n        &mut self,\n        buffer_row: u32,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Task<Option<Rc<[AvailableCodeAction]>>> {\n        let mut task = self.code_actions_task.take();\n        cx.spawn_in(window, async move |editor, cx| {\n            while let Some(prev_task) = task {\n                prev_task.await.log_err();\n                task = editor\n                    .update(cx, |this, _| this.code_actions_task.take())\n                    .ok()?;\n            }\n\n            editor\n                .update(cx, |editor, cx| {\n                    editor\n                        .available_code_actions\n                        .clone()\n                        .and_then(|(location, code_actions)| {\n                            let snapshot = location.buffer.read(cx).snapshot();\n                            let point_range = location.range.to_point(&snapshot);\n                            let point_range = point_range.start.row..=point_range.end.row;\n                            if point_range.contains(&buffer_row) {\n                                Some(code_actions)\n                            } else {\n                                None\n                            }\n                        })\n                })\n                .ok()\n                .flatten()\n        })\n    }\n\n    pub fn confirm_code_action(\n        &mut self,\n        action: &ConfirmCodeAction,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<Task<Result<()>>> {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::TypingAction, cx);\n\n        let actions_menu =\n            if let CodeContextMenu::CodeActions(menu) = self.hide_context_menu(window, cx)? {\n                menu\n            } else {\n                return None;\n            };\n\n        let action_ix = action.item_ix.unwrap_or(actions_menu.selected_item);\n        let action = actions_menu.actions.get(action_ix)?;\n        let title = action.label();\n        let buffer = actions_menu.buffer;\n        let workspace = self.workspace()?;\n\n        match action {\n            CodeActionsItem::Task(task_source_kind, resolved_task) => {\n                workspace.update(cx, |workspace, cx| {\n                    workspace.schedule_resolved_task(\n                        task_source_kind,\n                        resolved_task,\n                        false,\n                        window,\n                        cx,\n                    );\n\n                    Some(Task::ready(Ok(())))\n                })\n            }\n            CodeActionsItem::CodeAction {\n                excerpt_id,\n                action,\n                provider,\n            } => {\n                let apply_code_action =\n                    provider.apply_code_action(buffer, action, excerpt_id, true, window, cx);\n                let workspace = workspace.downgrade();\n                Some(cx.spawn_in(window, async move |editor, cx| {\n                    let project_transaction = apply_code_action.await?;\n                    Self::open_project_transaction(\n                        &editor,\n                        workspace,\n                        project_transaction,\n                        title,\n                        cx,\n                    )\n                    .await\n                }))\n            }\n            CodeActionsItem::DebugScenario(scenario) => {\n                let context = actions_menu.actions.context;\n\n                workspace.update(cx, |workspace, cx| {\n                    dap::send_telemetry(&scenario, TelemetrySpawnLocation::Gutter, cx);\n                    workspace.start_debug_session(\n                        scenario,\n                        context,\n                        Some(buffer),\n                        None,\n                        window,\n                        cx,\n                    );\n                });\n                Some(Task::ready(Ok(())))\n            }\n        }\n    }\n\n    pub async fn open_project_transaction(\n        editor: &WeakEntity<Editor>,\n        workspace: WeakEntity<Workspace>,\n        transaction: ProjectTransaction,\n        title: String,\n        cx: &mut AsyncWindowContext,\n    ) -> Result<()> {\n        let mut entries = transaction.0.into_iter().collect::<Vec<_>>();\n        cx.update(|_, cx| {\n            entries.sort_unstable_by_key(|(buffer, _)| {\n                buffer.read(cx).file().map(|f| f.path().clone())\n            });\n        })?;\n        if entries.is_empty() {\n            return Ok(());\n        }\n\n        // If the project transaction's edits are all contained within this editor, then\n        // avoid opening a new editor to display them.\n\n        if let [(buffer, transaction)] = &*entries {\n            let excerpt = editor.update(cx, |editor, cx| {\n                editor\n                    .buffer()\n                    .read(cx)\n                    .excerpt_containing(editor.selections.newest_anchor().head(), cx)\n            })?;\n            if let Some((_, excerpted_buffer, excerpt_range)) = excerpt\n                && excerpted_buffer == *buffer\n            {\n                let all_edits_within_excerpt = buffer.read_with(cx, |buffer, _| {\n                    let excerpt_range = excerpt_range.to_offset(buffer);\n                    buffer\n                        .edited_ranges_for_transaction::<usize>(transaction)\n                        .all(|range| {\n                            excerpt_range.start <= range.start && excerpt_range.end >= range.end\n                        })\n                })?;\n\n                if all_edits_within_excerpt {\n                    return Ok(());\n                }\n            }\n        }\n\n        let mut ranges_to_highlight = Vec::new();\n        let excerpt_buffer = cx.new(|cx| {\n            let mut multibuffer = MultiBuffer::new(Capability::ReadWrite).with_title(title);\n            for (buffer_handle, transaction) in &entries {\n                let edited_ranges = buffer_handle\n                    .read(cx)\n                    .edited_ranges_for_transaction::<Point>(transaction)\n                    .collect::<Vec<_>>();\n                let (ranges, _) = multibuffer.set_excerpts_for_path(\n                    PathKey::for_buffer(buffer_handle, cx),\n                    buffer_handle.clone(),\n                    edited_ranges,\n                    multibuffer_context_lines(cx),\n                    cx,\n                );\n\n                ranges_to_highlight.extend(ranges);\n            }\n            multibuffer.push_transaction(entries.iter().map(|(b, t)| (b, t)), cx);\n            multibuffer\n        })?;\n\n        workspace.update_in(cx, |workspace, window, cx| {\n            let project = workspace.project().clone();\n            let editor =\n                cx.new(|cx| Editor::for_multibuffer(excerpt_buffer, Some(project), window, cx));\n            workspace.add_item_to_active_pane(Box::new(editor.clone()), None, true, window, cx);\n            editor.update(cx, |editor, cx| {\n                editor.highlight_background::<Self>(\n                    &ranges_to_highlight,\n                    |theme| theme.colors().editor_highlighted_line_background,\n                    cx,\n                );\n            });\n        })?;\n\n        Ok(())\n    }\n\n    pub fn clear_code_action_providers(&mut self) {\n        self.code_action_providers.clear();\n        self.available_code_actions.take();\n    }\n\n    pub fn add_code_action_provider(\n        &mut self,\n        provider: Rc<dyn CodeActionProvider>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if self\n            .code_action_providers\n            .iter()\n            .any(|existing_provider| existing_provider.id() == provider.id())\n        {\n            return;\n        }\n\n        self.code_action_providers.push(provider);\n        self.refresh_code_actions(window, cx);\n    }\n\n    pub fn remove_code_action_provider(\n        &mut self,\n        id: Arc<str>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.code_action_providers\n            .retain(|provider| provider.id() != id);\n        self.refresh_code_actions(window, cx);\n    }\n\n    pub fn code_actions_enabled_for_toolbar(&self, cx: &App) -> bool {\n        !self.code_action_providers.is_empty()\n            && EditorSettings::get_global(cx).toolbar.code_actions\n    }\n\n    pub fn has_available_code_actions(&self) -> bool {\n        self.available_code_actions\n            .as_ref()\n            .is_some_and(|(_, actions)| !actions.is_empty())\n    }\n\n    fn render_inline_code_actions(\n        &self,\n        icon_size: ui::IconSize,\n        display_row: DisplayRow,\n        is_active: bool,\n        cx: &mut Context<Self>,\n    ) -> AnyElement {\n        let show_tooltip = !self.context_menu_visible();\n        IconButton::new(": "",
        ", ui::IconName::BoltFilled)\n            .icon_size(icon_size)\n            .shape(ui::IconButtonShape::Square)\n            .icon_color(ui::Color::Hidden)\n            .toggle_state(is_active)\n            .when(show_tooltip, |this| {\n                this.tooltip({\n                    let focus_handle = self.focus_handle.clone();\n                    move |_window, cx| {\n                        Tooltip::for_action_in(\n                            ": "",
        ",\n                            &ToggleCodeActions {\n                                deployed_from: None,\n                                quick_launch: false,\n                            },\n                            &focus_handle,\n                            cx,\n                        )\n                    }\n                })\n            })\n            .on_click(cx.listener(move |editor, _: &ClickEvent, window, cx| {\n                window.focus(&editor.focus_handle(cx));\n                editor.toggle_code_actions(\n                    &crate::actions::ToggleCodeActions {\n                        deployed_from: Some(crate::actions::CodeActionSource::Indicator(\n                            display_row,\n                        )),\n                        quick_launch: false,\n                    },\n                    window,\n                    cx,\n                );\n            }))\n            .into_any_element()\n    }\n\n    pub fn context_menu(&self) -> &RefCell<Option<CodeContextMenu>> {\n        &self.context_menu\n    }\n\n    fn refresh_code_actions(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n        self.code_actions_task = Some(cx.spawn_in(window, async move |this, cx| {\n            cx.background_executor()\n                .timer(CODE_ACTIONS_DEBOUNCE_TIMEOUT)\n                .await;\n\n            let (start_buffer, start, _, end, newest_selection) = this\n                .update(cx, |this, cx| {\n                    let newest_selection = this.selections.newest_anchor().clone();\n                    if newest_selection.head().diff_base_anchor.is_some() {\n                        return None;\n                    }\n                    let display_snapshot = this.display_snapshot(cx);\n                    let newest_selection_adjusted =\n                        this.selections.newest_adjusted(&display_snapshot);\n                    let buffer = this.buffer.read(cx);\n\n                    let (start_buffer, start) =\n                        buffer.text_anchor_for_position(newest_selection_adjusted.start, cx)?;\n                    let (end_buffer, end) =\n                        buffer.text_anchor_for_position(newest_selection_adjusted.end, cx)?;\n\n                    Some((start_buffer, start, end_buffer, end, newest_selection))\n                })?\n                .filter(|(start_buffer, _, end_buffer, _, _)| start_buffer == end_buffer)\n                .context(\n                    ": "",
        ",\n                )?;\n            let (providers, tasks) = this.update_in(cx, |this, window, cx| {\n                let providers = this.code_action_providers.clone();\n                let tasks = this\n                    .code_action_providers\n                    .iter()\n                    .map(|provider| provider.code_actions(&start_buffer, start..end, window, cx))\n                    .collect::<Vec<_>>();\n                (providers, tasks)\n            })?;\n\n            let mut actions = Vec::new();\n            for (provider, provider_actions) in\n                providers.into_iter().zip(future::join_all(tasks).await)\n            {\n                if let Some(provider_actions) = provider_actions.log_err() {\n                    actions.extend(provider_actions.into_iter().map(|action| {\n                        AvailableCodeAction {\n                            excerpt_id: newest_selection.start.excerpt_id,\n                            action,\n                            provider: provider.clone(),\n                        }\n                    }));\n                }\n            }\n\n            this.update(cx, |this, cx| {\n                this.available_code_actions = if actions.is_empty() {\n                    None\n                } else {\n                    Some((\n                        Location {\n                            buffer: start_buffer,\n                            range: start..end,\n                        },\n                        actions.into(),\n                    ))\n                };\n                cx.notify();\n            })\n        }));\n    }\n\n    fn start_inline_blame_timer(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n        if let Some(delay) = ProjectSettings::get_global(cx).git.inline_blame_delay() {\n            self.show_git_blame_inline = false;\n\n            self.show_git_blame_inline_delay_task =\n                Some(cx.spawn_in(window, async move |this, cx| {\n                    cx.background_executor().timer(delay).await;\n\n                    this.update(cx, |this, cx| {\n                        this.show_git_blame_inline = true;\n                        cx.notify();\n                    })\n                    .log_err();\n                }));\n        }\n    }\n\n    pub fn blame_hover(&mut self, _: &BlameHover, window: &mut Window, cx: &mut Context<Self>) {\n        let snapshot = self.snapshot(window, cx);\n        let cursor = self\n            .selections\n            .newest::<Point>(&snapshot.display_snapshot)\n            .head();\n        let Some((buffer, point, _)) = snapshot.buffer_snapshot().point_to_buffer_point(cursor)\n        else {\n            return;\n        };\n\n        let Some(blame) = self.blame.as_ref() else {\n            return;\n        };\n\n        let row_info = RowInfo {\n            buffer_id: Some(buffer.remote_id()),\n            buffer_row: Some(point.row),\n            ..Default::default()\n        };\n        let Some((buffer, blame_entry)) = blame\n            .update(cx, |blame, cx| blame.blame_for_rows(&[row_info], cx).next())\n            .flatten()\n        else {\n            return;\n        };\n\n        let anchor = self.selections.newest_anchor().head();\n        let position = self.to_pixel_point(anchor, &snapshot, window);\n        if let (Some(position), Some(last_bounds)) = (position, self.last_bounds) {\n            self.show_blame_popover(\n                buffer,\n                &blame_entry,\n                position + last_bounds.origin,\n                true,\n                cx,\n            );\n        };\n    }\n\n    fn show_blame_popover(\n        &mut self,\n        buffer: BufferId,\n        blame_entry: &BlameEntry,\n        position: gpui::Point<Pixels>,\n        ignore_timeout: bool,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(state) = &mut self.inline_blame_popover {\n            state.hide_task.take();\n        } else {\n            let blame_popover_delay = EditorSettings::get_global(cx).hover_popover_delay.0;\n            let blame_entry = blame_entry.clone();\n            let show_task = cx.spawn(async move |editor, cx| {\n                if !ignore_timeout {\n                    cx.background_executor()\n                        .timer(std::time::Duration::from_millis(blame_popover_delay))\n                        .await;\n                }\n                editor\n                    .update(cx, |editor, cx| {\n                        editor.inline_blame_popover_show_task.take();\n                        let Some(blame) = editor.blame.as_ref() else {\n                            return;\n                        };\n                        let blame = blame.read(cx);\n                        let details = blame.details_for_entry(buffer, &blame_entry);\n                        let markdown = cx.new(|cx| {\n                            Markdown::new(\n                                details\n                                    .as_ref()\n                                    .map(|message| message.message.clone())\n                                    .unwrap_or_default(),\n                                None,\n                                None,\n                                cx,\n                            )\n                        });\n                        editor.inline_blame_popover = Some(InlineBlamePopover {\n                            position,\n                            hide_task: None,\n                            popover_bounds: None,\n                            popover_state: InlineBlamePopoverState {\n                                scroll_handle: ScrollHandle::new(),\n                                commit_message: details,\n                                markdown,\n                            },\n                            keyboard_grace: ignore_timeout,\n                        });\n                        cx.notify();\n                    })\n                    .ok();\n            });\n            self.inline_blame_popover_show_task = Some(show_task);\n        }\n    }\n\n    fn hide_blame_popover(&mut self, ignore_timeout: bool, cx: &mut Context<Self>) -> bool {\n        self.inline_blame_popover_show_task.take();\n        if let Some(state) = &mut self.inline_blame_popover {\n            let hide_task = cx.spawn(async move |editor, cx| {\n                if !ignore_timeout {\n                    cx.background_executor()\n                        .timer(std::time::Duration::from_millis(100))\n                        .await;\n                }\n                editor\n                    .update(cx, |editor, cx| {\n                        editor.inline_blame_popover.take();\n                        cx.notify();\n                    })\n                    .ok();\n            });\n            state.hide_task = Some(hide_task);\n            true\n        } else {\n            false\n        }\n    }\n\n    fn refresh_document_highlights(&mut self, cx: &mut Context<Self>) -> Option<()> {\n        if self.pending_rename.is_some() {\n            return None;\n        }\n\n        let provider = self.semantics_provider.clone()?;\n        let buffer = self.buffer.read(cx);\n        let newest_selection = self.selections.newest_anchor().clone();\n        let cursor_position = newest_selection.head();\n        let (cursor_buffer, cursor_buffer_position) =\n            buffer.text_anchor_for_position(cursor_position, cx)?;\n        let (tail_buffer, tail_buffer_position) =\n            buffer.text_anchor_for_position(newest_selection.tail(), cx)?;\n        if cursor_buffer != tail_buffer {\n            return None;\n        }\n\n        let snapshot = cursor_buffer.read(cx).snapshot();\n        let (start_word_range, _) = snapshot.surrounding_word(cursor_buffer_position, None);\n        let (end_word_range, _) = snapshot.surrounding_word(tail_buffer_position, None);\n        if start_word_range != end_word_range {\n            self.document_highlights_task.take();\n            self.clear_background_highlights::<DocumentHighlightRead>(cx);\n            self.clear_background_highlights::<DocumentHighlightWrite>(cx);\n            return None;\n        }\n\n        let debounce = EditorSettings::get_global(cx).lsp_highlight_debounce.0;\n        self.document_highlights_task = Some(cx.spawn(async move |this, cx| {\n            cx.background_executor()\n                .timer(Duration::from_millis(debounce))\n                .await;\n\n            let highlights = if let Some(highlights) = cx\n                .update(|cx| {\n                    provider.document_highlights(&cursor_buffer, cursor_buffer_position, cx)\n                })\n                .ok()\n                .flatten()\n            {\n                highlights.await.log_err()\n            } else {\n                None\n            };\n\n            if let Some(highlights) = highlights {\n                this.update(cx, |this, cx| {\n                    if this.pending_rename.is_some() {\n                        return;\n                    }\n\n                    let buffer = this.buffer.read(cx);\n                    if buffer\n                        .text_anchor_for_position(cursor_position, cx)\n                        .is_none_or(|(buffer, _)| buffer != cursor_buffer)\n                    {\n                        return;\n                    }\n\n                    let cursor_buffer_snapshot = cursor_buffer.read(cx);\n                    let mut write_ranges = Vec::new();\n                    let mut read_ranges = Vec::new();\n                    for highlight in highlights {\n                        let buffer_id = cursor_buffer.read(cx).remote_id();\n                        for (excerpt_id, excerpt_range) in buffer.excerpts_for_buffer(buffer_id, cx)\n                        {\n                            let start = highlight\n                                .range\n                                .start\n                                .max(&excerpt_range.context.start, cursor_buffer_snapshot);\n                            let end = highlight\n                                .range\n                                .end\n                                .min(&excerpt_range.context.end, cursor_buffer_snapshot);\n                            if start.cmp(&end, cursor_buffer_snapshot).is_ge() {\n                                continue;\n                            }\n\n                            let range =\n                                Anchor::range_in_buffer(excerpt_id, buffer_id, *start..*end);\n                            if highlight.kind == lsp::DocumentHighlightKind::WRITE {\n                                write_ranges.push(range);\n                            } else {\n                                read_ranges.push(range);\n                            }\n                        }\n                    }\n\n                    this.highlight_background::<DocumentHighlightRead>(\n                        &read_ranges,\n                        |theme| theme.colors().editor_document_highlight_read_background,\n                        cx,\n                    );\n                    this.highlight_background::<DocumentHighlightWrite>(\n                        &write_ranges,\n                        |theme| theme.colors().editor_document_highlight_write_background,\n                        cx,\n                    );\n                    cx.notify();\n                })\n                .log_err();\n            }\n        }));\n        None\n    }\n\n    fn prepare_highlight_query_from_selection(\n        &mut self,\n        window: &Window,\n        cx: &mut Context<Editor>,\n    ) -> Option<(String, Range<Anchor>)> {\n        if matches!(self.mode, EditorMode::SingleLine) {\n            return None;\n        }\n        if !EditorSettings::get_global(cx).selection_highlight {\n            return None;\n        }\n        if self.selections.count() != 1 || self.selections.line_mode() {\n            return None;\n        }\n        let snapshot = self.snapshot(window, cx);\n        let selection = self.selections.newest::<Point>(&snapshot);\n        // If the selection spans multiple rows OR it is empty\n        if selection.start.row != selection.end.row\n            || selection.start.column == selection.end.column\n        {\n            return None;\n        }\n        let selection_anchor_range = selection.range().to_anchors(snapshot.buffer_snapshot());\n        let query = snapshot\n            .buffer_snapshot()\n            .text_for_range(selection_anchor_range.clone())\n            .collect::<String>();\n        if query.trim().is_empty() {\n            return None;\n        }\n        Some((query, selection_anchor_range))\n    }\n\n    fn update_selection_occurrence_highlights(\n        &mut self,\n        query_text: String,\n        query_range: Range<Anchor>,\n        multi_buffer_range_to_query: Range<Point>,\n        use_debounce: bool,\n        window: &mut Window,\n        cx: &mut Context<Editor>,\n    ) -> Task<()> {\n        let multi_buffer_snapshot = self.buffer().read(cx).snapshot(cx);\n        cx.spawn_in(window, async move |editor, cx| {\n            if use_debounce {\n                cx.background_executor()\n                    .timer(SELECTION_HIGHLIGHT_DEBOUNCE_TIMEOUT)\n                    .await;\n            }\n            let match_task = cx.background_spawn(async move {\n                let buffer_ranges = multi_buffer_snapshot\n                    .range_to_buffer_ranges(multi_buffer_range_to_query)\n                    .into_iter()\n                    .filter(|(_, excerpt_visible_range, _)| !excerpt_visible_range.is_empty());\n                let mut match_ranges = Vec::new();\n                let Ok(regex) = project::search::SearchQuery::text(\n                    query_text.clone(),\n                    false,\n                    false,\n                    false,\n                    Default::default(),\n                    Default::default(),\n                    false,\n                    None,\n                ) else {\n                    return Vec::default();\n                };\n                let query_range = query_range.to_anchors(&multi_buffer_snapshot);\n                for (buffer_snapshot, search_range, excerpt_id) in buffer_ranges {\n                    match_ranges.extend(\n                        regex\n                            .search(buffer_snapshot, Some(search_range.clone()))\n                            .await\n                            .into_iter()\n                            .filter_map(|match_range| {\n                                let match_start = buffer_snapshot\n                                    .anchor_after(search_range.start + match_range.start);\n                                let match_end = buffer_snapshot\n                                    .anchor_before(search_range.start + match_range.end);\n                                let match_anchor_range = Anchor::range_in_buffer(\n                                    excerpt_id,\n                                    buffer_snapshot.remote_id(),\n                                    match_start..match_end,\n                                );\n                                (match_anchor_range != query_range).then_some(match_anchor_range)\n                            }),\n                    );\n                }\n                match_ranges\n            });\n            let match_ranges = match_task.await;\n            editor\n                .update_in(cx, |editor, _, cx| {\n                    editor.clear_background_highlights::<SelectedTextHighlight>(cx);\n                    if !match_ranges.is_empty() {\n                        editor.highlight_background::<SelectedTextHighlight>(\n                            &match_ranges,\n                            |theme| theme.colors().editor_document_highlight_bracket_background,\n                            cx,\n                        )\n                    }\n                })\n                .log_err();\n        })\n    }\n\n    fn refresh_single_line_folds(&mut self, window: &mut Window, cx: &mut Context<Editor>) {\n        struct NewlineFold;\n        let type_id = std::any::TypeId::of::<NewlineFold>();\n        if !self.mode.is_single_line() {\n            return;\n        }\n        let snapshot = self.snapshot(window, cx);\n        if snapshot.buffer_snapshot().max_point().row == 0 {\n            return;\n        }\n        let task = cx.background_spawn(async move {\n            let new_newlines = snapshot\n                .buffer_chars_at(0)\n                .filter_map(|(c, i)| {\n                    if c == '\\n' {\n                        Some(\n                            snapshot.buffer_snapshot().anchor_after(i)\n                                ..snapshot.buffer_snapshot().anchor_before(i + 1),\n                        )\n                    } else {\n                        None\n                    }\n                })\n                .collect::<Vec<_>>();\n            let existing_newlines = snapshot\n                .folds_in_range(0..snapshot.buffer_snapshot().len())\n                .filter_map(|fold| {\n                    if fold.placeholder.type_tag == Some(type_id) {\n                        Some(fold.range.start..fold.range.end)\n                    } else {\n                        None\n                    }\n                })\n                .collect::<Vec<_>>();\n\n            (new_newlines, existing_newlines)\n        });\n        self.folding_newlines = cx.spawn(async move |this, cx| {\n            let (new_newlines, existing_newlines) = task.await;\n            if new_newlines == existing_newlines {\n                return;\n            }\n            let placeholder = FoldPlaceholder {\n                render: Arc::new(move |_, _, cx| {\n                    div()\n                        .bg(cx.theme().status().hint_background)\n                        .border_b_1()\n                        .size_full()\n                        .font(ThemeSettings::get_global(cx).buffer_font.clone())\n                        .border_color(cx.theme().status().hint)\n                        .child(": "",
        ")\n                        .into_any()\n                }),\n                constrain_width: false,\n                merge_adjacent: false,\n                type_tag: Some(type_id),\n            };\n            let creases = new_newlines\n                .into_iter()\n                .map(|range| Crease::simple(range, placeholder.clone()))\n                .collect();\n            this.update(cx, |this, cx| {\n                this.display_map.update(cx, |display_map, cx| {\n                    display_map.remove_folds_with_type(existing_newlines, type_id, cx);\n                    display_map.fold(creases, cx);\n                });\n            })\n            .ok();\n        });\n    }\n\n    fn refresh_selected_text_highlights(\n        &mut self,\n        on_buffer_edit: bool,\n        window: &mut Window,\n        cx: &mut Context<Editor>,\n    ) {\n        let Some((query_text, query_range)) =\n            self.prepare_highlight_query_from_selection(window, cx)\n        else {\n            self.clear_background_highlights::<SelectedTextHighlight>(cx);\n            self.quick_selection_highlight_task.take();\n            self.debounced_selection_highlight_task.take();\n            return;\n        };\n        let multi_buffer_snapshot = self.buffer().read(cx).snapshot(cx);\n        if on_buffer_edit\n            || self\n                .quick_selection_highlight_task\n                .as_ref()\n                .is_none_or(|(prev_anchor_range, _)| prev_anchor_range != &query_range)\n        {\n            let multi_buffer_visible_start = self\n                .scroll_manager\n                .anchor()\n                .anchor\n                .to_point(&multi_buffer_snapshot);\n            let multi_buffer_visible_end = multi_buffer_snapshot.clip_point(\n                multi_buffer_visible_start\n                    + Point::new(self.visible_line_count().unwrap_or(0.).ceil() as u32, 0),\n                Bias::Left,\n            );\n            let multi_buffer_visible_range = multi_buffer_visible_start..multi_buffer_visible_end;\n            self.quick_selection_highlight_task = Some((\n                query_range.clone(),\n                self.update_selection_occurrence_highlights(\n                    query_text.clone(),\n                    query_range.clone(),\n                    multi_buffer_visible_range,\n                    false,\n                    window,\n                    cx,\n                ),\n            ));\n        }\n        if on_buffer_edit\n            || self\n                .debounced_selection_highlight_task\n                .as_ref()\n                .is_none_or(|(prev_anchor_range, _)| prev_anchor_range != &query_range)\n        {\n            let multi_buffer_start = multi_buffer_snapshot\n                .anchor_before(0)\n                .to_point(&multi_buffer_snapshot);\n            let multi_buffer_end = multi_buffer_snapshot\n                .anchor_after(multi_buffer_snapshot.len())\n                .to_point(&multi_buffer_snapshot);\n            let multi_buffer_full_range = multi_buffer_start..multi_buffer_end;\n            self.debounced_selection_highlight_task = Some((\n                query_range.clone(),\n                self.update_selection_occurrence_highlights(\n                    query_text,\n                    query_range,\n                    multi_buffer_full_range,\n                    true,\n                    window,\n                    cx,\n                ),\n            ));\n        }\n    }\n\n    pub fn refresh_edit_prediction(\n        &mut self,\n        debounce: bool,\n        user_requested: bool,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<()> {\n        if DisableAiSettings::get_global(cx).disable_ai {\n            return None;\n        }\n\n        let provider = self.edit_prediction_provider()?;\n        let cursor = self.selections.newest_anchor().head();\n        let (buffer, cursor_buffer_position) =\n            self.buffer.read(cx).text_anchor_for_position(cursor, cx)?;\n\n        if !self.edit_predictions_enabled_in_buffer(&buffer, cursor_buffer_position, cx) {\n            self.discard_edit_prediction(false, cx);\n            return None;\n        }\n\n        self.update_visible_edit_prediction(window, cx);\n\n        if !user_requested\n            && (!self.should_show_edit_predictions()\n                || !self.is_focused(window)\n                || buffer.read(cx).is_empty())\n        {\n            self.discard_edit_prediction(false, cx);\n            return None;\n        }\n\n        provider.refresh(buffer, cursor_buffer_position, debounce, cx);\n        Some(())\n    }\n\n    fn show_edit_predictions_in_menu(&self) -> bool {\n        match self.edit_prediction_settings {\n            EditPredictionSettings::Disabled => false,\n            EditPredictionSettings::Enabled { show_in_menu, .. } => show_in_menu,\n        }\n    }\n\n    pub fn edit_predictions_enabled(&self) -> bool {\n        match self.edit_prediction_settings {\n            EditPredictionSettings::Disabled => false,\n            EditPredictionSettings::Enabled { .. } => true,\n        }\n    }\n\n    fn edit_prediction_requires_modifier(&self) -> bool {\n        match self.edit_prediction_settings {\n            EditPredictionSettings::Disabled => false,\n            EditPredictionSettings::Enabled {\n                preview_requires_modifier,\n                ..\n            } => preview_requires_modifier,\n        }\n    }\n\n    pub fn update_edit_prediction_settings(&mut self, cx: &mut Context<Self>) {\n        if self.edit_prediction_provider.is_none() || DisableAiSettings::get_global(cx).disable_ai {\n            self.edit_prediction_settings = EditPredictionSettings::Disabled;\n            self.discard_edit_prediction(false, cx);\n        } else {\n            let selection = self.selections.newest_anchor();\n            let cursor = selection.head();\n\n            if let Some((buffer, cursor_buffer_position)) =\n                self.buffer.read(cx).text_anchor_for_position(cursor, cx)\n            {\n                self.edit_prediction_settings =\n                    self.edit_prediction_settings_at_position(&buffer, cursor_buffer_position, cx);\n            }\n        }\n    }\n\n    fn edit_prediction_settings_at_position(\n        &self,\n        buffer: &Entity<Buffer>,\n        buffer_position: language::Anchor,\n        cx: &App,\n    ) -> EditPredictionSettings {\n        if !self.mode.is_full()\n            || !self.show_edit_predictions_override.unwrap_or(true)\n            || self.edit_predictions_disabled_in_scope(buffer, buffer_position, cx)\n        {\n            return EditPredictionSettings::Disabled;\n        }\n\n        let buffer = buffer.read(cx);\n\n        let file = buffer.file();\n\n        if !language_settings(buffer.language().map(|l| l.name()), file, cx).show_edit_predictions {\n            return EditPredictionSettings::Disabled;\n        };\n\n        let by_provider = matches!(\n            self.menu_edit_predictions_policy,\n            MenuEditPredictionsPolicy::ByProvider\n        );\n\n        let show_in_menu = by_provider\n            && self\n                .edit_prediction_provider\n                .as_ref()\n                .is_some_and(|provider| provider.provider.show_completions_in_menu());\n\n        let preview_requires_modifier =\n            all_language_settings(file, cx).edit_predictions_mode() == EditPredictionsMode::Subtle;\n\n        EditPredictionSettings::Enabled {\n            show_in_menu,\n            preview_requires_modifier,\n        }\n    }\n\n    fn should_show_edit_predictions(&self) -> bool {\n        self.snippet_stack.is_empty() && self.edit_predictions_enabled()\n    }\n\n    pub fn edit_prediction_preview_is_active(&self) -> bool {\n        matches!(\n            self.edit_prediction_preview,\n            EditPredictionPreview::Active { .. }\n        )\n    }\n\n    pub fn edit_predictions_enabled_at_cursor(&self, cx: &App) -> bool {\n        let cursor = self.selections.newest_anchor().head();\n        if let Some((buffer, cursor_position)) =\n            self.buffer.read(cx).text_anchor_for_position(cursor, cx)\n        {\n            self.edit_predictions_enabled_in_buffer(&buffer, cursor_position, cx)\n        } else {\n            false\n        }\n    }\n\n    pub fn supports_minimap(&self, cx: &App) -> bool {\n        !self.minimap_visibility.disabled() && self.buffer_kind(cx) == ItemBufferKind::Singleton\n    }\n\n    fn edit_predictions_enabled_in_buffer(\n        &self,\n        buffer: &Entity<Buffer>,\n        buffer_position: language::Anchor,\n        cx: &App,\n    ) -> bool {\n        maybe!({\n            if self.read_only(cx) {\n                return Some(false);\n            }\n            let provider = self.edit_prediction_provider()?;\n            if !provider.is_enabled(buffer, buffer_position, cx) {\n                return Some(false);\n            }\n            let buffer = buffer.read(cx);\n            let Some(file) = buffer.file() else {\n                return Some(true);\n            };\n            let settings = all_language_settings(Some(file), cx);\n            Some(settings.edit_predictions_enabled_for_file(file, cx))\n        })\n        .unwrap_or(false)\n    }\n\n    fn cycle_edit_prediction(\n        &mut self,\n        direction: Direction,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<()> {\n        let provider = self.edit_prediction_provider()?;\n        let cursor = self.selections.newest_anchor().head();\n        let (buffer, cursor_buffer_position) =\n            self.buffer.read(cx).text_anchor_for_position(cursor, cx)?;\n        if self.edit_predictions_hidden_for_vim_mode || !self.should_show_edit_predictions() {\n            return None;\n        }\n\n        provider.cycle(buffer, cursor_buffer_position, direction, cx);\n        self.update_visible_edit_prediction(window, cx);\n\n        Some(())\n    }\n\n    pub fn show_edit_prediction(\n        &mut self,\n        _: &ShowEditPrediction,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if !self.has_active_edit_prediction() {\n            self.refresh_edit_prediction(false, true, window, cx);\n            return;\n        }\n\n        self.update_visible_edit_prediction(window, cx);\n    }\n\n    pub fn display_cursor_names(\n        &mut self,\n        _: &DisplayCursorNames,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.show_cursor_names(window, cx);\n    }\n\n    fn show_cursor_names(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n        self.show_cursor_names = true;\n        cx.notify();\n        cx.spawn_in(window, async move |this, cx| {\n            cx.background_executor().timer(CURSORS_VISIBLE_FOR).await;\n            this.update(cx, |this, cx| {\n                this.show_cursor_names = false;\n                cx.notify()\n            })\n            .ok()\n        })\n        .detach();\n    }\n\n    pub fn next_edit_prediction(\n        &mut self,\n        _: &NextEditPrediction,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if self.has_active_edit_prediction() {\n            self.cycle_edit_prediction(Direction::Next, window, cx);\n        } else {\n            let is_copilot_disabled = self\n                .refresh_edit_prediction(false, true, window, cx)\n                .is_none();\n            if is_copilot_disabled {\n                cx.propagate();\n            }\n        }\n    }\n\n    pub fn previous_edit_prediction(\n        &mut self,\n        _: &PreviousEditPrediction,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if self.has_active_edit_prediction() {\n            self.cycle_edit_prediction(Direction::Prev, window, cx);\n        } else {\n            let is_copilot_disabled = self\n                .refresh_edit_prediction(false, true, window, cx)\n                .is_none();\n            if is_copilot_disabled {\n                cx.propagate();\n            }\n        }\n    }\n\n    pub fn accept_edit_prediction(\n        &mut self,\n        _: &AcceptEditPrediction,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if self.show_edit_predictions_in_menu() {\n            self.hide_context_menu(window, cx);\n        }\n\n        let Some(active_edit_prediction) = self.active_edit_prediction.as_ref() else {\n            return;\n        };\n\n        match &active_edit_prediction.completion {\n            EditPrediction::MoveWithin { target, .. } => {\n                let target = *target;\n\n                if let Some(position_map) = &self.last_position_map {\n                    if position_map\n                        .visible_row_range\n                        .contains(&target.to_display_point(&position_map.snapshot).row())\n                        || !self.edit_prediction_requires_modifier()\n                    {\n                        self.unfold_ranges(&[target..target], true, false, cx);\n                        // Note that this is also done in vim's handler of the Tab action.\n                        self.change_selections(\n                            SelectionEffects::scroll(Autoscroll::newest()),\n                            window,\n                            cx,\n                            |selections| {\n                                selections.select_anchor_ranges([target..target]);\n                            },\n                        );\n                        self.clear_row_highlights::<EditPredictionPreview>();\n\n                        self.edit_prediction_preview\n                            .set_previous_scroll_position(None);\n                    } else {\n                        self.edit_prediction_preview\n                            .set_previous_scroll_position(Some(\n                                position_map.snapshot.scroll_anchor,\n                            ));\n\n                        self.highlight_rows::<EditPredictionPreview>(\n                            target..target,\n                            cx.theme().colors().editor_highlighted_line_background,\n                            RowHighlightOptions {\n                                autoscroll: true,\n                                ..Default::default()\n                            },\n                            cx,\n                        );\n                        self.request_autoscroll(Autoscroll::fit(), cx);\n                    }\n                }\n            }\n            EditPrediction::MoveOutside { snapshot, target } => {\n                if let Some(workspace) = self.workspace() {\n                    Self::open_editor_at_anchor(snapshot, *target, &workspace, window, cx)\n                        .detach_and_log_err(cx);\n                }\n            }\n            EditPrediction::Edit { edits, .. } => {\n                self.report_edit_prediction_event(\n                    active_edit_prediction.completion_id.clone(),\n                    true,\n                    cx,\n                );\n\n                if let Some(provider) = self.edit_prediction_provider() {\n                    provider.accept(cx);\n                }\n\n                // Store the transaction ID and selections before applying the edit\n                let transaction_id_prev = self.buffer.read(cx).last_transaction_id(cx);\n\n                let snapshot = self.buffer.read(cx).snapshot(cx);\n                let last_edit_end = edits.last().unwrap().0.end.bias_right(&snapshot);\n\n                self.buffer.update(cx, |buffer, cx| {\n                    buffer.edit(edits.iter().cloned(), None, cx)\n                });\n\n                self.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n                    s.select_anchor_ranges([last_edit_end..last_edit_end]);\n                });\n\n                let selections = self.selections.disjoint_anchors_arc();\n                if let Some(transaction_id_now) = self.buffer.read(cx).last_transaction_id(cx) {\n                    let has_new_transaction = transaction_id_prev != Some(transaction_id_now);\n                    if has_new_transaction {\n                        self.selection_history\n                            .insert_transaction(transaction_id_now, selections);\n                    }\n                }\n\n                self.update_visible_edit_prediction(window, cx);\n                if self.active_edit_prediction.is_none() {\n                    self.refresh_edit_prediction(true, true, window, cx);\n                }\n\n                cx.notify();\n            }\n        }\n\n        self.edit_prediction_requires_modifier_in_indent_conflict = false;\n    }\n\n    pub fn accept_partial_edit_prediction(\n        &mut self,\n        _: &AcceptPartialEditPrediction,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let Some(active_edit_prediction) = self.active_edit_prediction.as_ref() else {\n            return;\n        };\n        if self.selections.count() != 1 {\n            return;\n        }\n\n        match &active_edit_prediction.completion {\n            EditPrediction::MoveWithin { target, .. } => {\n                let target = *target;\n                self.change_selections(\n                    SelectionEffects::scroll(Autoscroll::newest()),\n                    window,\n                    cx,\n                    |selections| {\n                        selections.select_anchor_ranges([target..target]);\n                    },\n                );\n            }\n            EditPrediction::MoveOutside { snapshot, target } => {\n                if let Some(workspace) = self.workspace() {\n                    Self::open_editor_at_anchor(snapshot, *target, &workspace, window, cx)\n                        .detach_and_log_err(cx);\n                }\n            }\n            EditPrediction::Edit { edits, .. } => {\n                self.report_edit_prediction_event(\n                    active_edit_prediction.completion_id.clone(),\n                    true,\n                    cx,\n                );\n\n                // Find an insertion that starts at the cursor position.\n                let snapshot = self.buffer.read(cx).snapshot(cx);\n                let cursor_offset = self\n                    .selections\n                    .newest::<usize>(&self.display_snapshot(cx))\n                    .head();\n                let insertion = edits.iter().find_map(|(range, text)| {\n                    let range = range.to_offset(&snapshot);\n                    if range.is_empty() && range.start == cursor_offset {\n                        Some(text)\n                    } else {\n                        None\n                    }\n                });\n\n                if let Some(text) = insertion {\n                    let mut partial_completion = text\n                        .chars()\n                        .by_ref()\n                        .take_while(|c| c.is_alphabetic())\n                        .collect::<String>();\n                    if partial_completion.is_empty() {\n                        partial_completion = text\n                            .chars()\n                            .by_ref()\n                            .take_while(|c| c.is_whitespace() || !c.is_alphabetic())\n                            .collect::<String>();\n                    }\n\n                    cx.emit(EditorEvent::InputHandled {\n                        utf16_range_to_replace: None,\n                        text: partial_completion.clone().into(),\n                    });\n\n                    self.insert_with_autoindent_mode(&partial_completion, None, window, cx);\n\n                    self.refresh_edit_prediction(true, true, window, cx);\n                    cx.notify();\n                } else {\n                    self.accept_edit_prediction(&Default::default(), window, cx);\n                }\n            }\n        }\n    }\n\n    fn discard_edit_prediction(\n        &mut self,\n        should_report_edit_prediction_event: bool,\n        cx: &mut Context<Self>,\n    ) -> bool {\n        if should_report_edit_prediction_event {\n            let completion_id = self\n                .active_edit_prediction\n                .as_ref()\n                .and_then(|active_completion| active_completion.completion_id.clone());\n\n            self.report_edit_prediction_event(completion_id, false, cx);\n        }\n\n        if let Some(provider) = self.edit_prediction_provider() {\n            provider.discard(cx);\n        }\n\n        self.take_active_edit_prediction(cx)\n    }\n\n    fn report_edit_prediction_event(&self, id: Option<SharedString>, accepted: bool, cx: &App) {\n        let Some(provider) = self.edit_prediction_provider() else {\n            return;\n        };\n\n        let Some((_, buffer, _)) = self\n            .buffer\n            .read(cx)\n            .excerpt_containing(self.selections.newest_anchor().head(), cx)\n        else {\n            return;\n        };\n\n        let extension = buffer\n            .read(cx)\n            .file()\n            .and_then(|file| Some(file.path().extension()?.to_string()));\n\n        let event_type = match accepted {\n            true => ": "",
        ",\n            false => ": "",
        ",\n        };\n        telemetry::event!(\n            event_type,\n            provider = provider.name(),\n            prediction_id = id,\n            suggestion_accepted = accepted,\n            file_extension = extension,\n        );\n    }\n\n    fn open_editor_at_anchor(\n        snapshot: &language::BufferSnapshot,\n        target: language::Anchor,\n        workspace: &Entity<Workspace>,\n        window: &mut Window,\n        cx: &mut App,\n    ) -> Task<Result<()>> {\n        workspace.update(cx, |workspace, cx| {\n            let path = snapshot.file().map(|file| file.full_path(cx));\n            let Some(path) =\n                path.and_then(|path| workspace.project().read(cx).find_project_path(path, cx))\n            else {\n                return Task::ready(Err(anyhow::anyhow!(": "",
        ")));\n            };\n            let target = text::ToPoint::to_point(&target, snapshot);\n            let item = workspace.open_path(path, None, true, window, cx);\n            window.spawn(cx, async move |cx| {\n                let Some(editor) = item.await?.downcast::<Editor>() else {\n                    return Ok(());\n                };\n                editor\n                    .update_in(cx, |editor, window, cx| {\n                        editor.go_to_singleton_buffer_point(target, window, cx);\n                    })\n                    .ok();\n                anyhow::Ok(())\n            })\n        })\n    }\n\n    pub fn has_active_edit_prediction(&self) -> bool {\n        self.active_edit_prediction.is_some()\n    }\n\n    fn take_active_edit_prediction(&mut self, cx: &mut Context<Self>) -> bool {\n        let Some(active_edit_prediction) = self.active_edit_prediction.take() else {\n            return false;\n        };\n\n        self.splice_inlays(&active_edit_prediction.inlay_ids, Default::default(), cx);\n        self.clear_highlights::<EditPredictionHighlight>(cx);\n        self.stale_edit_prediction_in_menu = Some(active_edit_prediction);\n        true\n    }\n\n    /// Returns true when we're displaying the edit prediction popover below the cursor\n    /// like we are not previewing and the LSP autocomplete menu is visible\n    /// or we are in `when_holding_modifier` mode.\n    pub fn edit_prediction_visible_in_cursor_popover(&self, has_completion: bool) -> bool {\n        if self.edit_prediction_preview_is_active()\n            || !self.show_edit_predictions_in_menu()\n            || !self.edit_predictions_enabled()\n        {\n            return false;\n        }\n\n        if self.has_visible_completions_menu() {\n            return true;\n        }\n\n        has_completion && self.edit_prediction_requires_modifier()\n    }\n\n    fn handle_modifiers_changed(\n        &mut self,\n        modifiers: Modifiers,\n        position_map: &PositionMap,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        // Ensure that the edit prediction preview is updated, even when not\n        // enabled, if there's an active edit prediction preview.\n        if self.show_edit_predictions_in_menu()\n            || matches!(\n                self.edit_prediction_preview,\n                EditPredictionPreview::Active { .. }\n            )\n        {\n            self.update_edit_prediction_preview(&modifiers, window, cx);\n        }\n\n        self.update_selection_mode(&modifiers, position_map, window, cx);\n\n        let mouse_position = window.mouse_position();\n        if !position_map.text_hitbox.is_hovered(window) {\n            return;\n        }\n\n        self.update_hovered_link(\n            position_map.point_for_position(mouse_position),\n            &position_map.snapshot,\n            modifiers,\n            window,\n            cx,\n        )\n    }\n\n    fn is_cmd_or_ctrl_pressed(modifiers: &Modifiers, cx: &mut Context<Self>) -> bool {\n        match EditorSettings::get_global(cx).multi_cursor_modifier {\n            MultiCursorModifier::Alt => modifiers.secondary(),\n            MultiCursorModifier::CmdOrCtrl => modifiers.alt,\n        }\n    }\n\n    fn is_alt_pressed(modifiers: &Modifiers, cx: &mut Context<Self>) -> bool {\n        match EditorSettings::get_global(cx).multi_cursor_modifier {\n            MultiCursorModifier::Alt => modifiers.alt,\n            MultiCursorModifier::CmdOrCtrl => modifiers.secondary(),\n        }\n    }\n\n    fn columnar_selection_mode(\n        modifiers: &Modifiers,\n        cx: &mut Context<Self>,\n    ) -> Option<ColumnarMode> {\n        if modifiers.shift && modifiers.number_of_modifiers() == 2 {\n            if Self::is_cmd_or_ctrl_pressed(modifiers, cx) {\n                Some(ColumnarMode::FromMouse)\n            } else if Self::is_alt_pressed(modifiers, cx) {\n                Some(ColumnarMode::FromSelection)\n            } else {\n                None\n            }\n        } else {\n            None\n        }\n    }\n\n    fn update_selection_mode(\n        &mut self,\n        modifiers: &Modifiers,\n        position_map: &PositionMap,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let Some(mode) = Self::columnar_selection_mode(modifiers, cx) else {\n            return;\n        };\n        if self.selections.pending_anchor().is_none() {\n            return;\n        }\n\n        let mouse_position = window.mouse_position();\n        let point_for_position = position_map.point_for_position(mouse_position);\n        let position = point_for_position.previous_valid;\n\n        self.select(\n            SelectPhase::BeginColumnar {\n                position,\n                reset: false,\n                mode,\n                goal_column: point_for_position.exact_unclipped.column(),\n            },\n            window,\n            cx,\n        );\n    }\n\n    fn update_edit_prediction_preview(\n        &mut self,\n        modifiers: &Modifiers,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let mut modifiers_held = false;\n        if let Some(accept_keystroke) = self\n            .accept_edit_prediction_keybind(false, window, cx)\n            .keystroke()\n        {\n            modifiers_held = modifiers_held\n                || (accept_keystroke.modifiers() == modifiers\n                    && accept_keystroke.modifiers().modified());\n        };\n        if let Some(accept_partial_keystroke) = self\n            .accept_edit_prediction_keybind(true, window, cx)\n            .keystroke()\n        {\n            modifiers_held = modifiers_held\n                || (accept_partial_keystroke.modifiers() == modifiers\n                    && accept_partial_keystroke.modifiers().modified());\n        }\n\n        if modifiers_held {\n            if matches!(\n                self.edit_prediction_preview,\n                EditPredictionPreview::Inactive { .. }\n            ) {\n                self.edit_prediction_preview = EditPredictionPreview::Active {\n                    previous_scroll_position: None,\n                    since: Instant::now(),\n                };\n\n                self.update_visible_edit_prediction(window, cx);\n                cx.notify();\n            }\n        } else if let EditPredictionPreview::Active {\n            previous_scroll_position,\n            since,\n        } = self.edit_prediction_preview\n        {\n            if let (Some(previous_scroll_position), Some(position_map)) =\n                (previous_scroll_position, self.last_position_map.as_ref())\n            {\n                self.set_scroll_position(\n                    previous_scroll_position\n                        .scroll_position(&position_map.snapshot.display_snapshot),\n                    window,\n                    cx,\n                );\n            }\n\n            self.edit_prediction_preview = EditPredictionPreview::Inactive {\n                released_too_fast: since.elapsed() < Duration::from_millis(200),\n            };\n            self.clear_row_highlights::<EditPredictionPreview>();\n            self.update_visible_edit_prediction(window, cx);\n            cx.notify();\n        }\n    }\n\n    fn update_visible_edit_prediction(\n        &mut self,\n        _window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<()> {\n        if DisableAiSettings::get_global(cx).disable_ai {\n            return None;\n        }\n\n        if self.ime_transaction.is_some() {\n            self.discard_edit_prediction(false, cx);\n            return None;\n        }\n\n        let selection = self.selections.newest_anchor();\n        let cursor = selection.head();\n        let multibuffer = self.buffer.read(cx).snapshot(cx);\n        let offset_selection = selection.map(|endpoint| endpoint.to_offset(&multibuffer));\n        let excerpt_id = cursor.excerpt_id;\n\n        let show_in_menu = self.show_edit_predictions_in_menu();\n        let completions_menu_has_precedence = !show_in_menu\n            && (self.context_menu.borrow().is_some()\n                || (!self.completion_tasks.is_empty() && !self.has_active_edit_prediction()));\n\n        if completions_menu_has_precedence\n            || !offset_selection.is_empty()\n            || self\n                .active_edit_prediction\n                .as_ref()\n                .is_some_and(|completion| {\n                    let Some(invalidation_range) = completion.invalidation_range.as_ref() else {\n                        return false;\n                    };\n                    let invalidation_range = invalidation_range.to_offset(&multibuffer);\n                    let invalidation_range = invalidation_range.start..=invalidation_range.end;\n                    !invalidation_range.contains(&offset_selection.head())\n                })\n        {\n            self.discard_edit_prediction(false, cx);\n            return None;\n        }\n\n        self.take_active_edit_prediction(cx);\n        let Some(provider) = self.edit_prediction_provider() else {\n            self.edit_prediction_settings = EditPredictionSettings::Disabled;\n            return None;\n        };\n\n        let (buffer, cursor_buffer_position) =\n            self.buffer.read(cx).text_anchor_for_position(cursor, cx)?;\n\n        self.edit_prediction_settings =\n            self.edit_prediction_settings_at_position(&buffer, cursor_buffer_position, cx);\n\n        self.edit_prediction_indent_conflict = multibuffer.is_line_whitespace_upto(cursor);\n\n        if self.edit_prediction_indent_conflict {\n            let cursor_point = cursor.to_point(&multibuffer);\n\n            let indents = multibuffer.suggested_indents(cursor_point.row..cursor_point.row + 1, cx);\n\n            if let Some((_, indent)) = indents.iter().next()\n                && indent.len == cursor_point.column\n            {\n                self.edit_prediction_indent_conflict = false;\n            }\n        }\n\n        let edit_prediction = provider.suggest(&buffer, cursor_buffer_position, cx)?;\n\n        let (completion_id, edits, edit_preview) = match edit_prediction {\n            edit_prediction::EditPrediction::Local {\n                id,\n                edits,\n                edit_preview,\n            } => (id, edits, edit_preview),\n            edit_prediction::EditPrediction::Jump {\n                id,\n                snapshot,\n                target,\n            } => {\n                self.stale_edit_prediction_in_menu = None;\n                self.active_edit_prediction = Some(EditPredictionState {\n                    inlay_ids: vec![],\n                    completion: EditPrediction::MoveOutside { snapshot, target },\n                    completion_id: id,\n                    invalidation_range: None,\n                });\n                cx.notify();\n                return Some(());\n            }\n        };\n\n        let edits = edits\n            .into_iter()\n            .flat_map(|(range, new_text)| {\n                Some((\n                    multibuffer.anchor_range_in_excerpt(excerpt_id, range)?,\n                    new_text,\n                ))\n            })\n            .collect::<Vec<_>>();\n        if edits.is_empty() {\n            return None;\n        }\n\n        let first_edit_start = edits.first().unwrap().0.start;\n        let first_edit_start_point = first_edit_start.to_point(&multibuffer);\n        let edit_start_row = first_edit_start_point.row.saturating_sub(2);\n\n        let last_edit_end = edits.last().unwrap().0.end;\n        let last_edit_end_point = last_edit_end.to_point(&multibuffer);\n        let edit_end_row = cmp::min(multibuffer.max_point().row, last_edit_end_point.row + 2);\n\n        let cursor_row = cursor.to_point(&multibuffer).row;\n\n        let snapshot = multibuffer.buffer_for_excerpt(excerpt_id).cloned()?;\n\n        let mut inlay_ids = Vec::new();\n        let invalidation_row_range;\n        let move_invalidation_row_range = if cursor_row < edit_start_row {\n            Some(cursor_row..edit_end_row)\n        } else if cursor_row > edit_end_row {\n            Some(edit_start_row..cursor_row)\n        } else {\n            None\n        };\n        let supports_jump = self\n            .edit_prediction_provider\n            .as_ref()\n            .map(|provider| provider.provider.supports_jump_to_edit())\n            .unwrap_or(true);\n\n        let is_move = supports_jump\n            && (move_invalidation_row_range.is_some() || self.edit_predictions_hidden_for_vim_mode);\n        let completion = if is_move {\n            invalidation_row_range =\n                move_invalidation_row_range.unwrap_or(edit_start_row..edit_end_row);\n            let target = first_edit_start;\n            EditPrediction::MoveWithin { target, snapshot }\n        } else {\n            let show_completions_in_buffer = !self.edit_prediction_visible_in_cursor_popover(true)\n                && !self.edit_predictions_hidden_for_vim_mode;\n\n            if show_completions_in_buffer {\n                if edits\n                    .iter()\n                    .all(|(range, _)| range.to_offset(&multibuffer).is_empty())\n                {\n                    let mut inlays = Vec::new();\n                    for (range, new_text) in &edits {\n                        let inlay = Inlay::edit_prediction(\n                            post_inc(&mut self.next_inlay_id),\n                            range.start,\n                            new_text.as_ref(),\n                        );\n                        inlay_ids.push(inlay.id);\n                        inlays.push(inlay);\n                    }\n\n                    self.splice_inlays(&[], inlays, cx);\n                } else {\n                    let background_color = cx.theme().status().deleted_background;\n                    self.highlight_text::<EditPredictionHighlight>(\n                        edits.iter().map(|(range, _)| range.clone()).collect(),\n                        HighlightStyle {\n                            background_color: Some(background_color),\n                            ..Default::default()\n                        },\n                        cx,\n                    );\n                }\n            }\n\n            invalidation_row_range = edit_start_row..edit_end_row;\n\n            let display_mode = if all_edits_insertions_or_deletions(&edits, &multibuffer) {\n                if provider.show_tab_accept_marker() {\n                    EditDisplayMode::TabAccept\n                } else {\n                    EditDisplayMode::Inline\n                }\n            } else {\n                EditDisplayMode::DiffPopover\n            };\n\n            EditPrediction::Edit {\n                edits,\n                edit_preview,\n                display_mode,\n                snapshot,\n            }\n        };\n\n        let invalidation_range = multibuffer\n            .anchor_before(Point::new(invalidation_row_range.start, 0))\n            ..multibuffer.anchor_after(Point::new(\n                invalidation_row_range.end,\n                multibuffer.line_len(MultiBufferRow(invalidation_row_range.end)),\n            ));\n\n        self.stale_edit_prediction_in_menu = None;\n        self.active_edit_prediction = Some(EditPredictionState {\n            inlay_ids,\n            completion,\n            completion_id,\n            invalidation_range: Some(invalidation_range),\n        });\n\n        cx.notify();\n\n        Some(())\n    }\n\n    pub fn edit_prediction_provider(&self) -> Option<Arc<dyn EditPredictionProviderHandle>> {\n        Some(self.edit_prediction_provider.as_ref()?.provider.clone())\n    }\n\n    fn clear_tasks(&mut self) {\n        self.tasks.clear()\n    }\n\n    fn insert_tasks(&mut self, key: (BufferId, BufferRow), value: RunnableTasks) {\n        if self.tasks.insert(key, value).is_some() {\n            // This case should hopefully be rare, but just in case...\n            log::error!(\n                ": "",
        "\n            )\n        }\n    }\n\n    /// Get all display points of breakpoints that will be rendered within editor\n    ///\n    /// This function is used to handle overlaps between breakpoints and Code action/runner symbol.\n    /// It's also used to set the color of line numbers with breakpoints to the breakpoint color.\n    /// TODO debugger: Use this function to color toggle symbols that house nested breakpoints\n    fn active_breakpoints(\n        &self,\n        range: Range<DisplayRow>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> HashMap<DisplayRow, (Anchor, Breakpoint, Option<BreakpointSessionState>)> {\n        let mut breakpoint_display_points = HashMap::default();\n\n        let Some(breakpoint_store) = self.breakpoint_store.clone() else {\n            return breakpoint_display_points;\n        };\n\n        let snapshot = self.snapshot(window, cx);\n\n        let multi_buffer_snapshot = snapshot.buffer_snapshot();\n        let Some(project) = self.project() else {\n            return breakpoint_display_points;\n        };\n\n        let range = snapshot.display_point_to_point(DisplayPoint::new(range.start, 0), Bias::Left)\n            ..snapshot.display_point_to_point(DisplayPoint::new(range.end, 0), Bias::Right);\n\n        for (buffer_snapshot, range, excerpt_id) in\n            multi_buffer_snapshot.range_to_buffer_ranges(range)\n        {\n            let Some(buffer) = project\n                .read(cx)\n                .buffer_for_id(buffer_snapshot.remote_id(), cx)\n            else {\n                continue;\n            };\n            let breakpoints = breakpoint_store.read(cx).breakpoints(\n                &buffer,\n                Some(\n                    buffer_snapshot.anchor_before(range.start)\n                        ..buffer_snapshot.anchor_after(range.end),\n                ),\n                buffer_snapshot,\n                cx,\n            );\n            for (breakpoint, state) in breakpoints {\n                let multi_buffer_anchor =\n                    Anchor::in_buffer(excerpt_id, buffer_snapshot.remote_id(), breakpoint.position);\n                let position = multi_buffer_anchor\n                    .to_point(&multi_buffer_snapshot)\n                    .to_display_point(&snapshot);\n\n                breakpoint_display_points.insert(\n                    position.row(),\n                    (multi_buffer_anchor, breakpoint.bp.clone(), state),\n                );\n            }\n        }\n\n        breakpoint_display_points\n    }\n\n    fn breakpoint_context_menu(\n        &self,\n        anchor: Anchor,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Entity<ui::ContextMenu> {\n        let weak_editor = cx.weak_entity();\n        let focus_handle = self.focus_handle(cx);\n\n        let row = self\n            .buffer\n            .read(cx)\n            .snapshot(cx)\n            .summary_for_anchor::<Point>(&anchor)\n            .row;\n\n        let breakpoint = self\n            .breakpoint_at_row(row, window, cx)\n            .map(|(anchor, bp)| (anchor, Arc::from(bp)));\n\n        let log_breakpoint_msg = if breakpoint.as_ref().is_some_and(|bp| bp.1.message.is_some()) {\n            ": "",
        "\n        } else {\n            ": "",
        "\n        };\n\n        let condition_breakpoint_msg = if breakpoint\n            .as_ref()\n            .is_some_and(|bp| bp.1.condition.is_some())\n        {\n            ": "",
        "\n        };\n\n        let hit_condition_breakpoint_msg = if breakpoint\n            .as_ref()\n            .is_some_and(|bp| bp.1.hit_condition.is_some())\n        {\n            ": "",
        "\n        };\n\n        let set_breakpoint_msg = if breakpoint.as_ref().is_some() {\n            ": "",
        "\n        };\n\n        let run_to_cursor = window.is_action_available(&RunToCursor, cx);\n\n        let toggle_state_msg = breakpoint.as_ref().map_or(None, |bp| match bp.1.state {\n            BreakpointState::Enabled => Some(": "",
        "),\n            BreakpointState::Disabled => Some(": "",
        "),\n        });\n\n        let (anchor, breakpoint) =\n            breakpoint.unwrap_or_else(|| (anchor, Arc::new(Breakpoint::new_standard())));\n\n        ui::ContextMenu::build(window, cx, |menu, _, _cx| {\n            menu.on_blur_subscription(Subscription::new(|| {}))\n                .context(focus_handle)\n                .when(run_to_cursor, |this| {\n                    let weak_editor = weak_editor.clone();\n                    this.entry(": "",
        ", None, move |window, cx| {\n                        weak_editor\n                            .update(cx, |editor, cx| {\n                                editor.change_selections(\n                                    SelectionEffects::no_scroll(),\n                                    window,\n                                    cx,\n                                    |s| s.select_ranges([Point::new(row, 0)..Point::new(row, 0)]),\n                                );\n                            })\n                            .ok();\n\n                        window.dispatch_action(Box::new(RunToCursor), cx);\n                    })\n                    .separator()\n                })\n                .when_some(toggle_state_msg, |this, msg| {\n                    this.entry(msg, None, {\n                        let weak_editor = weak_editor.clone();\n                        let breakpoint = breakpoint.clone();\n                        move |_window, cx| {\n                            weak_editor\n                                .update(cx, |this, cx| {\n                                    this.edit_breakpoint_at_anchor(\n                                        anchor,\n                                        breakpoint.as_ref().clone(),\n                                        BreakpointEditAction::InvertState,\n                                        cx,\n                                    );\n                                })\n                                .log_err();\n                        }\n                    })\n                })\n                .entry(set_breakpoint_msg, None, {\n                    let weak_editor = weak_editor.clone();\n                    let breakpoint = breakpoint.clone();\n                    move |_window, cx| {\n                        weak_editor\n                            .update(cx, |this, cx| {\n                                this.edit_breakpoint_at_anchor(\n                                    anchor,\n                                    breakpoint.as_ref().clone(),\n                                    BreakpointEditAction::Toggle,\n                                    cx,\n                                );\n                            })\n                            .log_err();\n                    }\n                })\n                .entry(log_breakpoint_msg, None, {\n                    let breakpoint = breakpoint.clone();\n                    let weak_editor = weak_editor.clone();\n                    move |window, cx| {\n                        weak_editor\n                            .update(cx, |this, cx| {\n                                this.add_edit_breakpoint_block(\n                                    anchor,\n                                    breakpoint.as_ref(),\n                                    BreakpointPromptEditAction::Log,\n                                    window,\n                                    cx,\n                                );\n                            })\n                            .log_err();\n                    }\n                })\n                .entry(condition_breakpoint_msg, None, {\n                    let breakpoint = breakpoint.clone();\n                    let weak_editor = weak_editor.clone();\n                    move |window, cx| {\n                        weak_editor\n                            .update(cx, |this, cx| {\n                                this.add_edit_breakpoint_block(\n                                    anchor,\n                                    breakpoint.as_ref(),\n                                    BreakpointPromptEditAction::Condition,\n                                    window,\n                                    cx,\n                                );\n                            })\n                            .log_err();\n                    }\n                })\n                .entry(hit_condition_breakpoint_msg, None, move |window, cx| {\n                    weak_editor\n                        .update(cx, |this, cx| {\n                            this.add_edit_breakpoint_block(\n                                anchor,\n                                breakpoint.as_ref(),\n                                BreakpointPromptEditAction::HitCondition,\n                                window,\n                                cx,\n                            );\n                        })\n                        .log_err();\n                })\n        })\n    }\n\n    fn render_breakpoint(\n        &self,\n        position: Anchor,\n        row: DisplayRow,\n        breakpoint: &Breakpoint,\n        state: Option<BreakpointSessionState>,\n        cx: &mut Context<Self>,\n    ) -> IconButton {\n        let is_rejected = state.is_some_and(|s| !s.verified);\n        // Is it a breakpoint that shows up when hovering over gutter?\n        let (is_phantom, collides_with_existing) = self.gutter_breakpoint_indicator.0.map_or(\n            (false, false),\n            |PhantomBreakpointIndicator {\n                 is_active,\n                 display_row,\n                 collides_with_existing_breakpoint,\n             }| {\n                (\n                    is_active && display_row == row,\n                    collides_with_existing_breakpoint,\n                )\n            },\n        );\n\n        let (color, icon) = {\n            let icon = match (&breakpoint.message.is_some(), breakpoint.is_disabled()) {\n                (false, false) => ui::IconName::DebugBreakpoint,\n                (true, false) => ui::IconName::DebugLogBreakpoint,\n                (false, true) => ui::IconName::DebugDisabledBreakpoint,\n                (true, true) => ui::IconName::DebugDisabledLogBreakpoint,\n            };\n\n            let color = if is_phantom {\n                Color::Hint\n            } else if is_rejected {\n                Color::Disabled\n            } else {\n                Color::Debugger\n            };\n\n            (color, icon)\n        };\n\n        let breakpoint = Arc::from(breakpoint.clone());\n\n        let alt_as_text = gpui::Keystroke {\n            modifiers: Modifiers::secondary_key(),\n            ..Default::default()\n        };\n        let primary_action_text = if breakpoint.is_disabled() {\n            ": "",
        "\n        } else if is_phantom && !collides_with_existing {\n            ": "",
        "\n        };\n        let focus_handle = self.focus_handle.clone();\n\n        let meta = if is_rejected {\n            SharedString::from(": "",
        ")\n        } else if collides_with_existing && !breakpoint.is_disabled() {\n            SharedString::from(format!(\n                ": "",
        "\n            ))\n        } else {\n            SharedString::from(": "",
        ")\n        };\n        IconButton::new((": "",
        ", row.0 as usize), icon)\n            .icon_size(IconSize::XSmall)\n            .size(ui::ButtonSize::None)\n            .when(is_rejected, |this| {\n                this.indicator(Indicator::icon(Icon::new(IconName::Warning)).color(Color::Warning))\n            })\n            .icon_color(color)\n            .style(ButtonStyle::Transparent)\n            .on_click(cx.listener({\n                move |editor, event: &ClickEvent, window, cx| {\n                    let edit_action = if event.modifiers().platform || breakpoint.is_disabled() {\n                        BreakpointEditAction::InvertState\n                    } else {\n                        BreakpointEditAction::Toggle\n                    };\n\n                    window.focus(&editor.focus_handle(cx));\n                    editor.edit_breakpoint_at_anchor(\n                        position,\n                        breakpoint.as_ref().clone(),\n                        edit_action,\n                        cx,\n                    );\n                }\n            }))\n            .on_right_click(cx.listener(move |editor, event: &ClickEvent, window, cx| {\n                editor.set_breakpoint_context_menu(\n                    row,\n                    Some(position),\n                    event.position(),\n                    window,\n                    cx,\n                );\n            }))\n            .tooltip(move |_window, cx| {\n                Tooltip::with_meta_in(\n                    primary_action_text,\n                    Some(&ToggleBreakpoint),\n                    meta.clone(),\n                    &focus_handle,\n                    cx,\n                )\n            })\n    }\n\n    fn build_tasks_context(\n        project: &Entity<Project>,\n        buffer: &Entity<Buffer>,\n        buffer_row: u32,\n        tasks: &Arc<RunnableTasks>,\n        cx: &mut Context<Self>,\n    ) -> Task<Option<task::TaskContext>> {\n        let position = Point::new(buffer_row, tasks.column);\n        let range_start = buffer.read(cx).anchor_at(position, Bias::Right);\n        let location = Location {\n            buffer: buffer.clone(),\n            range: range_start..range_start,\n        };\n        // Fill in the environmental variables from the tree-sitter captures\n        let mut captured_task_variables = TaskVariables::default();\n        for (capture_name, value) in tasks.extra_variables.clone() {\n            captured_task_variables.insert(\n                task::VariableName::Custom(capture_name.into()),\n                value.clone(),\n            );\n        }\n        project.update(cx, |project, cx| {\n            project.task_store().update(cx, |task_store, cx| {\n                task_store.task_context_for_location(captured_task_variables, location, cx)\n            })\n        })\n    }\n\n    pub fn spawn_nearest_task(\n        &mut self,\n        action: &SpawnNearestTask,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let Some((workspace, _)) = self.workspace.clone() else {\n            return;\n        };\n        let Some(project) = self.project.clone() else {\n            return;\n        };\n\n        // Try to find a closest, enclosing node using tree-sitter that has a task\n        let Some((buffer, buffer_row, tasks)) = self\n            .find_enclosing_node_task(cx)\n            // Or find the task that's closest in row-distance.\n            .or_else(|| self.find_closest_task(cx))\n        else {\n            return;\n        };\n\n        let reveal_strategy = action.reveal;\n        let task_context = Self::build_tasks_context(&project, &buffer, buffer_row, &tasks, cx);\n        cx.spawn_in(window, async move |_, cx| {\n            let context = task_context.await?;\n            let (task_source_kind, mut resolved_task) = tasks.resolve(&context).next()?;\n\n            let resolved = &mut resolved_task.resolved;\n            resolved.reveal = reveal_strategy;\n\n            workspace\n                .update_in(cx, |workspace, window, cx| {\n                    workspace.schedule_resolved_task(\n                        task_source_kind,\n                        resolved_task,\n                        false,\n                        window,\n                        cx,\n                    );\n                })\n                .ok()\n        })\n        .detach();\n    }\n\n    fn find_closest_task(\n        &mut self,\n        cx: &mut Context<Self>,\n    ) -> Option<(Entity<Buffer>, u32, Arc<RunnableTasks>)> {\n        let cursor_row = self\n            .selections\n            .newest_adjusted(&self.display_snapshot(cx))\n            .head()\n            .row;\n\n        let ((buffer_id, row), tasks) = self\n            .tasks\n            .iter()\n            .min_by_key(|((_, row), _)| cursor_row.abs_diff(*row))?;\n\n        let buffer = self.buffer.read(cx).buffer(*buffer_id)?;\n        let tasks = Arc::new(tasks.to_owned());\n        Some((buffer, *row, tasks))\n    }\n\n    fn find_enclosing_node_task(\n        &mut self,\n        cx: &mut Context<Self>,\n    ) -> Option<(Entity<Buffer>, u32, Arc<RunnableTasks>)> {\n        let snapshot = self.buffer.read(cx).snapshot(cx);\n        let offset = self\n            .selections\n            .newest::<usize>(&self.display_snapshot(cx))\n            .head();\n        let excerpt = snapshot.excerpt_containing(offset..offset)?;\n        let buffer_id = excerpt.buffer().remote_id();\n\n        let layer = excerpt.buffer().syntax_layer_at(offset)?;\n        let mut cursor = layer.node().walk();\n\n        while cursor.goto_first_child_for_byte(offset).is_some() {\n            if cursor.node().end_byte() == offset {\n                cursor.goto_next_sibling();\n            }\n        }\n\n        // Ascend to the smallest ancestor that contains the range and has a task.\n        loop {\n            let node = cursor.node();\n            let node_range = node.byte_range();\n            let symbol_start_row = excerpt.buffer().offset_to_point(node.start_byte()).row;\n\n            // Check if this node contains our offset\n            if node_range.start <= offset && node_range.end >= offset {\n                // If it contains offset, check for task\n                if let Some(tasks) = self.tasks.get(&(buffer_id, symbol_start_row)) {\n                    let buffer = self.buffer.read(cx).buffer(buffer_id)?;\n                    return Some((buffer, symbol_start_row, Arc::new(tasks.to_owned())));\n                }\n            }\n\n            if !cursor.goto_parent() {\n                break;\n            }\n        }\n        None\n    }\n\n    fn render_run_indicator(\n        &self,\n        _style: &EditorStyle,\n        is_active: bool,\n        row: DisplayRow,\n        breakpoint: Option<(Anchor, Breakpoint, Option<BreakpointSessionState>)>,\n        cx: &mut Context<Self>,\n    ) -> IconButton {\n        let color = Color::Muted;\n        let position = breakpoint.as_ref().map(|(anchor, _, _)| *anchor);\n\n        IconButton::new(\n            (": "",
        ", row.0 as usize),\n            ui::IconName::PlayOutlined,\n        )\n        .shape(ui::IconButtonShape::Square)\n        .icon_size(IconSize::XSmall)\n        .icon_color(color)\n        .toggle_state(is_active)\n        .on_click(cx.listener(move |editor, e: &ClickEvent, window, cx| {\n            let quick_launch = match e {\n                ClickEvent::Keyboard(_) => true,\n                ClickEvent::Mouse(e) => e.down.button == MouseButton::Left,\n            };\n\n            window.focus(&editor.focus_handle(cx));\n            editor.toggle_code_actions(\n                &ToggleCodeActions {\n                    deployed_from: Some(CodeActionSource::RunMenu(row)),\n                    quick_launch,\n                },\n                window,\n                cx,\n            );\n        }))\n        .on_right_click(cx.listener(move |editor, event: &ClickEvent, window, cx| {\n            editor.set_breakpoint_context_menu(row, position, event.position(), window, cx);\n        }))\n    }\n\n    pub fn context_menu_visible(&self) -> bool {\n        !self.edit_prediction_preview_is_active()\n            && self\n                .context_menu\n                .borrow()\n                .as_ref()\n                .is_some_and(|menu| menu.visible())\n    }\n\n    pub fn context_menu_origin(&self) -> Option<ContextMenuOrigin> {\n        self.context_menu\n            .borrow()\n            .as_ref()\n            .map(|menu| menu.origin())\n    }\n\n    pub fn set_context_menu_options(&mut self, options: ContextMenuOptions) {\n        self.context_menu_options = Some(options);\n    }\n\n    const EDIT_PREDICTION_POPOVER_PADDING_X: Pixels = px(24.);\n    const EDIT_PREDICTION_POPOVER_PADDING_Y: Pixels = px(2.);\n\n    fn render_edit_prediction_popover(\n        &mut self,\n        text_bounds: &Bounds<Pixels>,\n        content_origin: gpui::Point<Pixels>,\n        right_margin: Pixels,\n        editor_snapshot: &EditorSnapshot,\n        visible_row_range: Range<DisplayRow>,\n        scroll_top: ScrollOffset,\n        scroll_bottom: ScrollOffset,\n        line_layouts: &[LineWithInvisibles],\n        line_height: Pixels,\n        scroll_position: gpui::Point<ScrollOffset>,\n        scroll_pixel_position: gpui::Point<ScrollPixelOffset>,\n        newest_selection_head: Option<DisplayPoint>,\n        editor_width: Pixels,\n        style: &EditorStyle,\n        window: &mut Window,\n        cx: &mut App,\n    ) -> Option<(AnyElement, gpui::Point<Pixels>)> {\n        if self.mode().is_minimap() {\n            return None;\n        }\n        let active_edit_prediction = self.active_edit_prediction.as_ref()?;\n\n        if self.edit_prediction_visible_in_cursor_popover(true) {\n            return None;\n        }\n\n        match &active_edit_prediction.completion {\n            EditPrediction::MoveWithin { target, .. } => {\n                let target_display_point = target.to_display_point(editor_snapshot);\n\n                if self.edit_prediction_requires_modifier() {\n                    if !self.edit_prediction_preview_is_active() {\n                        return None;\n                    }\n\n                    self.render_edit_prediction_modifier_jump_popover(\n                        text_bounds,\n                        content_origin,\n                        visible_row_range,\n                        line_layouts,\n                        line_height,\n                        scroll_pixel_position,\n                        newest_selection_head,\n                        target_display_point,\n                        window,\n                        cx,\n                    )\n                } else {\n                    self.render_edit_prediction_eager_jump_popover(\n                        text_bounds,\n                        content_origin,\n                        editor_snapshot,\n                        visible_row_range,\n                        scroll_top,\n                        scroll_bottom,\n                        line_height,\n                        scroll_pixel_position,\n                        target_display_point,\n                        editor_width,\n                        window,\n                        cx,\n                    )\n                }\n            }\n            EditPrediction::Edit {\n                display_mode: EditDisplayMode::Inline,\n                ..\n            } => None,\n            EditPrediction::Edit {\n                display_mode: EditDisplayMode::TabAccept,\n                edits,\n                ..\n            } => {\n                let range = &edits.first()?.0;\n                let target_display_point = range.end.to_display_point(editor_snapshot);\n\n                self.render_edit_prediction_end_of_line_popover(\n                    ": "",
        ",\n                    editor_snapshot,\n                    visible_row_range,\n                    target_display_point,\n                    line_height,\n                    scroll_pixel_position,\n                    content_origin,\n                    editor_width,\n                    window,\n                    cx,\n                )\n            }\n            EditPrediction::Edit {\n                edits,\n                edit_preview,\n                display_mode: EditDisplayMode::DiffPopover,\n                snapshot,\n            } => self.render_edit_prediction_diff_popover(\n                text_bounds,\n                content_origin,\n                right_margin,\n                editor_snapshot,\n                visible_row_range,\n                line_layouts,\n                line_height,\n                scroll_position,\n                scroll_pixel_position,\n                newest_selection_head,\n                editor_width,\n                style,\n                edits,\n                edit_preview,\n                snapshot,\n                window,\n                cx,\n            ),\n            EditPrediction::MoveOutside { snapshot, .. } => {\n                let file_name = snapshot\n                    .file()\n                    .map(|file| file.file_name(cx))\n                    .unwrap_or(": "",
        ");\n                let mut element = self\n                    .render_edit_prediction_line_popover(\n                        format!(": "",
        "),\n                        Some(IconName::ZedPredict),\n                        window,\n                        cx,\n                    )\n                    .into_any();\n\n                let size = element.layout_as_root(AvailableSpace::min_size(), window, cx);\n                let origin_x = text_bounds.size.width / 2. - size.width / 2.;\n                let origin_y = text_bounds.size.height - size.height - px(30.);\n                let origin = text_bounds.origin + gpui::Point::new(origin_x, origin_y);\n                element.prepaint_at(origin, window, cx);\n\n                Some((element, origin))\n            }\n        }\n    }\n\n    fn render_edit_prediction_modifier_jump_popover(\n        &mut self,\n        text_bounds: &Bounds<Pixels>,\n        content_origin: gpui::Point<Pixels>,\n        visible_row_range: Range<DisplayRow>,\n        line_layouts: &[LineWithInvisibles],\n        line_height: Pixels,\n        scroll_pixel_position: gpui::Point<ScrollPixelOffset>,\n        newest_selection_head: Option<DisplayPoint>,\n        target_display_point: DisplayPoint,\n        window: &mut Window,\n        cx: &mut App,\n    ) -> Option<(AnyElement, gpui::Point<Pixels>)> {\n        let scrolled_content_origin =\n            content_origin - gpui::Point::new(scroll_pixel_position.x.into(), Pixels::ZERO);\n\n        const SCROLL_PADDING_Y: Pixels = px(12.);\n\n        if target_display_point.row() < visible_row_range.start {\n            return self.render_edit_prediction_scroll_popover(\n                |_| SCROLL_PADDING_Y,\n                IconName::ArrowUp,\n                visible_row_range,\n                line_layouts,\n                newest_selection_head,\n                scrolled_content_origin,\n                window,\n                cx,\n            );\n        } else if target_display_point.row() >= visible_row_range.end {\n            return self.render_edit_prediction_scroll_popover(\n                |size| text_bounds.size.height - size.height - SCROLL_PADDING_Y,\n                IconName::ArrowDown,\n                visible_row_range,\n                line_layouts,\n                newest_selection_head,\n                scrolled_content_origin,\n                window,\n                cx,\n            );\n        }\n\n        const POLE_WIDTH: Pixels = px(2.);\n\n        let line_layout =\n            line_layouts.get(target_display_point.row().minus(visible_row_range.start) as usize)?;\n        let target_column = target_display_point.column() as usize;\n\n        let target_x = line_layout.x_for_index(target_column);\n        let target_y = (target_display_point.row().as_f64() * f64::from(line_height))\n            - scroll_pixel_position.y;\n\n        let flag_on_right = target_x < text_bounds.size.width / 2.;\n\n        let mut border_color = Self::edit_prediction_callout_popover_border_color(cx);\n        border_color.l += 0.001;\n\n        let mut element = v_flex()\n            .items_end()\n            .when(flag_on_right, |el| el.items_start())\n            .child(if flag_on_right {\n                self.render_edit_prediction_line_popover(": "",
        ", None, window, cx)\n                    .rounded_bl(px(0.))\n                    .rounded_tl(px(0.))\n                    .border_l_2()\n                    .border_color(border_color)\n            } else {\n                self.render_edit_prediction_line_popover(": "",
        ", None, window, cx)\n                    .rounded_br(px(0.))\n                    .rounded_tr(px(0.))\n                    .border_r_2()\n                    .border_color(border_color)\n            })\n            .child(div().w(POLE_WIDTH).bg(border_color).h(line_height))\n            .into_any();\n\n        let size = element.layout_as_root(AvailableSpace::min_size(), window, cx);\n\n        let mut origin = scrolled_content_origin + point(target_x, target_y.into())\n            - point(\n                if flag_on_right {\n                    POLE_WIDTH\n                } else {\n                    size.width - POLE_WIDTH\n                },\n                size.height - line_height,\n            );\n\n        origin.x = origin.x.max(content_origin.x);\n\n        element.prepaint_at(origin, window, cx);\n\n        Some((element, origin))\n    }\n\n    fn render_edit_prediction_scroll_popover(\n        &mut self,\n        to_y: impl Fn(Size<Pixels>) -> Pixels,\n        scroll_icon: IconName,\n        visible_row_range: Range<DisplayRow>,\n        line_layouts: &[LineWithInvisibles],\n        newest_selection_head: Option<DisplayPoint>,\n        scrolled_content_origin: gpui::Point<Pixels>,\n        window: &mut Window,\n        cx: &mut App,\n    ) -> Option<(AnyElement, gpui::Point<Pixels>)> {\n        let mut element = self\n            .render_edit_prediction_line_popover(": "",
        ", Some(scroll_icon), window, cx)\n            .into_any();\n\n        let size = element.layout_as_root(AvailableSpace::min_size(), window, cx);\n\n        let cursor = newest_selection_head?;\n        let cursor_row_layout =\n            line_layouts.get(cursor.row().minus(visible_row_range.start) as usize)?;\n        let cursor_column = cursor.column() as usize;\n\n        let cursor_character_x = cursor_row_layout.x_for_index(cursor_column);\n\n        let origin = scrolled_content_origin + point(cursor_character_x, to_y(size));\n\n        element.prepaint_at(origin, window, cx);\n        Some((element, origin))\n    }\n\n    fn render_edit_prediction_eager_jump_popover(\n        &mut self,\n        text_bounds: &Bounds<Pixels>,\n        content_origin: gpui::Point<Pixels>,\n        editor_snapshot: &EditorSnapshot,\n        visible_row_range: Range<DisplayRow>,\n        scroll_top: ScrollOffset,\n        scroll_bottom: ScrollOffset,\n        line_height: Pixels,\n        scroll_pixel_position: gpui::Point<ScrollPixelOffset>,\n        target_display_point: DisplayPoint,\n        editor_width: Pixels,\n        window: &mut Window,\n        cx: &mut App,\n    ) -> Option<(AnyElement, gpui::Point<Pixels>)> {\n        if target_display_point.row().as_f64() < scroll_top {\n            let mut element = self\n                .render_edit_prediction_line_popover(\n                    ": "",
        ",\n                    Some(IconName::ArrowUp),\n                    window,\n                    cx,\n                )\n                .into_any();\n\n            let size = element.layout_as_root(AvailableSpace::min_size(), window, cx);\n            let offset = point(\n                (text_bounds.size.width - size.width) / 2.,\n                Self::EDIT_PREDICTION_POPOVER_PADDING_Y,\n            );\n\n            let origin = text_bounds.origin + offset;\n            element.prepaint_at(origin, window, cx);\n            Some((element, origin))\n        } else if (target_display_point.row().as_f64() + 1.) > scroll_bottom {\n            let mut element = self\n                .render_edit_prediction_line_popover(\n                    ": "",
        ",\n                    Some(IconName::ArrowDown),\n                    window,\n                    cx,\n                )\n                .into_any();\n\n            let size = element.layout_as_root(AvailableSpace::min_size(), window, cx);\n            let offset = point(\n                (text_bounds.size.width - size.width) / 2.,\n                text_bounds.size.height - size.height - Self::EDIT_PREDICTION_POPOVER_PADDING_Y,\n            );\n\n            let origin = text_bounds.origin + offset;\n            element.prepaint_at(origin, window, cx);\n            Some((element, origin))\n        } else {\n            self.render_edit_prediction_end_of_line_popover(\n                ": "",
        ",\n                editor_snapshot,\n                visible_row_range,\n                target_display_point,\n                line_height,\n                scroll_pixel_position,\n                content_origin,\n                editor_width,\n                window,\n                cx,\n            )\n        }\n    }\n\n    fn render_edit_prediction_end_of_line_popover(\n        self: &mut Editor,\n        label: &'static str,\n        editor_snapshot: &EditorSnapshot,\n        visible_row_range: Range<DisplayRow>,\n        target_display_point: DisplayPoint,\n        line_height: Pixels,\n        scroll_pixel_position: gpui::Point<ScrollPixelOffset>,\n        content_origin: gpui::Point<Pixels>,\n        editor_width: Pixels,\n        window: &mut Window,\n        cx: &mut App,\n    ) -> Option<(AnyElement, gpui::Point<Pixels>)> {\n        let target_line_end = DisplayPoint::new(\n            target_display_point.row(),\n            editor_snapshot.line_len(target_display_point.row()),\n        );\n\n        let mut element = self\n            .render_edit_prediction_line_popover(label, None, window, cx)\n            .into_any();\n\n        let size = element.layout_as_root(AvailableSpace::min_size(), window, cx);\n\n        let line_origin = self.display_to_pixel_point(target_line_end, editor_snapshot, window)?;\n\n        let start_point = content_origin - point(scroll_pixel_position.x.into(), Pixels::ZERO);\n        let mut origin = start_point\n            + line_origin\n            + point(Self::EDIT_PREDICTION_POPOVER_PADDING_X, Pixels::ZERO);\n        origin.x = origin.x.max(content_origin.x);\n\n        let max_x = content_origin.x + editor_width - size.width;\n\n        if origin.x > max_x {\n            let offset = line_height + Self::EDIT_PREDICTION_POPOVER_PADDING_Y;\n\n            let icon = if visible_row_range.contains(&(target_display_point.row() + 2)) {\n                origin.y += offset;\n                IconName::ArrowUp\n            } else {\n                origin.y -= offset;\n                IconName::ArrowDown\n            };\n\n            element = self\n                .render_edit_prediction_line_popover(label, Some(icon), window, cx)\n                .into_any();\n\n            let size = element.layout_as_root(AvailableSpace::min_size(), window, cx);\n\n            origin.x = content_origin.x + editor_width - size.width - px(2.);\n        }\n\n        element.prepaint_at(origin, window, cx);\n        Some((element, origin))\n    }\n\n    fn render_edit_prediction_diff_popover(\n        self: &Editor,\n        text_bounds: &Bounds<Pixels>,\n        content_origin: gpui::Point<Pixels>,\n        right_margin: Pixels,\n        editor_snapshot: &EditorSnapshot,\n        visible_row_range: Range<DisplayRow>,\n        line_layouts: &[LineWithInvisibles],\n        line_height: Pixels,\n        scroll_position: gpui::Point<ScrollOffset>,\n        scroll_pixel_position: gpui::Point<ScrollPixelOffset>,\n        newest_selection_head: Option<DisplayPoint>,\n        editor_width: Pixels,\n        style: &EditorStyle,\n        edits: &Vec<(Range<Anchor>, Arc<str>)>,\n        edit_preview: &Option<language::EditPreview>,\n        snapshot: &language::BufferSnapshot,\n        window: &mut Window,\n        cx: &mut App,\n    ) -> Option<(AnyElement, gpui::Point<Pixels>)> {\n        let edit_start = edits\n            .first()\n            .unwrap()\n            .0\n            .start\n            .to_display_point(editor_snapshot);\n        let edit_end = edits\n            .last()\n            .unwrap()\n            .0\n            .end\n            .to_display_point(editor_snapshot);\n\n        let is_visible = visible_row_range.contains(&edit_start.row())\n            || visible_row_range.contains(&edit_end.row());\n        if !is_visible {\n            return None;\n        }\n\n        let highlighted_edits = if let Some(edit_preview) = edit_preview.as_ref() {\n            crate::edit_prediction_edit_text(snapshot, edits, edit_preview, false, cx)\n        } else {\n            // Fallback for providers without edit_preview\n            crate::edit_prediction_fallback_text(edits, cx)\n        };\n\n        let styled_text = highlighted_edits.to_styled_text(&style.text);\n        let line_count = highlighted_edits.text.lines().count();\n\n        const BORDER_WIDTH: Pixels = px(1.);\n\n        let keybind = self.render_edit_prediction_accept_keybind(window, cx);\n        let has_keybind = keybind.is_some();\n\n        let mut element = h_flex()\n            .items_start()\n            .child(\n                h_flex()\n                    .bg(cx.theme().colors().editor_background)\n                    .border(BORDER_WIDTH)\n                    .shadow_xs()\n                    .border_color(cx.theme().colors().border)\n                    .rounded_l_lg()\n                    .when(line_count > 1, |el| el.rounded_br_lg())\n                    .pr_1()\n                    .child(styled_text),\n            )\n            .child(\n                h_flex()\n                    .h(line_height + BORDER_WIDTH * 2.)\n                    .px_1p5()\n                    .gap_1()\n                    // Workaround: For some reason, there's a gap if we don't do this\n                    .ml(-BORDER_WIDTH)\n                    .shadow(vec![gpui::BoxShadow {\n                        color: gpui::black().opacity(0.05),\n                        offset: point(px(1.), px(1.)),\n                        blur_radius: px(2.),\n                        spread_radius: px(0.),\n                    }])\n                    .bg(Editor::edit_prediction_line_popover_bg_color(cx))\n                    .border(BORDER_WIDTH)\n                    .border_color(cx.theme().colors().border)\n                    .rounded_r_lg()\n                    .id(": "",
        ")\n                    .when(!has_keybind, |el| {\n                        let status_colors = cx.theme().status();\n\n                        el.bg(status_colors.error_background)\n                            .border_color(status_colors.error.opacity(0.6))\n                            .child(Icon::new(IconName::Info).color(Color::Error))\n                            .cursor_default()\n                            .hoverable_tooltip(move |_window, cx| {\n                                cx.new(|_| MissingEditPredictionKeybindingTooltip).into()\n                            })\n                    })\n                    .children(keybind),\n            )\n            .into_any();\n\n        let longest_row =\n            editor_snapshot.longest_row_in_range(edit_start.row()..edit_end.row() + 1);\n        let longest_line_width = if visible_row_range.contains(&longest_row) {\n            line_layouts[(longest_row.0 - visible_row_range.start.0) as usize].width\n        } else {\n            layout_line(\n                longest_row,\n                editor_snapshot,\n                style,\n                editor_width,\n                |_| false,\n                window,\n                cx,\n            )\n            .width\n        };\n\n        let viewport_bounds =\n            Bounds::new(Default::default(), window.viewport_size()).extend(Edges {\n                right: -right_margin,\n                ..Default::default()\n            });\n\n        let x_after_longest = Pixels::from(\n            ScrollPixelOffset::from(\n                text_bounds.origin.x + longest_line_width + Self::EDIT_PREDICTION_POPOVER_PADDING_X,\n            ) - scroll_pixel_position.x,\n        );\n\n        let element_bounds = element.layout_as_root(AvailableSpace::min_size(), window, cx);\n\n        // Fully visible if it can be displayed within the window (allow overlapping other\n        // panes). However, this is only allowed if the popover starts within text_bounds.\n        let can_position_to_the_right = x_after_longest < text_bounds.right()\n            && x_after_longest + element_bounds.width < viewport_bounds.right();\n\n        let mut origin = if can_position_to_the_right {\n            point(\n                x_after_longest,\n                text_bounds.origin.y\n                    + Pixels::from(\n                        edit_start.row().as_f64() * ScrollPixelOffset::from(line_height)\n                            - scroll_pixel_position.y,\n                    ),\n            )\n        } else {\n            let cursor_row = newest_selection_head.map(|head| head.row());\n            let above_edit = edit_start\n                .row()\n                .0\n                .checked_sub(line_count as u32)\n                .map(DisplayRow);\n            let below_edit = Some(edit_end.row() + 1);\n            let above_cursor =\n                cursor_row.and_then(|row| row.0.checked_sub(line_count as u32).map(DisplayRow));\n            let below_cursor = cursor_row.map(|cursor_row| cursor_row + 1);\n\n            // Place the edit popover adjacent to the edit if there is a location\n            // available that is onscreen and does not obscure the cursor. Otherwise,\n            // place it adjacent to the cursor.\n            let row_target = [above_edit, below_edit, above_cursor, below_cursor]\n                .into_iter()\n                .flatten()\n                .find(|&start_row| {\n                    let end_row = start_row + line_count as u32;\n                    visible_row_range.contains(&start_row)\n                        && visible_row_range.contains(&end_row)\n                        && cursor_row\n                            .is_none_or(|cursor_row| !((start_row..end_row).contains(&cursor_row)))\n                })?;\n\n            content_origin\n                + point(\n                    Pixels::from(-scroll_pixel_position.x),\n                    Pixels::from(\n                        (row_target.as_f64() - scroll_position.y) * f64::from(line_height),\n                    ),\n                )\n        };\n\n        origin.x -= BORDER_WIDTH;\n\n        window.defer_draw(element, origin, 1);\n\n        // Do not return an element, since it will already be drawn due to defer_draw.\n        None\n    }\n\n    fn edit_prediction_cursor_popover_height(&self) -> Pixels {\n        px(30.)\n    }\n\n    fn current_user_player_color(&self, cx: &mut App) -> PlayerColor {\n        if self.read_only(cx) {\n            cx.theme().players().read_only()\n        } else {\n            self.style.as_ref().unwrap().local_player\n        }\n    }\n\n    fn render_edit_prediction_accept_keybind(\n        &self,\n        window: &mut Window,\n        cx: &mut App,\n    ) -> Option<AnyElement> {\n        let accept_binding = self.accept_edit_prediction_keybind(false, window, cx);\n        let accept_keystroke = accept_binding.keystroke()?;\n\n        let is_platform_style_mac = PlatformStyle::platform() == PlatformStyle::Mac;\n\n        let modifiers_color = if *accept_keystroke.modifiers() == window.modifiers() {\n            Color::Accent\n        } else {\n            Color::Muted\n        };\n\n        h_flex()\n            .px_0p5()\n            .when(is_platform_style_mac, |parent| parent.gap_0p5())\n            .font(theme::ThemeSettings::get_global(cx).buffer_font.clone())\n            .text_size(TextSize::XSmall.rems(cx))\n            .child(h_flex().children(ui::render_modifiers(\n                accept_keystroke.modifiers(),\n                PlatformStyle::platform(),\n                Some(modifiers_color),\n                Some(IconSize::XSmall.rems().into()),\n                true,\n            )))\n            .when(is_platform_style_mac, |parent| {\n                parent.child(accept_keystroke.key().to_string())\n            })\n            .when(!is_platform_style_mac, |parent| {\n                parent.child(\n                    Key::new(\n                        util::capitalize(accept_keystroke.key()),\n                        Some(Color::Default),\n                    )\n                    .size(Some(IconSize::XSmall.rems().into())),\n                )\n            })\n            .into_any()\n            .into()\n    }\n\n    fn render_edit_prediction_line_popover(\n        &self,\n        label: impl Into<SharedString>,\n        icon: Option<IconName>,\n        window: &mut Window,\n        cx: &mut App,\n    ) -> Stateful<Div> {\n        let padding_right = if icon.is_some() { px(4.) } else { px(8.) };\n\n        let keybind = self.render_edit_prediction_accept_keybind(window, cx);\n        let has_keybind = keybind.is_some();\n\n        h_flex()\n            .id(": "",
        ")\n            .py_0p5()\n            .pl_1()\n            .pr(padding_right)\n            .gap_1()\n            .rounded_md()\n            .border_1()\n            .bg(Self::edit_prediction_line_popover_bg_color(cx))\n            .border_color(Self::edit_prediction_callout_popover_border_color(cx))\n            .shadow_xs()\n            .when(!has_keybind, |el| {\n                let status_colors = cx.theme().status();\n\n                el.bg(status_colors.error_background)\n                    .border_color(status_colors.error.opacity(0.6))\n                    .pl_2()\n                    .child(Icon::new(IconName::ZedPredictError).color(Color::Error))\n                    .cursor_default()\n                    .hoverable_tooltip(move |_window, cx| {\n                        cx.new(|_| MissingEditPredictionKeybindingTooltip).into()\n                    })\n            })\n            .children(keybind)\n            .child(\n                Label::new(label)\n                    .size(LabelSize::Small)\n                    .when(!has_keybind, |el| {\n                        el.color(cx.theme().status().error.into()).strikethrough()\n                    }),\n            )\n            .when(!has_keybind, |el| {\n                el.child(\n                    h_flex().ml_1().child(\n                        Icon::new(IconName::Info)\n                            .size(IconSize::Small)\n                            .color(cx.theme().status().error.into()),\n                    ),\n                )\n            })\n            .when_some(icon, |element, icon| {\n                element.child(\n                    div()\n                        .mt(px(1.5))\n                        .child(Icon::new(icon).size(IconSize::Small)),\n                )\n            })\n    }\n\n    fn edit_prediction_line_popover_bg_color(cx: &App) -> Hsla {\n        let accent_color = cx.theme().colors().text_accent;\n        let editor_bg_color = cx.theme().colors().editor_background;\n        editor_bg_color.blend(accent_color.opacity(0.1))\n    }\n\n    fn edit_prediction_callout_popover_border_color(cx: &App) -> Hsla {\n        let accent_color = cx.theme().colors().text_accent;\n        let editor_bg_color = cx.theme().colors().editor_background;\n        editor_bg_color.blend(accent_color.opacity(0.6))\n    }\n    fn get_prediction_provider_icon_name(\n        provider: &Option<RegisteredEditPredictionProvider>,\n    ) -> IconName {\n        match provider {\n            Some(provider) => match provider.provider.name() {\n                ": "",
        " => IconName::Copilot,\n                ": "",
        " => IconName::Supermaven,\n                _ => IconName::ZedPredict,\n            },\n            None => IconName::ZedPredict,\n        }\n    }\n\n    fn render_edit_prediction_cursor_popover(\n        &self,\n        min_width: Pixels,\n        max_width: Pixels,\n        cursor_point: Point,\n        style: &EditorStyle,\n        accept_keystroke: Option<&gpui::KeybindingKeystroke>,\n        _window: &Window,\n        cx: &mut Context<Editor>,\n    ) -> Option<AnyElement> {\n        let provider = self.edit_prediction_provider.as_ref()?;\n        let provider_icon = Self::get_prediction_provider_icon_name(&self.edit_prediction_provider);\n\n        let is_refreshing = provider.provider.is_refreshing(cx);\n\n        fn pending_completion_container(icon: IconName) -> Div {\n            h_flex().h_full().flex_1().gap_2().child(Icon::new(icon))\n        }\n\n        let completion = match &self.active_edit_prediction {\n            Some(prediction) => {\n                if !self.has_visible_completions_menu() {\n                    const RADIUS: Pixels = px(6.);\n                    const BORDER_WIDTH: Pixels = px(1.);\n\n                    return Some(\n                        h_flex()\n                            .elevation_2(cx)\n                            .border(BORDER_WIDTH)\n                            .border_color(cx.theme().colors().border)\n                            .when(accept_keystroke.is_none(), |el| {\n                                el.border_color(cx.theme().status().error)\n                            })\n                            .rounded(RADIUS)\n                            .rounded_tl(px(0.))\n                            .overflow_hidden()\n                            .child(div().px_1p5().child(match &prediction.completion {\n                                EditPrediction::MoveWithin { target, snapshot } => {\n                                    use text::ToPoint as _;\n                                    if target.text_anchor.to_point(snapshot).row > cursor_point.row\n                                    {\n                                        Icon::new(IconName::ZedPredictDown)\n                                    } else {\n                                        Icon::new(IconName::ZedPredictUp)\n                                    }\n                                }\n                                EditPrediction::MoveOutside { .. } => {\n                                    // TODO [zeta2] custom icon for external jump?\n                                    Icon::new(provider_icon)\n                                }\n                                EditPrediction::Edit { .. } => Icon::new(provider_icon),\n                            }))\n                            .child(\n                                h_flex()\n                                    .gap_1()\n                                    .py_1()\n                                    .px_2()\n                                    .rounded_r(RADIUS - BORDER_WIDTH)\n                                    .border_l_1()\n                                    .border_color(cx.theme().colors().border)\n                                    .bg(Self::edit_prediction_line_popover_bg_color(cx))\n                                    .when(self.edit_prediction_preview.released_too_fast(), |el| {\n                                        el.child(\n                                            Label::new(": "",
        ")\n                                                .size(LabelSize::Small)\n                                                .when(accept_keystroke.is_none(), |el| {\n                                                    el.strikethrough()\n                                                })\n                                                .line_height_style(LineHeightStyle::UiLabel),\n                                        )\n                                    })\n                                    .id(": "",
        ")\n                                    .when(accept_keystroke.is_none(), |el| {\n                                        let status_colors = cx.theme().status();\n\n                                        el.bg(status_colors.error_background)\n                                            .border_color(status_colors.error.opacity(0.6))\n                                            .child(Icon::new(IconName::Info).color(Color::Error))\n                                            .cursor_default()\n                                            .hoverable_tooltip(move |_window, cx| {\n                                                cx.new(|_| MissingEditPredictionKeybindingTooltip)\n                                                    .into()\n                                            })\n                                    })\n                                    .when_some(\n                                        accept_keystroke.as_ref(),\n                                        |el, accept_keystroke| {\n                                            el.child(h_flex().children(ui::render_modifiers(\n                                                accept_keystroke.modifiers(),\n                                                PlatformStyle::platform(),\n                                                Some(Color::Default),\n                                                Some(IconSize::XSmall.rems().into()),\n                                                false,\n                                            )))\n                                        },\n                                    ),\n                            )\n                            .into_any(),\n                    );\n                }\n\n                self.render_edit_prediction_cursor_popover_preview(\n                    prediction,\n                    cursor_point,\n                    style,\n                    cx,\n                )?\n            }\n\n            None if is_refreshing => match &self.stale_edit_prediction_in_menu {\n                Some(stale_completion) => self.render_edit_prediction_cursor_popover_preview(\n                    stale_completion,\n                    cursor_point,\n                    style,\n                    cx,\n                )?,\n\n                None => pending_completion_container(provider_icon)\n                    .child(Label::new(": "",
        ").size(LabelSize::Small)),\n            },\n\n            None => pending_completion_container(provider_icon)\n                .child(Label::new(": "",
        ").size(LabelSize::Small)),\n        };\n\n        let completion = if is_refreshing || self.active_edit_prediction.is_none() {\n            completion\n                .with_animation(\n                    ": "",
        ",\n                    Animation::new(Duration::from_secs(2))\n                        .repeat()\n                        .with_easing(pulsating_between(0.4, 0.8)),\n                    |label, delta| label.opacity(delta),\n                )\n                .into_any_element()\n        } else {\n            completion.into_any_element()\n        };\n\n        let has_completion = self.active_edit_prediction.is_some();\n\n        let is_platform_style_mac = PlatformStyle::platform() == PlatformStyle::Mac;\n        Some(\n            h_flex()\n                .min_w(min_width)\n                .max_w(max_width)\n                .flex_1()\n                .elevation_2(cx)\n                .border_color(cx.theme().colors().border)\n                .child(\n                    div()\n                        .flex_1()\n                        .py_1()\n                        .px_2()\n                        .overflow_hidden()\n                        .child(completion),\n                )\n                .when_some(accept_keystroke, |el, accept_keystroke| {\n                    if !accept_keystroke.modifiers().modified() {\n                        return el;\n                    }\n\n                    el.child(\n                        h_flex()\n                            .h_full()\n                            .border_l_1()\n                            .rounded_r_lg()\n                            .border_color(cx.theme().colors().border)\n                            .bg(Self::edit_prediction_line_popover_bg_color(cx))\n                            .gap_1()\n                            .py_1()\n                            .px_2()\n                            .child(\n                                h_flex()\n                                    .font(theme::ThemeSettings::get_global(cx).buffer_font.clone())\n                                    .when(is_platform_style_mac, |parent| parent.gap_1())\n                                    .child(h_flex().children(ui::render_modifiers(\n                                        accept_keystroke.modifiers(),\n                                        PlatformStyle::platform(),\n                                        Some(if !has_completion {\n                                            Color::Muted\n                                        } else {\n                                            Color::Default\n                                        }),\n                                        None,\n                                        false,\n                                    ))),\n                            )\n                            .child(Label::new(": "",
        ").into_any_element())\n                            .opacity(if has_completion { 1.0 } else { 0.4 }),\n                    )\n                })\n                .into_any(),\n        )\n    }\n\n    fn render_edit_prediction_cursor_popover_preview(\n        &self,\n        completion: &EditPredictionState,\n        cursor_point: Point,\n        style: &EditorStyle,\n        cx: &mut Context<Editor>,\n    ) -> Option<Div> {\n        use text::ToPoint as _;\n\n        fn render_relative_row_jump(\n            prefix: impl Into<String>,\n            current_row: u32,\n            target_row: u32,\n        ) -> Div {\n            let (row_diff, arrow) = if target_row < current_row {\n                (current_row - target_row, IconName::ArrowUp)\n            } else {\n                (target_row - current_row, IconName::ArrowDown)\n            };\n\n            h_flex()\n                .child(\n                    Label::new(format!(": "",
        ", prefix.into(), row_diff))\n                        .color(Color::Muted)\n                        .size(LabelSize::Small),\n                )\n                .child(Icon::new(arrow).color(Color::Muted).size(IconSize::Small))\n        }\n\n        let supports_jump = self\n            .edit_prediction_provider\n            .as_ref()\n            .map(|provider| provider.provider.supports_jump_to_edit())\n            .unwrap_or(true);\n\n        match &completion.completion {\n            EditPrediction::MoveWithin {\n                target, snapshot, ..\n            } => {\n                if !supports_jump {\n                    return None;\n                }\n\n                Some(\n                    h_flex()\n                        .px_2()\n                        .gap_2()\n                        .flex_1()\n                        .child(\n                            if target.text_anchor.to_point(snapshot).row > cursor_point.row {\n                                Icon::new(IconName::ZedPredictDown)\n                            } else {\n                                Icon::new(IconName::ZedPredictUp)\n                            },\n                        )\n                        .child(Label::new(": "",
        ")),\n                )\n            }\n            EditPrediction::MoveOutside { snapshot, .. } => {\n                let file_name = snapshot\n                    .file()\n                    .map(|file| file.file_name(cx))\n                    .unwrap_or(": "",
        ");\n                Some(\n                    h_flex()\n                        .px_2()\n                        .gap_2()\n                        .flex_1()\n                        .child(Icon::new(IconName::ZedPredict))\n                        .child(Label::new(format!(": "",
        "))),\n                )\n            }\n            EditPrediction::Edit {\n                edits,\n                edit_preview,\n                snapshot,\n                display_mode: _,\n            } => {\n                let first_edit_row = edits.first()?.0.start.text_anchor.to_point(snapshot).row;\n\n                let (highlighted_edits, has_more_lines) =\n                    if let Some(edit_preview) = edit_preview.as_ref() {\n                        crate::edit_prediction_edit_text(snapshot, edits, edit_preview, true, cx)\n                            .first_line_preview()\n                    } else {\n                        crate::edit_prediction_fallback_text(edits, cx).first_line_preview()\n                    };\n\n                let styled_text = gpui::StyledText::new(highlighted_edits.text)\n                    .with_default_highlights(&style.text, highlighted_edits.highlights);\n\n                let preview = h_flex()\n                    .gap_1()\n                    .min_w_16()\n                    .child(styled_text)\n                    .when(has_more_lines, |parent| parent.child(": "",
        "));\n\n                let left = if supports_jump && first_edit_row != cursor_point.row {\n                    render_relative_row_jump(": "",
        ", cursor_point.row, first_edit_row)\n                        .into_any_element()\n                } else {\n                    let icon_name =\n                        Editor::get_prediction_provider_icon_name(&self.edit_prediction_provider);\n                    Icon::new(icon_name).into_any_element()\n                };\n\n                Some(\n                    h_flex()\n                        .h_full()\n                        .flex_1()\n                        .gap_2()\n                        .pr_1()\n                        .overflow_x_hidden()\n                        .font(theme::ThemeSettings::get_global(cx).buffer_font.clone())\n                        .child(left)\n                        .child(preview),\n                )\n            }\n        }\n    }\n\n    pub fn render_context_menu(\n        &self,\n        style: &EditorStyle,\n        max_height_in_lines: u32,\n        window: &mut Window,\n        cx: &mut Context<Editor>,\n    ) -> Option<AnyElement> {\n        let menu = self.context_menu.borrow();\n        let menu = menu.as_ref()?;\n        if !menu.visible() {\n            return None;\n        };\n        Some(menu.render(style, max_height_in_lines, window, cx))\n    }\n\n    fn render_context_menu_aside(\n        &mut self,\n        max_size: Size<Pixels>,\n        window: &mut Window,\n        cx: &mut Context<Editor>,\n    ) -> Option<AnyElement> {\n        self.context_menu.borrow_mut().as_mut().and_then(|menu| {\n            if menu.visible() {\n                menu.render_aside(max_size, window, cx)\n            } else {\n                None\n            }\n        })\n    }\n\n    fn hide_context_menu(\n        &mut self,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<CodeContextMenu> {\n        cx.notify();\n        self.completion_tasks.clear();\n        let context_menu = self.context_menu.borrow_mut().take();\n        self.stale_edit_prediction_in_menu.take();\n        self.update_visible_edit_prediction(window, cx);\n        if let Some(CodeContextMenu::Completions(_)) = &context_menu\n            && let Some(completion_provider) = &self.completion_provider\n        {\n            completion_provider.selection_changed(None, window, cx);\n        }\n        context_menu\n    }\n\n    fn show_snippet_choices(\n        &mut self,\n        choices: &Vec<String>,\n        selection: Range<Anchor>,\n        cx: &mut Context<Self>,\n    ) {\n        let Some((_, buffer, _)) = self\n            .buffer()\n            .read(cx)\n            .excerpt_containing(selection.start, cx)\n        else {\n            return;\n        };\n        let Some((_, end_buffer, _)) = self.buffer().read(cx).excerpt_containing(selection.end, cx)\n        else {\n            return;\n        };\n        if buffer != end_buffer {\n            log::error!(": "",
        ");\n            return;\n        }\n\n        let id = post_inc(&mut self.next_completion_id);\n        let snippet_sort_order = EditorSettings::get_global(cx).snippet_sort_order;\n        *self.context_menu.borrow_mut() = Some(CodeContextMenu::Completions(\n            CompletionsMenu::new_snippet_choices(\n                id,\n                true,\n                choices,\n                selection,\n                buffer,\n                snippet_sort_order,\n            ),\n        ));\n    }\n\n    pub fn insert_snippet(\n        &mut self,\n        insertion_ranges: &[Range<usize>],\n        snippet: Snippet,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Result<()> {\n        struct Tabstop<T> {\n            is_end_tabstop: bool,\n            ranges: Vec<Range<T>>,\n            choices: Option<Vec<String>>,\n        }\n\n        let tabstops = self.buffer.update(cx, |buffer, cx| {\n            let snippet_text: Arc<str> = snippet.text.clone().into();\n            let edits = insertion_ranges\n                .iter()\n                .cloned()\n                .map(|range| (range, snippet_text.clone()));\n            let autoindent_mode = AutoindentMode::Block {\n                original_indent_columns: Vec::new(),\n            };\n            buffer.edit(edits, Some(autoindent_mode), cx);\n\n            let snapshot = &*buffer.read(cx);\n            let snippet = &snippet;\n            snippet\n                .tabstops\n                .iter()\n                .map(|tabstop| {\n                    let is_end_tabstop = tabstop.ranges.first().is_some_and(|tabstop| {\n                        tabstop.is_empty() && tabstop.start == snippet.text.len() as isize\n                    });\n                    let mut tabstop_ranges = tabstop\n                        .ranges\n                        .iter()\n                        .flat_map(|tabstop_range| {\n                            let mut delta = 0_isize;\n                            insertion_ranges.iter().map(move |insertion_range| {\n                                let insertion_start = insertion_range.start as isize + delta;\n                                delta +=\n                                    snippet.text.len() as isize - insertion_range.len() as isize;\n\n                                let start = ((insertion_start + tabstop_range.start) as usize)\n                                    .min(snapshot.len());\n                                let end = ((insertion_start + tabstop_range.end) as usize)\n                                    .min(snapshot.len());\n                                snapshot.anchor_before(start)..snapshot.anchor_after(end)\n                            })\n                        })\n                        .collect::<Vec<_>>();\n                    tabstop_ranges.sort_unstable_by(|a, b| a.start.cmp(&b.start, snapshot));\n\n                    Tabstop {\n                        is_end_tabstop,\n                        ranges: tabstop_ranges,\n                        choices: tabstop.choices.clone(),\n                    }\n                })\n                .collect::<Vec<_>>()\n        });\n        if let Some(tabstop) = tabstops.first() {\n            self.change_selections(Default::default(), window, cx, |s| {\n                // Reverse order so that the first range is the newest created selection.\n                // Completions will use it and autoscroll will prioritize it.\n                s.select_ranges(tabstop.ranges.iter().rev().cloned());\n            });\n\n            if let Some(choices) = &tabstop.choices\n                && let Some(selection) = tabstop.ranges.first()\n            {\n                self.show_snippet_choices(choices, selection.clone(), cx)\n            }\n\n            // If we're already at the last tabstop and it's at the end of the snippet,\n            // we're done, we don't need to keep the state around.\n            if !tabstop.is_end_tabstop {\n                let choices = tabstops\n                    .iter()\n                    .map(|tabstop| tabstop.choices.clone())\n                    .collect();\n\n                let ranges = tabstops\n                    .into_iter()\n                    .map(|tabstop| tabstop.ranges)\n                    .collect::<Vec<_>>();\n\n                self.snippet_stack.push(SnippetState {\n                    active_index: 0,\n                    ranges,\n                    choices,\n                });\n            }\n\n            // Check whether the just-entered snippet ends with an auto-closable bracket.\n            if self.autoclose_regions.is_empty() {\n                let snapshot = self.buffer.read(cx).snapshot(cx);\n                for selection in &mut self.selections.all::<Point>(&self.display_snapshot(cx)) {\n                    let selection_head = selection.head();\n                    let Some(scope) = snapshot.language_scope_at(selection_head) else {\n                        continue;\n                    };\n\n                    let mut bracket_pair = None;\n                    let max_lookup_length = scope\n                        .brackets()\n                        .map(|(pair, _)| {\n                            pair.start\n                                .as_str()\n                                .chars()\n                                .count()\n                                .max(pair.end.as_str().chars().count())\n                        })\n                        .max();\n                    if let Some(max_lookup_length) = max_lookup_length {\n                        let next_text = snapshot\n                            .chars_at(selection_head)\n                            .take(max_lookup_length)\n                            .collect::<String>();\n                        let prev_text = snapshot\n                            .reversed_chars_at(selection_head)\n                            .take(max_lookup_length)\n                            .collect::<String>();\n\n                        for (pair, enabled) in scope.brackets() {\n                            if enabled\n                                && pair.close\n                                && prev_text.starts_with(pair.start.as_str())\n                                && next_text.starts_with(pair.end.as_str())\n                            {\n                                bracket_pair = Some(pair.clone());\n                                break;\n                            }\n                        }\n                    }\n\n                    if let Some(pair) = bracket_pair {\n                        let snapshot_settings = snapshot.language_settings_at(selection_head, cx);\n                        let autoclose_enabled =\n                            self.use_autoclose && snapshot_settings.use_autoclose;\n                        if autoclose_enabled {\n                            let start = snapshot.anchor_after(selection_head);\n                            let end = snapshot.anchor_after(selection_head);\n                            self.autoclose_regions.push(AutocloseRegion {\n                                selection_id: selection.id,\n                                range: start..end,\n                                pair,\n                            });\n                        }\n                    }\n                }\n            }\n        }\n        Ok(())\n    }\n\n    pub fn move_to_next_snippet_tabstop(\n        &mut self,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> bool {\n        self.move_to_snippet_tabstop(Bias::Right, window, cx)\n    }\n\n    pub fn move_to_prev_snippet_tabstop(\n        &mut self,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> bool {\n        self.move_to_snippet_tabstop(Bias::Left, window, cx)\n    }\n\n    pub fn move_to_snippet_tabstop(\n        &mut self,\n        bias: Bias,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> bool {\n        if let Some(mut snippet) = self.snippet_stack.pop() {\n            match bias {\n                Bias::Left => {\n                    if snippet.active_index > 0 {\n                        snippet.active_index -= 1;\n                    } else {\n                        self.snippet_stack.push(snippet);\n                        return false;\n                    }\n                }\n                Bias::Right => {\n                    if snippet.active_index + 1 < snippet.ranges.len() {\n                        snippet.active_index += 1;\n                    } else {\n                        self.snippet_stack.push(snippet);\n                        return false;\n                    }\n                }\n            }\n            if let Some(current_ranges) = snippet.ranges.get(snippet.active_index) {\n                self.change_selections(Default::default(), window, cx, |s| {\n                    // Reverse order so that the first range is the newest created selection.\n                    // Completions will use it and autoscroll will prioritize it.\n                    s.select_ranges(current_ranges.iter().rev().cloned())\n                });\n\n                if let Some(choices) = &snippet.choices[snippet.active_index]\n                    && let Some(selection) = current_ranges.first()\n                {\n                    self.show_snippet_choices(choices, selection.clone(), cx);\n                }\n\n                // If snippet state is not at the last tabstop, push it back on the stack\n                if snippet.active_index + 1 < snippet.ranges.len() {\n                    self.snippet_stack.push(snippet);\n                }\n                return true;\n            }\n        }\n\n        false\n    }\n\n    pub fn clear(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n        self.transact(window, cx, |this, window, cx| {\n            this.select_all(&SelectAll, window, cx);\n            this.insert(": "",
        ", window, cx);\n        });\n    }\n\n    pub fn backspace(&mut self, _: &Backspace, window: &mut Window, cx: &mut Context<Self>) {\n        if self.read_only(cx) {\n            return;\n        }\n        self.hide_mouse_cursor(HideMouseCursorOrigin::TypingAction, cx);\n        self.transact(window, cx, |this, window, cx| {\n            this.select_autoclose_pair(window, cx);\n\n            let display_map = this.display_map.update(cx, |map, cx| map.snapshot(cx));\n\n            let mut linked_ranges = HashMap::<_, Vec<_>>::default();\n            if !this.linked_edit_ranges.is_empty() {\n                let selections = this.selections.all::<MultiBufferPoint>(&display_map);\n                let snapshot = this.buffer.read(cx).snapshot(cx);\n\n                for selection in selections.iter() {\n                    let selection_start = snapshot.anchor_before(selection.start).text_anchor;\n                    let selection_end = snapshot.anchor_after(selection.end).text_anchor;\n                    if selection_start.buffer_id != selection_end.buffer_id {\n                        continue;\n                    }\n                    if let Some(ranges) =\n                        this.linked_editing_ranges_for(selection_start..selection_end, cx)\n                    {\n                        for (buffer, entries) in ranges {\n                            linked_ranges.entry(buffer).or_default().extend(entries);\n                        }\n                    }\n                }\n            }\n\n            let mut selections = this.selections.all::<MultiBufferPoint>(&display_map);\n            for selection in &mut selections {\n                if selection.is_empty() {\n                    let old_head = selection.head();\n                    let mut new_head =\n                        movement::left(&display_map, old_head.to_display_point(&display_map))\n                            .to_point(&display_map);\n                    if let Some((buffer, line_buffer_range)) = display_map\n                        .buffer_snapshot()\n                        .buffer_line_for_row(MultiBufferRow(old_head.row))\n                    {\n                        let indent_size = buffer.indent_size_for_line(line_buffer_range.start.row);\n                        let indent_len = match indent_size.kind {\n                            IndentKind::Space => {\n                                buffer.settings_at(line_buffer_range.start, cx).tab_size\n                            }\n                            IndentKind::Tab => NonZeroU32::new(1).unwrap(),\n                        };\n                        if old_head.column <= indent_size.len && old_head.column > 0 {\n                            let indent_len = indent_len.get();\n                            new_head = cmp::min(\n                                new_head,\n                                MultiBufferPoint::new(\n                                    old_head.row,\n                                    ((old_head.column - 1) / indent_len) * indent_len,\n                                ),\n                            );\n                        }\n                    }\n\n                    selection.set_head(new_head, SelectionGoal::None);\n                }\n            }\n\n            this.change_selections(Default::default(), window, cx, |s| s.select(selections));\n            this.insert(": "",
        ", window, cx);\n            let empty_str: Arc<str> = Arc::from(": "",
        ");\n            for (buffer, edits) in linked_ranges {\n                let snapshot = buffer.read(cx).snapshot();\n                use text::ToPoint as TP;\n\n                let edits = edits\n                    .into_iter()\n                    .map(|range| {\n                        let end_point = TP::to_point(&range.end, &snapshot);\n                        let mut start_point = TP::to_point(&range.start, &snapshot);\n\n                        if end_point == start_point {\n                            let offset = text::ToOffset::to_offset(&range.start, &snapshot)\n                                .saturating_sub(1);\n                            start_point =\n                                snapshot.clip_point(TP::to_point(&offset, &snapshot), Bias::Left);\n                        };\n\n                        (start_point..end_point, empty_str.clone())\n                    })\n                    .sorted_by_key(|(range, _)| range.start)\n                    .collect::<Vec<_>>();\n                buffer.update(cx, |this, cx| {\n                    this.edit(edits, None, cx);\n                })\n            }\n            this.refresh_edit_prediction(true, false, window, cx);\n            refresh_linked_ranges(this, window, cx);\n        });\n    }\n\n    pub fn delete(&mut self, _: &Delete, window: &mut Window, cx: &mut Context<Self>) {\n        if self.read_only(cx) {\n            return;\n        }\n        self.hide_mouse_cursor(HideMouseCursorOrigin::TypingAction, cx);\n        self.transact(window, cx, |this, window, cx| {\n            this.change_selections(Default::default(), window, cx, |s| {\n                s.move_with(|map, selection| {\n                    if selection.is_empty() {\n                        let cursor = movement::right(map, selection.head());\n                        selection.end = cursor;\n                        selection.reversed = true;\n                        selection.goal = SelectionGoal::None;\n                    }\n                })\n            });\n            this.insert(": "",
        ", window, cx);\n            this.refresh_edit_prediction(true, false, window, cx);\n        });\n    }\n\n    pub fn backtab(&mut self, _: &Backtab, window: &mut Window, cx: &mut Context<Self>) {\n        if self.mode.is_single_line() {\n            cx.propagate();\n            return;\n        }\n\n        self.hide_mouse_cursor(HideMouseCursorOrigin::TypingAction, cx);\n        if self.move_to_prev_snippet_tabstop(window, cx) {\n            return;\n        }\n        self.outdent(&Outdent, window, cx);\n    }\n\n    pub fn next_snippet_tabstop(\n        &mut self,\n        _: &NextSnippetTabstop,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if self.mode.is_single_line() || self.snippet_stack.is_empty() {\n            cx.propagate();\n            return;\n        }\n\n        if self.move_to_next_snippet_tabstop(window, cx) {\n            self.hide_mouse_cursor(HideMouseCursorOrigin::TypingAction, cx);\n            return;\n        }\n        cx.propagate();\n    }\n\n    pub fn previous_snippet_tabstop(\n        &mut self,\n        _: &PreviousSnippetTabstop,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if self.mode.is_single_line() || self.snippet_stack.is_empty() {\n            cx.propagate();\n            return;\n        }\n\n        if self.move_to_prev_snippet_tabstop(window, cx) {\n            self.hide_mouse_cursor(HideMouseCursorOrigin::TypingAction, cx);\n            return;\n        }\n        cx.propagate();\n    }\n\n    pub fn tab(&mut self, _: &Tab, window: &mut Window, cx: &mut Context<Self>) {\n        if self.mode.is_single_line() {\n            cx.propagate();\n            return;\n        }\n\n        if self.move_to_next_snippet_tabstop(window, cx) {\n            self.hide_mouse_cursor(HideMouseCursorOrigin::TypingAction, cx);\n            return;\n        }\n        if self.read_only(cx) {\n            return;\n        }\n        self.hide_mouse_cursor(HideMouseCursorOrigin::TypingAction, cx);\n        let mut selections = self.selections.all_adjusted(&self.display_snapshot(cx));\n        let buffer = self.buffer.read(cx);\n        let snapshot = buffer.snapshot(cx);\n        let rows_iter = selections.iter().map(|s| s.head().row);\n        let suggested_indents = snapshot.suggested_indents(rows_iter, cx);\n\n        let has_some_cursor_in_whitespace = selections\n            .iter()\n            .filter(|selection| selection.is_empty())\n            .any(|selection| {\n                let cursor = selection.head();\n                let current_indent = snapshot.indent_size_for_line(MultiBufferRow(cursor.row));\n                cursor.column < current_indent.len\n            });\n\n        let mut edits = Vec::new();\n        let mut prev_edited_row = 0;\n        let mut row_delta = 0;\n        for selection in &mut selections {\n            if selection.start.row != prev_edited_row {\n                row_delta = 0;\n            }\n            prev_edited_row = selection.end.row;\n\n            // If the selection is non-empty, then increase the indentation of the selected lines.\n            if !selection.is_empty() {\n                row_delta =\n                    Self::indent_selection(buffer, &snapshot, selection, &mut edits, row_delta, cx);\n                continue;\n            }\n\n            let cursor = selection.head();\n            let current_indent = snapshot.indent_size_for_line(MultiBufferRow(cursor.row));\n            if let Some(suggested_indent) =\n                suggested_indents.get(&MultiBufferRow(cursor.row)).copied()\n            {\n                // Don't do anything if already at suggested indent\n                // and there is any other cursor which is not\n                if has_some_cursor_in_whitespace\n                    && cursor.column == current_indent.len\n                    && current_indent.len == suggested_indent.len\n                {\n                    continue;\n                }\n\n                // Adjust line and move cursor to suggested indent\n                // if cursor is not at suggested indent\n                if cursor.column < suggested_indent.len\n                    && cursor.column <= current_indent.len\n                    && current_indent.len <= suggested_indent.len\n                {\n                    selection.start = Point::new(cursor.row, suggested_indent.len);\n                    selection.end = selection.start;\n                    if row_delta == 0 {\n                        edits.extend(Buffer::edit_for_indent_size_adjustment(\n                            cursor.row,\n                            current_indent,\n                            suggested_indent,\n                        ));\n                        row_delta = suggested_indent.len - current_indent.len;\n                    }\n                    continue;\n                }\n\n                // If current indent is more than suggested indent\n                // only move cursor to current indent and skip indent\n                if cursor.column < current_indent.len && current_indent.len > suggested_indent.len {\n                    selection.start = Point::new(cursor.row, current_indent.len);\n                    selection.end = selection.start;\n                    continue;\n                }\n            }\n\n            // Otherwise, insert a hard or soft tab.\n            let settings = buffer.language_settings_at(cursor, cx);\n            let tab_size = if settings.hard_tabs {\n                IndentSize::tab()\n            } else {\n                let tab_size = settings.tab_size.get();\n                let indent_remainder = snapshot\n                    .text_for_range(Point::new(cursor.row, 0)..cursor)\n                    .flat_map(str::chars)\n                    .fold(row_delta % tab_size, |counter: u32, c| {\n                        if c == '\\t' {\n                            0\n                        } else {\n                            (counter + 1) % tab_size\n                        }\n                    });\n\n                let chars_to_next_tab_stop = tab_size - indent_remainder;\n                IndentSize::spaces(chars_to_next_tab_stop)\n            };\n            selection.start = Point::new(cursor.row, cursor.column + row_delta + tab_size.len);\n            selection.end = selection.start;\n            edits.push((cursor..cursor, tab_size.chars().collect::<String>()));\n            row_delta += tab_size.len;\n        }\n\n        self.transact(window, cx, |this, window, cx| {\n            this.buffer.update(cx, |b, cx| b.edit(edits, None, cx));\n            this.change_selections(Default::default(), window, cx, |s| s.select(selections));\n            this.refresh_edit_prediction(true, false, window, cx);\n        });\n    }\n\n    pub fn indent(&mut self, _: &Indent, window: &mut Window, cx: &mut Context<Self>) {\n        if self.read_only(cx) {\n            return;\n        }\n        if self.mode.is_single_line() {\n            cx.propagate();\n            return;\n        }\n\n        self.hide_mouse_cursor(HideMouseCursorOrigin::TypingAction, cx);\n        let mut selections = self.selections.all::<Point>(&self.display_snapshot(cx));\n        let mut prev_edited_row = 0;\n        let mut row_delta = 0;\n        let mut edits = Vec::new();\n        let buffer = self.buffer.read(cx);\n        let snapshot = buffer.snapshot(cx);\n        for selection in &mut selections {\n            if selection.start.row != prev_edited_row {\n                row_delta = 0;\n            }\n            prev_edited_row = selection.end.row;\n\n            row_delta =\n                Self::indent_selection(buffer, &snapshot, selection, &mut edits, row_delta, cx);\n        }\n\n        self.transact(window, cx, |this, window, cx| {\n            this.buffer.update(cx, |b, cx| b.edit(edits, None, cx));\n            this.change_selections(Default::default(), window, cx, |s| s.select(selections));\n        });\n    }\n\n    fn indent_selection(\n        buffer: &MultiBuffer,\n        snapshot: &MultiBufferSnapshot,\n        selection: &mut Selection<Point>,\n        edits: &mut Vec<(Range<Point>, String)>,\n        delta_for_start_row: u32,\n        cx: &App,\n    ) -> u32 {\n        let settings = buffer.language_settings_at(selection.start, cx);\n        let tab_size = settings.tab_size.get();\n        let indent_kind = if settings.hard_tabs {\n            IndentKind::Tab\n        } else {\n            IndentKind::Space\n        };\n        let mut start_row = selection.start.row;\n        let mut end_row = selection.end.row + 1;\n\n        // If a selection ends at the beginning of a line, don't indent\n        // that last line.\n        if selection.end.column == 0 && selection.end.row > selection.start.row {\n            end_row -= 1;\n        }\n\n        // Avoid re-indenting a row that has already been indented by a\n        // previous selection, but still update this selection's column\n        // to reflect that indentation.\n        if delta_for_start_row > 0 {\n            start_row += 1;\n            selection.start.column += delta_for_start_row;\n            if selection.end.row == selection.start.row {\n                selection.end.column += delta_for_start_row;\n            }\n        }\n\n        let mut delta_for_end_row = 0;\n        let has_multiple_rows = start_row + 1 != end_row;\n        for row in start_row..end_row {\n            let current_indent = snapshot.indent_size_for_line(MultiBufferRow(row));\n            let indent_delta = match (current_indent.kind, indent_kind) {\n                (IndentKind::Space, IndentKind::Space) => {\n                    let columns_to_next_tab_stop = tab_size - (current_indent.len % tab_size);\n                    IndentSize::spaces(columns_to_next_tab_stop)\n                }\n                (IndentKind::Tab, IndentKind::Space) => IndentSize::spaces(tab_size),\n                (_, IndentKind::Tab) => IndentSize::tab(),\n            };\n\n            let start = if has_multiple_rows || current_indent.len < selection.start.column {\n                0\n            } else {\n                selection.start.column\n            };\n            let row_start = Point::new(row, start);\n            edits.push((\n                row_start..row_start,\n                indent_delta.chars().collect::<String>(),\n            ));\n\n            // Update this selection's endpoints to reflect the indentation.\n            if row == selection.start.row {\n                selection.start.column += indent_delta.len;\n            }\n            if row == selection.end.row {\n                selection.end.column += indent_delta.len;\n                delta_for_end_row = indent_delta.len;\n            }\n        }\n\n        if selection.start.row == selection.end.row {\n            delta_for_start_row + delta_for_end_row\n        } else {\n            delta_for_end_row\n        }\n    }\n\n    pub fn outdent(&mut self, _: &Outdent, window: &mut Window, cx: &mut Context<Self>) {\n        if self.read_only(cx) {\n            return;\n        }\n        if self.mode.is_single_line() {\n            cx.propagate();\n            return;\n        }\n\n        self.hide_mouse_cursor(HideMouseCursorOrigin::TypingAction, cx);\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n        let selections = self.selections.all::<Point>(&display_map);\n        let mut deletion_ranges = Vec::new();\n        let mut last_outdent = None;\n        {\n            let buffer = self.buffer.read(cx);\n            let snapshot = buffer.snapshot(cx);\n            for selection in &selections {\n                let settings = buffer.language_settings_at(selection.start, cx);\n                let tab_size = settings.tab_size.get();\n                let mut rows = selection.spanned_rows(false, &display_map);\n\n                // Avoid re-outdenting a row that has already been outdented by a\n                // previous selection.\n                if let Some(last_row) = last_outdent\n                    && last_row == rows.start\n                {\n                    rows.start = rows.start.next_row();\n                }\n                let has_multiple_rows = rows.len() > 1;\n                for row in rows.iter_rows() {\n                    let indent_size = snapshot.indent_size_for_line(row);\n                    if indent_size.len > 0 {\n                        let deletion_len = match indent_size.kind {\n                            IndentKind::Space => {\n                                let columns_to_prev_tab_stop = indent_size.len % tab_size;\n                                if columns_to_prev_tab_stop == 0 {\n                                    tab_size\n                                } else {\n                                    columns_to_prev_tab_stop\n                                }\n                            }\n                            IndentKind::Tab => 1,\n                        };\n                        let start = if has_multiple_rows\n                            || deletion_len > selection.start.column\n                            || indent_size.len < selection.start.column\n                        {\n                            0\n                        } else {\n                            selection.start.column - deletion_len\n                        };\n                        deletion_ranges.push(\n                            Point::new(row.0, start)..Point::new(row.0, start + deletion_len),\n                        );\n                        last_outdent = Some(row);\n                    }\n                }\n            }\n        }\n\n        self.transact(window, cx, |this, window, cx| {\n            this.buffer.update(cx, |buffer, cx| {\n                let empty_str: Arc<str> = Arc::default();\n                buffer.edit(\n                    deletion_ranges\n                        .into_iter()\n                        .map(|range| (range, empty_str.clone())),\n                    None,\n                    cx,\n                );\n            });\n            let selections = this.selections.all::<usize>(&this.display_snapshot(cx));\n            this.change_selections(Default::default(), window, cx, |s| s.select(selections));\n        });\n    }\n\n    pub fn autoindent(&mut self, _: &AutoIndent, window: &mut Window, cx: &mut Context<Self>) {\n        if self.read_only(cx) {\n            return;\n        }\n        if self.mode.is_single_line() {\n            cx.propagate();\n            return;\n        }\n\n        self.hide_mouse_cursor(HideMouseCursorOrigin::TypingAction, cx);\n        let selections = self\n            .selections\n            .all::<usize>(&self.display_snapshot(cx))\n            .into_iter()\n            .map(|s| s.range());\n\n        self.transact(window, cx, |this, window, cx| {\n            this.buffer.update(cx, |buffer, cx| {\n                buffer.autoindent_ranges(selections, cx);\n            });\n            let selections = this.selections.all::<usize>(&this.display_snapshot(cx));\n            this.change_selections(Default::default(), window, cx, |s| s.select(selections));\n        });\n    }\n\n    pub fn delete_line(&mut self, _: &DeleteLine, window: &mut Window, cx: &mut Context<Self>) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::TypingAction, cx);\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n        let selections = self.selections.all::<Point>(&display_map);\n\n        let mut new_cursors = Vec::new();\n        let mut edit_ranges = Vec::new();\n        let mut selections = selections.iter().peekable();\n        while let Some(selection) = selections.next() {\n            let mut rows = selection.spanned_rows(false, &display_map);\n\n            // Accumulate contiguous regions of rows that we want to delete.\n            while let Some(next_selection) = selections.peek() {\n                let next_rows = next_selection.spanned_rows(false, &display_map);\n                if next_rows.start <= rows.end {\n                    rows.end = next_rows.end;\n                    selections.next().unwrap();\n                } else {\n                    break;\n                }\n            }\n\n            let buffer = display_map.buffer_snapshot();\n            let mut edit_start = ToOffset::to_offset(&Point::new(rows.start.0, 0), buffer);\n            let (edit_end, target_row) = if buffer.max_point().row >= rows.end.0 {\n                // If there's a line after the range, delete the \\n from the end of the row range\n                (\n                    ToOffset::to_offset(&Point::new(rows.end.0, 0), buffer),\n                    rows.end,\n                )\n            } else {\n                // If there isn't a line after the range, delete the \\n from the line before the\n                // start of the row range\n                edit_start = edit_start.saturating_sub(1);\n                (buffer.len(), rows.start.previous_row())\n            };\n\n            let text_layout_details = self.text_layout_details(window);\n            let x = display_map.x_for_display_point(\n                selection.head().to_display_point(&display_map),\n                &text_layout_details,\n            );\n            let row = Point::new(target_row.0, 0)\n                .to_display_point(&display_map)\n                .row();\n            let column = display_map.display_column_for_x(row, x, &text_layout_details);\n\n            new_cursors.push((\n                selection.id,\n                buffer.anchor_after(DisplayPoint::new(row, column).to_point(&display_map)),\n                SelectionGoal::None,\n            ));\n            edit_ranges.push(edit_start..edit_end);\n        }\n\n        self.transact(window, cx, |this, window, cx| {\n            let buffer = this.buffer.update(cx, |buffer, cx| {\n                let empty_str: Arc<str> = Arc::default();\n                buffer.edit(\n                    edit_ranges\n                        .into_iter()\n                        .map(|range| (range, empty_str.clone())),\n                    None,\n                    cx,\n                );\n                buffer.snapshot(cx)\n            });\n            let new_selections = new_cursors\n                .into_iter()\n                .map(|(id, cursor, goal)| {\n                    let cursor = cursor.to_point(&buffer);\n                    Selection {\n                        id,\n                        start: cursor,\n                        end: cursor,\n                        reversed: false,\n                        goal,\n                    }\n                })\n                .collect();\n\n            this.change_selections(Default::default(), window, cx, |s| {\n                s.select(new_selections);\n            });\n        });\n    }\n\n    pub fn join_lines_impl(\n        &mut self,\n        insert_whitespace: bool,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if self.read_only(cx) {\n            return;\n        }\n        let mut row_ranges = Vec::<Range<MultiBufferRow>>::new();\n        for selection in self.selections.all::<Point>(&self.display_snapshot(cx)) {\n            let start = MultiBufferRow(selection.start.row);\n            // Treat single line selections as if they include the next line. Otherwise this action\n            // would do nothing for single line selections individual cursors.\n            let end = if selection.start.row == selection.end.row {\n                MultiBufferRow(selection.start.row + 1)\n            } else {\n                MultiBufferRow(selection.end.row)\n            };\n\n            if let Some(last_row_range) = row_ranges.last_mut()\n                && start <= last_row_range.end\n            {\n                last_row_range.end = end;\n                continue;\n            }\n            row_ranges.push(start..end);\n        }\n\n        let snapshot = self.buffer.read(cx).snapshot(cx);\n        let mut cursor_positions = Vec::new();\n        for row_range in &row_ranges {\n            let anchor = snapshot.anchor_before(Point::new(\n                row_range.end.previous_row().0,\n                snapshot.line_len(row_range.end.previous_row()),\n            ));\n            cursor_positions.push(anchor..anchor);\n        }\n\n        self.transact(window, cx, |this, window, cx| {\n            for row_range in row_ranges.into_iter().rev() {\n                for row in row_range.iter_rows().rev() {\n                    let end_of_line = Point::new(row.0, snapshot.line_len(row));\n                    let next_line_row = row.next_row();\n                    let indent = snapshot.indent_size_for_line(next_line_row);\n                    let start_of_next_line = Point::new(next_line_row.0, indent.len);\n\n                    let replace =\n                        if snapshot.line_len(next_line_row) > indent.len && insert_whitespace {\n                            ": "",
        "\n                        } else {\n                            ": "",
        "\n                        };\n\n                    this.buffer.update(cx, |buffer, cx| {\n                        buffer.edit([(end_of_line..start_of_next_line, replace)], None, cx)\n                    });\n                }\n            }\n\n            this.change_selections(Default::default(), window, cx, |s| {\n                s.select_anchor_ranges(cursor_positions)\n            });\n        });\n    }\n\n    pub fn join_lines(&mut self, _: &JoinLines, window: &mut Window, cx: &mut Context<Self>) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::TypingAction, cx);\n        self.join_lines_impl(true, window, cx);\n    }\n\n    pub fn sort_lines_case_sensitive(\n        &mut self,\n        _: &SortLinesCaseSensitive,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.manipulate_immutable_lines(window, cx, |lines| lines.sort())\n    }\n\n    pub fn sort_lines_by_length(\n        &mut self,\n        _: &SortLinesByLength,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.manipulate_immutable_lines(window, cx, |lines| {\n            lines.sort_by_key(|&line| line.chars().count())\n        })\n    }\n\n    pub fn sort_lines_case_insensitive(\n        &mut self,\n        _: &SortLinesCaseInsensitive,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.manipulate_immutable_lines(window, cx, |lines| {\n            lines.sort_by_key(|line| line.to_lowercase())\n        })\n    }\n\n    pub fn unique_lines_case_insensitive(\n        &mut self,\n        _: &UniqueLinesCaseInsensitive,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.manipulate_immutable_lines(window, cx, |lines| {\n            let mut seen = HashSet::default();\n            lines.retain(|line| seen.insert(line.to_lowercase()));\n        })\n    }\n\n    pub fn unique_lines_case_sensitive(\n        &mut self,\n        _: &UniqueLinesCaseSensitive,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.manipulate_immutable_lines(window, cx, |lines| {\n            let mut seen = HashSet::default();\n            lines.retain(|line| seen.insert(*line));\n        })\n    }\n\n    fn enable_wrap_selections_in_tag(&self, cx: &App) -> bool {\n        let snapshot = self.buffer.read(cx).snapshot(cx);\n        for selection in self.selections.disjoint_anchors_arc().iter() {\n            if snapshot\n                .language_at(selection.start)\n                .and_then(|lang| lang.config().wrap_characters.as_ref())\n                .is_some()\n            {\n                return true;\n            }\n        }\n        false\n    }\n\n    fn wrap_selections_in_tag(\n        &mut self,\n        _: &WrapSelectionsInTag,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::TypingAction, cx);\n\n        let snapshot = self.buffer.read(cx).snapshot(cx);\n\n        let mut edits = Vec::new();\n        let mut boundaries = Vec::new();\n\n        for selection in self\n            .selections\n            .all_adjusted(&self.display_snapshot(cx))\n            .iter()\n        {\n            let Some(wrap_config) = snapshot\n                .language_at(selection.start)\n                .and_then(|lang| lang.config().wrap_characters.clone())\n            else {\n                continue;\n            };\n\n            let open_tag = format!(": "",
        ", wrap_config.start_prefix, wrap_config.start_suffix);\n            let close_tag = format!(": "",
        ", wrap_config.end_prefix, wrap_config.end_suffix);\n\n            let start_before = snapshot.anchor_before(selection.start);\n            let end_after = snapshot.anchor_after(selection.end);\n\n            edits.push((start_before..start_before, open_tag));\n            edits.push((end_after..end_after, close_tag));\n\n            boundaries.push((\n                start_before,\n                end_after,\n                wrap_config.start_prefix.len(),\n                wrap_config.end_suffix.len(),\n            ));\n        }\n\n        if edits.is_empty() {\n            return;\n        }\n\n        self.transact(window, cx, |this, window, cx| {\n            let buffer = this.buffer.update(cx, |buffer, cx| {\n                buffer.edit(edits, None, cx);\n                buffer.snapshot(cx)\n            });\n\n            let mut new_selections = Vec::with_capacity(boundaries.len() * 2);\n            for (start_before, end_after, start_prefix_len, end_suffix_len) in\n                boundaries.into_iter()\n            {\n                let open_offset = start_before.to_offset(&buffer) + start_prefix_len;\n                let close_offset = end_after.to_offset(&buffer).saturating_sub(end_suffix_len);\n                new_selections.push(open_offset..open_offset);\n                new_selections.push(close_offset..close_offset);\n            }\n\n            this.change_selections(Default::default(), window, cx, |s| {\n                s.select_ranges(new_selections);\n            });\n\n            this.request_autoscroll(Autoscroll::fit(), cx);\n        });\n    }\n\n    pub fn reload_file(&mut self, _: &ReloadFile, window: &mut Window, cx: &mut Context<Self>) {\n        let Some(project) = self.project.clone() else {\n            return;\n        };\n        self.reload(project, window, cx)\n            .detach_and_notify_err(window, cx);\n    }\n\n    pub fn restore_file(\n        &mut self,\n        _: &::git::RestoreFile,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::TypingAction, cx);\n        let mut buffer_ids = HashSet::default();\n        let snapshot = self.buffer().read(cx).snapshot(cx);\n        for selection in self.selections.all::<usize>(&self.display_snapshot(cx)) {\n            buffer_ids.extend(snapshot.buffer_ids_for_range(selection.range()))\n        }\n\n        let buffer = self.buffer().read(cx);\n        let ranges = buffer_ids\n            .into_iter()\n            .flat_map(|buffer_id| buffer.excerpt_ranges_for_buffer(buffer_id, cx))\n            .collect::<Vec<_>>();\n\n        self.restore_hunks_in_ranges(ranges, window, cx);\n    }\n\n    pub fn git_restore(&mut self, _: &Restore, window: &mut Window, cx: &mut Context<Self>) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::TypingAction, cx);\n        let selections = self\n            .selections\n            .all(&self.display_snapshot(cx))\n            .into_iter()\n            .map(|s| s.range())\n            .collect();\n        self.restore_hunks_in_ranges(selections, window, cx);\n    }\n\n    pub fn restore_hunks_in_ranges(\n        &mut self,\n        ranges: Vec<Range<Point>>,\n        window: &mut Window,\n        cx: &mut Context<Editor>,\n    ) {\n        let mut revert_changes = HashMap::default();\n        let chunk_by = self\n            .snapshot(window, cx)\n            .hunks_for_ranges(ranges)\n            .into_iter()\n            .chunk_by(|hunk| hunk.buffer_id);\n        for (buffer_id, hunks) in &chunk_by {\n            let hunks = hunks.collect::<Vec<_>>();\n            for hunk in &hunks {\n                self.prepare_restore_change(&mut revert_changes, hunk, cx);\n            }\n            self.do_stage_or_unstage(false, buffer_id, hunks.into_iter(), cx);\n        }\n        drop(chunk_by);\n        if !revert_changes.is_empty() {\n            self.transact(window, cx, |editor, window, cx| {\n                editor.restore(revert_changes, window, cx);\n            });\n        }\n    }\n\n    pub fn status_for_buffer_id(&self, buffer_id: BufferId, cx: &App) -> Option<FileStatus> {\n        if let Some(status) = self\n            .addons\n            .iter()\n            .find_map(|(_, addon)| addon.override_status_for_buffer_id(buffer_id, cx))\n        {\n            return Some(status);\n        }\n        self.project\n            .as_ref()?\n            .read(cx)\n            .status_for_buffer_id(buffer_id, cx)\n    }\n\n    pub fn open_active_item_in_terminal(\n        &mut self,\n        _: &OpenInTerminal,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(working_directory) = self.active_excerpt(cx).and_then(|(_, buffer, _)| {\n            let project_path = buffer.read(cx).project_path(cx)?;\n            let project = self.project()?.read(cx);\n            let entry = project.entry_for_path(&project_path, cx)?;\n            let parent = match &entry.canonical_path {\n                Some(canonical_path) => canonical_path.to_path_buf(),\n                None => project.absolute_path(&project_path, cx)?,\n            }\n            .parent()?\n            .to_path_buf();\n            Some(parent)\n        }) {\n            window.dispatch_action(OpenTerminal { working_directory }.boxed_clone(), cx);\n        }\n    }\n\n    fn set_breakpoint_context_menu(\n        &mut self,\n        display_row: DisplayRow,\n        position: Option<Anchor>,\n        clicked_point: gpui::Point<Pixels>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let source = self\n            .buffer\n            .read(cx)\n            .snapshot(cx)\n            .anchor_before(Point::new(display_row.0, 0u32));\n\n        let context_menu = self.breakpoint_context_menu(position.unwrap_or(source), window, cx);\n\n        self.mouse_context_menu = MouseContextMenu::pinned_to_editor(\n            self,\n            source,\n            clicked_point,\n            context_menu,\n            window,\n            cx,\n        );\n    }\n\n    fn add_edit_breakpoint_block(\n        &mut self,\n        anchor: Anchor,\n        breakpoint: &Breakpoint,\n        edit_action: BreakpointPromptEditAction,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let weak_editor = cx.weak_entity();\n        let bp_prompt = cx.new(|cx| {\n            BreakpointPromptEditor::new(\n                weak_editor,\n                anchor,\n                breakpoint.clone(),\n                edit_action,\n                window,\n                cx,\n            )\n        });\n\n        let height = bp_prompt.update(cx, |this, cx| {\n            this.prompt\n                .update(cx, |prompt, cx| prompt.max_point(cx).row().0 + 1 + 2)\n        });\n        let cloned_prompt = bp_prompt.clone();\n        let blocks = vec![BlockProperties {\n            style: BlockStyle::Sticky,\n            placement: BlockPlacement::Above(anchor),\n            height: Some(height),\n            render: Arc::new(move |cx| {\n                *cloned_prompt.read(cx).editor_margins.lock() = *cx.margins;\n                cloned_prompt.clone().into_any_element()\n            }),\n            priority: 0,\n        }];\n\n        let focus_handle = bp_prompt.focus_handle(cx);\n        window.focus(&focus_handle);\n\n        let block_ids = self.insert_blocks(blocks, None, cx);\n        bp_prompt.update(cx, |prompt, _| {\n            prompt.add_block_ids(block_ids);\n        });\n    }\n\n    pub(crate) fn breakpoint_at_row(\n        &self,\n        row: u32,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<(Anchor, Breakpoint)> {\n        let snapshot = self.snapshot(window, cx);\n        let breakpoint_position = snapshot.buffer_snapshot().anchor_before(Point::new(row, 0));\n\n        self.breakpoint_at_anchor(breakpoint_position, &snapshot, cx)\n    }\n\n    pub(crate) fn breakpoint_at_anchor(\n        &self,\n        breakpoint_position: Anchor,\n        snapshot: &EditorSnapshot,\n        cx: &mut Context<Self>,\n    ) -> Option<(Anchor, Breakpoint)> {\n        let buffer = self\n            .buffer\n            .read(cx)\n            .buffer_for_anchor(breakpoint_position, cx)?;\n\n        let enclosing_excerpt = breakpoint_position.excerpt_id;\n        let buffer_snapshot = buffer.read(cx).snapshot();\n\n        let row = buffer_snapshot\n            .summary_for_anchor::<text::PointUtf16>(&breakpoint_position.text_anchor)\n            .row;\n\n        let line_len = snapshot.buffer_snapshot().line_len(MultiBufferRow(row));\n        let anchor_end = snapshot\n            .buffer_snapshot()\n            .anchor_after(Point::new(row, line_len));\n\n        self.breakpoint_store\n            .as_ref()?\n            .read_with(cx, |breakpoint_store, cx| {\n                breakpoint_store\n                    .breakpoints(\n                        &buffer,\n                        Some(breakpoint_position.text_anchor..anchor_end.text_anchor),\n                        &buffer_snapshot,\n                        cx,\n                    )\n                    .next()\n                    .and_then(|(bp, _)| {\n                        let breakpoint_row = buffer_snapshot\n                            .summary_for_anchor::<text::PointUtf16>(&bp.position)\n                            .row;\n\n                        if breakpoint_row == row {\n                            snapshot\n                                .buffer_snapshot()\n                                .anchor_in_excerpt(enclosing_excerpt, bp.position)\n                                .map(|position| (position, bp.bp.clone()))\n                        } else {\n                            None\n                        }\n                    })\n            })\n    }\n\n    pub fn edit_log_breakpoint(\n        &mut self,\n        _: &EditLogBreakpoint,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        for (anchor, breakpoint) in self.breakpoints_at_cursors(window, cx) {\n            let breakpoint = breakpoint.unwrap_or_else(|| Breakpoint {\n                message: None,\n                state: BreakpointState::Enabled,\n                condition: None,\n                hit_condition: None,\n            });\n\n            self.add_edit_breakpoint_block(\n                anchor,\n                &breakpoint,\n                BreakpointPromptEditAction::Log,\n                window,\n                cx,\n            );\n        }\n    }\n\n    fn breakpoints_at_cursors(\n        &self,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Vec<(Anchor, Option<Breakpoint>)> {\n        let snapshot = self.snapshot(window, cx);\n        let cursors = self\n            .selections\n            .disjoint_anchors_arc()\n            .iter()\n            .map(|selection| {\n                let cursor_position: Point = selection.head().to_point(&snapshot.buffer_snapshot());\n\n                let breakpoint_position = self\n                    .breakpoint_at_row(cursor_position.row, window, cx)\n                    .map(|bp| bp.0)\n                    .unwrap_or_else(|| {\n                        snapshot\n                            .display_snapshot\n                            .buffer_snapshot()\n                            .anchor_after(Point::new(cursor_position.row, 0))\n                    });\n\n                let breakpoint = self\n                    .breakpoint_at_anchor(breakpoint_position, &snapshot, cx)\n                    .map(|(anchor, breakpoint)| (anchor, Some(breakpoint)));\n\n                breakpoint.unwrap_or_else(|| (breakpoint_position, None))\n            })\n            // There might be multiple cursors on the same line; all of them should have the same anchors though as their breakpoints positions, which makes it possible to sort and dedup the list.\n            .collect::<HashMap<Anchor, _>>();\n\n        cursors.into_iter().collect()\n    }\n\n    pub fn enable_breakpoint(\n        &mut self,\n        _: &crate::actions::EnableBreakpoint,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        for (anchor, breakpoint) in self.breakpoints_at_cursors(window, cx) {\n            let Some(breakpoint) = breakpoint.filter(|breakpoint| breakpoint.is_disabled()) else {\n                continue;\n            };\n            self.edit_breakpoint_at_anchor(\n                anchor,\n                breakpoint,\n                BreakpointEditAction::InvertState,\n                cx,\n            );\n        }\n    }\n\n    pub fn disable_breakpoint(\n        &mut self,\n        _: &crate::actions::DisableBreakpoint,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        for (anchor, breakpoint) in self.breakpoints_at_cursors(window, cx) {\n            let Some(breakpoint) = breakpoint.filter(|breakpoint| breakpoint.is_enabled()) else {\n                continue;\n            };\n            self.edit_breakpoint_at_anchor(\n                anchor,\n                breakpoint,\n                BreakpointEditAction::InvertState,\n                cx,\n            );\n        }\n    }\n\n    pub fn toggle_breakpoint(\n        &mut self,\n        _: &crate::actions::ToggleBreakpoint,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        for (anchor, breakpoint) in self.breakpoints_at_cursors(window, cx) {\n            if let Some(breakpoint) = breakpoint {\n                self.edit_breakpoint_at_anchor(\n                    anchor,\n                    breakpoint,\n                    BreakpointEditAction::Toggle,\n                    cx,\n                );\n            } else {\n                self.edit_breakpoint_at_anchor(\n                    anchor,\n                    Breakpoint::new_standard(),\n                    BreakpointEditAction::Toggle,\n                    cx,\n                );\n            }\n        }\n    }\n\n    pub fn edit_breakpoint_at_anchor(\n        &mut self,\n        breakpoint_position: Anchor,\n        breakpoint: Breakpoint,\n        edit_action: BreakpointEditAction,\n        cx: &mut Context<Self>,\n    ) {\n        let Some(breakpoint_store) = &self.breakpoint_store else {\n            return;\n        };\n\n        let Some(buffer) = self\n            .buffer\n            .read(cx)\n            .buffer_for_anchor(breakpoint_position, cx)\n        else {\n            return;\n        };\n\n        breakpoint_store.update(cx, |breakpoint_store, cx| {\n            breakpoint_store.toggle_breakpoint(\n                buffer,\n                BreakpointWithPosition {\n                    position: breakpoint_position.text_anchor,\n                    bp: breakpoint,\n                },\n                edit_action,\n                cx,\n            );\n        });\n\n        cx.notify();\n    }\n\n    #[cfg(any(test, feature = ": "",
        "))]\n    pub fn breakpoint_store(&self) -> Option<Entity<BreakpointStore>> {\n        self.breakpoint_store.clone()\n    }\n\n    pub fn prepare_restore_change(\n        &self,\n        revert_changes: &mut HashMap<BufferId, Vec<(Range<text::Anchor>, Rope)>>,\n        hunk: &MultiBufferDiffHunk,\n        cx: &mut App,\n    ) -> Option<()> {\n        if hunk.is_created_file() {\n            return None;\n        }\n        let buffer = self.buffer.read(cx);\n        let diff = buffer.diff_for(hunk.buffer_id)?;\n        let buffer = buffer.buffer(hunk.buffer_id)?;\n        let buffer = buffer.read(cx);\n        let original_text = diff\n            .read(cx)\n            .base_text()\n            .as_rope()\n            .slice(hunk.diff_base_byte_range.clone());\n        let buffer_snapshot = buffer.snapshot();\n        let buffer_revert_changes = revert_changes.entry(buffer.remote_id()).or_default();\n        if let Err(i) = buffer_revert_changes.binary_search_by(|probe| {\n            probe\n                .0\n                .start\n                .cmp(&hunk.buffer_range.start, &buffer_snapshot)\n                .then(probe.0.end.cmp(&hunk.buffer_range.end, &buffer_snapshot))\n        }) {\n            buffer_revert_changes.insert(i, (hunk.buffer_range.clone(), original_text));\n            Some(())\n        } else {\n            None\n        }\n    }\n\n    pub fn reverse_lines(&mut self, _: &ReverseLines, window: &mut Window, cx: &mut Context<Self>) {\n        self.manipulate_immutable_lines(window, cx, |lines| lines.reverse())\n    }\n\n    pub fn shuffle_lines(&mut self, _: &ShuffleLines, window: &mut Window, cx: &mut Context<Self>) {\n        self.manipulate_immutable_lines(window, cx, |lines| lines.shuffle(&mut rand::rng()))\n    }\n\n    fn manipulate_lines<M>(\n        &mut self,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n        mut manipulate: M,\n    ) where\n        M: FnMut(&str) -> LineManipulationResult,\n    {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::TypingAction, cx);\n\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n        let buffer = self.buffer.read(cx).snapshot(cx);\n\n        let mut edits = Vec::new();\n\n        let selections = self.selections.all::<Point>(&display_map);\n        let mut selections = selections.iter().peekable();\n        let mut contiguous_row_selections = Vec::new();\n        let mut new_selections = Vec::new();\n        let mut added_lines = 0;\n        let mut removed_lines = 0;\n\n        while let Some(selection) = selections.next() {\n            let (start_row, end_row) = consume_contiguous_rows(\n                &mut contiguous_row_selections,\n                selection,\n                &display_map,\n                &mut selections,\n            );\n\n            let start_point = Point::new(start_row.0, 0);\n            let end_point = Point::new(\n                end_row.previous_row().0,\n                buffer.line_len(end_row.previous_row()),\n            );\n            let text = buffer\n                .text_for_range(start_point..end_point)\n                .collect::<String>();\n\n            let LineManipulationResult {\n                new_text,\n                line_count_before,\n                line_count_after,\n            } = manipulate(&text);\n\n            edits.push((start_point..end_point, new_text));\n\n            // Selections must change based on added and removed line count\n            let start_row =\n                MultiBufferRow(start_point.row + added_lines as u32 - removed_lines as u32);\n            let end_row = MultiBufferRow(start_row.0 + line_count_after.saturating_sub(1) as u32);\n            new_selections.push(Selection {\n                id: selection.id,\n                start: start_row,\n                end: end_row,\n                goal: SelectionGoal::None,\n                reversed: selection.reversed,\n            });\n\n            if line_count_after > line_count_before {\n                added_lines += line_count_after - line_count_before;\n            } else if line_count_before > line_count_after {\n                removed_lines += line_count_before - line_count_after;\n            }\n        }\n\n        self.transact(window, cx, |this, window, cx| {\n            let buffer = this.buffer.update(cx, |buffer, cx| {\n                buffer.edit(edits, None, cx);\n                buffer.snapshot(cx)\n            });\n\n            // Recalculate offsets on newly edited buffer\n            let new_selections = new_selections\n                .iter()\n                .map(|s| {\n                    let start_point = Point::new(s.start.0, 0);\n                    let end_point = Point::new(s.end.0, buffer.line_len(s.end));\n                    Selection {\n                        id: s.id,\n                        start: buffer.point_to_offset(start_point),\n                        end: buffer.point_to_offset(end_point),\n                        goal: s.goal,\n                        reversed: s.reversed,\n                    }\n                })\n                .collect();\n\n            this.change_selections(Default::default(), window, cx, |s| {\n                s.select(new_selections);\n            });\n\n            this.request_autoscroll(Autoscroll::fit(), cx);\n        });\n    }\n\n    fn manipulate_immutable_lines<Fn>(\n        &mut self,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n        mut callback: Fn,\n    ) where\n        Fn: FnMut(&mut Vec<&str>),\n    {\n        self.manipulate_lines(window, cx, |text| {\n            let mut lines: Vec<&str> = text.split('\\n').collect();\n            let line_count_before = lines.len();\n\n            callback(&mut lines);\n\n            LineManipulationResult {\n                new_text: lines.join(": "",
        "),\n                line_count_before,\n                line_count_after: lines.len(),\n            }\n        });\n    }\n\n    fn manipulate_mutable_lines<Fn>(\n        &mut self,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n        mut callback: Fn,\n    ) where\n        Fn: FnMut(&mut Vec<Cow<'_, str>>),\n    {\n        self.manipulate_lines(window, cx, |text| {\n            let mut lines: Vec<Cow<str>> = text.split('\\n').map(Cow::from).collect();\n            let line_count_before = lines.len();\n\n            callback(&mut lines);\n\n            LineManipulationResult {\n                new_text: lines.join(": "",
        "),\n                line_count_before,\n                line_count_after: lines.len(),\n            }\n        });\n    }\n\n    pub fn convert_indentation_to_spaces(\n        &mut self,\n        _: &ConvertIndentationToSpaces,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let settings = self.buffer.read(cx).language_settings(cx);\n        let tab_size = settings.tab_size.get() as usize;\n\n        self.manipulate_mutable_lines(window, cx, |lines| {\n            // Allocates a reasonably sized scratch buffer once for the whole loop\n            let mut reindented_line = String::with_capacity(MAX_LINE_LEN);\n            // Avoids recomputing spaces that could be inserted many times\n            let space_cache: Vec<Vec<char>> = (1..=tab_size)\n                .map(|n| IndentSize::spaces(n as u32).chars().collect())\n                .collect();\n\n            for line in lines.iter_mut().filter(|line| !line.is_empty()) {\n                let mut chars = line.as_ref().chars();\n                let mut col = 0;\n                let mut changed = false;\n\n                for ch in chars.by_ref() {\n                    match ch {\n                        ' ' => {\n                            reindented_line.push(' ');\n                            col += 1;\n                        }\n                        '\\t' => {\n                            // \\t are converted to spaces depending on the current column\n                            let spaces_len = tab_size - (col % tab_size);\n                            reindented_line.extend(&space_cache[spaces_len - 1]);\n                            col += spaces_len;\n                            changed = true;\n                        }\n                        _ => {\n                            // If we dont append before break, the character is consumed\n                            reindented_line.push(ch);\n                            break;\n                        }\n                    }\n                }\n\n                if !changed {\n                    reindented_line.clear();\n                    continue;\n                }\n                // Append the rest of the line and replace old reference with new one\n                reindented_line.extend(chars);\n                *line = Cow::Owned(reindented_line.clone());\n                reindented_line.clear();\n            }\n        });\n    }\n\n    pub fn convert_indentation_to_tabs(\n        &mut self,\n        _: &ConvertIndentationToTabs,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let settings = self.buffer.read(cx).language_settings(cx);\n        let tab_size = settings.tab_size.get() as usize;\n\n        self.manipulate_mutable_lines(window, cx, |lines| {\n            // Allocates a reasonably sized buffer once for the whole loop\n            let mut reindented_line = String::with_capacity(MAX_LINE_LEN);\n            // Avoids recomputing spaces that could be inserted many times\n            let space_cache: Vec<Vec<char>> = (1..=tab_size)\n                .map(|n| IndentSize::spaces(n as u32).chars().collect())\n                .collect();\n\n            for line in lines.iter_mut().filter(|line| !line.is_empty()) {\n                let mut chars = line.chars();\n                let mut spaces_count = 0;\n                let mut first_non_indent_char = None;\n                let mut changed = false;\n\n                for ch in chars.by_ref() {\n                    match ch {\n                        ' ' => {\n                            // Keep track of spaces. Append \\t when we reach tab_size\n                            spaces_count += 1;\n                            changed = true;\n                            if spaces_count == tab_size {\n                                reindented_line.push('\\t');\n                                spaces_count = 0;\n                            }\n                        }\n                        '\\t' => {\n                            reindented_line.push('\\t');\n                            spaces_count = 0;\n                        }\n                        _ => {\n                            // Dont append it yet, we might have remaining spaces\n                            first_non_indent_char = Some(ch);\n                            break;\n                        }\n                    }\n                }\n\n                if !changed {\n                    reindented_line.clear();\n                    continue;\n                }\n                // Remaining spaces that didn't make a full tab stop\n                if spaces_count > 0 {\n                    reindented_line.extend(&space_cache[spaces_count - 1]);\n                }\n                // If we consume an extra character that was not indentation, add it back\n                if let Some(extra_char) = first_non_indent_char {\n                    reindented_line.push(extra_char);\n                }\n                // Append the rest of the line and replace old reference with new one\n                reindented_line.extend(chars);\n                *line = Cow::Owned(reindented_line.clone());\n                reindented_line.clear();\n            }\n        });\n    }\n\n    pub fn convert_to_upper_case(\n        &mut self,\n        _: &ConvertToUpperCase,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.manipulate_text(window, cx, |text| text.to_uppercase())\n    }\n\n    pub fn convert_to_lower_case(\n        &mut self,\n        _: &ConvertToLowerCase,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.manipulate_text(window, cx, |text| text.to_lowercase())\n    }\n\n    pub fn convert_to_title_case(\n        &mut self,\n        _: &ConvertToTitleCase,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.manipulate_text(window, cx, |text| {\n            text.split('\\n')\n                .map(|line| line.to_case(Case::Title))\n                .join(": "",
        ")\n        })\n    }\n\n    pub fn convert_to_snake_case(\n        &mut self,\n        _: &ConvertToSnakeCase,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.manipulate_text(window, cx, |text| text.to_case(Case::Snake))\n    }\n\n    pub fn convert_to_kebab_case(\n        &mut self,\n        _: &ConvertToKebabCase,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.manipulate_text(window, cx, |text| text.to_case(Case::Kebab))\n    }\n\n    pub fn convert_to_upper_camel_case(\n        &mut self,\n        _: &ConvertToUpperCamelCase,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.manipulate_text(window, cx, |text| {\n            text.split('\\n')\n                .map(|line| line.to_case(Case::UpperCamel))\n                .join(": "",
        ")\n        })\n    }\n\n    pub fn convert_to_lower_camel_case(\n        &mut self,\n        _: &ConvertToLowerCamelCase,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.manipulate_text(window, cx, |text| text.to_case(Case::Camel))\n    }\n\n    pub fn convert_to_opposite_case(\n        &mut self,\n        _: &ConvertToOppositeCase,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.manipulate_text(window, cx, |text| {\n            text.chars()\n                .fold(String::with_capacity(text.len()), |mut t, c| {\n                    if c.is_uppercase() {\n                        t.extend(c.to_lowercase());\n                    } else {\n                        t.extend(c.to_uppercase());\n                    }\n                    t\n                })\n        })\n    }\n\n    pub fn convert_to_sentence_case(\n        &mut self,\n        _: &ConvertToSentenceCase,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.manipulate_text(window, cx, |text| text.to_case(Case::Sentence))\n    }\n\n    pub fn toggle_case(&mut self, _: &ToggleCase, window: &mut Window, cx: &mut Context<Self>) {\n        self.manipulate_text(window, cx, |text| {\n            let has_upper_case_characters = text.chars().any(|c| c.is_uppercase());\n            if has_upper_case_characters {\n                text.to_lowercase()\n            } else {\n                text.to_uppercase()\n            }\n        })\n    }\n\n    pub fn convert_to_rot13(\n        &mut self,\n        _: &ConvertToRot13,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.manipulate_text(window, cx, |text| {\n            text.chars()\n                .map(|c| match c {\n                    'A'..='M' | 'a'..='m' => ((c as u8) + 13) as char,\n                    'N'..='Z' | 'n'..='z' => ((c as u8) - 13) as char,\n                    _ => c,\n                })\n                .collect()\n        })\n    }\n\n    pub fn convert_to_rot47(\n        &mut self,\n        _: &ConvertToRot47,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.manipulate_text(window, cx, |text| {\n            text.chars()\n                .map(|c| {\n                    let code_point = c as u32;\n                    if code_point >= 33 && code_point <= 126 {\n                        return char::from_u32(33 + ((code_point + 14) % 94)).unwrap();\n                    }\n                    c\n                })\n                .collect()\n        })\n    }\n\n    fn manipulate_text<Fn>(&mut self, window: &mut Window, cx: &mut Context<Self>, mut callback: Fn)\n    where\n        Fn: FnMut(&str) -> String,\n    {\n        let buffer = self.buffer.read(cx).snapshot(cx);\n\n        let mut new_selections = Vec::new();\n        let mut edits = Vec::new();\n        let mut selection_adjustment = 0i32;\n\n        for selection in self.selections.all_adjusted(&self.display_snapshot(cx)) {\n            let selection_is_empty = selection.is_empty();\n\n            let (start, end) = if selection_is_empty {\n                let (word_range, _) = buffer.surrounding_word(selection.start, None);\n                (word_range.start, word_range.end)\n            } else {\n                (\n                    buffer.point_to_offset(selection.start),\n                    buffer.point_to_offset(selection.end),\n                )\n            };\n\n            let text = buffer.text_for_range(start..end).collect::<String>();\n            let old_length = text.len() as i32;\n            let text = callback(&text);\n\n            new_selections.push(Selection {\n                start: (start as i32 - selection_adjustment) as usize,\n                end: ((start + text.len()) as i32 - selection_adjustment) as usize,\n                goal: SelectionGoal::None,\n                id: selection.id,\n                reversed: selection.reversed,\n            });\n\n            selection_adjustment += old_length - text.len() as i32;\n\n            edits.push((start..end, text));\n        }\n\n        self.transact(window, cx, |this, window, cx| {\n            this.buffer.update(cx, |buffer, cx| {\n                buffer.edit(edits, None, cx);\n            });\n\n            this.change_selections(Default::default(), window, cx, |s| {\n                s.select(new_selections);\n            });\n\n            this.request_autoscroll(Autoscroll::fit(), cx);\n        });\n    }\n\n    pub fn move_selection_on_drop(\n        &mut self,\n        selection: &Selection<Anchor>,\n        target: DisplayPoint,\n        is_cut: bool,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n        let buffer = display_map.buffer_snapshot();\n        let mut edits = Vec::new();\n        let insert_point = display_map\n            .clip_point(target, Bias::Left)\n            .to_point(&display_map);\n        let text = buffer\n            .text_for_range(selection.start..selection.end)\n            .collect::<String>();\n        if is_cut {\n            edits.push(((selection.start..selection.end), String::new()));\n        }\n        let insert_anchor = buffer.anchor_before(insert_point);\n        edits.push(((insert_anchor..insert_anchor), text));\n        let last_edit_start = insert_anchor.bias_left(buffer);\n        let last_edit_end = insert_anchor.bias_right(buffer);\n        self.transact(window, cx, |this, window, cx| {\n            this.buffer.update(cx, |buffer, cx| {\n                buffer.edit(edits, None, cx);\n            });\n            this.change_selections(Default::default(), window, cx, |s| {\n                s.select_anchor_ranges([last_edit_start..last_edit_end]);\n            });\n        });\n    }\n\n    pub fn clear_selection_drag_state(&mut self) {\n        self.selection_drag_state = SelectionDragState::None;\n    }\n\n    pub fn duplicate(\n        &mut self,\n        upwards: bool,\n        whole_lines: bool,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::TypingAction, cx);\n\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n        let buffer = display_map.buffer_snapshot();\n        let selections = self.selections.all::<Point>(&display_map);\n\n        let mut edits = Vec::new();\n        let mut selections_iter = selections.iter().peekable();\n        while let Some(selection) = selections_iter.next() {\n            let mut rows = selection.spanned_rows(false, &display_map);\n            // duplicate line-wise\n            if whole_lines || selection.start == selection.end {\n                // Avoid duplicating the same lines twice.\n                while let Some(next_selection) = selections_iter.peek() {\n                    let next_rows = next_selection.spanned_rows(false, &display_map);\n                    if next_rows.start < rows.end {\n                        rows.end = next_rows.end;\n                        selections_iter.next().unwrap();\n                    } else {\n                        break;\n                    }\n                }\n\n                // Copy the text from the selected row region and splice it either at the start\n                // or end of the region.\n                let start = Point::new(rows.start.0, 0);\n                let end = Point::new(\n                    rows.end.previous_row().0,\n                    buffer.line_len(rows.end.previous_row()),\n                );\n\n                let mut text = buffer.text_for_range(start..end).collect::<String>();\n\n                let insert_location = if upwards {\n                    // When duplicating upward, we need to insert before the current line.\n                    // If we're on the last line and it doesn't end with a newline,\n                    // we need to add a newline before the duplicated content.\n                    let needs_leading_newline = rows.end.0 >= buffer.max_point().row\n                        && buffer.max_point().column > 0\n                        && !text.ends_with('\\n');\n\n                    if needs_leading_newline {\n                        text.insert(0, '\\n');\n                        end\n                    } else {\n                        text.push('\\n');\n                        Point::new(rows.start.0, 0)\n                    }\n                } else {\n                    text.push('\\n');\n                    start\n                };\n                edits.push((insert_location..insert_location, text));\n            } else {\n                // duplicate character-wise\n                let start = selection.start;\n                let end = selection.end;\n                let text = buffer.text_for_range(start..end).collect::<String>();\n                edits.push((selection.end..selection.end, text));\n            }\n        }\n\n        self.transact(window, cx, |this, window, cx| {\n            this.buffer.update(cx, |buffer, cx| {\n                buffer.edit(edits, None, cx);\n            });\n\n            // When duplicating upward with whole lines, move the cursor to the duplicated line\n            if upwards && whole_lines {\n                let display_map = this.display_map.update(cx, |map, cx| map.snapshot(cx));\n\n                this.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n                    let mut new_ranges = Vec::new();\n                    let selections = s.all::<Point>(&display_map);\n                    let mut selections_iter = selections.iter().peekable();\n\n                    while let Some(first_selection) = selections_iter.next() {\n                        // Group contiguous selections together to find the total row span\n                        let mut group_selections = vec![first_selection];\n                        let mut rows = first_selection.spanned_rows(false, &display_map);\n\n                        while let Some(next_selection) = selections_iter.peek() {\n                            let next_rows = next_selection.spanned_rows(false, &display_map);\n                            if next_rows.start < rows.end {\n                                rows.end = next_rows.end;\n                                group_selections.push(selections_iter.next().unwrap());\n                            } else {\n                                break;\n                            }\n                        }\n\n                        let row_count = rows.end.0 - rows.start.0;\n\n                        // Move all selections in this group up by the total number of duplicated rows\n                        for selection in group_selections {\n                            let new_start = Point::new(\n                                selection.start.row.saturating_sub(row_count),\n                                selection.start.column,\n                            );\n\n                            let new_end = Point::new(\n                                selection.end.row.saturating_sub(row_count),\n                                selection.end.column,\n                            );\n\n                            new_ranges.push(new_start..new_end);\n                        }\n                    }\n\n                    s.select_ranges(new_ranges);\n                });\n            }\n\n            this.request_autoscroll(Autoscroll::fit(), cx);\n        });\n    }\n\n    pub fn duplicate_line_up(\n        &mut self,\n        _: &DuplicateLineUp,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.duplicate(true, true, window, cx);\n    }\n\n    pub fn duplicate_line_down(\n        &mut self,\n        _: &DuplicateLineDown,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.duplicate(false, true, window, cx);\n    }\n\n    pub fn duplicate_selection(\n        &mut self,\n        _: &DuplicateSelection,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.duplicate(false, false, window, cx);\n    }\n\n    pub fn move_line_up(&mut self, _: &MoveLineUp, window: &mut Window, cx: &mut Context<Self>) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::TypingAction, cx);\n        if self.mode.is_single_line() {\n            cx.propagate();\n            return;\n        }\n\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n        let buffer = self.buffer.read(cx).snapshot(cx);\n\n        let mut edits = Vec::new();\n        let mut unfold_ranges = Vec::new();\n        let mut refold_creases = Vec::new();\n\n        let selections = self.selections.all::<Point>(&display_map);\n        let mut selections = selections.iter().peekable();\n        let mut contiguous_row_selections = Vec::new();\n        let mut new_selections = Vec::new();\n\n        while let Some(selection) = selections.next() {\n            // Find all the selections that span a contiguous row range\n            let (start_row, end_row) = consume_contiguous_rows(\n                &mut contiguous_row_selections,\n                selection,\n                &display_map,\n                &mut selections,\n            );\n\n            // Move the text spanned by the row range to be before the line preceding the row range\n            if start_row.0 > 0 {\n                let range_to_move = Point::new(\n                    start_row.previous_row().0,\n                    buffer.line_len(start_row.previous_row()),\n                )\n                    ..Point::new(\n                        end_row.previous_row().0,\n                        buffer.line_len(end_row.previous_row()),\n                    );\n                let insertion_point = display_map\n                    .prev_line_boundary(Point::new(start_row.previous_row().0, 0))\n                    .0;\n\n                // Don't move lines across excerpts\n                if buffer\n                    .excerpt_containing(insertion_point..range_to_move.end)\n                    .is_some()\n                {\n                    let text = buffer\n                        .text_for_range(range_to_move.clone())\n                        .flat_map(|s| s.chars())\n                        .skip(1)\n                        .chain(['\\n'])\n                        .collect::<String>();\n\n                    edits.push((\n                        buffer.anchor_after(range_to_move.start)\n                            ..buffer.anchor_before(range_to_move.end),\n                        String::new(),\n                    ));\n                    let insertion_anchor = buffer.anchor_after(insertion_point);\n                    edits.push((insertion_anchor..insertion_anchor, text));\n\n                    let row_delta = range_to_move.start.row - insertion_point.row + 1;\n\n                    // Move selections up\n                    new_selections.extend(contiguous_row_selections.drain(..).map(\n                        |mut selection| {\n                            selection.start.row -= row_delta;\n                            selection.end.row -= row_delta;\n                            selection\n                        },\n                    ));\n\n                    // Move folds up\n                    unfold_ranges.push(range_to_move.clone());\n                    for fold in display_map.folds_in_range(\n                        buffer.anchor_before(range_to_move.start)\n                            ..buffer.anchor_after(range_to_move.end),\n                    ) {\n                        let mut start = fold.range.start.to_point(&buffer);\n                        let mut end = fold.range.end.to_point(&buffer);\n                        start.row -= row_delta;\n                        end.row -= row_delta;\n                        refold_creases.push(Crease::simple(start..end, fold.placeholder.clone()));\n                    }\n                }\n            }\n\n            // If we didn't move line(s), preserve the existing selections\n            new_selections.append(&mut contiguous_row_selections);\n        }\n\n        self.transact(window, cx, |this, window, cx| {\n            this.unfold_ranges(&unfold_ranges, true, true, cx);\n            this.buffer.update(cx, |buffer, cx| {\n                for (range, text) in edits {\n                    buffer.edit([(range, text)], None, cx);\n                }\n            });\n            this.fold_creases(refold_creases, true, window, cx);\n            this.change_selections(Default::default(), window, cx, |s| {\n                s.select(new_selections);\n            })\n        });\n    }\n\n    pub fn move_line_down(\n        &mut self,\n        _: &MoveLineDown,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::TypingAction, cx);\n        if self.mode.is_single_line() {\n            cx.propagate();\n            return;\n        }\n\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n        let buffer = self.buffer.read(cx).snapshot(cx);\n\n        let mut edits = Vec::new();\n        let mut unfold_ranges = Vec::new();\n        let mut refold_creases = Vec::new();\n\n        let selections = self.selections.all::<Point>(&display_map);\n        let mut selections = selections.iter().peekable();\n        let mut contiguous_row_selections = Vec::new();\n        let mut new_selections = Vec::new();\n\n        while let Some(selection) = selections.next() {\n            // Find all the selections that span a contiguous row range\n            let (start_row, end_row) = consume_contiguous_rows(\n                &mut contiguous_row_selections,\n                selection,\n                &display_map,\n                &mut selections,\n            );\n\n            // Move the text spanned by the row range to be after the last line of the row range\n            if end_row.0 <= buffer.max_point().row {\n                let range_to_move =\n                    MultiBufferPoint::new(start_row.0, 0)..MultiBufferPoint::new(end_row.0, 0);\n                let insertion_point = display_map\n                    .next_line_boundary(MultiBufferPoint::new(end_row.0, 0))\n                    .0;\n\n                // Don't move lines across excerpt boundaries\n                if buffer\n                    .excerpt_containing(range_to_move.start..insertion_point)\n                    .is_some()\n                {\n                    let mut text = String::from(": "",
        ");\n                    text.extend(buffer.text_for_range(range_to_move.clone()));\n                    text.pop(); // Drop trailing newline\n                    edits.push((\n                        buffer.anchor_after(range_to_move.start)\n                            ..buffer.anchor_before(range_to_move.end),\n                        String::new(),\n                    ));\n                    let insertion_anchor = buffer.anchor_after(insertion_point);\n                    edits.push((insertion_anchor..insertion_anchor, text));\n\n                    let row_delta = insertion_point.row - range_to_move.end.row + 1;\n\n                    // Move selections down\n                    new_selections.extend(contiguous_row_selections.drain(..).map(\n                        |mut selection| {\n                            selection.start.row += row_delta;\n                            selection.end.row += row_delta;\n                            selection\n                        },\n                    ));\n\n                    // Move folds down\n                    unfold_ranges.push(range_to_move.clone());\n                    for fold in display_map.folds_in_range(\n                        buffer.anchor_before(range_to_move.start)\n                            ..buffer.anchor_after(range_to_move.end),\n                    ) {\n                        let mut start = fold.range.start.to_point(&buffer);\n                        let mut end = fold.range.end.to_point(&buffer);\n                        start.row += row_delta;\n                        end.row += row_delta;\n                        refold_creases.push(Crease::simple(start..end, fold.placeholder.clone()));\n                    }\n                }\n            }\n\n            // If we didn't move line(s), preserve the existing selections\n            new_selections.append(&mut contiguous_row_selections);\n        }\n\n        self.transact(window, cx, |this, window, cx| {\n            this.unfold_ranges(&unfold_ranges, true, true, cx);\n            this.buffer.update(cx, |buffer, cx| {\n                for (range, text) in edits {\n                    buffer.edit([(range, text)], None, cx);\n                }\n            });\n            this.fold_creases(refold_creases, true, window, cx);\n            this.change_selections(Default::default(), window, cx, |s| s.select(new_selections));\n        });\n    }\n\n    pub fn transpose(&mut self, _: &Transpose, window: &mut Window, cx: &mut Context<Self>) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::TypingAction, cx);\n        let text_layout_details = &self.text_layout_details(window);\n        self.transact(window, cx, |this, window, cx| {\n            let edits = this.change_selections(Default::default(), window, cx, |s| {\n                let mut edits: Vec<(Range<usize>, String)> = Default::default();\n                s.move_with(|display_map, selection| {\n                    if !selection.is_empty() {\n                        return;\n                    }\n\n                    let mut head = selection.head();\n                    let mut transpose_offset = head.to_offset(display_map, Bias::Right);\n                    if head.column() == display_map.line_len(head.row()) {\n                        transpose_offset = display_map\n                            .buffer_snapshot()\n                            .clip_offset(transpose_offset.saturating_sub(1), Bias::Left);\n                    }\n\n                    if transpose_offset == 0 {\n                        return;\n                    }\n\n                    *head.column_mut() += 1;\n                    head = display_map.clip_point(head, Bias::Right);\n                    let goal = SelectionGoal::HorizontalPosition(\n                        display_map\n                            .x_for_display_point(head, text_layout_details)\n                            .into(),\n                    );\n                    selection.collapse_to(head, goal);\n\n                    let transpose_start = display_map\n                        .buffer_snapshot()\n                        .clip_offset(transpose_offset.saturating_sub(1), Bias::Left);\n                    if edits.last().is_none_or(|e| e.0.end <= transpose_start) {\n                        let transpose_end = display_map\n                            .buffer_snapshot()\n                            .clip_offset(transpose_offset + 1, Bias::Right);\n                        if let Some(ch) = display_map\n                            .buffer_snapshot()\n                            .chars_at(transpose_start)\n                            .next()\n                        {\n                            edits.push((transpose_start..transpose_offset, String::new()));\n                            edits.push((transpose_end..transpose_end, ch.to_string()));\n                        }\n                    }\n                });\n                edits\n            });\n            this.buffer\n                .update(cx, |buffer, cx| buffer.edit(edits, None, cx));\n            let selections = this.selections.all::<usize>(&this.display_snapshot(cx));\n            this.change_selections(Default::default(), window, cx, |s| {\n                s.select(selections);\n            });\n        });\n    }\n\n    pub fn rewrap(&mut self, _: &Rewrap, _: &mut Window, cx: &mut Context<Self>) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::TypingAction, cx);\n        if self.mode.is_single_line() {\n            cx.propagate();\n            return;\n        }\n\n        self.rewrap_impl(RewrapOptions::default(), cx)\n    }\n\n    pub fn rewrap_impl(&mut self, options: RewrapOptions, cx: &mut Context<Self>) {\n        let buffer = self.buffer.read(cx).snapshot(cx);\n        let selections = self.selections.all::<Point>(&self.display_snapshot(cx));\n\n        #[derive(Clone, Debug, PartialEq)]\n        enum CommentFormat {\n            /// single line comment, with prefix for line\n            Line(String),\n            /// single line within a block comment, with prefix for line\n            BlockLine(String),\n            /// a single line of a block comment that includes the initial delimiter\n            BlockCommentWithStart(BlockCommentConfig),\n            /// a single line of a block comment that includes the ending delimiter\n            BlockCommentWithEnd(BlockCommentConfig),\n        }\n\n        // Split selections to respect paragraph, indent, and comment prefix boundaries.\n        let wrap_ranges = selections.into_iter().flat_map(|selection| {\n            let mut non_blank_rows_iter = (selection.start.row..=selection.end.row)\n                .filter(|row| !buffer.is_line_blank(MultiBufferRow(*row)))\n                .peekable();\n\n            let first_row = if let Some(&row) = non_blank_rows_iter.peek() {\n                row\n            } else {\n                return Vec::new();\n            };\n\n            let language_settings = buffer.language_settings_at(selection.head(), cx);\n            let language_scope = buffer.language_scope_at(selection.head());\n\n            let indent_and_prefix_for_row =\n                |row: u32| -> (IndentSize, Option<CommentFormat>, Option<String>) {\n                    let indent = buffer.indent_size_for_line(MultiBufferRow(row));\n                    let (comment_prefix, rewrap_prefix) = if let Some(language_scope) =\n                        &language_scope\n                    {\n                        let indent_end = Point::new(row, indent.len);\n                        let line_end = Point::new(row, buffer.line_len(MultiBufferRow(row)));\n                        let line_text_after_indent = buffer\n                            .text_for_range(indent_end..line_end)\n                            .collect::<String>();\n\n                        let is_within_comment_override = buffer\n                            .language_scope_at(indent_end)\n                            .is_some_and(|scope| scope.override_name() == Some(": "",
        "));\n                        let comment_delimiters = if is_within_comment_override {\n                            // we are within a comment syntax node, but we don't\n                            // yet know what kind of comment: block, doc or line\n                            match (\n                                language_scope.documentation_comment(),\n                                language_scope.block_comment(),\n                            ) {\n                                (Some(config), _) | (_, Some(config))\n                                    if buffer.contains_str_at(indent_end, &config.start) =>\n                                {\n                                    Some(CommentFormat::BlockCommentWithStart(config.clone()))\n                                }\n                                (Some(config), _) | (_, Some(config))\n                                    if line_text_after_indent.ends_with(config.end.as_ref()) =>\n                                {\n                                    Some(CommentFormat::BlockCommentWithEnd(config.clone()))\n                                }\n                                (Some(config), _) | (_, Some(config))\n                                    if buffer.contains_str_at(indent_end, &config.prefix) =>\n                                {\n                                    Some(CommentFormat::BlockLine(config.prefix.to_string()))\n                                }\n                                (_, _) => language_scope\n                                    .line_comment_prefixes()\n                                    .iter()\n                                    .find(|prefix| buffer.contains_str_at(indent_end, prefix))\n                                    .map(|prefix| CommentFormat::Line(prefix.to_string())),\n                            }\n                        } else {\n                            // we not in an overridden comment node, but we may\n                            // be within a non-overridden line comment node\n                            language_scope\n                                .line_comment_prefixes()\n                                .iter()\n                                .find(|prefix| buffer.contains_str_at(indent_end, prefix))\n                                .map(|prefix| CommentFormat::Line(prefix.to_string()))\n                        };\n\n                        let rewrap_prefix = language_scope\n                            .rewrap_prefixes()\n                            .iter()\n                            .find_map(|prefix_regex| {\n                                prefix_regex.find(&line_text_after_indent).map(|mat| {\n                                    if mat.start() == 0 {\n                                        Some(mat.as_str().to_string())\n                                    } else {\n                                        None\n                                    }\n                                })\n                            })\n                            .flatten();\n                        (comment_delimiters, rewrap_prefix)\n                    } else {\n                        (None, None)\n                    };\n                    (indent, comment_prefix, rewrap_prefix)\n                };\n\n            let mut ranges = Vec::new();\n            let from_empty_selection = selection.is_empty();\n\n            let mut current_range_start = first_row;\n            let mut prev_row = first_row;\n            let (\n                mut current_range_indent,\n                mut current_range_comment_delimiters,\n                mut current_range_rewrap_prefix,\n            ) = indent_and_prefix_for_row(first_row);\n\n            for row in non_blank_rows_iter.skip(1) {\n                let has_paragraph_break = row > prev_row + 1;\n\n                let (row_indent, row_comment_delimiters, row_rewrap_prefix) =\n                    indent_and_prefix_for_row(row);\n\n                let has_indent_change = row_indent != current_range_indent;\n                let has_comment_change = row_comment_delimiters != current_range_comment_delimiters;\n\n                let has_boundary_change = has_comment_change\n                    || row_rewrap_prefix.is_some()\n                    || (has_indent_change && current_range_comment_delimiters.is_some());\n\n                if has_paragraph_break || has_boundary_change {\n                    ranges.push((\n                        language_settings.clone(),\n                        Point::new(current_range_start, 0)\n                            ..Point::new(prev_row, buffer.line_len(MultiBufferRow(prev_row))),\n                        current_range_indent,\n                        current_range_comment_delimiters.clone(),\n                        current_range_rewrap_prefix.clone(),\n                        from_empty_selection,\n                    ));\n                    current_range_start = row;\n                    current_range_indent = row_indent;\n                    current_range_comment_delimiters = row_comment_delimiters;\n                    current_range_rewrap_prefix = row_rewrap_prefix;\n                }\n                prev_row = row;\n            }\n\n            ranges.push((\n                language_settings.clone(),\n                Point::new(current_range_start, 0)\n                    ..Point::new(prev_row, buffer.line_len(MultiBufferRow(prev_row))),\n                current_range_indent,\n                current_range_comment_delimiters,\n                current_range_rewrap_prefix,\n                from_empty_selection,\n            ));\n\n            ranges\n        });\n\n        let mut edits = Vec::new();\n        let mut rewrapped_row_ranges = Vec::<RangeInclusive<u32>>::new();\n\n        for (\n            language_settings,\n            wrap_range,\n            mut indent_size,\n            comment_prefix,\n            rewrap_prefix,\n            from_empty_selection,\n        ) in wrap_ranges\n        {\n            let mut start_row = wrap_range.start.row;\n            let mut end_row = wrap_range.end.row;\n\n            // Skip selections that overlap with a range that has already been rewrapped.\n            let selection_range = start_row..end_row;\n            if rewrapped_row_ranges\n                .iter()\n                .any(|range| range.overlaps(&selection_range))\n            {\n                continue;\n            }\n\n            let tab_size = language_settings.tab_size;\n\n            let (line_prefix, inside_comment) = match &comment_prefix {\n                Some(CommentFormat::Line(prefix) | CommentFormat::BlockLine(prefix)) => {\n                    (Some(prefix.as_str()), true)\n                }\n                Some(CommentFormat::BlockCommentWithEnd(BlockCommentConfig { prefix, .. })) => {\n                    (Some(prefix.as_ref()), true)\n                }\n                Some(CommentFormat::BlockCommentWithStart(BlockCommentConfig {\n                    start: _,\n                    end: _,\n                    prefix,\n                    tab_size,\n                })) => {\n                    indent_size.len += tab_size;\n                    (Some(prefix.as_ref()), true)\n                }\n                None => (None, false),\n            };\n            let indent_prefix = indent_size.chars().collect::<String>();\n            let line_prefix = format!(": "",
        ", line_prefix.unwrap_or(": "",
        "));\n\n            let allow_rewrap_based_on_language = match language_settings.allow_rewrap {\n                RewrapBehavior::InComments => inside_comment,\n                RewrapBehavior::InSelections => !wrap_range.is_empty(),\n                RewrapBehavior::Anywhere => true,\n            };\n\n            let should_rewrap = options.override_language_settings\n                || allow_rewrap_based_on_language\n                || self.hard_wrap.is_some();\n            if !should_rewrap {\n                continue;\n            }\n\n            if from_empty_selection {\n                'expand_upwards: while start_row > 0 {\n                    let prev_row = start_row - 1;\n                    if buffer.contains_str_at(Point::new(prev_row, 0), &line_prefix)\n                        && buffer.line_len(MultiBufferRow(prev_row)) as usize > line_prefix.len()\n                        && !buffer.is_line_blank(MultiBufferRow(prev_row))\n                    {\n                        start_row = prev_row;\n                    } else {\n                        break 'expand_upwards;\n                    }\n                }\n\n                'expand_downwards: while end_row < buffer.max_point().row {\n                    let next_row = end_row + 1;\n                    if buffer.contains_str_at(Point::new(next_row, 0), &line_prefix)\n                        && buffer.line_len(MultiBufferRow(next_row)) as usize > line_prefix.len()\n                        && !buffer.is_line_blank(MultiBufferRow(next_row))\n                    {\n                        end_row = next_row;\n                    } else {\n                        break 'expand_downwards;\n                    }\n                }\n            }\n\n            let start = Point::new(start_row, 0);\n            let start_offset = ToOffset::to_offset(&start, &buffer);\n            let end = Point::new(end_row, buffer.line_len(MultiBufferRow(end_row)));\n            let selection_text = buffer.text_for_range(start..end).collect::<String>();\n            let mut first_line_delimiter = None;\n            let mut last_line_delimiter = None;\n            let Some(lines_without_prefixes) = selection_text\n                .lines()\n                .enumerate()\n                .map(|(ix, line)| {\n                    let line_trimmed = line.trim_start();\n                    if rewrap_prefix.is_some() && ix > 0 {\n                        Ok(line_trimmed)\n                    } else if let Some(\n                        CommentFormat::BlockCommentWithStart(BlockCommentConfig {\n                            start,\n                            prefix,\n                            end,\n                            tab_size,\n                        })\n                        | CommentFormat::BlockCommentWithEnd(BlockCommentConfig {\n                            start,\n                            prefix,\n                            end,\n                            tab_size,\n                        }),\n                    ) = &comment_prefix\n                    {\n                        let line_trimmed = line_trimmed\n                            .strip_prefix(start.as_ref())\n                            .map(|s| {\n                                let mut indent_size = indent_size;\n                                indent_size.len -= tab_size;\n                                let indent_prefix: String = indent_size.chars().collect();\n                                first_line_delimiter = Some((indent_prefix, start));\n                                s.trim_start()\n                            })\n                            .unwrap_or(line_trimmed);\n                        let line_trimmed = line_trimmed\n                            .strip_suffix(end.as_ref())\n                            .map(|s| {\n                                last_line_delimiter = Some(end);\n                                s.trim_end()\n                            })\n                            .unwrap_or(line_trimmed);\n                        let line_trimmed = line_trimmed\n                            .strip_prefix(prefix.as_ref())\n                            .unwrap_or(line_trimmed);\n                        Ok(line_trimmed)\n                    } else if let Some(CommentFormat::BlockLine(prefix)) = &comment_prefix {\n                        line_trimmed.strip_prefix(prefix).with_context(|| {\n                            format!(": "",
        ")\n                        })\n                    } else {\n                        line_trimmed\n                            .strip_prefix(&line_prefix.trim_start())\n                            .with_context(|| {\n                                format!(": "",
        ")\n                            })\n                    }\n                })\n                .collect::<Result<Vec<_>, _>>()\n                .log_err()\n            else {\n                continue;\n            };\n\n            let wrap_column = self.hard_wrap.unwrap_or_else(|| {\n                buffer\n                    .language_settings_at(Point::new(start_row, 0), cx)\n                    .preferred_line_length as usize\n            });\n\n            let subsequent_lines_prefix = if let Some(rewrap_prefix_str) = &rewrap_prefix {\n                format!(": "",
        ", indent_prefix, ": "",
        ".repeat(rewrap_prefix_str.len()))\n            } else {\n                line_prefix.clone()\n            };\n\n            let wrapped_text = {\n                let mut wrapped_text = wrap_with_prefix(\n                    line_prefix,\n                    subsequent_lines_prefix,\n                    lines_without_prefixes.join(": "",
        "),\n                    wrap_column,\n                    tab_size,\n                    options.preserve_existing_whitespace,\n                );\n\n                if let Some((indent, delimiter)) = first_line_delimiter {\n                    wrapped_text = format!(": "",
        ");\n                }\n                if let Some(last_line) = last_line_delimiter {\n                    wrapped_text = format!(": "",
        ");\n                }\n\n                wrapped_text\n            };\n\n            // TODO: should always use char-based diff while still supporting cursor behavior that\n            // matches vim.\n            let mut diff_options = DiffOptions::default();\n            if options.override_language_settings {\n                diff_options.max_word_diff_len = 0;\n                diff_options.max_word_diff_line_count = 0;\n            } else {\n                diff_options.max_word_diff_len = usize::MAX;\n                diff_options.max_word_diff_line_count = usize::MAX;\n            }\n\n            for (old_range, new_text) in\n                text_diff_with_options(&selection_text, &wrapped_text, diff_options)\n            {\n                let edit_start = buffer.anchor_after(start_offset + old_range.start);\n                let edit_end = buffer.anchor_after(start_offset + old_range.end);\n                edits.push((edit_start..edit_end, new_text));\n            }\n\n            rewrapped_row_ranges.push(start_row..=end_row);\n        }\n\n        self.buffer\n            .update(cx, |buffer, cx| buffer.edit(edits, None, cx));\n    }\n\n    pub fn cut_common(\n        &mut self,\n        cut_no_selection_line: bool,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> ClipboardItem {\n        let mut text = String::new();\n        let buffer = self.buffer.read(cx).snapshot(cx);\n        let mut selections = self.selections.all::<Point>(&self.display_snapshot(cx));\n        let mut clipboard_selections = Vec::with_capacity(selections.len());\n        {\n            let max_point = buffer.max_point();\n            let mut is_first = true;\n            for selection in &mut selections {\n                let is_entire_line =\n                    (selection.is_empty() && cut_no_selection_line) || self.selections.line_mode();\n                if is_entire_line {\n                    selection.start = Point::new(selection.start.row, 0);\n                    if !selection.is_empty() && selection.end.column == 0 {\n                        selection.end = cmp::min(max_point, selection.end);\n                    } else {\n                        selection.end = cmp::min(max_point, Point::new(selection.end.row + 1, 0));\n                    }\n                    selection.goal = SelectionGoal::None;\n                }\n                if is_first {\n                    is_first = false;\n                } else {\n                    text += ": "",
        ";\n                }\n                let mut len = 0;\n                for chunk in buffer.text_for_range(selection.start..selection.end) {\n                    text.push_str(chunk);\n                    len += chunk.len();\n                }\n                clipboard_selections.push(ClipboardSelection {\n                    len,\n                    is_entire_line,\n                    first_line_indent: buffer\n                        .indent_size_for_line(MultiBufferRow(selection.start.row))\n                        .len,\n                });\n            }\n        }\n\n        self.transact(window, cx, |this, window, cx| {\n            this.change_selections(Default::default(), window, cx, |s| {\n                s.select(selections);\n            });\n            this.insert(": "",
        ", window, cx);\n        });\n        ClipboardItem::new_string_with_json_metadata(text, clipboard_selections)\n    }\n\n    pub fn cut(&mut self, _: &Cut, window: &mut Window, cx: &mut Context<Self>) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::TypingAction, cx);\n        let item = self.cut_common(true, window, cx);\n        cx.write_to_clipboard(item);\n    }\n\n    pub fn kill_ring_cut(&mut self, _: &KillRingCut, window: &mut Window, cx: &mut Context<Self>) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::TypingAction, cx);\n        self.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n            s.move_with(|snapshot, sel| {\n                if sel.is_empty() {\n                    sel.end = DisplayPoint::new(sel.end.row(), snapshot.line_len(sel.end.row()));\n                }\n                if sel.is_empty() {\n                    sel.end = DisplayPoint::new(sel.end.row() + 1_u32, 0);\n                }\n            });\n        });\n        let item = self.cut_common(false, window, cx);\n        cx.set_global(KillRing(item))\n    }\n\n    pub fn kill_ring_yank(\n        &mut self,\n        _: &KillRingYank,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::TypingAction, cx);\n        let (text, metadata) = if let Some(KillRing(item)) = cx.try_global() {\n            if let Some(ClipboardEntry::String(kill_ring)) = item.entries().first() {\n                (kill_ring.text().to_string(), kill_ring.metadata_json())\n            } else {\n                return;\n            }\n        } else {\n            return;\n        };\n        self.do_paste(&text, metadata, false, window, cx);\n    }\n\n    pub fn copy_and_trim(&mut self, _: &CopyAndTrim, _: &mut Window, cx: &mut Context<Self>) {\n        self.do_copy(true, cx);\n    }\n\n    pub fn copy(&mut self, _: &Copy, _: &mut Window, cx: &mut Context<Self>) {\n        self.do_copy(false, cx);\n    }\n\n    fn do_copy(&self, strip_leading_indents: bool, cx: &mut Context<Self>) {\n        let selections = self.selections.all::<Point>(&self.display_snapshot(cx));\n        let buffer = self.buffer.read(cx).read(cx);\n        let mut text = String::new();\n\n        let mut clipboard_selections = Vec::with_capacity(selections.len());\n        {\n            let max_point = buffer.max_point();\n            let mut is_first = true;\n            for selection in &selections {\n                let mut start = selection.start;\n                let mut end = selection.end;\n                let is_entire_line = selection.is_empty() || self.selections.line_mode();\n                let mut add_trailing_newline = false;\n                if is_entire_line {\n                    start = Point::new(start.row, 0);\n                    let next_line_start = Point::new(end.row + 1, 0);\n                    if next_line_start <= max_point {\n                        end = next_line_start;\n                    } else {\n                        // We're on the last line without a trailing newline.\n                        // Copy to the end of the line and add a newline afterwards.\n                        end = Point::new(end.row, buffer.line_len(MultiBufferRow(end.row)));\n                        add_trailing_newline = true;\n                    }\n                }\n\n                let mut trimmed_selections = Vec::new();\n                if strip_leading_indents && end.row.saturating_sub(start.row) > 0 {\n                    let row = MultiBufferRow(start.row);\n                    let first_indent = buffer.indent_size_for_line(row);\n                    if first_indent.len == 0 || start.column > first_indent.len {\n                        trimmed_selections.push(start..end);\n                    } else {\n                        trimmed_selections.push(\n                            Point::new(row.0, first_indent.len)\n                                ..Point::new(row.0, buffer.line_len(row)),\n                        );\n                        for row in start.row + 1..=end.row {\n                            let mut line_len = buffer.line_len(MultiBufferRow(row));\n                            if row == end.row {\n                                line_len = end.column;\n                            }\n                            if line_len == 0 {\n                                trimmed_selections\n                                    .push(Point::new(row, 0)..Point::new(row, line_len));\n                                continue;\n                            }\n                            let row_indent_size = buffer.indent_size_for_line(MultiBufferRow(row));\n                            if row_indent_size.len >= first_indent.len {\n                                trimmed_selections.push(\n                                    Point::new(row, first_indent.len)..Point::new(row, line_len),\n                                );\n                            } else {\n                                trimmed_selections.clear();\n                                trimmed_selections.push(start..end);\n                                break;\n                            }\n                        }\n                    }\n                } else {\n                    trimmed_selections.push(start..end);\n                }\n\n                for trimmed_range in trimmed_selections {\n                    if is_first {\n                        is_first = false;\n                    } else {\n                        text += ": "",
        ";\n                    }\n                    let mut len = 0;\n                    for chunk in buffer.text_for_range(trimmed_range.start..trimmed_range.end) {\n                        text.push_str(chunk);\n                        len += chunk.len();\n                    }\n                    if add_trailing_newline {\n                        text.push('\\n');\n                        len += 1;\n                    }\n                    clipboard_selections.push(ClipboardSelection {\n                        len,\n                        is_entire_line,\n                        first_line_indent: buffer\n                            .indent_size_for_line(MultiBufferRow(trimmed_range.start.row))\n                            .len,\n                    });\n                }\n            }\n        }\n\n        cx.write_to_clipboard(ClipboardItem::new_string_with_json_metadata(\n            text,\n            clipboard_selections,\n        ));\n    }\n\n    pub fn do_paste(\n        &mut self,\n        text: &String,\n        clipboard_selections: Option<Vec<ClipboardSelection>>,\n        handle_entire_lines: bool,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if self.read_only(cx) {\n            return;\n        }\n\n        let clipboard_text = Cow::Borrowed(text.as_str());\n\n        self.transact(window, cx, |this, window, cx| {\n            let had_active_edit_prediction = this.has_active_edit_prediction();\n            let display_map = this.display_snapshot(cx);\n            let old_selections = this.selections.all::<usize>(&display_map);\n            let cursor_offset = this.selections.last::<usize>(&display_map).head();\n\n            if let Some(mut clipboard_selections) = clipboard_selections {\n                let all_selections_were_entire_line =\n                    clipboard_selections.iter().all(|s| s.is_entire_line);\n                let first_selection_indent_column =\n                    clipboard_selections.first().map(|s| s.first_line_indent);\n                if clipboard_selections.len() != old_selections.len() {\n                    clipboard_selections.drain(..);\n                }\n                let mut auto_indent_on_paste = true;\n\n                this.buffer.update(cx, |buffer, cx| {\n                    let snapshot = buffer.read(cx);\n                    auto_indent_on_paste = snapshot\n                        .language_settings_at(cursor_offset, cx)\n                        .auto_indent_on_paste;\n\n                    let mut start_offset = 0;\n                    let mut edits = Vec::new();\n                    let mut original_indent_columns = Vec::new();\n                    for (ix, selection) in old_selections.iter().enumerate() {\n                        let to_insert;\n                        let entire_line;\n                        let original_indent_column;\n                        if let Some(clipboard_selection) = clipboard_selections.get(ix) {\n                            let end_offset = start_offset + clipboard_selection.len;\n                            to_insert = &clipboard_text[start_offset..end_offset];\n                            entire_line = clipboard_selection.is_entire_line;\n                            start_offset = end_offset + 1;\n                            original_indent_column = Some(clipboard_selection.first_line_indent);\n                        } else {\n                            to_insert = &*clipboard_text;\n                            entire_line = all_selections_were_entire_line;\n                            original_indent_column = first_selection_indent_column\n                        }\n\n                        let (range, to_insert) =\n                            if selection.is_empty() && handle_entire_lines && entire_line {\n                                // If the corresponding selection was empty when this slice of the\n                                // clipboard text was written, then the entire line containing the\n                                // selection was copied. If this selection is also currently empty,\n                                // then paste the line before the current line of the buffer.\n                                let column = selection.start.to_point(&snapshot).column as usize;\n                                let line_start = selection.start - column;\n                                (line_start..line_start, Cow::Borrowed(to_insert))\n                            } else {\n                                let language = snapshot.language_at(selection.head());\n                                let range = selection.range();\n                                if let Some(language) = language\n                                    && language.name() == ": "",
        ".into()\n                                {\n                                    edit_for_markdown_paste(\n                                        &snapshot,\n                                        range,\n                                        to_insert,\n                                        url::Url::parse(to_insert).ok(),\n                                    )\n                                } else {\n                                    (range, Cow::Borrowed(to_insert))\n                                }\n                            };\n\n                        edits.push((range, to_insert));\n                        original_indent_columns.push(original_indent_column);\n                    }\n                    drop(snapshot);\n\n                    buffer.edit(\n                        edits,\n                        if auto_indent_on_paste {\n                            Some(AutoindentMode::Block {\n                                original_indent_columns,\n                            })\n                        } else {\n                            None\n                        },\n                        cx,\n                    );\n                });\n\n                let selections = this.selections.all::<usize>(&this.display_snapshot(cx));\n                this.change_selections(Default::default(), window, cx, |s| s.select(selections));\n            } else {\n                let url = url::Url::parse(&clipboard_text).ok();\n\n                let auto_indent_mode = if !clipboard_text.is_empty() {\n                    Some(AutoindentMode::Block {\n                        original_indent_columns: Vec::new(),\n                    })\n                } else {\n                    None\n                };\n\n                let selection_anchors = this.buffer.update(cx, |buffer, cx| {\n                    let snapshot = buffer.snapshot(cx);\n\n                    let anchors = old_selections\n                        .iter()\n                        .map(|s| {\n                            let anchor = snapshot.anchor_after(s.head());\n                            s.map(|_| anchor)\n                        })\n                        .collect::<Vec<_>>();\n\n                    let mut edits = Vec::new();\n\n                    for selection in old_selections.iter() {\n                        let language = snapshot.language_at(selection.head());\n                        let range = selection.range();\n\n                        let (edit_range, edit_text) = if let Some(language) = language\n                            && language.name() == ": "",
        ".into()\n                        {\n                            edit_for_markdown_paste(&snapshot, range, &clipboard_text, url.clone())\n                        } else {\n                            (range, clipboard_text.clone())\n                        };\n\n                        edits.push((edit_range, edit_text));\n                    }\n\n                    drop(snapshot);\n                    buffer.edit(edits, auto_indent_mode, cx);\n\n                    anchors\n                });\n\n                this.change_selections(Default::default(), window, cx, |s| {\n                    s.select_anchors(selection_anchors);\n                });\n            }\n\n            //   🤔                 |    ..     | show_in_menu |\n            // | ..                  |   true        true\n            // | had_edit_prediction |   false       true\n\n            let trigger_in_words =\n                this.show_edit_predictions_in_menu() || !had_active_edit_prediction;\n\n            this.trigger_completion_on_input(text, trigger_in_words, window, cx);\n        });\n    }\n\n    pub fn diff_clipboard_with_selection(\n        &mut self,\n        _: &DiffClipboardWithSelection,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let selections = self.selections.all::<usize>(&self.display_snapshot(cx));\n\n        if selections.is_empty() {\n            log::warn!(": "",
        ");\n            return;\n        };\n\n        let clipboard_text = match cx.read_from_clipboard() {\n            Some(item) => match item.entries().first() {\n                Some(ClipboardEntry::String(text)) => Some(text.text().to_string()),\n                _ => None,\n            },\n            None => None,\n        };\n\n        let Some(clipboard_text) = clipboard_text else {\n            log::warn!(": "",
        ");\n            return;\n        };\n\n        window.dispatch_action(\n            Box::new(DiffClipboardWithSelectionData {\n                clipboard_text,\n                editor: cx.entity(),\n            }),\n            cx,\n        );\n    }\n\n    pub fn paste(&mut self, _: &Paste, window: &mut Window, cx: &mut Context<Self>) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::TypingAction, cx);\n        if let Some(item) = cx.read_from_clipboard() {\n            let entries = item.entries();\n\n            match entries.first() {\n                // For now, we only support applying metadata if there's one string. In the future, we can incorporate all the selections\n                // of all the pasted entries.\n                Some(ClipboardEntry::String(clipboard_string)) if entries.len() == 1 => self\n                    .do_paste(\n                        clipboard_string.text(),\n                        clipboard_string.metadata_json::<Vec<ClipboardSelection>>(),\n                        true,\n                        window,\n                        cx,\n                    ),\n                _ => self.do_paste(&item.text().unwrap_or_default(), None, true, window, cx),\n            }\n        }\n    }\n\n    pub fn undo(&mut self, _: &Undo, window: &mut Window, cx: &mut Context<Self>) {\n        if self.read_only(cx) {\n            return;\n        }\n\n        self.hide_mouse_cursor(HideMouseCursorOrigin::TypingAction, cx);\n\n        if let Some(transaction_id) = self.buffer.update(cx, |buffer, cx| buffer.undo(cx)) {\n            if let Some((selections, _)) =\n                self.selection_history.transaction(transaction_id).cloned()\n            {\n                self.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n                    s.select_anchors(selections.to_vec());\n                });\n            } else {\n                log::error!(\n                    ": "",
        "\n                );\n            }\n            self.request_autoscroll(Autoscroll::fit(), cx);\n            self.unmark_text(window, cx);\n            self.refresh_edit_prediction(true, false, window, cx);\n            cx.emit(EditorEvent::Edited { transaction_id });\n            cx.emit(EditorEvent::TransactionUndone { transaction_id });\n        }\n    }\n\n    pub fn redo(&mut self, _: &Redo, window: &mut Window, cx: &mut Context<Self>) {\n        if self.read_only(cx) {\n            return;\n        }\n\n        self.hide_mouse_cursor(HideMouseCursorOrigin::TypingAction, cx);\n\n        if let Some(transaction_id) = self.buffer.update(cx, |buffer, cx| buffer.redo(cx)) {\n            if let Some((_, Some(selections))) =\n                self.selection_history.transaction(transaction_id).cloned()\n            {\n                self.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n                    s.select_anchors(selections.to_vec());\n                });\n            } else {\n                log::error!(\n                    ": "",
        "\n                );\n            }\n            self.request_autoscroll(Autoscroll::fit(), cx);\n            self.unmark_text(window, cx);\n            self.refresh_edit_prediction(true, false, window, cx);\n            cx.emit(EditorEvent::Edited { transaction_id });\n        }\n    }\n\n    pub fn finalize_last_transaction(&mut self, cx: &mut Context<Self>) {\n        self.buffer\n            .update(cx, |buffer, cx| buffer.finalize_last_transaction(cx));\n    }\n\n    pub fn group_until_transaction(&mut self, tx_id: TransactionId, cx: &mut Context<Self>) {\n        self.buffer\n            .update(cx, |buffer, cx| buffer.group_until_transaction(tx_id, cx));\n    }\n\n    pub fn move_left(&mut self, _: &MoveLeft, window: &mut Window, cx: &mut Context<Self>) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n        self.change_selections(Default::default(), window, cx, |s| {\n            s.move_with(|map, selection| {\n                let cursor = if selection.is_empty() {\n                    movement::left(map, selection.start)\n                } else {\n                    selection.start\n                };\n                selection.collapse_to(cursor, SelectionGoal::None);\n            });\n        })\n    }\n\n    pub fn select_left(&mut self, _: &SelectLeft, window: &mut Window, cx: &mut Context<Self>) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n        self.change_selections(Default::default(), window, cx, |s| {\n            s.move_heads_with(|map, head, _| (movement::left(map, head), SelectionGoal::None));\n        })\n    }\n\n    pub fn move_right(&mut self, _: &MoveRight, window: &mut Window, cx: &mut Context<Self>) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n        self.change_selections(Default::default(), window, cx, |s| {\n            s.move_with(|map, selection| {\n                let cursor = if selection.is_empty() {\n                    movement::right(map, selection.end)\n                } else {\n                    selection.end\n                };\n                selection.collapse_to(cursor, SelectionGoal::None)\n            });\n        })\n    }\n\n    pub fn select_right(&mut self, _: &SelectRight, window: &mut Window, cx: &mut Context<Self>) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n        self.change_selections(Default::default(), window, cx, |s| {\n            s.move_heads_with(|map, head, _| (movement::right(map, head), SelectionGoal::None));\n        });\n    }\n\n    pub fn move_up(&mut self, _: &MoveUp, window: &mut Window, cx: &mut Context<Self>) {\n        if self.take_rename(true, window, cx).is_some() {\n            return;\n        }\n\n        if self.mode.is_single_line() {\n            cx.propagate();\n            return;\n        }\n\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n\n        let text_layout_details = &self.text_layout_details(window);\n        let selection_count = self.selections.count();\n        let first_selection = self.selections.first_anchor();\n\n        self.change_selections(Default::default(), window, cx, |s| {\n            s.move_with(|map, selection| {\n                if !selection.is_empty() {\n                    selection.goal = SelectionGoal::None;\n                }\n                let (cursor, goal) = movement::up(\n                    map,\n                    selection.start,\n                    selection.goal,\n                    false,\n                    text_layout_details,\n                );\n                selection.collapse_to(cursor, goal);\n            });\n        });\n\n        if selection_count == 1 && first_selection.range() == self.selections.first_anchor().range()\n        {\n            cx.propagate();\n        }\n    }\n\n    pub fn move_up_by_lines(\n        &mut self,\n        action: &MoveUpByLines,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if self.take_rename(true, window, cx).is_some() {\n            return;\n        }\n\n        if self.mode.is_single_line() {\n            cx.propagate();\n            return;\n        }\n\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n\n        let text_layout_details = &self.text_layout_details(window);\n\n        self.change_selections(Default::default(), window, cx, |s| {\n            s.move_with(|map, selection| {\n                if !selection.is_empty() {\n                    selection.goal = SelectionGoal::None;\n                }\n                let (cursor, goal) = movement::up_by_rows(\n                    map,\n                    selection.start,\n                    action.lines,\n                    selection.goal,\n                    false,\n                    text_layout_details,\n                );\n                selection.collapse_to(cursor, goal);\n            });\n        })\n    }\n\n    pub fn move_down_by_lines(\n        &mut self,\n        action: &MoveDownByLines,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if self.take_rename(true, window, cx).is_some() {\n            return;\n        }\n\n        if self.mode.is_single_line() {\n            cx.propagate();\n            return;\n        }\n\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n\n        let text_layout_details = &self.text_layout_details(window);\n\n        self.change_selections(Default::default(), window, cx, |s| {\n            s.move_with(|map, selection| {\n                if !selection.is_empty() {\n                    selection.goal = SelectionGoal::None;\n                }\n                let (cursor, goal) = movement::down_by_rows(\n                    map,\n                    selection.start,\n                    action.lines,\n                    selection.goal,\n                    false,\n                    text_layout_details,\n                );\n                selection.collapse_to(cursor, goal);\n            });\n        })\n    }\n\n    pub fn select_down_by_lines(\n        &mut self,\n        action: &SelectDownByLines,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n        let text_layout_details = &self.text_layout_details(window);\n        self.change_selections(Default::default(), window, cx, |s| {\n            s.move_heads_with(|map, head, goal| {\n                movement::down_by_rows(map, head, action.lines, goal, false, text_layout_details)\n            })\n        })\n    }\n\n    pub fn select_up_by_lines(\n        &mut self,\n        action: &SelectUpByLines,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n        let text_layout_details = &self.text_layout_details(window);\n        self.change_selections(Default::default(), window, cx, |s| {\n            s.move_heads_with(|map, head, goal| {\n                movement::up_by_rows(map, head, action.lines, goal, false, text_layout_details)\n            })\n        })\n    }\n\n    pub fn select_page_up(\n        &mut self,\n        _: &SelectPageUp,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let Some(row_count) = self.visible_row_count() else {\n            return;\n        };\n\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n\n        let text_layout_details = &self.text_layout_details(window);\n\n        self.change_selections(Default::default(), window, cx, |s| {\n            s.move_heads_with(|map, head, goal| {\n                movement::up_by_rows(map, head, row_count, goal, false, text_layout_details)\n            })\n        })\n    }\n\n    pub fn move_page_up(\n        &mut self,\n        action: &MovePageUp,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if self.take_rename(true, window, cx).is_some() {\n            return;\n        }\n\n        if self\n            .context_menu\n            .borrow_mut()\n            .as_mut()\n            .map(|menu| menu.select_first(self.completion_provider.as_deref(), window, cx))\n            .unwrap_or(false)\n        {\n            return;\n        }\n\n        if matches!(self.mode, EditorMode::SingleLine) {\n            cx.propagate();\n            return;\n        }\n\n        let Some(row_count) = self.visible_row_count() else {\n            return;\n        };\n\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n\n        let effects = if action.center_cursor {\n            SelectionEffects::scroll(Autoscroll::center())\n        } else {\n            SelectionEffects::default()\n        };\n\n        let text_layout_details = &self.text_layout_details(window);\n\n        self.change_selections(effects, window, cx, |s| {\n            s.move_with(|map, selection| {\n                if !selection.is_empty() {\n                    selection.goal = SelectionGoal::None;\n                }\n                let (cursor, goal) = movement::up_by_rows(\n                    map,\n                    selection.end,\n                    row_count,\n                    selection.goal,\n                    false,\n                    text_layout_details,\n                );\n                selection.collapse_to(cursor, goal);\n            });\n        });\n    }\n\n    pub fn select_up(&mut self, _: &SelectUp, window: &mut Window, cx: &mut Context<Self>) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n        let text_layout_details = &self.text_layout_details(window);\n        self.change_selections(Default::default(), window, cx, |s| {\n            s.move_heads_with(|map, head, goal| {\n                movement::up(map, head, goal, false, text_layout_details)\n            })\n        })\n    }\n\n    pub fn move_down(&mut self, _: &MoveDown, window: &mut Window, cx: &mut Context<Self>) {\n        self.take_rename(true, window, cx);\n\n        if self.mode.is_single_line() {\n            cx.propagate();\n            return;\n        }\n\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n\n        let text_layout_details = &self.text_layout_details(window);\n        let selection_count = self.selections.count();\n        let first_selection = self.selections.first_anchor();\n\n        self.change_selections(Default::default(), window, cx, |s| {\n            s.move_with(|map, selection| {\n                if !selection.is_empty() {\n                    selection.goal = SelectionGoal::None;\n                }\n                let (cursor, goal) = movement::down(\n                    map,\n                    selection.end,\n                    selection.goal,\n                    false,\n                    text_layout_details,\n                );\n                selection.collapse_to(cursor, goal);\n            });\n        });\n\n        if selection_count == 1 && first_selection.range() == self.selections.first_anchor().range()\n        {\n            cx.propagate();\n        }\n    }\n\n    pub fn select_page_down(\n        &mut self,\n        _: &SelectPageDown,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let Some(row_count) = self.visible_row_count() else {\n            return;\n        };\n\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n\n        let text_layout_details = &self.text_layout_details(window);\n\n        self.change_selections(Default::default(), window, cx, |s| {\n            s.move_heads_with(|map, head, goal| {\n                movement::down_by_rows(map, head, row_count, goal, false, text_layout_details)\n            })\n        })\n    }\n\n    pub fn move_page_down(\n        &mut self,\n        action: &MovePageDown,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if self.take_rename(true, window, cx).is_some() {\n            return;\n        }\n\n        if self\n            .context_menu\n            .borrow_mut()\n            .as_mut()\n            .map(|menu| menu.select_last(self.completion_provider.as_deref(), window, cx))\n            .unwrap_or(false)\n        {\n            return;\n        }\n\n        if matches!(self.mode, EditorMode::SingleLine) {\n            cx.propagate();\n            return;\n        }\n\n        let Some(row_count) = self.visible_row_count() else {\n            return;\n        };\n\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n\n        let effects = if action.center_cursor {\n            SelectionEffects::scroll(Autoscroll::center())\n        } else {\n            SelectionEffects::default()\n        };\n\n        let text_layout_details = &self.text_layout_details(window);\n        self.change_selections(effects, window, cx, |s| {\n            s.move_with(|map, selection| {\n                if !selection.is_empty() {\n                    selection.goal = SelectionGoal::None;\n                }\n                let (cursor, goal) = movement::down_by_rows(\n                    map,\n                    selection.end,\n                    row_count,\n                    selection.goal,\n                    false,\n                    text_layout_details,\n                );\n                selection.collapse_to(cursor, goal);\n            });\n        });\n    }\n\n    pub fn select_down(&mut self, _: &SelectDown, window: &mut Window, cx: &mut Context<Self>) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n        let text_layout_details = &self.text_layout_details(window);\n        self.change_selections(Default::default(), window, cx, |s| {\n            s.move_heads_with(|map, head, goal| {\n                movement::down(map, head, goal, false, text_layout_details)\n            })\n        });\n    }\n\n    pub fn context_menu_first(\n        &mut self,\n        _: &ContextMenuFirst,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(context_menu) = self.context_menu.borrow_mut().as_mut() {\n            context_menu.select_first(self.completion_provider.as_deref(), window, cx);\n        }\n    }\n\n    pub fn context_menu_prev(\n        &mut self,\n        _: &ContextMenuPrevious,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(context_menu) = self.context_menu.borrow_mut().as_mut() {\n            context_menu.select_prev(self.completion_provider.as_deref(), window, cx);\n        }\n    }\n\n    pub fn context_menu_next(\n        &mut self,\n        _: &ContextMenuNext,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(context_menu) = self.context_menu.borrow_mut().as_mut() {\n            context_menu.select_next(self.completion_provider.as_deref(), window, cx);\n        }\n    }\n\n    pub fn context_menu_last(\n        &mut self,\n        _: &ContextMenuLast,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(context_menu) = self.context_menu.borrow_mut().as_mut() {\n            context_menu.select_last(self.completion_provider.as_deref(), window, cx);\n        }\n    }\n\n    pub fn signature_help_prev(\n        &mut self,\n        _: &SignatureHelpPrevious,\n        _: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(popover) = self.signature_help_state.popover_mut() {\n            if popover.current_signature == 0 {\n                popover.current_signature = popover.signatures.len() - 1;\n            } else {\n                popover.current_signature -= 1;\n            }\n            cx.notify();\n        }\n    }\n\n    pub fn signature_help_next(\n        &mut self,\n        _: &SignatureHelpNext,\n        _: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(popover) = self.signature_help_state.popover_mut() {\n            if popover.current_signature + 1 == popover.signatures.len() {\n                popover.current_signature = 0;\n            } else {\n                popover.current_signature += 1;\n            }\n            cx.notify();\n        }\n    }\n\n    pub fn move_to_previous_word_start(\n        &mut self,\n        _: &MoveToPreviousWordStart,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n        self.change_selections(Default::default(), window, cx, |s| {\n            s.move_cursors_with(|map, head, _| {\n                (\n                    movement::previous_word_start(map, head),\n                    SelectionGoal::None,\n                )\n            });\n        })\n    }\n\n    pub fn move_to_previous_subword_start(\n        &mut self,\n        _: &MoveToPreviousSubwordStart,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n        self.change_selections(Default::default(), window, cx, |s| {\n            s.move_cursors_with(|map, head, _| {\n                (\n                    movement::previous_subword_start(map, head),\n                    SelectionGoal::None,\n                )\n            });\n        })\n    }\n\n    pub fn select_to_previous_word_start(\n        &mut self,\n        _: &SelectToPreviousWordStart,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n        self.change_selections(Default::default(), window, cx, |s| {\n            s.move_heads_with(|map, head, _| {\n                (\n                    movement::previous_word_start(map, head),\n                    SelectionGoal::None,\n                )\n            });\n        })\n    }\n\n    pub fn select_to_previous_subword_start(\n        &mut self,\n        _: &SelectToPreviousSubwordStart,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n        self.change_selections(Default::default(), window, cx, |s| {\n            s.move_heads_with(|map, head, _| {\n                (\n                    movement::previous_subword_start(map, head),\n                    SelectionGoal::None,\n                )\n            });\n        })\n    }\n\n    pub fn delete_to_previous_word_start(\n        &mut self,\n        action: &DeleteToPreviousWordStart,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::TypingAction, cx);\n        self.transact(window, cx, |this, window, cx| {\n            this.select_autoclose_pair(window, cx);\n            this.change_selections(Default::default(), window, cx, |s| {\n                s.move_with(|map, selection| {\n                    if selection.is_empty() {\n                        let mut cursor = if action.ignore_newlines {\n                            movement::previous_word_start(map, selection.head())\n                        } else {\n                            movement::previous_word_start_or_newline(map, selection.head())\n                        };\n                        cursor = movement::adjust_greedy_deletion(\n                            map,\n                            selection.head(),\n                            cursor,\n                            action.ignore_brackets,\n                        );\n                        selection.set_head(cursor, SelectionGoal::None);\n                    }\n                });\n            });\n            this.insert(": "",
        ", window, cx);\n        });\n    }\n\n    pub fn delete_to_previous_subword_start(\n        &mut self,\n        _: &DeleteToPreviousSubwordStart,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::TypingAction, cx);\n        self.transact(window, cx, |this, window, cx| {\n            this.select_autoclose_pair(window, cx);\n            this.change_selections(Default::default(), window, cx, |s| {\n                s.move_with(|map, selection| {\n                    if selection.is_empty() {\n                        let mut cursor = movement::previous_subword_start(map, selection.head());\n                        cursor =\n                            movement::adjust_greedy_deletion(map, selection.head(), cursor, false);\n                        selection.set_head(cursor, SelectionGoal::None);\n                    }\n                });\n            });\n            this.insert(": "",
        ", window, cx);\n        });\n    }\n\n    pub fn move_to_next_word_end(\n        &mut self,\n        _: &MoveToNextWordEnd,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n        self.change_selections(Default::default(), window, cx, |s| {\n            s.move_cursors_with(|map, head, _| {\n                (movement::next_word_end(map, head), SelectionGoal::None)\n            });\n        })\n    }\n\n    pub fn move_to_next_subword_end(\n        &mut self,\n        _: &MoveToNextSubwordEnd,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n        self.change_selections(Default::default(), window, cx, |s| {\n            s.move_cursors_with(|map, head, _| {\n                (movement::next_subword_end(map, head), SelectionGoal::None)\n            });\n        })\n    }\n\n    pub fn select_to_next_word_end(\n        &mut self,\n        _: &SelectToNextWordEnd,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n        self.change_selections(Default::default(), window, cx, |s| {\n            s.move_heads_with(|map, head, _| {\n                (movement::next_word_end(map, head), SelectionGoal::None)\n            });\n        })\n    }\n\n    pub fn select_to_next_subword_end(\n        &mut self,\n        _: &SelectToNextSubwordEnd,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n        self.change_selections(Default::default(), window, cx, |s| {\n            s.move_heads_with(|map, head, _| {\n                (movement::next_subword_end(map, head), SelectionGoal::None)\n            });\n        })\n    }\n\n    pub fn delete_to_next_word_end(\n        &mut self,\n        action: &DeleteToNextWordEnd,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::TypingAction, cx);\n        self.transact(window, cx, |this, window, cx| {\n            this.change_selections(Default::default(), window, cx, |s| {\n                s.move_with(|map, selection| {\n                    if selection.is_empty() {\n                        let mut cursor = if action.ignore_newlines {\n                            movement::next_word_end(map, selection.head())\n                        } else {\n                            movement::next_word_end_or_newline(map, selection.head())\n                        };\n                        cursor = movement::adjust_greedy_deletion(\n                            map,\n                            selection.head(),\n                            cursor,\n                            action.ignore_brackets,\n                        );\n                        selection.set_head(cursor, SelectionGoal::None);\n                    }\n                });\n            });\n            this.insert(": "",
        ", window, cx);\n        });\n    }\n\n    pub fn delete_to_next_subword_end(\n        &mut self,\n        _: &DeleteToNextSubwordEnd,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::TypingAction, cx);\n        self.transact(window, cx, |this, window, cx| {\n            this.change_selections(Default::default(), window, cx, |s| {\n                s.move_with(|map, selection| {\n                    if selection.is_empty() {\n                        let mut cursor = movement::next_subword_end(map, selection.head());\n                        cursor =\n                            movement::adjust_greedy_deletion(map, selection.head(), cursor, false);\n                        selection.set_head(cursor, SelectionGoal::None);\n                    }\n                });\n            });\n            this.insert(": "",
        ", window, cx);\n        });\n    }\n\n    pub fn move_to_beginning_of_line(\n        &mut self,\n        action: &MoveToBeginningOfLine,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n        self.change_selections(Default::default(), window, cx, |s| {\n            s.move_cursors_with(|map, head, _| {\n                (\n                    movement::indented_line_beginning(\n                        map,\n                        head,\n                        action.stop_at_soft_wraps,\n                        action.stop_at_indent,\n                    ),\n                    SelectionGoal::None,\n                )\n            });\n        })\n    }\n\n    pub fn select_to_beginning_of_line(\n        &mut self,\n        action: &SelectToBeginningOfLine,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n        self.change_selections(Default::default(), window, cx, |s| {\n            s.move_heads_with(|map, head, _| {\n                (\n                    movement::indented_line_beginning(\n                        map,\n                        head,\n                        action.stop_at_soft_wraps,\n                        action.stop_at_indent,\n                    ),\n                    SelectionGoal::None,\n                )\n            });\n        });\n    }\n\n    pub fn delete_to_beginning_of_line(\n        &mut self,\n        action: &DeleteToBeginningOfLine,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::TypingAction, cx);\n        self.transact(window, cx, |this, window, cx| {\n            this.change_selections(Default::default(), window, cx, |s| {\n                s.move_with(|_, selection| {\n                    selection.reversed = true;\n                });\n            });\n\n            this.select_to_beginning_of_line(\n                &SelectToBeginningOfLine {\n                    stop_at_soft_wraps: false,\n                    stop_at_indent: action.stop_at_indent,\n                },\n                window,\n                cx,\n            );\n            this.backspace(&Backspace, window, cx);\n        });\n    }\n\n    pub fn move_to_end_of_line(\n        &mut self,\n        action: &MoveToEndOfLine,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n        self.change_selections(Default::default(), window, cx, |s| {\n            s.move_cursors_with(|map, head, _| {\n                (\n                    movement::line_end(map, head, action.stop_at_soft_wraps),\n                    SelectionGoal::None,\n                )\n            });\n        })\n    }\n\n    pub fn select_to_end_of_line(\n        &mut self,\n        action: &SelectToEndOfLine,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n        self.change_selections(Default::default(), window, cx, |s| {\n            s.move_heads_with(|map, head, _| {\n                (\n                    movement::line_end(map, head, action.stop_at_soft_wraps),\n                    SelectionGoal::None,\n                )\n            });\n        })\n    }\n\n    pub fn delete_to_end_of_line(\n        &mut self,\n        _: &DeleteToEndOfLine,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::TypingAction, cx);\n        self.transact(window, cx, |this, window, cx| {\n            this.select_to_end_of_line(\n                &SelectToEndOfLine {\n                    stop_at_soft_wraps: false,\n                },\n                window,\n                cx,\n            );\n            this.delete(&Delete, window, cx);\n        });\n    }\n\n    pub fn cut_to_end_of_line(\n        &mut self,\n        action: &CutToEndOfLine,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::TypingAction, cx);\n        self.transact(window, cx, |this, window, cx| {\n            this.select_to_end_of_line(\n                &SelectToEndOfLine {\n                    stop_at_soft_wraps: false,\n                },\n                window,\n                cx,\n            );\n            if !action.stop_at_newlines {\n                this.change_selections(Default::default(), window, cx, |s| {\n                    s.move_with(|_, sel| {\n                        if sel.is_empty() {\n                            sel.end = DisplayPoint::new(sel.end.row() + 1_u32, 0);\n                        }\n                    });\n                });\n            }\n            this.hide_mouse_cursor(HideMouseCursorOrigin::TypingAction, cx);\n            let item = this.cut_common(false, window, cx);\n            cx.write_to_clipboard(item);\n        });\n    }\n\n    pub fn move_to_start_of_paragraph(\n        &mut self,\n        _: &MoveToStartOfParagraph,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if matches!(self.mode, EditorMode::SingleLine) {\n            cx.propagate();\n            return;\n        }\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n        self.change_selections(Default::default(), window, cx, |s| {\n            s.move_with(|map, selection| {\n                selection.collapse_to(\n                    movement::start_of_paragraph(map, selection.head(), 1),\n                    SelectionGoal::None,\n                )\n            });\n        })\n    }\n\n    pub fn move_to_end_of_paragraph(\n        &mut self,\n        _: &MoveToEndOfParagraph,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if matches!(self.mode, EditorMode::SingleLine) {\n            cx.propagate();\n            return;\n        }\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n        self.change_selections(Default::default(), window, cx, |s| {\n            s.move_with(|map, selection| {\n                selection.collapse_to(\n                    movement::end_of_paragraph(map, selection.head(), 1),\n                    SelectionGoal::None,\n                )\n            });\n        })\n    }\n\n    pub fn select_to_start_of_paragraph(\n        &mut self,\n        _: &SelectToStartOfParagraph,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if matches!(self.mode, EditorMode::SingleLine) {\n            cx.propagate();\n            return;\n        }\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n        self.change_selections(Default::default(), window, cx, |s| {\n            s.move_heads_with(|map, head, _| {\n                (\n                    movement::start_of_paragraph(map, head, 1),\n                    SelectionGoal::None,\n                )\n            });\n        })\n    }\n\n    pub fn select_to_end_of_paragraph(\n        &mut self,\n        _: &SelectToEndOfParagraph,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if matches!(self.mode, EditorMode::SingleLine) {\n            cx.propagate();\n            return;\n        }\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n        self.change_selections(Default::default(), window, cx, |s| {\n            s.move_heads_with(|map, head, _| {\n                (\n                    movement::end_of_paragraph(map, head, 1),\n                    SelectionGoal::None,\n                )\n            });\n        })\n    }\n\n    pub fn move_to_start_of_excerpt(\n        &mut self,\n        _: &MoveToStartOfExcerpt,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if matches!(self.mode, EditorMode::SingleLine) {\n            cx.propagate();\n            return;\n        }\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n        self.change_selections(Default::default(), window, cx, |s| {\n            s.move_with(|map, selection| {\n                selection.collapse_to(\n                    movement::start_of_excerpt(\n                        map,\n                        selection.head(),\n                        workspace::searchable::Direction::Prev,\n                    ),\n                    SelectionGoal::None,\n                )\n            });\n        })\n    }\n\n    pub fn move_to_start_of_next_excerpt(\n        &mut self,\n        _: &MoveToStartOfNextExcerpt,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if matches!(self.mode, EditorMode::SingleLine) {\n            cx.propagate();\n            return;\n        }\n\n        self.change_selections(Default::default(), window, cx, |s| {\n            s.move_with(|map, selection| {\n                selection.collapse_to(\n                    movement::start_of_excerpt(\n                        map,\n                        selection.head(),\n                        workspace::searchable::Direction::Next,\n                    ),\n                    SelectionGoal::None,\n                )\n            });\n        })\n    }\n\n    pub fn move_to_end_of_excerpt(\n        &mut self,\n        _: &MoveToEndOfExcerpt,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if matches!(self.mode, EditorMode::SingleLine) {\n            cx.propagate();\n            return;\n        }\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n        self.change_selections(Default::default(), window, cx, |s| {\n            s.move_with(|map, selection| {\n                selection.collapse_to(\n                    movement::end_of_excerpt(\n                        map,\n                        selection.head(),\n                        workspace::searchable::Direction::Next,\n                    ),\n                    SelectionGoal::None,\n                )\n            });\n        })\n    }\n\n    pub fn move_to_end_of_previous_excerpt(\n        &mut self,\n        _: &MoveToEndOfPreviousExcerpt,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if matches!(self.mode, EditorMode::SingleLine) {\n            cx.propagate();\n            return;\n        }\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n        self.change_selections(Default::default(), window, cx, |s| {\n            s.move_with(|map, selection| {\n                selection.collapse_to(\n                    movement::end_of_excerpt(\n                        map,\n                        selection.head(),\n                        workspace::searchable::Direction::Prev,\n                    ),\n                    SelectionGoal::None,\n                )\n            });\n        })\n    }\n\n    pub fn select_to_start_of_excerpt(\n        &mut self,\n        _: &SelectToStartOfExcerpt,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if matches!(self.mode, EditorMode::SingleLine) {\n            cx.propagate();\n            return;\n        }\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n        self.change_selections(Default::default(), window, cx, |s| {\n            s.move_heads_with(|map, head, _| {\n                (\n                    movement::start_of_excerpt(map, head, workspace::searchable::Direction::Prev),\n                    SelectionGoal::None,\n                )\n            });\n        })\n    }\n\n    pub fn select_to_start_of_next_excerpt(\n        &mut self,\n        _: &SelectToStartOfNextExcerpt,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if matches!(self.mode, EditorMode::SingleLine) {\n            cx.propagate();\n            return;\n        }\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n        self.change_selections(Default::default(), window, cx, |s| {\n            s.move_heads_with(|map, head, _| {\n                (\n                    movement::start_of_excerpt(map, head, workspace::searchable::Direction::Next),\n                    SelectionGoal::None,\n                )\n            });\n        })\n    }\n\n    pub fn select_to_end_of_excerpt(\n        &mut self,\n        _: &SelectToEndOfExcerpt,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if matches!(self.mode, EditorMode::SingleLine) {\n            cx.propagate();\n            return;\n        }\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n        self.change_selections(Default::default(), window, cx, |s| {\n            s.move_heads_with(|map, head, _| {\n                (\n                    movement::end_of_excerpt(map, head, workspace::searchable::Direction::Next),\n                    SelectionGoal::None,\n                )\n            });\n        })\n    }\n\n    pub fn select_to_end_of_previous_excerpt(\n        &mut self,\n        _: &SelectToEndOfPreviousExcerpt,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if matches!(self.mode, EditorMode::SingleLine) {\n            cx.propagate();\n            return;\n        }\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n        self.change_selections(Default::default(), window, cx, |s| {\n            s.move_heads_with(|map, head, _| {\n                (\n                    movement::end_of_excerpt(map, head, workspace::searchable::Direction::Prev),\n                    SelectionGoal::None,\n                )\n            });\n        })\n    }\n\n    pub fn move_to_beginning(\n        &mut self,\n        _: &MoveToBeginning,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if matches!(self.mode, EditorMode::SingleLine) {\n            cx.propagate();\n            return;\n        }\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n        self.change_selections(Default::default(), window, cx, |s| {\n            s.select_ranges(vec![0..0]);\n        });\n    }\n\n    pub fn select_to_beginning(\n        &mut self,\n        _: &SelectToBeginning,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let mut selection = self.selections.last::<Point>(&self.display_snapshot(cx));\n        selection.set_head(Point::zero(), SelectionGoal::None);\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n        self.change_selections(Default::default(), window, cx, |s| {\n            s.select(vec![selection]);\n        });\n    }\n\n    pub fn move_to_end(&mut self, _: &MoveToEnd, window: &mut Window, cx: &mut Context<Self>) {\n        if matches!(self.mode, EditorMode::SingleLine) {\n            cx.propagate();\n            return;\n        }\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n        let cursor = self.buffer.read(cx).read(cx).len();\n        self.change_selections(Default::default(), window, cx, |s| {\n            s.select_ranges(vec![cursor..cursor])\n        });\n    }\n\n    pub fn set_nav_history(&mut self, nav_history: Option<ItemNavHistory>) {\n        self.nav_history = nav_history;\n    }\n\n    pub fn nav_history(&self) -> Option<&ItemNavHistory> {\n        self.nav_history.as_ref()\n    }\n\n    pub fn create_nav_history_entry(&mut self, cx: &mut Context<Self>) {\n        self.push_to_nav_history(\n            self.selections.newest_anchor().head(),\n            None,\n            false,\n            true,\n            cx,\n        );\n    }\n\n    fn push_to_nav_history(\n        &mut self,\n        cursor_anchor: Anchor,\n        new_position: Option<Point>,\n        is_deactivate: bool,\n        always: bool,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(nav_history) = self.nav_history.as_mut() {\n            let buffer = self.buffer.read(cx).read(cx);\n            let cursor_position = cursor_anchor.to_point(&buffer);\n            let scroll_state = self.scroll_manager.anchor();\n            let scroll_top_row = scroll_state.top_row(&buffer);\n            drop(buffer);\n\n            if let Some(new_position) = new_position {\n                let row_delta = (new_position.row as i64 - cursor_position.row as i64).abs();\n                if row_delta == 0 || (row_delta < MIN_NAVIGATION_HISTORY_ROW_DELTA && !always) {\n                    return;\n                }\n            }\n\n            nav_history.push(\n                Some(NavigationData {\n                    cursor_anchor,\n                    cursor_position,\n                    scroll_anchor: scroll_state,\n                    scroll_top_row,\n                }),\n                cx,\n            );\n            cx.emit(EditorEvent::PushedToNavHistory {\n                anchor: cursor_anchor,\n                is_deactivate,\n            })\n        }\n    }\n\n    pub fn select_to_end(&mut self, _: &SelectToEnd, window: &mut Window, cx: &mut Context<Self>) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n        let buffer = self.buffer.read(cx).snapshot(cx);\n        let mut selection = self.selections.first::<usize>(&self.display_snapshot(cx));\n        selection.set_head(buffer.len(), SelectionGoal::None);\n        self.change_selections(Default::default(), window, cx, |s| {\n            s.select(vec![selection]);\n        });\n    }\n\n    pub fn select_all(&mut self, _: &SelectAll, window: &mut Window, cx: &mut Context<Self>) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n        let end = self.buffer.read(cx).read(cx).len();\n        self.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n            s.select_ranges(vec![0..end]);\n        });\n    }\n\n    pub fn select_line(&mut self, _: &SelectLine, window: &mut Window, cx: &mut Context<Self>) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n        let mut selections = self.selections.all::<Point>(&display_map);\n        let max_point = display_map.buffer_snapshot().max_point();\n        for selection in &mut selections {\n            let rows = selection.spanned_rows(true, &display_map);\n            selection.start = Point::new(rows.start.0, 0);\n            selection.end = cmp::min(max_point, Point::new(rows.end.0, 0));\n            selection.reversed = false;\n        }\n        self.change_selections(Default::default(), window, cx, |s| {\n            s.select(selections);\n        });\n    }\n\n    pub fn split_selection_into_lines(\n        &mut self,\n        action: &SplitSelectionIntoLines,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let selections = self\n            .selections\n            .all::<Point>(&self.display_snapshot(cx))\n            .into_iter()\n            .map(|selection| selection.start..selection.end)\n            .collect::<Vec<_>>();\n        self.unfold_ranges(&selections, true, true, cx);\n\n        let mut new_selection_ranges = Vec::new();\n        {\n            let buffer = self.buffer.read(cx).read(cx);\n            for selection in selections {\n                for row in selection.start.row..selection.end.row {\n                    let line_start = Point::new(row, 0);\n                    let line_end = Point::new(row, buffer.line_len(MultiBufferRow(row)));\n\n                    if action.keep_selections {\n                        // Keep the selection range for each line\n                        let selection_start = if row == selection.start.row {\n                            selection.start\n                        } else {\n                            line_start\n                        };\n                        new_selection_ranges.push(selection_start..line_end);\n                    } else {\n                        // Collapse to cursor at end of line\n                        new_selection_ranges.push(line_end..line_end);\n                    }\n                }\n\n                let is_multiline_selection = selection.start.row != selection.end.row;\n                // Don't insert last one if it's a multi-line selection ending at the start of a line,\n                // so this action feels more ergonomic when paired with other selection operations\n                let should_skip_last = is_multiline_selection && selection.end.column == 0;\n                if !should_skip_last {\n                    if action.keep_selections {\n                        if is_multiline_selection {\n                            let line_start = Point::new(selection.end.row, 0);\n                            new_selection_ranges.push(line_start..selection.end);\n                        } else {\n                            new_selection_ranges.push(selection.start..selection.end);\n                        }\n                    } else {\n                        new_selection_ranges.push(selection.end..selection.end);\n                    }\n                }\n            }\n        }\n        self.change_selections(Default::default(), window, cx, |s| {\n            s.select_ranges(new_selection_ranges);\n        });\n    }\n\n    pub fn add_selection_above(\n        &mut self,\n        action: &AddSelectionAbove,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.add_selection(true, action.skip_soft_wrap, window, cx);\n    }\n\n    pub fn add_selection_below(\n        &mut self,\n        action: &AddSelectionBelow,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.add_selection(false, action.skip_soft_wrap, window, cx);\n    }\n\n    fn add_selection(\n        &mut self,\n        above: bool,\n        skip_soft_wrap: bool,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n        let all_selections = self.selections.all::<Point>(&display_map);\n        let text_layout_details = self.text_layout_details(window);\n\n        let (mut columnar_selections, new_selections_to_columnarize) = {\n            if let Some(state) = self.add_selections_state.as_ref() {\n                let columnar_selection_ids: HashSet<_> = state\n                    .groups\n                    .iter()\n                    .flat_map(|group| group.stack.iter())\n                    .copied()\n                    .collect();\n\n                all_selections\n                    .into_iter()\n                    .partition(|s| columnar_selection_ids.contains(&s.id))\n            } else {\n                (Vec::new(), all_selections)\n            }\n        };\n\n        let mut state = self\n            .add_selections_state\n            .take()\n            .unwrap_or_else(|| AddSelectionsState { groups: Vec::new() });\n\n        for selection in new_selections_to_columnarize {\n            let range = selection.display_range(&display_map).sorted();\n            let start_x = display_map.x_for_display_point(range.start, &text_layout_details);\n            let end_x = display_map.x_for_display_point(range.end, &text_layout_details);\n            let positions = start_x.min(end_x)..start_x.max(end_x);\n            let mut stack = Vec::new();\n            for row in range.start.row().0..=range.end.row().0 {\n                if let Some(selection) = self.selections.build_columnar_selection(\n                    &display_map,\n                    DisplayRow(row),\n                    &positions,\n                    selection.reversed,\n                    &text_layout_details,\n                ) {\n                    stack.push(selection.id);\n                    columnar_selections.push(selection);\n                }\n            }\n            if !stack.is_empty() {\n                if above {\n                    stack.reverse();\n                }\n                state.groups.push(AddSelectionsGroup { above, stack });\n            }\n        }\n\n        let mut final_selections = Vec::new();\n        let end_row = if above {\n            DisplayRow(0)\n        } else {\n            display_map.max_point().row()\n        };\n\n        let mut last_added_item_per_group = HashMap::default();\n        for group in state.groups.iter_mut() {\n            if let Some(last_id) = group.stack.last() {\n                last_added_item_per_group.insert(*last_id, group);\n            }\n        }\n\n        for selection in columnar_selections {\n            if let Some(group) = last_added_item_per_group.get_mut(&selection.id) {\n                if above == group.above {\n                    let range = selection.display_range(&display_map).sorted();\n                    debug_assert_eq!(range.start.row(), range.end.row());\n                    let mut row = range.start.row();\n                    let positions =\n                        if let SelectionGoal::HorizontalRange { start, end } = selection.goal {\n                            Pixels::from(start)..Pixels::from(end)\n                        } else {\n                            let start_x =\n                                display_map.x_for_display_point(range.start, &text_layout_details);\n                            let end_x =\n                                display_map.x_for_display_point(range.end, &text_layout_details);\n                            start_x.min(end_x)..start_x.max(end_x)\n                        };\n\n                    let mut maybe_new_selection = None;\n                    let direction = if above { -1 } else { 1 };\n\n                    while row != end_row {\n                        if skip_soft_wrap {\n                            row = display_map\n                                .start_of_relative_buffer_row(DisplayPoint::new(row, 0), direction)\n                                .row();\n                        } else if above {\n                            row.0 -= 1;\n                        } else {\n                            row.0 += 1;\n                        }\n\n                        if let Some(new_selection) = self.selections.build_columnar_selection(\n                            &display_map,\n                            row,\n                            &positions,\n                            selection.reversed,\n                            &text_layout_details,\n                        ) {\n                            maybe_new_selection = Some(new_selection);\n                            break;\n                        }\n                    }\n\n                    if let Some(new_selection) = maybe_new_selection {\n                        group.stack.push(new_selection.id);\n                        if above {\n                            final_selections.push(new_selection);\n                            final_selections.push(selection);\n                        } else {\n                            final_selections.push(selection);\n                            final_selections.push(new_selection);\n                        }\n                    } else {\n                        final_selections.push(selection);\n                    }\n                } else {\n                    group.stack.pop();\n                }\n            } else {\n                final_selections.push(selection);\n            }\n        }\n\n        self.change_selections(Default::default(), window, cx, |s| {\n            s.select(final_selections);\n        });\n\n        let final_selection_ids: HashSet<_> = self\n            .selections\n            .all::<Point>(&display_map)\n            .iter()\n            .map(|s| s.id)\n            .collect();\n        state.groups.retain_mut(|group| {\n            // selections might get merged above so we remove invalid items from stacks\n            group.stack.retain(|id| final_selection_ids.contains(id));\n\n            // single selection in stack can be treated as initial state\n            group.stack.len() > 1\n        });\n\n        if !state.groups.is_empty() {\n            self.add_selections_state = Some(state);\n        }\n    }\n\n    fn select_match_ranges(\n        &mut self,\n        range: Range<usize>,\n        reversed: bool,\n        replace_newest: bool,\n        auto_scroll: Option<Autoscroll>,\n        window: &mut Window,\n        cx: &mut Context<Editor>,\n    ) {\n        self.unfold_ranges(\n            std::slice::from_ref(&range),\n            false,\n            auto_scroll.is_some(),\n            cx,\n        );\n        let effects = if let Some(scroll) = auto_scroll {\n            SelectionEffects::scroll(scroll)\n        } else {\n            SelectionEffects::no_scroll()\n        };\n        self.change_selections(effects, window, cx, |s| {\n            if replace_newest {\n                s.delete(s.newest_anchor().id);\n            }\n            if reversed {\n                s.insert_range(range.end..range.start);\n            } else {\n                s.insert_range(range);\n            }\n        });\n    }\n\n    pub fn select_next_match_internal(\n        &mut self,\n        display_map: &DisplaySnapshot,\n        replace_newest: bool,\n        autoscroll: Option<Autoscroll>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Result<()> {\n        let buffer = display_map.buffer_snapshot();\n        let mut selections = self.selections.all::<usize>(&display_map);\n        if let Some(mut select_next_state) = self.select_next_state.take() {\n            let query = &select_next_state.query;\n            if !select_next_state.done {\n                let first_selection = selections.iter().min_by_key(|s| s.id).unwrap();\n                let last_selection = selections.iter().max_by_key(|s| s.id).unwrap();\n                let mut next_selected_range = None;\n\n                let bytes_after_last_selection =\n                    buffer.bytes_in_range(last_selection.end..buffer.len());\n                let bytes_before_first_selection = buffer.bytes_in_range(0..first_selection.start);\n                let query_matches = query\n                    .stream_find_iter(bytes_after_last_selection)\n                    .map(|result| (last_selection.end, result))\n                    .chain(\n                        query\n                            .stream_find_iter(bytes_before_first_selection)\n                            .map(|result| (0, result)),\n                    );\n\n                for (start_offset, query_match) in query_matches {\n                    let query_match = query_match.unwrap(); // can only fail due to I/O\n                    let offset_range =\n                        start_offset + query_match.start()..start_offset + query_match.end();\n\n                    if !select_next_state.wordwise\n                        || (!buffer.is_inside_word(offset_range.start, None)\n                            && !buffer.is_inside_word(offset_range.end, None))\n                    {\n                        let idx = selections\n                            .partition_point(|selection| selection.end <= offset_range.start);\n                        let overlaps = selections\n                            .get(idx)\n                            .map_or(false, |selection| selection.start < offset_range.end);\n\n                        if !overlaps {\n                            next_selected_range = Some(offset_range);\n                            break;\n                        }\n                    }\n                }\n\n                if let Some(next_selected_range) = next_selected_range {\n                    self.select_match_ranges(\n                        next_selected_range,\n                        last_selection.reversed,\n                        replace_newest,\n                        autoscroll,\n                        window,\n                        cx,\n                    );\n                } else {\n                    select_next_state.done = true;\n                }\n            }\n\n            self.select_next_state = Some(select_next_state);\n        } else {\n            let mut only_carets = true;\n            let mut same_text_selected = true;\n            let mut selected_text = None;\n\n            let mut selections_iter = selections.iter().peekable();\n            while let Some(selection) = selections_iter.next() {\n                if selection.start != selection.end {\n                    only_carets = false;\n                }\n\n                if same_text_selected {\n                    if selected_text.is_none() {\n                        selected_text =\n                            Some(buffer.text_for_range(selection.range()).collect::<String>());\n                    }\n\n                    if let Some(next_selection) = selections_iter.peek() {\n                        if next_selection.range().len() == selection.range().len() {\n                            let next_selected_text = buffer\n                                .text_for_range(next_selection.range())\n                                .collect::<String>();\n                            if Some(next_selected_text) != selected_text {\n                                same_text_selected = false;\n                                selected_text = None;\n                            }\n                        } else {\n                            same_text_selected = false;\n                            selected_text = None;\n                        }\n                    }\n                }\n            }\n\n            if only_carets {\n                for selection in &mut selections {\n                    let (word_range, _) = buffer.surrounding_word(selection.start, None);\n                    selection.start = word_range.start;\n                    selection.end = word_range.end;\n                    selection.goal = SelectionGoal::None;\n                    selection.reversed = false;\n                    self.select_match_ranges(\n                        selection.start..selection.end,\n                        selection.reversed,\n                        replace_newest,\n                        autoscroll,\n                        window,\n                        cx,\n                    );\n                }\n\n                if selections.len() == 1 {\n                    let selection = selections\n                        .last()\n                        .expect(": "",
        ");\n                    let query = buffer\n                        .text_for_range(selection.start..selection.end)\n                        .collect::<String>();\n                    let is_empty = query.is_empty();\n                    let select_state = SelectNextState {\n                        query: self.build_query(&[query], cx)?,\n                        wordwise: true,\n                        done: is_empty,\n                    };\n                    self.select_next_state = Some(select_state);\n                } else {\n                    self.select_next_state = None;\n                }\n            } else if let Some(selected_text) = selected_text {\n                self.select_next_state = Some(SelectNextState {\n                    query: self.build_query(&[selected_text], cx)?,\n                    wordwise: false,\n                    done: false,\n                });\n                self.select_next_match_internal(\n                    display_map,\n                    replace_newest,\n                    autoscroll,\n                    window,\n                    cx,\n                )?;\n            }\n        }\n        Ok(())\n    }\n\n    pub fn select_all_matches(\n        &mut self,\n        _action: &SelectAllMatches,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Result<()> {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n\n        self.select_next_match_internal(&display_map, false, None, window, cx)?;\n        let Some(select_next_state) = self.select_next_state.as_mut() else {\n            return Ok(());\n        };\n        if select_next_state.done {\n            return Ok(());\n        }\n\n        let mut new_selections = Vec::new();\n\n        let reversed = self.selections.oldest::<usize>(&display_map).reversed;\n        let buffer = display_map.buffer_snapshot();\n        let query_matches = select_next_state\n            .query\n            .stream_find_iter(buffer.bytes_in_range(0..buffer.len()));\n\n        for query_match in query_matches.into_iter() {\n            let query_match = query_match.context(": "",
        ")?; // can only fail due to I/O\n            let offset_range = if reversed {\n                query_match.end()..query_match.start()\n            } else {\n                query_match.start()..query_match.end()\n            };\n\n            if !select_next_state.wordwise\n                || (!buffer.is_inside_word(offset_range.start, None)\n                    && !buffer.is_inside_word(offset_range.end, None))\n            {\n                new_selections.push(offset_range.start..offset_range.end);\n            }\n        }\n\n        select_next_state.done = true;\n\n        if new_selections.is_empty() {\n            log::error!(": "",
        ");\n            return Ok(());\n        }\n\n        self.unfold_ranges(&new_selections.clone(), false, false, cx);\n        self.change_selections(SelectionEffects::no_scroll(), window, cx, |selections| {\n            selections.select_ranges(new_selections)\n        });\n\n        Ok(())\n    }\n\n    pub fn select_next(\n        &mut self,\n        action: &SelectNext,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Result<()> {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n        self.select_next_match_internal(\n            &display_map,\n            action.replace_newest,\n            Some(Autoscroll::newest()),\n            window,\n            cx,\n        )?;\n        Ok(())\n    }\n\n    pub fn select_previous(\n        &mut self,\n        action: &SelectPrevious,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Result<()> {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n        let buffer = display_map.buffer_snapshot();\n        let mut selections = self.selections.all::<usize>(&display_map);\n        if let Some(mut select_prev_state) = self.select_prev_state.take() {\n            let query = &select_prev_state.query;\n            if !select_prev_state.done {\n                let first_selection = selections.iter().min_by_key(|s| s.id).unwrap();\n                let last_selection = selections.iter().max_by_key(|s| s.id).unwrap();\n                let mut next_selected_range = None;\n                // When we're iterating matches backwards, the oldest match will actually be the furthest one in the buffer.\n                let bytes_before_last_selection =\n                    buffer.reversed_bytes_in_range(0..last_selection.start);\n                let bytes_after_first_selection =\n                    buffer.reversed_bytes_in_range(first_selection.end..buffer.len());\n                let query_matches = query\n                    .stream_find_iter(bytes_before_last_selection)\n                    .map(|result| (last_selection.start, result))\n                    .chain(\n                        query\n                            .stream_find_iter(bytes_after_first_selection)\n                            .map(|result| (buffer.len(), result)),\n                    );\n                for (end_offset, query_match) in query_matches {\n                    let query_match = query_match.unwrap(); // can only fail due to I/O\n                    let offset_range =\n                        end_offset - query_match.end()..end_offset - query_match.start();\n\n                    if !select_prev_state.wordwise\n                        || (!buffer.is_inside_word(offset_range.start, None)\n                            && !buffer.is_inside_word(offset_range.end, None))\n                    {\n                        next_selected_range = Some(offset_range);\n                        break;\n                    }\n                }\n\n                if let Some(next_selected_range) = next_selected_range {\n                    self.select_match_ranges(\n                        next_selected_range,\n                        last_selection.reversed,\n                        action.replace_newest,\n                        Some(Autoscroll::newest()),\n                        window,\n                        cx,\n                    );\n                } else {\n                    select_prev_state.done = true;\n                }\n            }\n\n            self.select_prev_state = Some(select_prev_state);\n        } else {\n            let mut only_carets = true;\n            let mut same_text_selected = true;\n            let mut selected_text = None;\n\n            let mut selections_iter = selections.iter().peekable();\n            while let Some(selection) = selections_iter.next() {\n                if selection.start != selection.end {\n                    only_carets = false;\n                }\n\n                if same_text_selected {\n                    if selected_text.is_none() {\n                        selected_text =\n                            Some(buffer.text_for_range(selection.range()).collect::<String>());\n                    }\n\n                    if let Some(next_selection) = selections_iter.peek() {\n                        if next_selection.range().len() == selection.range().len() {\n                            let next_selected_text = buffer\n                                .text_for_range(next_selection.range())\n                                .collect::<String>();\n                            if Some(next_selected_text) != selected_text {\n                                same_text_selected = false;\n                                selected_text = None;\n                            }\n                        } else {\n                            same_text_selected = false;\n                            selected_text = None;\n                        }\n                    }\n                }\n            }\n\n            if only_carets {\n                for selection in &mut selections {\n                    let (word_range, _) = buffer.surrounding_word(selection.start, None);\n                    selection.start = word_range.start;\n                    selection.end = word_range.end;\n                    selection.goal = SelectionGoal::None;\n                    selection.reversed = false;\n                    self.select_match_ranges(\n                        selection.start..selection.end,\n                        selection.reversed,\n                        action.replace_newest,\n                        Some(Autoscroll::newest()),\n                        window,\n                        cx,\n                    );\n                }\n                if selections.len() == 1 {\n                    let selection = selections\n                        .last()\n                        .expect(": "",
        ");\n                    let query = buffer\n                        .text_for_range(selection.start..selection.end)\n                        .collect::<String>();\n                    let is_empty = query.is_empty();\n                    let select_state = SelectNextState {\n                        query: self.build_query(&[query.chars().rev().collect::<String>()], cx)?,\n                        wordwise: true,\n                        done: is_empty,\n                    };\n                    self.select_prev_state = Some(select_state);\n                } else {\n                    self.select_prev_state = None;\n                }\n            } else if let Some(selected_text) = selected_text {\n                self.select_prev_state = Some(SelectNextState {\n                    query: self\n                        .build_query(&[selected_text.chars().rev().collect::<String>()], cx)?,\n                    wordwise: false,\n                    done: false,\n                });\n                self.select_previous(action, window, cx)?;\n            }\n        }\n        Ok(())\n    }\n\n    /// Builds an `AhoCorasick` automaton from the provided patterns, while\n    /// setting the case sensitivity based on the global\n    /// `SelectNextCaseSensitive` setting, if set, otherwise based on the\n    /// editor's settings.\n    fn build_query<I, P>(&self, patterns: I, cx: &Context<Self>) -> Result<AhoCorasick, BuildError>\n    where\n        I: IntoIterator<Item = P>,\n        P: AsRef<[u8]>,\n    {\n        let case_sensitive = self.select_next_is_case_sensitive.map_or_else(\n            || EditorSettings::get_global(cx).search.case_sensitive,\n            |value| value,\n        );\n\n        let mut builder = AhoCorasickBuilder::new();\n        builder.ascii_case_insensitive(!case_sensitive);\n        builder.build(patterns)\n    }\n\n    pub fn find_next_match(\n        &mut self,\n        _: &FindNextMatch,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Result<()> {\n        let selections = self.selections.disjoint_anchors_arc();\n        match selections.first() {\n            Some(first) if selections.len() >= 2 => {\n                self.change_selections(Default::default(), window, cx, |s| {\n                    s.select_ranges([first.range()]);\n                });\n            }\n            _ => self.select_next(\n                &SelectNext {\n                    replace_newest: true,\n                },\n                window,\n                cx,\n            )?,\n        }\n        Ok(())\n    }\n\n    pub fn find_previous_match(\n        &mut self,\n        _: &FindPreviousMatch,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Result<()> {\n        let selections = self.selections.disjoint_anchors_arc();\n        match selections.last() {\n            Some(last) if selections.len() >= 2 => {\n                self.change_selections(Default::default(), window, cx, |s| {\n                    s.select_ranges([last.range()]);\n                });\n            }\n            _ => self.select_previous(\n                &SelectPrevious {\n                    replace_newest: true,\n                },\n                window,\n                cx,\n            )?,\n        }\n        Ok(())\n    }\n\n    pub fn toggle_comments(\n        &mut self,\n        action: &ToggleComments,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if self.read_only(cx) {\n            return;\n        }\n        self.hide_mouse_cursor(HideMouseCursorOrigin::TypingAction, cx);\n        let text_layout_details = &self.text_layout_details(window);\n        self.transact(window, cx, |this, window, cx| {\n            let mut selections = this\n                .selections\n                .all::<MultiBufferPoint>(&this.display_snapshot(cx));\n            let mut edits = Vec::new();\n            let mut selection_edit_ranges = Vec::new();\n            let mut last_toggled_row = None;\n            let snapshot = this.buffer.read(cx).read(cx);\n            let empty_str: Arc<str> = Arc::default();\n            let mut suffixes_inserted = Vec::new();\n            let ignore_indent = action.ignore_indent;\n\n            fn comment_prefix_range(\n                snapshot: &MultiBufferSnapshot,\n                row: MultiBufferRow,\n                comment_prefix: &str,\n                comment_prefix_whitespace: &str,\n                ignore_indent: bool,\n            ) -> Range<Point> {\n                let indent_size = if ignore_indent {\n                    0\n                } else {\n                    snapshot.indent_size_for_line(row).len\n                };\n\n                let start = Point::new(row.0, indent_size);\n\n                let mut line_bytes = snapshot\n                    .bytes_in_range(start..snapshot.max_point())\n                    .flatten()\n                    .copied();\n\n                // If this line currently begins with the line comment prefix, then record\n                // the range containing the prefix.\n                if line_bytes\n                    .by_ref()\n                    .take(comment_prefix.len())\n                    .eq(comment_prefix.bytes())\n                {\n                    // Include any whitespace that matches the comment prefix.\n                    let matching_whitespace_len = line_bytes\n                        .zip(comment_prefix_whitespace.bytes())\n                        .take_while(|(a, b)| a == b)\n                        .count() as u32;\n                    let end = Point::new(\n                        start.row,\n                        start.column + comment_prefix.len() as u32 + matching_whitespace_len,\n                    );\n                    start..end\n                } else {\n                    start..start\n                }\n            }\n\n            fn comment_suffix_range(\n                snapshot: &MultiBufferSnapshot,\n                row: MultiBufferRow,\n                comment_suffix: &str,\n                comment_suffix_has_leading_space: bool,\n            ) -> Range<Point> {\n                let end = Point::new(row.0, snapshot.line_len(row));\n                let suffix_start_column = end.column.saturating_sub(comment_suffix.len() as u32);\n\n                let mut line_end_bytes = snapshot\n                    .bytes_in_range(Point::new(end.row, suffix_start_column.saturating_sub(1))..end)\n                    .flatten()\n                    .copied();\n\n                let leading_space_len = if suffix_start_column > 0\n                    && line_end_bytes.next() == Some(b' ')\n                    && comment_suffix_has_leading_space\n                {\n                    1\n                } else {\n                    0\n                };\n\n                // If this line currently begins with the line comment prefix, then record\n                // the range containing the prefix.\n                if line_end_bytes.by_ref().eq(comment_suffix.bytes()) {\n                    let start = Point::new(end.row, suffix_start_column - leading_space_len);\n                    start..end\n                } else {\n                    end..end\n                }\n            }\n\n            // TODO: Handle selections that cross excerpts\n            for selection in &mut selections {\n                let start_column = snapshot\n                    .indent_size_for_line(MultiBufferRow(selection.start.row))\n                    .len;\n                let language = if let Some(language) =\n                    snapshot.language_scope_at(Point::new(selection.start.row, start_column))\n                {\n                    language\n                } else {\n                    continue;\n                };\n\n                selection_edit_ranges.clear();\n\n                // If multiple selections contain a given row, avoid processing that\n                // row more than once.\n                let mut start_row = MultiBufferRow(selection.start.row);\n                if last_toggled_row == Some(start_row) {\n                    start_row = start_row.next_row();\n                }\n                let end_row =\n                    if selection.end.row > selection.start.row && selection.end.column == 0 {\n                        MultiBufferRow(selection.end.row - 1)\n                    } else {\n                        MultiBufferRow(selection.end.row)\n                    };\n                last_toggled_row = Some(end_row);\n\n                if start_row > end_row {\n                    continue;\n                }\n\n                // If the language has line comments, toggle those.\n                let mut full_comment_prefixes = language.line_comment_prefixes().to_vec();\n\n                // If ignore_indent is set, trim spaces from the right side of all full_comment_prefixes\n                if ignore_indent {\n                    full_comment_prefixes = full_comment_prefixes\n                        .into_iter()\n                        .map(|s| Arc::from(s.trim_end()))\n                        .collect();\n                }\n\n                if !full_comment_prefixes.is_empty() {\n                    let first_prefix = full_comment_prefixes\n                        .first()\n                        .expect(": "",
        ");\n                    let prefix_trimmed_lengths = full_comment_prefixes\n                        .iter()\n                        .map(|p| p.trim_end_matches(' ').len())\n                        .collect::<SmallVec<[usize; 4]>>();\n\n                    let mut all_selection_lines_are_comments = true;\n\n                    for row in start_row.0..=end_row.0 {\n                        let row = MultiBufferRow(row);\n                        if start_row < end_row && snapshot.is_line_blank(row) {\n                            continue;\n                        }\n\n                        let prefix_range = full_comment_prefixes\n                            .iter()\n                            .zip(prefix_trimmed_lengths.iter().copied())\n                            .map(|(prefix, trimmed_prefix_len)| {\n                                comment_prefix_range(\n                                    snapshot.deref(),\n                                    row,\n                                    &prefix[..trimmed_prefix_len],\n                                    &prefix[trimmed_prefix_len..],\n                                    ignore_indent,\n                                )\n                            })\n                            .max_by_key(|range| range.end.column - range.start.column)\n                            .expect(": "",
        ");\n\n                        if prefix_range.is_empty() {\n                            all_selection_lines_are_comments = false;\n                        }\n\n                        selection_edit_ranges.push(prefix_range);\n                    }\n\n                    if all_selection_lines_are_comments {\n                        edits.extend(\n                            selection_edit_ranges\n                                .iter()\n                                .cloned()\n                                .map(|range| (range, empty_str.clone())),\n                        );\n                    } else {\n                        let min_column = selection_edit_ranges\n                            .iter()\n                            .map(|range| range.start.column)\n                            .min()\n                            .unwrap_or(0);\n                        edits.extend(selection_edit_ranges.iter().map(|range| {\n                            let position = Point::new(range.start.row, min_column);\n                            (position..position, first_prefix.clone())\n                        }));\n                    }\n                } else if let Some(BlockCommentConfig {\n                    start: full_comment_prefix,\n                    end: comment_suffix,\n                    ..\n                }) = language.block_comment()\n                {\n                    let comment_prefix = full_comment_prefix.trim_end_matches(' ');\n                    let comment_prefix_whitespace = &full_comment_prefix[comment_prefix.len()..];\n                    let prefix_range = comment_prefix_range(\n                        snapshot.deref(),\n                        start_row,\n                        comment_prefix,\n                        comment_prefix_whitespace,\n                        ignore_indent,\n                    );\n                    let suffix_range = comment_suffix_range(\n                        snapshot.deref(),\n                        end_row,\n                        comment_suffix.trim_start_matches(' '),\n                        comment_suffix.starts_with(' '),\n                    );\n\n                    if prefix_range.is_empty() || suffix_range.is_empty() {\n                        edits.push((\n                            prefix_range.start..prefix_range.start,\n                            full_comment_prefix.clone(),\n                        ));\n                        edits.push((suffix_range.end..suffix_range.end, comment_suffix.clone()));\n                        suffixes_inserted.push((end_row, comment_suffix.len()));\n                    } else {\n                        edits.push((prefix_range, empty_str.clone()));\n                        edits.push((suffix_range, empty_str.clone()));\n                    }\n                } else {\n                    continue;\n                }\n            }\n\n            drop(snapshot);\n            this.buffer.update(cx, |buffer, cx| {\n                buffer.edit(edits, None, cx);\n            });\n\n            // Adjust selections so that they end before any comment suffixes that\n            // were inserted.\n            let mut suffixes_inserted = suffixes_inserted.into_iter().peekable();\n            let mut selections = this.selections.all::<Point>(&this.display_snapshot(cx));\n            let snapshot = this.buffer.read(cx).read(cx);\n            for selection in &mut selections {\n                while let Some((row, suffix_len)) = suffixes_inserted.peek().copied() {\n                    match row.cmp(&MultiBufferRow(selection.end.row)) {\n                        Ordering::Less => {\n                            suffixes_inserted.next();\n                            continue;\n                        }\n                        Ordering::Greater => break,\n                        Ordering::Equal => {\n                            if selection.end.column == snapshot.line_len(row) {\n                                if selection.is_empty() {\n                                    selection.start.column -= suffix_len as u32;\n                                }\n                                selection.end.column -= suffix_len as u32;\n                            }\n                            break;\n                        }\n                    }\n                }\n            }\n\n            drop(snapshot);\n            this.change_selections(Default::default(), window, cx, |s| s.select(selections));\n\n            let selections = this.selections.all::<Point>(&this.display_snapshot(cx));\n            let selections_on_single_row = selections.windows(2).all(|selections| {\n                selections[0].start.row == selections[1].start.row\n                    && selections[0].end.row == selections[1].end.row\n                    && selections[0].start.row == selections[0].end.row\n            });\n            let selections_selecting = selections\n                .iter()\n                .any(|selection| selection.start != selection.end);\n            let advance_downwards = action.advance_downwards\n                && selections_on_single_row\n                && !selections_selecting\n                && !matches!(this.mode, EditorMode::SingleLine);\n\n            if advance_downwards {\n                let snapshot = this.buffer.read(cx).snapshot(cx);\n\n                this.change_selections(Default::default(), window, cx, |s| {\n                    s.move_cursors_with(|display_snapshot, display_point, _| {\n                        let mut point = display_point.to_point(display_snapshot);\n                        point.row += 1;\n                        point = snapshot.clip_point(point, Bias::Left);\n                        let display_point = point.to_display_point(display_snapshot);\n                        let goal = SelectionGoal::HorizontalPosition(\n                            display_snapshot\n                                .x_for_display_point(display_point, text_layout_details)\n                                .into(),\n                        );\n                        (display_point, goal)\n                    })\n                });\n            }\n        });\n    }\n\n    pub fn select_enclosing_symbol(\n        &mut self,\n        _: &SelectEnclosingSymbol,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n\n        let buffer = self.buffer.read(cx).snapshot(cx);\n        let old_selections = self\n            .selections\n            .all::<usize>(&self.display_snapshot(cx))\n            .into_boxed_slice();\n\n        fn update_selection(\n            selection: &Selection<usize>,\n            buffer_snap: &MultiBufferSnapshot,\n        ) -> Option<Selection<usize>> {\n            let cursor = selection.head();\n            let (_buffer_id, symbols) = buffer_snap.symbols_containing(cursor, None)?;\n            for symbol in symbols.iter().rev() {\n                let start = symbol.range.start.to_offset(buffer_snap);\n                let end = symbol.range.end.to_offset(buffer_snap);\n                let new_range = start..end;\n                if start < selection.start || end > selection.end {\n                    return Some(Selection {\n                        id: selection.id,\n                        start: new_range.start,\n                        end: new_range.end,\n                        goal: SelectionGoal::None,\n                        reversed: selection.reversed,\n                    });\n                }\n            }\n            None\n        }\n\n        let mut selected_larger_symbol = false;\n        let new_selections = old_selections\n            .iter()\n            .map(|selection| match update_selection(selection, &buffer) {\n                Some(new_selection) => {\n                    if new_selection.range() != selection.range() {\n                        selected_larger_symbol = true;\n                    }\n                    new_selection\n                }\n                None => selection.clone(),\n            })\n            .collect::<Vec<_>>();\n\n        if selected_larger_symbol {\n            self.change_selections(Default::default(), window, cx, |s| {\n                s.select(new_selections);\n            });\n        }\n    }\n\n    pub fn select_larger_syntax_node(\n        &mut self,\n        _: &SelectLargerSyntaxNode,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let Some(visible_row_count) = self.visible_row_count() else {\n            return;\n        };\n        let old_selections: Box<[_]> = self\n            .selections\n            .all::<usize>(&self.display_snapshot(cx))\n            .into();\n        if old_selections.is_empty() {\n            return;\n        }\n\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n        let buffer = self.buffer.read(cx).snapshot(cx);\n\n        let mut selected_larger_node = false;\n        let mut new_selections = old_selections\n            .iter()\n            .map(|selection| {\n                let old_range = selection.start..selection.end;\n\n                if let Some((node, _)) = buffer.syntax_ancestor(old_range.clone()) {\n                    // manually select word at selection\n                    if [": "",
        ", ": "",
        "].contains(&node.kind()) {\n                        let (word_range, _) = buffer.surrounding_word(old_range.start, None);\n                        // ignore if word is already selected\n                        if !word_range.is_empty() && old_range != word_range {\n                            let (last_word_range, _) = buffer.surrounding_word(old_range.end, None);\n                            // only select word if start and end point belongs to same word\n                            if word_range == last_word_range {\n                                selected_larger_node = true;\n                                return Selection {\n                                    id: selection.id,\n                                    start: word_range.start,\n                                    end: word_range.end,\n                                    goal: SelectionGoal::None,\n                                    reversed: selection.reversed,\n                                };\n                            }\n                        }\n                    }\n                }\n\n                let mut new_range = old_range.clone();\n                while let Some((node, range)) = buffer.syntax_ancestor(new_range.clone()) {\n                    new_range = range;\n                    if !node.is_named() {\n                        continue;\n                    }\n                    if !display_map.intersects_fold(new_range.start)\n                        && !display_map.intersects_fold(new_range.end)\n                    {\n                        break;\n                    }\n                }\n\n                selected_larger_node |= new_range != old_range;\n                Selection {\n                    id: selection.id,\n                    start: new_range.start,\n                    end: new_range.end,\n                    goal: SelectionGoal::None,\n                    reversed: selection.reversed,\n                }\n            })\n            .collect::<Vec<_>>();\n\n        if !selected_larger_node {\n            return; // don't put this call in the history\n        }\n\n        // scroll based on transformation done to the last selection created by the user\n        let (last_old, last_new) = old_selections\n            .last()\n            .zip(new_selections.last().cloned())\n            .expect(": "",
        ");\n\n        // revert selection\n        let is_selection_reversed = {\n            let should_newest_selection_be_reversed = last_old.start != last_new.start;\n            new_selections.last_mut().expect(": "",
        ").reversed =\n                should_newest_selection_be_reversed;\n            should_newest_selection_be_reversed\n        };\n\n        if selected_larger_node {\n            self.select_syntax_node_history.disable_clearing = true;\n            self.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n                s.select(new_selections.clone());\n            });\n            self.select_syntax_node_history.disable_clearing = false;\n        }\n\n        let start_row = last_new.start.to_display_point(&display_map).row().0;\n        let end_row = last_new.end.to_display_point(&display_map).row().0;\n        let selection_height = end_row - start_row + 1;\n        let scroll_margin_rows = self.vertical_scroll_margin() as u32;\n\n        let fits_on_the_screen = visible_row_count >= selection_height + scroll_margin_rows * 2;\n        let scroll_behavior = if fits_on_the_screen {\n            self.request_autoscroll(Autoscroll::fit(), cx);\n            SelectSyntaxNodeScrollBehavior::FitSelection\n        } else if is_selection_reversed {\n            self.scroll_cursor_top(&ScrollCursorTop, window, cx);\n            SelectSyntaxNodeScrollBehavior::CursorTop\n        } else {\n            self.scroll_cursor_bottom(&ScrollCursorBottom, window, cx);\n            SelectSyntaxNodeScrollBehavior::CursorBottom\n        };\n\n        self.select_syntax_node_history.push((\n            old_selections,\n            scroll_behavior,\n            is_selection_reversed,\n        ));\n    }\n\n    pub fn select_smaller_syntax_node(\n        &mut self,\n        _: &SelectSmallerSyntaxNode,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n\n        if let Some((mut selections, scroll_behavior, is_selection_reversed)) =\n            self.select_syntax_node_history.pop()\n        {\n            if let Some(selection) = selections.last_mut() {\n                selection.reversed = is_selection_reversed;\n            }\n\n            self.select_syntax_node_history.disable_clearing = true;\n            self.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n                s.select(selections.to_vec());\n            });\n            self.select_syntax_node_history.disable_clearing = false;\n\n            match scroll_behavior {\n                SelectSyntaxNodeScrollBehavior::CursorTop => {\n                    self.scroll_cursor_top(&ScrollCursorTop, window, cx);\n                }\n                SelectSyntaxNodeScrollBehavior::FitSelection => {\n                    self.request_autoscroll(Autoscroll::fit(), cx);\n                }\n                SelectSyntaxNodeScrollBehavior::CursorBottom => {\n                    self.scroll_cursor_bottom(&ScrollCursorBottom, window, cx);\n                }\n            }\n        }\n    }\n\n    pub fn unwrap_syntax_node(\n        &mut self,\n        _: &UnwrapSyntaxNode,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n\n        let buffer = self.buffer.read(cx).snapshot(cx);\n        let selections = self\n            .selections\n            .all::<usize>(&self.display_snapshot(cx))\n            .into_iter()\n            // subtracting the offset requires sorting\n            .sorted_by_key(|i| i.start);\n\n        let full_edits = selections\n            .into_iter()\n            .filter_map(|selection| {\n                let child = if selection.is_empty()\n                    && let Some((_, ancestor_range)) =\n                        buffer.syntax_ancestor(selection.start..selection.end)\n                {\n                    ancestor_range\n                } else {\n                    selection.range()\n                };\n\n                let mut parent = child.clone();\n                while let Some((_, ancestor_range)) = buffer.syntax_ancestor(parent.clone()) {\n                    parent = ancestor_range;\n                    if parent.start < child.start || parent.end > child.end {\n                        break;\n                    }\n                }\n\n                if parent == child {\n                    return None;\n                }\n                let text = buffer.text_for_range(child).collect::<String>();\n                Some((selection.id, parent, text))\n            })\n            .collect::<Vec<_>>();\n        if full_edits.is_empty() {\n            return;\n        }\n\n        self.transact(window, cx, |this, window, cx| {\n            this.buffer.update(cx, |buffer, cx| {\n                buffer.edit(\n                    full_edits\n                        .iter()\n                        .map(|(_, p, t)| (p.clone(), t.clone()))\n                        .collect::<Vec<_>>(),\n                    None,\n                    cx,\n                );\n            });\n            this.change_selections(Default::default(), window, cx, |s| {\n                let mut offset = 0;\n                let mut selections = vec![];\n                for (id, parent, text) in full_edits {\n                    let start = parent.start - offset;\n                    offset += parent.len() - text.len();\n                    selections.push(Selection {\n                        id,\n                        start,\n                        end: start + text.len(),\n                        reversed: false,\n                        goal: Default::default(),\n                    });\n                }\n                s.select(selections);\n            });\n        });\n    }\n\n    pub fn select_next_syntax_node(\n        &mut self,\n        _: &SelectNextSyntaxNode,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let old_selections: Box<[_]> = self\n            .selections\n            .all::<usize>(&self.display_snapshot(cx))\n            .into();\n        if old_selections.is_empty() {\n            return;\n        }\n\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n\n        let buffer = self.buffer.read(cx).snapshot(cx);\n        let mut selected_sibling = false;\n\n        let new_selections = old_selections\n            .iter()\n            .map(|selection| {\n                let old_range = selection.start..selection.end;\n\n                if let Some(node) = buffer.syntax_next_sibling(old_range) {\n                    let new_range = node.byte_range();\n                    selected_sibling = true;\n                    Selection {\n                        id: selection.id,\n                        start: new_range.start,\n                        end: new_range.end,\n                        goal: SelectionGoal::None,\n                        reversed: selection.reversed,\n                    }\n                } else {\n                    selection.clone()\n                }\n            })\n            .collect::<Vec<_>>();\n\n        if selected_sibling {\n            self.change_selections(\n                SelectionEffects::scroll(Autoscroll::fit()),\n                window,\n                cx,\n                |s| {\n                    s.select(new_selections);\n                },\n            );\n        }\n    }\n\n    pub fn select_prev_syntax_node(\n        &mut self,\n        _: &SelectPreviousSyntaxNode,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let old_selections: Box<[_]> = self\n            .selections\n            .all::<usize>(&self.display_snapshot(cx))\n            .into();\n        if old_selections.is_empty() {\n            return;\n        }\n\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n\n        let buffer = self.buffer.read(cx).snapshot(cx);\n        let mut selected_sibling = false;\n\n        let new_selections = old_selections\n            .iter()\n            .map(|selection| {\n                let old_range = selection.start..selection.end;\n\n                if let Some(node) = buffer.syntax_prev_sibling(old_range) {\n                    let new_range = node.byte_range();\n                    selected_sibling = true;\n                    Selection {\n                        id: selection.id,\n                        start: new_range.start,\n                        end: new_range.end,\n                        goal: SelectionGoal::None,\n                        reversed: selection.reversed,\n                    }\n                } else {\n                    selection.clone()\n                }\n            })\n            .collect::<Vec<_>>();\n\n        if selected_sibling {\n            self.change_selections(\n                SelectionEffects::scroll(Autoscroll::fit()),\n                window,\n                cx,\n                |s| {\n                    s.select(new_selections);\n                },\n            );\n        }\n    }\n\n    fn refresh_runnables(&mut self, window: &mut Window, cx: &mut Context<Self>) -> Task<()> {\n        if !EditorSettings::get_global(cx).gutter.runnables {\n            self.clear_tasks();\n            return Task::ready(());\n        }\n        let project = self.project().map(Entity::downgrade);\n        let task_sources = self.lsp_task_sources(cx);\n        let multi_buffer = self.buffer.downgrade();\n        cx.spawn_in(window, async move |editor, cx| {\n            cx.background_executor().timer(UPDATE_DEBOUNCE).await;\n            let Some(project) = project.and_then(|p| p.upgrade()) else {\n                return;\n            };\n            let Ok(display_snapshot) = editor.update(cx, |this, cx| {\n                this.display_map.update(cx, |map, cx| map.snapshot(cx))\n            }) else {\n                return;\n            };\n\n            let hide_runnables = project\n                .update(cx, |project, _| project.is_via_collab())\n                .unwrap_or(true);\n            if hide_runnables {\n                return;\n            }\n            let new_rows =\n                cx.background_spawn({\n                    let snapshot = display_snapshot.clone();\n                    async move {\n                        Self::fetch_runnable_ranges(&snapshot, Anchor::min()..Anchor::max())\n                    }\n                })\n                    .await;\n            let Ok(lsp_tasks) =\n                cx.update(|_, cx| crate::lsp_tasks(project.clone(), &task_sources, None, cx))\n            else {\n                return;\n            };\n            let lsp_tasks = lsp_tasks.await;\n\n            let Ok(mut lsp_tasks_by_rows) = cx.update(|_, cx| {\n                lsp_tasks\n                    .into_iter()\n                    .flat_map(|(kind, tasks)| {\n                        tasks.into_iter().filter_map(move |(location, task)| {\n                            Some((kind.clone(), location?, task))\n                        })\n                    })\n                    .fold(HashMap::default(), |mut acc, (kind, location, task)| {\n                        let buffer = location.target.buffer;\n                        let buffer_snapshot = buffer.read(cx).snapshot();\n                        let offset = display_snapshot.buffer_snapshot().excerpts().find_map(\n                            |(excerpt_id, snapshot, _)| {\n                                if snapshot.remote_id() == buffer_snapshot.remote_id() {\n                                    display_snapshot\n                                        .buffer_snapshot()\n                                        .anchor_in_excerpt(excerpt_id, location.target.range.start)\n                                } else {\n                                    None\n                                }\n                            },\n                        );\n                        if let Some(offset) = offset {\n                            let task_buffer_range =\n                                location.target.range.to_point(&buffer_snapshot);\n                            let context_buffer_range =\n                                task_buffer_range.to_offset(&buffer_snapshot);\n                            let context_range = BufferOffset(context_buffer_range.start)\n                                ..BufferOffset(context_buffer_range.end);\n\n                            acc.entry((buffer_snapshot.remote_id(), task_buffer_range.start.row))\n                                .or_insert_with(|| RunnableTasks {\n                                    templates: Vec::new(),\n                                    offset,\n                                    column: task_buffer_range.start.column,\n                                    extra_variables: HashMap::default(),\n                                    context_range,\n                                })\n                                .templates\n                                .push((kind, task.original_task().clone()));\n                        }\n\n                        acc\n                    })\n            }) else {\n                return;\n            };\n\n            let Ok(prefer_lsp) = multi_buffer.update(cx, |buffer, cx| {\n                buffer.language_settings(cx).tasks.prefer_lsp\n            }) else {\n                return;\n            };\n\n            let rows = Self::runnable_rows(\n                project,\n                display_snapshot,\n                prefer_lsp && !lsp_tasks_by_rows.is_empty(),\n                new_rows,\n                cx.clone(),\n            )\n            .await;\n            editor\n                .update(cx, |editor, _| {\n                    editor.clear_tasks();\n                    for (key, mut value) in rows {\n                        if let Some(lsp_tasks) = lsp_tasks_by_rows.remove(&key) {\n                            value.templates.extend(lsp_tasks.templates);\n                        }\n\n                        editor.insert_tasks(key, value);\n                    }\n                    for (key, value) in lsp_tasks_by_rows {\n                        editor.insert_tasks(key, value);\n                    }\n                })\n                .ok();\n        })\n    }\n    fn fetch_runnable_ranges(\n        snapshot: &DisplaySnapshot,\n        range: Range<Anchor>,\n    ) -> Vec<language::RunnableRange> {\n        snapshot.buffer_snapshot().runnable_ranges(range).collect()\n    }\n\n    fn runnable_rows(\n        project: Entity<Project>,\n        snapshot: DisplaySnapshot,\n        prefer_lsp: bool,\n        runnable_ranges: Vec<RunnableRange>,\n        cx: AsyncWindowContext,\n    ) -> Task<Vec<((BufferId, BufferRow), RunnableTasks)>> {\n        cx.spawn(async move |cx| {\n            let mut runnable_rows = Vec::with_capacity(runnable_ranges.len());\n            for mut runnable in runnable_ranges {\n                let Some(tasks) = cx\n                    .update(|_, cx| Self::templates_with_tags(&project, &mut runnable.runnable, cx))\n                    .ok()\n                else {\n                    continue;\n                };\n                let mut tasks = tasks.await;\n\n                if prefer_lsp {\n                    tasks.retain(|(task_kind, _)| {\n                        !matches!(task_kind, TaskSourceKind::Language { .. })\n                    });\n                }\n                if tasks.is_empty() {\n                    continue;\n                }\n\n                let point = runnable\n                    .run_range\n                    .start\n                    .to_point(&snapshot.buffer_snapshot());\n                let Some(row) = snapshot\n                    .buffer_snapshot()\n                    .buffer_line_for_row(MultiBufferRow(point.row))\n                    .map(|(_, range)| range.start.row)\n                else {\n                    continue;\n                };\n\n                let context_range =\n                    BufferOffset(runnable.full_range.start)..BufferOffset(runnable.full_range.end);\n                runnable_rows.push((\n                    (runnable.buffer_id, row),\n                    RunnableTasks {\n                        templates: tasks,\n                        offset: snapshot\n                            .buffer_snapshot()\n                            .anchor_before(runnable.run_range.start),\n                        context_range,\n                        column: point.column,\n                        extra_variables: runnable.extra_captures,\n                    },\n                ));\n            }\n            runnable_rows\n        })\n    }\n\n    fn templates_with_tags(\n        project: &Entity<Project>,\n        runnable: &mut Runnable,\n        cx: &mut App,\n    ) -> Task<Vec<(TaskSourceKind, TaskTemplate)>> {\n        let (inventory, worktree_id, file) = project.read_with(cx, |project, cx| {\n            let (worktree_id, file) = project\n                .buffer_for_id(runnable.buffer, cx)\n                .and_then(|buffer| buffer.read(cx).file())\n                .map(|file| (file.worktree_id(cx), file.clone()))\n                .unzip();\n\n            (\n                project.task_store().read(cx).task_inventory().cloned(),\n                worktree_id,\n                file,\n            )\n        });\n\n        let tags = mem::take(&mut runnable.tags);\n        let language = runnable.language.clone();\n        cx.spawn(async move |cx| {\n            let mut templates_with_tags = Vec::new();\n            if let Some(inventory) = inventory {\n                for RunnableTag(tag) in tags {\n                    let Ok(new_tasks) = inventory.update(cx, |inventory, cx| {\n                        inventory.list_tasks(file.clone(), Some(language.clone()), worktree_id, cx)\n                    }) else {\n                        return templates_with_tags;\n                    };\n                    templates_with_tags.extend(new_tasks.await.into_iter().filter(\n                        move |(_, template)| {\n                            template.tags.iter().any(|source_tag| source_tag == &tag)\n                        },\n                    ));\n                }\n            }\n            templates_with_tags.sort_by_key(|(kind, _)| kind.to_owned());\n\n            if let Some((leading_tag_source, _)) = templates_with_tags.first() {\n                // Strongest source wins; if we have worktree tag binding, prefer that to\n                // global and language bindings;\n                // if we have a global binding, prefer that to language binding.\n                let first_mismatch = templates_with_tags\n                    .iter()\n                    .position(|(tag_source, _)| tag_source != leading_tag_source);\n                if let Some(index) = first_mismatch {\n                    templates_with_tags.truncate(index);\n                }\n            }\n\n            templates_with_tags\n        })\n    }\n\n    pub fn move_to_enclosing_bracket(\n        &mut self,\n        _: &MoveToEnclosingBracket,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n        self.change_selections(Default::default(), window, cx, |s| {\n            s.move_offsets_with(|snapshot, selection| {\n                let Some(enclosing_bracket_ranges) =\n                    snapshot.enclosing_bracket_ranges(selection.start..selection.end)\n                else {\n                    return;\n                };\n\n                let mut best_length = usize::MAX;\n                let mut best_inside = false;\n                let mut best_in_bracket_range = false;\n                let mut best_destination = None;\n                for (open, close) in enclosing_bracket_ranges {\n                    let close = close.to_inclusive();\n                    let length = close.end() - open.start;\n                    let inside = selection.start >= open.end && selection.end <= *close.start();\n                    let in_bracket_range = open.to_inclusive().contains(&selection.head())\n                        || close.contains(&selection.head());\n\n                    // If best is next to a bracket and current isn't, skip\n                    if !in_bracket_range && best_in_bracket_range {\n                        continue;\n                    }\n\n                    // Prefer smaller lengths unless best is inside and current isn't\n                    if length > best_length && (best_inside || !inside) {\n                        continue;\n                    }\n\n                    best_length = length;\n                    best_inside = inside;\n                    best_in_bracket_range = in_bracket_range;\n                    best_destination = Some(\n                        if close.contains(&selection.start) && close.contains(&selection.end) {\n                            if inside { open.end } else { open.start }\n                        } else if inside {\n                            *close.start()\n                        } else {\n                            *close.end()\n                        },\n                    );\n                }\n\n                if let Some(destination) = best_destination {\n                    selection.collapse_to(destination, SelectionGoal::None);\n                }\n            })\n        });\n    }\n\n    pub fn undo_selection(\n        &mut self,\n        _: &UndoSelection,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n        if let Some(entry) = self.selection_history.undo_stack.pop_back() {\n            self.selection_history.mode = SelectionHistoryMode::Undoing;\n            self.with_selection_effects_deferred(window, cx, |this, window, cx| {\n                this.end_selection(window, cx);\n                this.change_selections(\n                    SelectionEffects::scroll(Autoscroll::newest()),\n                    window,\n                    cx,\n                    |s| s.select_anchors(entry.selections.to_vec()),\n                );\n            });\n            self.selection_history.mode = SelectionHistoryMode::Normal;\n\n            self.select_next_state = entry.select_next_state;\n            self.select_prev_state = entry.select_prev_state;\n            self.add_selections_state = entry.add_selections_state;\n        }\n    }\n\n    pub fn redo_selection(\n        &mut self,\n        _: &RedoSelection,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n        if let Some(entry) = self.selection_history.redo_stack.pop_back() {\n            self.selection_history.mode = SelectionHistoryMode::Redoing;\n            self.with_selection_effects_deferred(window, cx, |this, window, cx| {\n                this.end_selection(window, cx);\n                this.change_selections(\n                    SelectionEffects::scroll(Autoscroll::newest()),\n                    window,\n                    cx,\n                    |s| s.select_anchors(entry.selections.to_vec()),\n                );\n            });\n            self.selection_history.mode = SelectionHistoryMode::Normal;\n\n            self.select_next_state = entry.select_next_state;\n            self.select_prev_state = entry.select_prev_state;\n            self.add_selections_state = entry.add_selections_state;\n        }\n    }\n\n    pub fn expand_excerpts(\n        &mut self,\n        action: &ExpandExcerpts,\n        _: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.expand_excerpts_for_direction(action.lines, ExpandExcerptDirection::UpAndDown, cx)\n    }\n\n    pub fn expand_excerpts_down(\n        &mut self,\n        action: &ExpandExcerptsDown,\n        _: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.expand_excerpts_for_direction(action.lines, ExpandExcerptDirection::Down, cx)\n    }\n\n    pub fn expand_excerpts_up(\n        &mut self,\n        action: &ExpandExcerptsUp,\n        _: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.expand_excerpts_for_direction(action.lines, ExpandExcerptDirection::Up, cx)\n    }\n\n    pub fn expand_excerpts_for_direction(\n        &mut self,\n        lines: u32,\n        direction: ExpandExcerptDirection,\n\n        cx: &mut Context<Self>,\n    ) {\n        let selections = self.selections.disjoint_anchors_arc();\n\n        let lines = if lines == 0 {\n            EditorSettings::get_global(cx).expand_excerpt_lines\n        } else {\n            lines\n        };\n\n        self.buffer.update(cx, |buffer, cx| {\n            let snapshot = buffer.snapshot(cx);\n            let mut excerpt_ids = selections\n                .iter()\n                .flat_map(|selection| snapshot.excerpt_ids_for_range(selection.range()))\n                .collect::<Vec<_>>();\n            excerpt_ids.sort();\n            excerpt_ids.dedup();\n            buffer.expand_excerpts(excerpt_ids, lines, direction, cx)\n        })\n    }\n\n    pub fn expand_excerpt(\n        &mut self,\n        excerpt: ExcerptId,\n        direction: ExpandExcerptDirection,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let current_scroll_position = self.scroll_position(cx);\n        let lines_to_expand = EditorSettings::get_global(cx).expand_excerpt_lines;\n        let mut scroll = None;\n\n        if direction == ExpandExcerptDirection::Down {\n            let multi_buffer = self.buffer.read(cx);\n            let snapshot = multi_buffer.snapshot(cx);\n            if let Some(buffer_id) = snapshot.buffer_id_for_excerpt(excerpt)\n                && let Some(buffer) = multi_buffer.buffer(buffer_id)\n                && let Some(excerpt_range) = snapshot.context_range_for_excerpt(excerpt)\n            {\n                let buffer_snapshot = buffer.read(cx).snapshot();\n                let excerpt_end_row = Point::from_anchor(&excerpt_range.end, &buffer_snapshot).row;\n                let last_row = buffer_snapshot.max_point().row;\n                let lines_below = last_row.saturating_sub(excerpt_end_row);\n                if lines_below >= lines_to_expand {\n                    scroll = Some(\n                        current_scroll_position\n                            + gpui::Point::new(0.0, lines_to_expand as ScrollOffset),\n                    );\n                }\n            }\n        }\n        if direction == ExpandExcerptDirection::Up\n            && self\n                .buffer\n                .read(cx)\n                .snapshot(cx)\n                .excerpt_before(excerpt)\n                .is_none()\n        {\n            scroll = Some(current_scroll_position);\n        }\n\n        self.buffer.update(cx, |buffer, cx| {\n            buffer.expand_excerpts([excerpt], lines_to_expand, direction, cx)\n        });\n\n        if let Some(new_scroll_position) = scroll {\n            self.set_scroll_position(new_scroll_position, window, cx);\n        }\n    }\n\n    pub fn go_to_singleton_buffer_point(\n        &mut self,\n        point: Point,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.go_to_singleton_buffer_range(point..point, window, cx);\n    }\n\n    pub fn go_to_singleton_buffer_range(\n        &mut self,\n        range: Range<Point>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let multibuffer = self.buffer().read(cx);\n        let Some(buffer) = multibuffer.as_singleton() else {\n            return;\n        };\n        let Some(start) = multibuffer.buffer_point_to_anchor(&buffer, range.start, cx) else {\n            return;\n        };\n        let Some(end) = multibuffer.buffer_point_to_anchor(&buffer, range.end, cx) else {\n            return;\n        };\n        self.change_selections(\n            SelectionEffects::default().nav_history(true),\n            window,\n            cx,\n            |s| s.select_anchor_ranges([start..end]),\n        );\n    }\n\n    pub fn go_to_diagnostic(\n        &mut self,\n        action: &GoToDiagnostic,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if !self.diagnostics_enabled() {\n            return;\n        }\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n        self.go_to_diagnostic_impl(Direction::Next, action.severity, window, cx)\n    }\n\n    pub fn go_to_prev_diagnostic(\n        &mut self,\n        action: &GoToPreviousDiagnostic,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if !self.diagnostics_enabled() {\n            return;\n        }\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n        self.go_to_diagnostic_impl(Direction::Prev, action.severity, window, cx)\n    }\n\n    pub fn go_to_diagnostic_impl(\n        &mut self,\n        direction: Direction,\n        severity: GoToDiagnosticSeverityFilter,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let buffer = self.buffer.read(cx).snapshot(cx);\n        let selection = self.selections.newest::<usize>(&self.display_snapshot(cx));\n\n        let mut active_group_id = None;\n        if let ActiveDiagnostic::Group(active_group) = &self.active_diagnostics\n            && active_group.active_range.start.to_offset(&buffer) == selection.start\n        {\n            active_group_id = Some(active_group.group_id);\n        }\n\n        fn filtered<'a>(\n            severity: GoToDiagnosticSeverityFilter,\n            diagnostics: impl Iterator<Item = DiagnosticEntryRef<'a, usize>>,\n        ) -> impl Iterator<Item = DiagnosticEntryRef<'a, usize>> {\n            diagnostics\n                .filter(move |entry| severity.matches(entry.diagnostic.severity))\n                .filter(|entry| entry.range.start != entry.range.end)\n                .filter(|entry| !entry.diagnostic.is_unnecessary)\n        }\n\n        let before = filtered(\n            severity,\n            buffer\n                .diagnostics_in_range(0..selection.start)\n                .filter(|entry| entry.range.start <= selection.start),\n        );\n        let after = filtered(\n            severity,\n            buffer\n                .diagnostics_in_range(selection.start..buffer.len())\n                .filter(|entry| entry.range.start >= selection.start),\n        );\n\n        let mut found: Option<DiagnosticEntryRef<usize>> = None;\n        if direction == Direction::Prev {\n            'outer: for prev_diagnostics in [before.collect::<Vec<_>>(), after.collect::<Vec<_>>()]\n            {\n                for diagnostic in prev_diagnostics.into_iter().rev() {\n                    if diagnostic.range.start != selection.start\n                        || active_group_id\n                            .is_some_and(|active| diagnostic.diagnostic.group_id < active)\n                    {\n                        found = Some(diagnostic);\n                        break 'outer;\n                    }\n                }\n            }\n        } else {\n            for diagnostic in after.chain(before) {\n                if diagnostic.range.start != selection.start\n                    || active_group_id.is_some_and(|active| diagnostic.diagnostic.group_id > active)\n                {\n                    found = Some(diagnostic);\n                    break;\n                }\n            }\n        }\n        let Some(next_diagnostic) = found else {\n            return;\n        };\n\n        let next_diagnostic_start = buffer.anchor_after(next_diagnostic.range.start);\n        let Some(buffer_id) = buffer.buffer_id_for_anchor(next_diagnostic_start) else {\n            return;\n        };\n        let snapshot = self.snapshot(window, cx);\n        if snapshot.intersects_fold(next_diagnostic.range.start) {\n            self.unfold_ranges(\n                std::slice::from_ref(&next_diagnostic.range),\n                true,\n                false,\n                cx,\n            );\n        }\n        self.change_selections(Default::default(), window, cx, |s| {\n            s.select_ranges(vec![\n                next_diagnostic.range.start..next_diagnostic.range.start,\n            ])\n        });\n        self.activate_diagnostics(buffer_id, next_diagnostic, window, cx);\n        self.refresh_edit_prediction(false, true, window, cx);\n    }\n\n    pub fn go_to_next_hunk(&mut self, _: &GoToHunk, window: &mut Window, cx: &mut Context<Self>) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n        let snapshot = self.snapshot(window, cx);\n        let selection = self.selections.newest::<Point>(&self.display_snapshot(cx));\n        self.go_to_hunk_before_or_after_position(\n            &snapshot,\n            selection.head(),\n            Direction::Next,\n            window,\n            cx,\n        );\n    }\n\n    pub fn go_to_hunk_before_or_after_position(\n        &mut self,\n        snapshot: &EditorSnapshot,\n        position: Point,\n        direction: Direction,\n        window: &mut Window,\n        cx: &mut Context<Editor>,\n    ) {\n        let row = if direction == Direction::Next {\n            self.hunk_after_position(snapshot, position)\n                .map(|hunk| hunk.row_range.start)\n        } else {\n            self.hunk_before_position(snapshot, position)\n        };\n\n        if let Some(row) = row {\n            let destination = Point::new(row.0, 0);\n            let autoscroll = Autoscroll::center();\n\n            self.unfold_ranges(&[destination..destination], false, false, cx);\n            self.change_selections(SelectionEffects::scroll(autoscroll), window, cx, |s| {\n                s.select_ranges([destination..destination]);\n            });\n        }\n    }\n\n    fn hunk_after_position(\n        &mut self,\n        snapshot: &EditorSnapshot,\n        position: Point,\n    ) -> Option<MultiBufferDiffHunk> {\n        snapshot\n            .buffer_snapshot()\n            .diff_hunks_in_range(position..snapshot.buffer_snapshot().max_point())\n            .find(|hunk| hunk.row_range.start.0 > position.row)\n            .or_else(|| {\n                snapshot\n                    .buffer_snapshot()\n                    .diff_hunks_in_range(Point::zero()..position)\n                    .find(|hunk| hunk.row_range.end.0 < position.row)\n            })\n    }\n\n    fn go_to_prev_hunk(\n        &mut self,\n        _: &GoToPreviousHunk,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n        let snapshot = self.snapshot(window, cx);\n        let selection = self.selections.newest::<Point>(&snapshot.display_snapshot);\n        self.go_to_hunk_before_or_after_position(\n            &snapshot,\n            selection.head(),\n            Direction::Prev,\n            window,\n            cx,\n        );\n    }\n\n    fn hunk_before_position(\n        &mut self,\n        snapshot: &EditorSnapshot,\n        position: Point,\n    ) -> Option<MultiBufferRow> {\n        snapshot\n            .buffer_snapshot()\n            .diff_hunk_before(position)\n            .or_else(|| snapshot.buffer_snapshot().diff_hunk_before(Point::MAX))\n    }\n\n    fn go_to_next_change(\n        &mut self,\n        _: &GoToNextChange,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(selections) = self\n            .change_list\n            .next_change(1, Direction::Next)\n            .map(|s| s.to_vec())\n        {\n            self.change_selections(Default::default(), window, cx, |s| {\n                let map = s.display_snapshot();\n                s.select_display_ranges(selections.iter().map(|a| {\n                    let point = a.to_display_point(&map);\n                    point..point\n                }))\n            })\n        }\n    }\n\n    fn go_to_previous_change(\n        &mut self,\n        _: &GoToPreviousChange,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(selections) = self\n            .change_list\n            .next_change(1, Direction::Prev)\n            .map(|s| s.to_vec())\n        {\n            self.change_selections(Default::default(), window, cx, |s| {\n                let map = s.display_snapshot();\n                s.select_display_ranges(selections.iter().map(|a| {\n                    let point = a.to_display_point(&map);\n                    point..point\n                }))\n            })\n        }\n    }\n\n    pub fn go_to_next_document_highlight(\n        &mut self,\n        _: &GoToNextDocumentHighlight,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.go_to_document_highlight_before_or_after_position(Direction::Next, window, cx);\n    }\n\n    pub fn go_to_prev_document_highlight(\n        &mut self,\n        _: &GoToPreviousDocumentHighlight,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.go_to_document_highlight_before_or_after_position(Direction::Prev, window, cx);\n    }\n\n    pub fn go_to_document_highlight_before_or_after_position(\n        &mut self,\n        direction: Direction,\n        window: &mut Window,\n        cx: &mut Context<Editor>,\n    ) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::MovementAction, cx);\n        let snapshot = self.snapshot(window, cx);\n        let buffer = &snapshot.buffer_snapshot();\n        let position = self\n            .selections\n            .newest::<Point>(&snapshot.display_snapshot)\n            .head();\n        let anchor_position = buffer.anchor_after(position);\n\n        // Get all document highlights (both read and write)\n        let mut all_highlights = Vec::new();\n\n        if let Some((_, read_highlights)) = self\n            .background_highlights\n            .get(&HighlightKey::Type(TypeId::of::<DocumentHighlightRead>()))\n        {\n            all_highlights.extend(read_highlights.iter());\n        }\n\n        if let Some((_, write_highlights)) = self\n            .background_highlights\n            .get(&HighlightKey::Type(TypeId::of::<DocumentHighlightWrite>()))\n        {\n            all_highlights.extend(write_highlights.iter());\n        }\n\n        if all_highlights.is_empty() {\n            return;\n        }\n\n        // Sort highlights by position\n        all_highlights.sort_by(|a, b| a.start.cmp(&b.start, buffer));\n\n        let target_highlight = match direction {\n            Direction::Next => {\n                // Find the first highlight after the current position\n                all_highlights\n                    .iter()\n                    .find(|highlight| highlight.start.cmp(&anchor_position, buffer).is_gt())\n            }\n            Direction::Prev => {\n                // Find the last highlight before the current position\n                all_highlights\n                    .iter()\n                    .rev()\n                    .find(|highlight| highlight.end.cmp(&anchor_position, buffer).is_lt())\n            }\n        };\n\n        if let Some(highlight) = target_highlight {\n            let destination = highlight.start.to_point(buffer);\n            let autoscroll = Autoscroll::center();\n\n            self.unfold_ranges(&[destination..destination], false, false, cx);\n            self.change_selections(SelectionEffects::scroll(autoscroll), window, cx, |s| {\n                s.select_ranges([destination..destination]);\n            });\n        }\n    }\n\n    fn go_to_line<T: 'static>(\n        &mut self,\n        position: Anchor,\n        highlight_color: Option<Hsla>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let snapshot = self.snapshot(window, cx).display_snapshot;\n        let position = position.to_point(&snapshot.buffer_snapshot());\n        let start = snapshot\n            .buffer_snapshot()\n            .clip_point(Point::new(position.row, 0), Bias::Left);\n        let end = start + Point::new(1, 0);\n        let start = snapshot.buffer_snapshot().anchor_before(start);\n        let end = snapshot.buffer_snapshot().anchor_before(end);\n\n        self.highlight_rows::<T>(\n            start..end,\n            highlight_color\n                .unwrap_or_else(|| cx.theme().colors().editor_highlighted_line_background),\n            Default::default(),\n            cx,\n        );\n\n        if self.buffer.read(cx).is_singleton() {\n            self.request_autoscroll(Autoscroll::center().for_anchor(start), cx);\n        }\n    }\n\n    pub fn go_to_definition(\n        &mut self,\n        _: &GoToDefinition,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Navigated>> {\n        let definition =\n            self.go_to_definition_of_kind(GotoDefinitionKind::Symbol, false, window, cx);\n        let fallback_strategy = EditorSettings::get_global(cx).go_to_definition_fallback;\n        cx.spawn_in(window, async move |editor, cx| {\n            if definition.await? == Navigated::Yes {\n                return Ok(Navigated::Yes);\n            }\n            match fallback_strategy {\n                GoToDefinitionFallback::None => Ok(Navigated::No),\n                GoToDefinitionFallback::FindAllReferences => {\n                    match editor.update_in(cx, |editor, window, cx| {\n                        editor.find_all_references(&FindAllReferences, window, cx)\n                    })? {\n                        Some(references) => references.await,\n                        None => Ok(Navigated::No),\n                    }\n                }\n            }\n        })\n    }\n\n    pub fn go_to_declaration(\n        &mut self,\n        _: &GoToDeclaration,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Navigated>> {\n        self.go_to_definition_of_kind(GotoDefinitionKind::Declaration, false, window, cx)\n    }\n\n    pub fn go_to_declaration_split(\n        &mut self,\n        _: &GoToDeclaration,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Navigated>> {\n        self.go_to_definition_of_kind(GotoDefinitionKind::Declaration, true, window, cx)\n    }\n\n    pub fn go_to_implementation(\n        &mut self,\n        _: &GoToImplementation,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Navigated>> {\n        self.go_to_definition_of_kind(GotoDefinitionKind::Implementation, false, window, cx)\n    }\n\n    pub fn go_to_implementation_split(\n        &mut self,\n        _: &GoToImplementationSplit,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Navigated>> {\n        self.go_to_definition_of_kind(GotoDefinitionKind::Implementation, true, window, cx)\n    }\n\n    pub fn go_to_type_definition(\n        &mut self,\n        _: &GoToTypeDefinition,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Navigated>> {\n        self.go_to_definition_of_kind(GotoDefinitionKind::Type, false, window, cx)\n    }\n\n    pub fn go_to_definition_split(\n        &mut self,\n        _: &GoToDefinitionSplit,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Navigated>> {\n        self.go_to_definition_of_kind(GotoDefinitionKind::Symbol, true, window, cx)\n    }\n\n    pub fn go_to_type_definition_split(\n        &mut self,\n        _: &GoToTypeDefinitionSplit,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Navigated>> {\n        self.go_to_definition_of_kind(GotoDefinitionKind::Type, true, window, cx)\n    }\n\n    fn go_to_definition_of_kind(\n        &mut self,\n        kind: GotoDefinitionKind,\n        split: bool,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Navigated>> {\n        let Some(provider) = self.semantics_provider.clone() else {\n            return Task::ready(Ok(Navigated::No));\n        };\n        let head = self\n            .selections\n            .newest::<usize>(&self.display_snapshot(cx))\n            .head();\n        let buffer = self.buffer.read(cx);\n        let Some((buffer, head)) = buffer.text_anchor_for_position(head, cx) else {\n            return Task::ready(Ok(Navigated::No));\n        };\n        let Some(definitions) = provider.definitions(&buffer, head, kind, cx) else {\n            return Task::ready(Ok(Navigated::No));\n        };\n\n        cx.spawn_in(window, async move |editor, cx| {\n            let Some(definitions) = definitions.await? else {\n                return Ok(Navigated::No);\n            };\n            let navigated = editor\n                .update_in(cx, |editor, window, cx| {\n                    editor.navigate_to_hover_links(\n                        Some(kind),\n                        definitions\n                            .into_iter()\n                            .filter(|location| {\n                                hover_links::exclude_link_to_position(&buffer, &head, location, cx)\n                            })\n                            .map(HoverLink::Text)\n                            .collect::<Vec<_>>(),\n                        split,\n                        window,\n                        cx,\n                    )\n                })?\n                .await?;\n            anyhow::Ok(navigated)\n        })\n    }\n\n    pub fn open_url(&mut self, _: &OpenUrl, window: &mut Window, cx: &mut Context<Self>) {\n        let selection = self.selections.newest_anchor();\n        let head = selection.head();\n        let tail = selection.tail();\n\n        let Some((buffer, start_position)) =\n            self.buffer.read(cx).text_anchor_for_position(head, cx)\n        else {\n            return;\n        };\n\n        let end_position = if head != tail {\n            let Some((_, pos)) = self.buffer.read(cx).text_anchor_for_position(tail, cx) else {\n                return;\n            };\n            Some(pos)\n        } else {\n            None\n        };\n\n        let url_finder = cx.spawn_in(window, async move |_editor, cx| {\n            let url = if let Some(end_pos) = end_position {\n                find_url_from_range(&buffer, start_position..end_pos, cx.clone())\n            } else {\n                find_url(&buffer, start_position, cx.clone()).map(|(_, url)| url)\n            };\n\n            if let Some(url) = url {\n                cx.update(|window, cx| {\n                    if parse_zed_link(&url, cx).is_some() {\n                        window.dispatch_action(Box::new(zed_actions::OpenZedUrl { url }), cx);\n                    } else {\n                        cx.open_url(&url);\n                    }\n                })?;\n            }\n\n            anyhow::Ok(())\n        });\n\n        url_finder.detach();\n    }\n\n    pub fn open_selected_filename(\n        &mut self,\n        _: &OpenSelectedFilename,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let Some(workspace) = self.workspace() else {\n            return;\n        };\n\n        let position = self.selections.newest_anchor().head();\n\n        let Some((buffer, buffer_position)) =\n            self.buffer.read(cx).text_anchor_for_position(position, cx)\n        else {\n            return;\n        };\n\n        let project = self.project.clone();\n\n        cx.spawn_in(window, async move |_, cx| {\n            let result = find_file(&buffer, project, buffer_position, cx).await;\n\n            if let Some((_, path)) = result {\n                workspace\n                    .update_in(cx, |workspace, window, cx| {\n                        workspace.open_resolved_path(path, window, cx)\n                    })?\n                    .await?;\n            }\n            anyhow::Ok(())\n        })\n        .detach();\n    }\n\n    pub(crate) fn navigate_to_hover_links(\n        &mut self,\n        kind: Option<GotoDefinitionKind>,\n        definitions: Vec<HoverLink>,\n        split: bool,\n        window: &mut Window,\n        cx: &mut Context<Editor>,\n    ) -> Task<Result<Navigated>> {\n        // Separate out url and file links, we can only handle one of them at most or an arbitrary number of locations\n        let mut first_url_or_file = None;\n        let definitions: Vec<_> = definitions\n            .into_iter()\n            .filter_map(|def| match def {\n                HoverLink::Text(link) => Some(Task::ready(anyhow::Ok(Some(link.target)))),\n                HoverLink::InlayHint(lsp_location, server_id) => {\n                    let computation =\n                        self.compute_target_location(lsp_location, server_id, window, cx);\n                    Some(cx.background_spawn(computation))\n                }\n                HoverLink::Url(url) => {\n                    first_url_or_file = Some(Either::Left(url));\n                    None\n                }\n                HoverLink::File(path) => {\n                    first_url_or_file = Some(Either::Right(path));\n                    None\n                }\n            })\n            .collect();\n\n        let workspace = self.workspace();\n\n        cx.spawn_in(window, async move |editor, cx| {\n            let locations: Vec<Location> = future::join_all(definitions)\n                .await\n                .into_iter()\n                .filter_map(|location| location.transpose())\n                .collect::<Result<_>>()\n                .context(": "",
        ")?;\n            let mut locations = cx.update(|_, cx| {\n                locations\n                    .into_iter()\n                    .map(|location| {\n                        let buffer = location.buffer.read(cx);\n                        (location.buffer, location.range.to_point(buffer))\n                    })\n                    .into_group_map()\n            })?;\n            let mut num_locations = 0;\n            for ranges in locations.values_mut() {\n                ranges.sort_by_key(|range| (range.start, Reverse(range.end)));\n                ranges.dedup();\n                num_locations += ranges.len();\n            }\n\n            if num_locations > 1 {\n                let Some(workspace) = workspace else {\n                    return Ok(Navigated::No);\n                };\n\n                let tab_kind = match kind {\n                    Some(GotoDefinitionKind::Implementation) => ": "",
        ",\n                    Some(GotoDefinitionKind::Symbol) | None => ": "",
        ",\n                    Some(GotoDefinitionKind::Declaration) => ": "",
        ",\n                    Some(GotoDefinitionKind::Type) => ": "",
        ",\n                };\n                let title = editor\n                    .update_in(cx, |_, _, cx| {\n                        let target = locations\n                            .iter()\n                            .flat_map(|(k, v)| iter::repeat(k.clone()).zip(v))\n                            .map(|(buffer, location)| {\n                                buffer\n                                    .read(cx)\n                                    .text_for_range(location.clone())\n                                    .collect::<String>()\n                            })\n                            .filter(|text| !text.contains('\\n'))\n                            .unique()\n                            .take(3)\n                            .join(": "",
        ");\n                        if target.is_empty() {\n                            tab_kind.to_owned()\n                        } else {\n                            format!(": "",
        ")\n                        }\n                    })\n                    .context(": "",
        ")?;\n\n                let opened = workspace\n                    .update_in(cx, |workspace, window, cx| {\n                        Self::open_locations_in_multibuffer(\n                            workspace,\n                            locations,\n                            title,\n                            split,\n                            MultibufferSelectionMode::First,\n                            window,\n                            cx,\n                        )\n                    })\n                    .is_ok();\n\n                anyhow::Ok(Navigated::from_bool(opened))\n            } else if num_locations == 0 {\n                // If there is one url or file, open it directly\n                match first_url_or_file {\n                    Some(Either::Left(url)) => {\n                        cx.update(|_, cx| cx.open_url(&url))?;\n                        Ok(Navigated::Yes)\n                    }\n                    Some(Either::Right(path)) => {\n                        let Some(workspace) = workspace else {\n                            return Ok(Navigated::No);\n                        };\n\n                        workspace\n                            .update_in(cx, |workspace, window, cx| {\n                                workspace.open_resolved_path(path, window, cx)\n                            })?\n                            .await?;\n                        Ok(Navigated::Yes)\n                    }\n                    None => Ok(Navigated::No),\n                }\n            } else {\n                let Some(workspace) = workspace else {\n                    return Ok(Navigated::No);\n                };\n\n                let (target_buffer, target_ranges) = locations.into_iter().next().unwrap();\n                let target_range = target_ranges.first().unwrap().clone();\n\n                editor.update_in(cx, |editor, window, cx| {\n                    let range = target_range.to_point(target_buffer.read(cx));\n                    let range = editor.range_for_match(&range, false);\n                    let range = collapse_multiline_range(range);\n\n                    if !split\n                        && Some(&target_buffer) == editor.buffer.read(cx).as_singleton().as_ref()\n                    {\n                        editor.go_to_singleton_buffer_range(range, window, cx);\n                    } else {\n                        let pane = workspace.read(cx).active_pane().clone();\n                        window.defer(cx, move |window, cx| {\n                            let target_editor: Entity<Self> =\n                                workspace.update(cx, |workspace, cx| {\n                                    let pane = if split {\n                                        workspace.adjacent_pane(window, cx)\n                                    } else {\n                                        workspace.active_pane().clone()\n                                    };\n\n                                    workspace.open_project_item(\n                                        pane,\n                                        target_buffer.clone(),\n                                        true,\n                                        true,\n                                        window,\n                                        cx,\n                                    )\n                                });\n                            target_editor.update(cx, |target_editor, cx| {\n                                // When selecting a definition in a different buffer, disable the nav history\n                                // to avoid creating a history entry at the previous cursor location.\n                                pane.update(cx, |pane, _| pane.disable_history());\n                                target_editor.go_to_singleton_buffer_range(range, window, cx);\n                                pane.update(cx, |pane, _| pane.enable_history());\n                            });\n                        });\n                    }\n                    Navigated::Yes\n                })\n            }\n        })\n    }\n\n    fn compute_target_location(\n        &self,\n        lsp_location: lsp::Location,\n        server_id: LanguageServerId,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Task<anyhow::Result<Option<Location>>> {\n        let Some(project) = self.project.clone() else {\n            return Task::ready(Ok(None));\n        };\n\n        cx.spawn_in(window, async move |editor, cx| {\n            let location_task = editor.update(cx, |_, cx| {\n                project.update(cx, |project, cx| {\n                    project.open_local_buffer_via_lsp(lsp_location.uri.clone(), server_id, cx)\n                })\n            })?;\n            let location = Some({\n                let target_buffer_handle = location_task.await.context(": "",
        ")?;\n                let range = target_buffer_handle.read_with(cx, |target_buffer, _| {\n                    let target_start = target_buffer\n                        .clip_point_utf16(point_from_lsp(lsp_location.range.start), Bias::Left);\n                    let target_end = target_buffer\n                        .clip_point_utf16(point_from_lsp(lsp_location.range.end), Bias::Left);\n                    target_buffer.anchor_after(target_start)\n                        ..target_buffer.anchor_before(target_end)\n                })?;\n                Location {\n                    buffer: target_buffer_handle,\n                    range,\n                }\n            });\n            Ok(location)\n        })\n    }\n\n    fn go_to_next_reference(\n        &mut self,\n        _: &GoToNextReference,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let task = self.go_to_reference_before_or_after_position(Direction::Next, 1, window, cx);\n        if let Some(task) = task {\n            task.detach();\n        };\n    }\n\n    fn go_to_prev_reference(\n        &mut self,\n        _: &GoToPreviousReference,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let task = self.go_to_reference_before_or_after_position(Direction::Prev, 1, window, cx);\n        if let Some(task) = task {\n            task.detach();\n        };\n    }\n\n    pub fn go_to_reference_before_or_after_position(\n        &mut self,\n        direction: Direction,\n        count: usize,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<Task<Result<()>>> {\n        let selection = self.selections.newest_anchor();\n        let head = selection.head();\n\n        let multi_buffer = self.buffer.read(cx);\n\n        let (buffer, text_head) = multi_buffer.text_anchor_for_position(head, cx)?;\n        let workspace = self.workspace()?;\n        let project = workspace.read(cx).project().clone();\n        let references =\n            project.update(cx, |project, cx| project.references(&buffer, text_head, cx));\n        Some(cx.spawn_in(window, async move |editor, cx| -> Result<()> {\n            let Some(locations) = references.await? else {\n                return Ok(());\n            };\n\n            if locations.is_empty() {\n                // totally normal - the cursor may be on something which is not\n                // a symbol (e.g. a keyword)\n                log::info!(": "",
        ");\n                return Ok(());\n            }\n\n            let multi_buffer = editor.read_with(cx, |editor, _| editor.buffer().clone())?;\n\n            let multi_buffer_snapshot =\n                multi_buffer.read_with(cx, |multi_buffer, cx| multi_buffer.snapshot(cx))?;\n\n            let (locations, current_location_index) =\n                multi_buffer.update(cx, |multi_buffer, cx| {\n                    let mut locations = locations\n                        .into_iter()\n                        .filter_map(|loc| {\n                            let start = multi_buffer.buffer_anchor_to_anchor(\n                                &loc.buffer,\n                                loc.range.start,\n                                cx,\n                            )?;\n                            let end = multi_buffer.buffer_anchor_to_anchor(\n                                &loc.buffer,\n                                loc.range.end,\n                                cx,\n                            )?;\n                            Some(start..end)\n                        })\n                        .collect::<Vec<_>>();\n\n                    // There is an O(n) implementation, but given this list will be\n                    // small (usually <100 items), the extra O(log(n)) factor isn't\n                    // worth the (surprisingly large amount of) extra complexity.\n                    locations\n                        .sort_unstable_by(|l, r| l.start.cmp(&r.start, &multi_buffer_snapshot));\n\n                    let head_offset = head.to_offset(&multi_buffer_snapshot);\n\n                    let current_location_index = locations.iter().position(|loc| {\n                        loc.start.to_offset(&multi_buffer_snapshot) <= head_offset\n                            && loc.end.to_offset(&multi_buffer_snapshot) >= head_offset\n                    });\n\n                    (locations, current_location_index)\n                })?;\n\n            let Some(current_location_index) = current_location_index else {\n                // This indicates something has gone wrong, because we already\n                // handle the ": "",
        " case above\n                log::error!(\n                    ": "",
        ",\n                    locations.len()\n                );\n                return Ok(());\n            };\n\n            let destination_location_index = match direction {\n                Direction::Next => (current_location_index + count) % locations.len(),\n                Direction::Prev => {\n                    (current_location_index + locations.len() - count % locations.len())\n                        % locations.len()\n                }\n            };\n\n            // TODO(cameron): is this needed?\n            // the thinking is to avoid ": "",
        " (avoid\n            // polluting ": "",
        " in vim terms)\n            if current_location_index == destination_location_index {\n                return Ok(());\n            }\n\n            let Range { start, end } = locations[destination_location_index];\n\n            editor.update_in(cx, |editor, window, cx| {\n                let effects = SelectionEffects::default();\n\n                editor.unfold_ranges(&[start..end], false, false, cx);\n                editor.change_selections(effects, window, cx, |s| {\n                    s.select_ranges([start..start]);\n                });\n            })?;\n\n            Ok(())\n        }))\n    }\n\n    pub fn find_all_references(\n        &mut self,\n        _: &FindAllReferences,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<Task<Result<Navigated>>> {\n        let selection = self.selections.newest::<usize>(&self.display_snapshot(cx));\n        let multi_buffer = self.buffer.read(cx);\n        let head = selection.head();\n\n        let multi_buffer_snapshot = multi_buffer.snapshot(cx);\n        let head_anchor = multi_buffer_snapshot.anchor_at(\n            head,\n            if head < selection.tail() {\n                Bias::Right\n            } else {\n                Bias::Left\n            },\n        );\n\n        match self\n            .find_all_references_task_sources\n            .binary_search_by(|anchor| anchor.cmp(&head_anchor, &multi_buffer_snapshot))\n        {\n            Ok(_) => {\n                log::info!(\n                    ": "",
        "\n                );\n                return None;\n            }\n            Err(i) => {\n                self.find_all_references_task_sources.insert(i, head_anchor);\n            }\n        }\n\n        let (buffer, head) = multi_buffer.text_anchor_for_position(head, cx)?;\n        let workspace = self.workspace()?;\n        let project = workspace.read(cx).project().clone();\n        let references = project.update(cx, |project, cx| project.references(&buffer, head, cx));\n        Some(cx.spawn_in(window, async move |editor, cx| {\n            let _cleanup = cx.on_drop(&editor, move |editor, _| {\n                if let Ok(i) = editor\n                    .find_all_references_task_sources\n                    .binary_search_by(|anchor| anchor.cmp(&head_anchor, &multi_buffer_snapshot))\n                {\n                    editor.find_all_references_task_sources.remove(i);\n                }\n            });\n\n            let Some(locations) = references.await? else {\n                return anyhow::Ok(Navigated::No);\n            };\n            let mut locations = cx.update(|_, cx| {\n                locations\n                    .into_iter()\n                    .map(|location| {\n                        let buffer = location.buffer.read(cx);\n                        (location.buffer, location.range.to_point(buffer))\n                    })\n                    .into_group_map()\n            })?;\n            if locations.is_empty() {\n                return anyhow::Ok(Navigated::No);\n            }\n            for ranges in locations.values_mut() {\n                ranges.sort_by_key(|range| (range.start, Reverse(range.end)));\n                ranges.dedup();\n            }\n\n            workspace.update_in(cx, |workspace, window, cx| {\n                let target = locations\n                    .iter()\n                    .flat_map(|(k, v)| iter::repeat(k.clone()).zip(v))\n                    .map(|(buffer, location)| {\n                        buffer\n                            .read(cx)\n                            .text_for_range(location.clone())\n                            .collect::<String>()\n                    })\n                    .filter(|text| !text.contains('\\n'))\n                    .unique()\n                    .take(3)\n                    .join(": "",
        ");\n                let title = if target.is_empty() {\n                    ": "",
        ".to_owned()\n                } else {\n                    format!(": "",
        ")\n                };\n                Self::open_locations_in_multibuffer(\n                    workspace,\n                    locations,\n                    title,\n                    false,\n                    MultibufferSelectionMode::First,\n                    window,\n                    cx,\n                );\n                Navigated::Yes\n            })\n        }))\n    }\n\n    /// Opens a multibuffer with the given project locations in it\n    pub fn open_locations_in_multibuffer(\n        workspace: &mut Workspace,\n        locations: std::collections::HashMap<Entity<Buffer>, Vec<Range<Point>>>,\n        title: String,\n        split: bool,\n        multibuffer_selection_mode: MultibufferSelectionMode,\n        window: &mut Window,\n        cx: &mut Context<Workspace>,\n    ) {\n        if locations.is_empty() {\n            log::error!(": "",
        ");\n            return;\n        }\n\n        let capability = workspace.project().read(cx).capability();\n        let mut ranges = <Vec<Range<Anchor>>>::new();\n\n        // a key to find existing multibuffer editors with the same set of locations\n        // to prevent us from opening more and more multibuffer tabs for searches and the like\n        let mut key = (title.clone(), vec![]);\n        let excerpt_buffer = cx.new(|cx| {\n            let key = &mut key.1;\n            let mut multibuffer = MultiBuffer::new(capability);\n            for (buffer, mut ranges_for_buffer) in locations {\n                ranges_for_buffer.sort_by_key(|range| (range.start, Reverse(range.end)));\n                key.push((buffer.read(cx).remote_id(), ranges_for_buffer.clone()));\n                let (new_ranges, _) = multibuffer.set_excerpts_for_path(\n                    PathKey::for_buffer(&buffer, cx),\n                    buffer.clone(),\n                    ranges_for_buffer,\n                    multibuffer_context_lines(cx),\n                    cx,\n                );\n                ranges.extend(new_ranges)\n            }\n\n            multibuffer.with_title(title)\n        });\n        let existing = workspace.active_pane().update(cx, |pane, cx| {\n            pane.items()\n                .filter_map(|item| item.downcast::<Editor>())\n                .find(|editor| {\n                    editor\n                        .read(cx)\n                        .lookup_key\n                        .as_ref()\n                        .and_then(|it| {\n                            it.downcast_ref::<(String, Vec<(BufferId, Vec<Range<Point>>)>)>()\n                        })\n                        .is_some_and(|it| *it == key)\n                })\n        });\n        let editor = existing.unwrap_or_else(|| {\n            cx.new(|cx| {\n                let mut editor = Editor::for_multibuffer(\n                    excerpt_buffer,\n                    Some(workspace.project().clone()),\n                    window,\n                    cx,\n                );\n                editor.lookup_key = Some(Box::new(key));\n                editor\n            })\n        });\n        editor.update(cx, |editor, cx| match multibuffer_selection_mode {\n            MultibufferSelectionMode::First => {\n                if let Some(first_range) = ranges.first() {\n                    editor.change_selections(\n                        SelectionEffects::no_scroll(),\n                        window,\n                        cx,\n                        |selections| {\n                            selections.clear_disjoint();\n                            selections.select_anchor_ranges(std::iter::once(first_range.clone()));\n                        },\n                    );\n                }\n                editor.highlight_background::<Self>(\n                    &ranges,\n                    |theme| theme.colors().editor_highlighted_line_background,\n                    cx,\n                );\n            }\n            MultibufferSelectionMode::All => {\n                editor.change_selections(SelectionEffects::no_scroll(), window, cx, |selections| {\n                    selections.clear_disjoint();\n                    selections.select_anchor_ranges(ranges);\n                });\n            }\n        });\n\n        let item = Box::new(editor);\n        let item_id = item.item_id();\n\n        if split {\n            let pane = workspace.adjacent_pane(window, cx);\n            workspace.add_item(pane, item, None, true, true, window, cx);\n        } else if PreviewTabsSettings::get_global(cx).enable_preview_from_code_navigation {\n            let (preview_item_id, preview_item_idx) =\n                workspace.active_pane().read_with(cx, |pane, _| {\n                    (pane.preview_item_id(), pane.preview_item_idx())\n                });\n\n            workspace.add_item_to_active_pane(item, preview_item_idx, true, window, cx);\n\n            if let Some(preview_item_id) = preview_item_id {\n                workspace.active_pane().update(cx, |pane, cx| {\n                    pane.remove_item(preview_item_id, false, false, window, cx);\n                });\n            }\n        } else {\n            workspace.add_item_to_active_pane(item, None, true, window, cx);\n        }\n        workspace.active_pane().update(cx, |pane, cx| {\n            pane.set_preview_item_id(Some(item_id), cx);\n        });\n    }\n\n    pub fn rename(\n        &mut self,\n        _: &Rename,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<Task<Result<()>>> {\n        use language::ToOffset as _;\n\n        let provider = self.semantics_provider.clone()?;\n        let selection = self.selections.newest_anchor().clone();\n        let (cursor_buffer, cursor_buffer_position) = self\n            .buffer\n            .read(cx)\n            .text_anchor_for_position(selection.head(), cx)?;\n        let (tail_buffer, cursor_buffer_position_end) = self\n            .buffer\n            .read(cx)\n            .text_anchor_for_position(selection.tail(), cx)?;\n        if tail_buffer != cursor_buffer {\n            return None;\n        }\n\n        let snapshot = cursor_buffer.read(cx).snapshot();\n        let cursor_buffer_offset = cursor_buffer_position.to_offset(&snapshot);\n        let cursor_buffer_offset_end = cursor_buffer_position_end.to_offset(&snapshot);\n        let prepare_rename = provider\n            .range_for_rename(&cursor_buffer, cursor_buffer_position, cx)\n            .unwrap_or_else(|| Task::ready(Ok(None)));\n        drop(snapshot);\n\n        Some(cx.spawn_in(window, async move |this, cx| {\n            let rename_range = if let Some(range) = prepare_rename.await? {\n                Some(range)\n            } else {\n                this.update(cx, |this, cx| {\n                    let buffer = this.buffer.read(cx).snapshot(cx);\n                    let mut buffer_highlights = this\n                        .document_highlights_for_position(selection.head(), &buffer)\n                        .filter(|highlight| {\n                            highlight.start.excerpt_id == selection.head().excerpt_id\n                                && highlight.end.excerpt_id == selection.head().excerpt_id\n                        });\n                    buffer_highlights\n                        .next()\n                        .map(|highlight| highlight.start.text_anchor..highlight.end.text_anchor)\n                })?\n            };\n            if let Some(rename_range) = rename_range {\n                this.update_in(cx, |this, window, cx| {\n                    let snapshot = cursor_buffer.read(cx).snapshot();\n                    let rename_buffer_range = rename_range.to_offset(&snapshot);\n                    let cursor_offset_in_rename_range =\n                        cursor_buffer_offset.saturating_sub(rename_buffer_range.start);\n                    let cursor_offset_in_rename_range_end =\n                        cursor_buffer_offset_end.saturating_sub(rename_buffer_range.start);\n\n                    this.take_rename(false, window, cx);\n                    let buffer = this.buffer.read(cx).read(cx);\n                    let cursor_offset = selection.head().to_offset(&buffer);\n                    let rename_start = cursor_offset.saturating_sub(cursor_offset_in_rename_range);\n                    let rename_end = rename_start + rename_buffer_range.len();\n                    let range = buffer.anchor_before(rename_start)..buffer.anchor_after(rename_end);\n                    let mut old_highlight_id = None;\n                    let old_name: Arc<str> = buffer\n                        .chunks(rename_start..rename_end, true)\n                        .map(|chunk| {\n                            if old_highlight_id.is_none() {\n                                old_highlight_id = chunk.syntax_highlight_id;\n                            }\n                            chunk.text\n                        })\n                        .collect::<String>()\n                        .into();\n\n                    drop(buffer);\n\n                    // Position the selection in the rename editor so that it matches the current selection.\n                    this.show_local_selections = false;\n                    let rename_editor = cx.new(|cx| {\n                        let mut editor = Editor::single_line(window, cx);\n                        editor.buffer.update(cx, |buffer, cx| {\n                            buffer.edit([(0..0, old_name.clone())], None, cx)\n                        });\n                        let rename_selection_range = match cursor_offset_in_rename_range\n                            .cmp(&cursor_offset_in_rename_range_end)\n                        {\n                            Ordering::Equal => {\n                                editor.select_all(&SelectAll, window, cx);\n                                return editor;\n                            }\n                            Ordering::Less => {\n                                cursor_offset_in_rename_range..cursor_offset_in_rename_range_end\n                            }\n                            Ordering::Greater => {\n                                cursor_offset_in_rename_range_end..cursor_offset_in_rename_range\n                            }\n                        };\n                        if rename_selection_range.end > old_name.len() {\n                            editor.select_all(&SelectAll, window, cx);\n                        } else {\n                            editor.change_selections(Default::default(), window, cx, |s| {\n                                s.select_ranges([rename_selection_range]);\n                            });\n                        }\n                        editor\n                    });\n                    cx.subscribe(&rename_editor, |_, _, e: &EditorEvent, cx| {\n                        if e == &EditorEvent::Focused {\n                            cx.emit(EditorEvent::FocusedIn)\n                        }\n                    })\n                    .detach();\n\n                    let write_highlights =\n                        this.clear_background_highlights::<DocumentHighlightWrite>(cx);\n                    let read_highlights =\n                        this.clear_background_highlights::<DocumentHighlightRead>(cx);\n                    let ranges = write_highlights\n                        .iter()\n                        .flat_map(|(_, ranges)| ranges.iter())\n                        .chain(read_highlights.iter().flat_map(|(_, ranges)| ranges.iter()))\n                        .cloned()\n                        .collect();\n\n                    this.highlight_text::<Rename>(\n                        ranges,\n                        HighlightStyle {\n                            fade_out: Some(0.6),\n                            ..Default::default()\n                        },\n                        cx,\n                    );\n                    let rename_focus_handle = rename_editor.focus_handle(cx);\n                    window.focus(&rename_focus_handle);\n                    let block_id = this.insert_blocks(\n                        [BlockProperties {\n                            style: BlockStyle::Flex,\n                            placement: BlockPlacement::Below(range.start),\n                            height: Some(1),\n                            render: Arc::new({\n                                let rename_editor = rename_editor.clone();\n                                move |cx: &mut BlockContext| {\n                                    let mut text_style = cx.editor_style.text.clone();\n                                    if let Some(highlight_style) = old_highlight_id\n                                        .and_then(|h| h.style(&cx.editor_style.syntax))\n                                    {\n                                        text_style = text_style.highlight(highlight_style);\n                                    }\n                                    div()\n                                        .block_mouse_except_scroll()\n                                        .pl(cx.anchor_x)\n                                        .child(EditorElement::new(\n                                            &rename_editor,\n                                            EditorStyle {\n                                                background: cx.theme().system().transparent,\n                                                local_player: cx.editor_style.local_player,\n                                                text: text_style,\n                                                scrollbar_width: cx.editor_style.scrollbar_width,\n                                                syntax: cx.editor_style.syntax.clone(),\n                                                status: cx.editor_style.status.clone(),\n                                                inlay_hints_style: HighlightStyle {\n                                                    font_weight: Some(FontWeight::BOLD),\n                                                    ..make_inlay_hints_style(cx.app)\n                                                },\n                                                edit_prediction_styles: make_suggestion_styles(\n                                                    cx.app,\n                                                ),\n                                                ..EditorStyle::default()\n                                            },\n                                        ))\n                                        .into_any_element()\n                                }\n                            }),\n                            priority: 0,\n                        }],\n                        Some(Autoscroll::fit()),\n                        cx,\n                    )[0];\n                    this.pending_rename = Some(RenameState {\n                        range,\n                        old_name,\n                        editor: rename_editor,\n                        block_id,\n                    });\n                })?;\n            }\n\n            Ok(())\n        }))\n    }\n\n    pub fn confirm_rename(\n        &mut self,\n        _: &ConfirmRename,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<Task<Result<()>>> {\n        let rename = self.take_rename(false, window, cx)?;\n        let workspace = self.workspace()?.downgrade();\n        let (buffer, start) = self\n            .buffer\n            .read(cx)\n            .text_anchor_for_position(rename.range.start, cx)?;\n        let (end_buffer, _) = self\n            .buffer\n            .read(cx)\n            .text_anchor_for_position(rename.range.end, cx)?;\n        if buffer != end_buffer {\n            return None;\n        }\n\n        let old_name = rename.old_name;\n        let new_name = rename.editor.read(cx).text(cx);\n\n        let rename = self.semantics_provider.as_ref()?.perform_rename(\n            &buffer,\n            start,\n            new_name.clone(),\n            cx,\n        )?;\n\n        Some(cx.spawn_in(window, async move |editor, cx| {\n            let project_transaction = rename.await?;\n            Self::open_project_transaction(\n                &editor,\n                workspace,\n                project_transaction,\n                format!(": "",
        ", old_name, new_name),\n                cx,\n            )\n            .await?;\n\n            editor.update(cx, |editor, cx| {\n                editor.refresh_document_highlights(cx);\n            })?;\n            Ok(())\n        }))\n    }\n\n    fn take_rename(\n        &mut self,\n        moving_cursor: bool,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<RenameState> {\n        let rename = self.pending_rename.take()?;\n        if rename.editor.focus_handle(cx).is_focused(window) {\n            window.focus(&self.focus_handle);\n        }\n\n        self.remove_blocks(\n            [rename.block_id].into_iter().collect(),\n            Some(Autoscroll::fit()),\n            cx,\n        );\n        self.clear_highlights::<Rename>(cx);\n        self.show_local_selections = true;\n\n        if moving_cursor {\n            let cursor_in_rename_editor = rename.editor.update(cx, |editor, cx| {\n                editor\n                    .selections\n                    .newest::<usize>(&editor.display_snapshot(cx))\n                    .head()\n            });\n\n            // Update the selection to match the position of the selection inside\n            // the rename editor.\n            let snapshot = self.buffer.read(cx).read(cx);\n            let rename_range = rename.range.to_offset(&snapshot);\n            let cursor_in_editor = snapshot\n                .clip_offset(rename_range.start + cursor_in_rename_editor, Bias::Left)\n                .min(rename_range.end);\n            drop(snapshot);\n\n            self.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n                s.select_ranges(vec![cursor_in_editor..cursor_in_editor])\n            });\n        } else {\n            self.refresh_document_highlights(cx);\n        }\n\n        Some(rename)\n    }\n\n    pub fn pending_rename(&self) -> Option<&RenameState> {\n        self.pending_rename.as_ref()\n    }\n\n    fn format(\n        &mut self,\n        _: &Format,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<Task<Result<()>>> {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::TypingAction, cx);\n\n        let project = match &self.project {\n            Some(project) => project.clone(),\n            None => return None,\n        };\n\n        Some(self.perform_format(\n            project,\n            FormatTrigger::Manual,\n            FormatTarget::Buffers(self.buffer.read(cx).all_buffers()),\n            window,\n            cx,\n        ))\n    }\n\n    fn format_selections(\n        &mut self,\n        _: &FormatSelections,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<Task<Result<()>>> {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::TypingAction, cx);\n\n        let project = match &self.project {\n            Some(project) => project.clone(),\n            None => return None,\n        };\n\n        let ranges = self\n            .selections\n            .all_adjusted(&self.display_snapshot(cx))\n            .into_iter()\n            .map(|selection| selection.range())\n            .collect_vec();\n\n        Some(self.perform_format(\n            project,\n            FormatTrigger::Manual,\n            FormatTarget::Ranges(ranges),\n            window,\n            cx,\n        ))\n    }\n\n    fn perform_format(\n        &mut self,\n        project: Entity<Project>,\n        trigger: FormatTrigger,\n        target: FormatTarget,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<()>> {\n        let buffer = self.buffer.clone();\n        let (buffers, target) = match target {\n            FormatTarget::Buffers(buffers) => (buffers, LspFormatTarget::Buffers),\n            FormatTarget::Ranges(selection_ranges) => {\n                let multi_buffer = buffer.read(cx);\n                let snapshot = multi_buffer.read(cx);\n                let mut buffers = HashSet::default();\n                let mut buffer_id_to_ranges: BTreeMap<BufferId, Vec<Range<text::Anchor>>> =\n                    BTreeMap::new();\n                for selection_range in selection_ranges {\n                    for (buffer, buffer_range, _) in\n                        snapshot.range_to_buffer_ranges(selection_range)\n                    {\n                        let buffer_id = buffer.remote_id();\n                        let start = buffer.anchor_before(buffer_range.start);\n                        let end = buffer.anchor_after(buffer_range.end);\n                        buffers.insert(multi_buffer.buffer(buffer_id).unwrap());\n                        buffer_id_to_ranges\n                            .entry(buffer_id)\n                            .and_modify(|buffer_ranges| buffer_ranges.push(start..end))\n                            .or_insert_with(|| vec![start..end]);\n                    }\n                }\n                (buffers, LspFormatTarget::Ranges(buffer_id_to_ranges))\n            }\n        };\n\n        let transaction_id_prev = buffer.read(cx).last_transaction_id(cx);\n        let selections_prev = transaction_id_prev\n            .and_then(|transaction_id_prev| {\n                // default to selections as they were after the last edit, if we have them,\n                // instead of how they are now.\n                // This will make it so that editing, moving somewhere else, formatting, then undoing the format\n                // will take you back to where you made the last edit, instead of staying where you scrolled\n                self.selection_history\n                    .transaction(transaction_id_prev)\n                    .map(|t| t.0.clone())\n            })\n            .unwrap_or_else(|| self.selections.disjoint_anchors_arc());\n\n        let mut timeout = cx.background_executor().timer(FORMAT_TIMEOUT).fuse();\n        let format = project.update(cx, |project, cx| {\n            project.format(buffers, target, true, trigger, cx)\n        });\n\n        cx.spawn_in(window, async move |editor, cx| {\n            let transaction = futures::select_biased! {\n                transaction = format.log_err().fuse() => transaction,\n                () = timeout => {\n                    log::warn!(": "",
        ");\n                    None\n                }\n            };\n\n            buffer\n                .update(cx, |buffer, cx| {\n                    if let Some(transaction) = transaction\n                        && !buffer.is_singleton()\n                    {\n                        buffer.push_transaction(&transaction.0, cx);\n                    }\n                    cx.notify();\n                })\n                .ok();\n\n            if let Some(transaction_id_now) =\n                buffer.read_with(cx, |b, cx| b.last_transaction_id(cx))?\n            {\n                let has_new_transaction = transaction_id_prev != Some(transaction_id_now);\n                if has_new_transaction {\n                    _ = editor.update(cx, |editor, _| {\n                        editor\n                            .selection_history\n                            .insert_transaction(transaction_id_now, selections_prev);\n                    });\n                }\n            }\n\n            Ok(())\n        })\n    }\n\n    fn organize_imports(\n        &mut self,\n        _: &OrganizeImports,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<Task<Result<()>>> {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::TypingAction, cx);\n        let project = match &self.project {\n            Some(project) => project.clone(),\n            None => return None,\n        };\n        Some(self.perform_code_action_kind(\n            project,\n            CodeActionKind::SOURCE_ORGANIZE_IMPORTS,\n            window,\n            cx,\n        ))\n    }\n\n    fn perform_code_action_kind(\n        &mut self,\n        project: Entity<Project>,\n        kind: CodeActionKind,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<()>> {\n        let buffer = self.buffer.clone();\n        let buffers = buffer.read(cx).all_buffers();\n        let mut timeout = cx.background_executor().timer(CODE_ACTION_TIMEOUT).fuse();\n        let apply_action = project.update(cx, |project, cx| {\n            project.apply_code_action_kind(buffers, kind, true, cx)\n        });\n        cx.spawn_in(window, async move |_, cx| {\n            let transaction = futures::select_biased! {\n                () = timeout => {\n                    log::warn!(": "",
        ");\n                    None\n                }\n                transaction = apply_action.log_err().fuse() => transaction,\n            };\n            buffer\n                .update(cx, |buffer, cx| {\n                    // check if we need this\n                    if let Some(transaction) = transaction\n                        && !buffer.is_singleton()\n                    {\n                        buffer.push_transaction(&transaction.0, cx);\n                    }\n                    cx.notify();\n                })\n                .ok();\n            Ok(())\n        })\n    }\n\n    pub fn restart_language_server(\n        &mut self,\n        _: &RestartLanguageServer,\n        _: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(project) = self.project.clone() {\n            self.buffer.update(cx, |multi_buffer, cx| {\n                project.update(cx, |project, cx| {\n                    project.restart_language_servers_for_buffers(\n                        multi_buffer.all_buffers().into_iter().collect(),\n                        HashSet::default(),\n                        cx,\n                    );\n                });\n            })\n        }\n    }\n\n    pub fn stop_language_server(\n        &mut self,\n        _: &StopLanguageServer,\n        _: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(project) = self.project.clone() {\n            self.buffer.update(cx, |multi_buffer, cx| {\n                project.update(cx, |project, cx| {\n                    project.stop_language_servers_for_buffers(\n                        multi_buffer.all_buffers().into_iter().collect(),\n                        HashSet::default(),\n                        cx,\n                    );\n                });\n            });\n            self.refresh_inlay_hints(InlayHintRefreshReason::NewLinesShown, cx);\n        }\n    }\n\n    fn cancel_language_server_work(\n        workspace: &mut Workspace,\n        _: &actions::CancelLanguageServerWork,\n        _: &mut Window,\n        cx: &mut Context<Workspace>,\n    ) {\n        let project = workspace.project();\n        let buffers = workspace\n            .active_item(cx)\n            .and_then(|item| item.act_as::<Editor>(cx))\n            .map_or(HashSet::default(), |editor| {\n                editor.read(cx).buffer.read(cx).all_buffers()\n            });\n        project.update(cx, |project, cx| {\n            project.cancel_language_server_work_for_buffers(buffers, cx);\n        });\n    }\n\n    fn show_character_palette(\n        &mut self,\n        _: &ShowCharacterPalette,\n        window: &mut Window,\n        _: &mut Context<Self>,\n    ) {\n        window.show_character_palette();\n    }\n\n    fn refresh_active_diagnostics(&mut self, cx: &mut Context<Editor>) {\n        if !self.diagnostics_enabled() {\n            return;\n        }\n\n        if let ActiveDiagnostic::Group(active_diagnostics) = &mut self.active_diagnostics {\n            let buffer = self.buffer.read(cx).snapshot(cx);\n            let primary_range_start = active_diagnostics.active_range.start.to_offset(&buffer);\n            let primary_range_end = active_diagnostics.active_range.end.to_offset(&buffer);\n            let is_valid = buffer\n                .diagnostics_in_range::<usize>(primary_range_start..primary_range_end)\n                .any(|entry| {\n                    entry.diagnostic.is_primary\n                        && !entry.range.is_empty()\n                        && entry.range.start == primary_range_start\n                        && entry.diagnostic.message == active_diagnostics.active_message\n                });\n\n            if !is_valid {\n                self.dismiss_diagnostics(cx);\n            }\n        }\n    }\n\n    pub fn active_diagnostic_group(&self) -> Option<&ActiveDiagnosticGroup> {\n        match &self.active_diagnostics {\n            ActiveDiagnostic::Group(group) => Some(group),\n            _ => None,\n        }\n    }\n\n    pub fn set_all_diagnostics_active(&mut self, cx: &mut Context<Self>) {\n        if !self.diagnostics_enabled() {\n            return;\n        }\n        self.dismiss_diagnostics(cx);\n        self.active_diagnostics = ActiveDiagnostic::All;\n    }\n\n    fn activate_diagnostics(\n        &mut self,\n        buffer_id: BufferId,\n        diagnostic: DiagnosticEntryRef<'_, usize>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if !self.diagnostics_enabled() || matches!(self.active_diagnostics, ActiveDiagnostic::All) {\n            return;\n        }\n        self.dismiss_diagnostics(cx);\n        let snapshot = self.snapshot(window, cx);\n        let buffer = self.buffer.read(cx).snapshot(cx);\n        let Some(renderer) = GlobalDiagnosticRenderer::global(cx) else {\n            return;\n        };\n\n        let diagnostic_group = buffer\n            .diagnostic_group(buffer_id, diagnostic.diagnostic.group_id)\n            .collect::<Vec<_>>();\n\n        let blocks =\n            renderer.render_group(diagnostic_group, buffer_id, snapshot, cx.weak_entity(), cx);\n\n        let blocks = self.display_map.update(cx, |display_map, cx| {\n            display_map.insert_blocks(blocks, cx).into_iter().collect()\n        });\n        self.active_diagnostics = ActiveDiagnostic::Group(ActiveDiagnosticGroup {\n            active_range: buffer.anchor_before(diagnostic.range.start)\n                ..buffer.anchor_after(diagnostic.range.end),\n            active_message: diagnostic.diagnostic.message.clone(),\n            group_id: diagnostic.diagnostic.group_id,\n            blocks,\n        });\n        cx.notify();\n    }\n\n    fn dismiss_diagnostics(&mut self, cx: &mut Context<Self>) {\n        if matches!(self.active_diagnostics, ActiveDiagnostic::All) {\n            return;\n        };\n\n        let prev = mem::replace(&mut self.active_diagnostics, ActiveDiagnostic::None);\n        if let ActiveDiagnostic::Group(group) = prev {\n            self.display_map.update(cx, |display_map, cx| {\n                display_map.remove_blocks(group.blocks, cx);\n            });\n            cx.notify();\n        }\n    }\n\n    /// Disable inline diagnostics rendering for this editor.\n    pub fn disable_inline_diagnostics(&mut self) {\n        self.inline_diagnostics_enabled = false;\n        self.inline_diagnostics_update = Task::ready(());\n        self.inline_diagnostics.clear();\n    }\n\n    pub fn disable_diagnostics(&mut self, cx: &mut Context<Self>) {\n        self.diagnostics_enabled = false;\n        self.dismiss_diagnostics(cx);\n        self.inline_diagnostics_update = Task::ready(());\n        self.inline_diagnostics.clear();\n    }\n\n    pub fn disable_word_completions(&mut self) {\n        self.word_completions_enabled = false;\n    }\n\n    pub fn diagnostics_enabled(&self) -> bool {\n        self.diagnostics_enabled && self.mode.is_full()\n    }\n\n    pub fn inline_diagnostics_enabled(&self) -> bool {\n        self.inline_diagnostics_enabled && self.diagnostics_enabled()\n    }\n\n    pub fn show_inline_diagnostics(&self) -> bool {\n        self.show_inline_diagnostics\n    }\n\n    pub fn toggle_inline_diagnostics(\n        &mut self,\n        _: &ToggleInlineDiagnostics,\n        window: &mut Window,\n        cx: &mut Context<Editor>,\n    ) {\n        self.show_inline_diagnostics = !self.show_inline_diagnostics;\n        self.refresh_inline_diagnostics(false, window, cx);\n    }\n\n    pub fn set_max_diagnostics_severity(&mut self, severity: DiagnosticSeverity, cx: &mut App) {\n        self.diagnostics_max_severity = severity;\n        self.display_map.update(cx, |display_map, _| {\n            display_map.diagnostics_max_severity = self.diagnostics_max_severity;\n        });\n    }\n\n    pub fn toggle_diagnostics(\n        &mut self,\n        _: &ToggleDiagnostics,\n        window: &mut Window,\n        cx: &mut Context<Editor>,\n    ) {\n        if !self.diagnostics_enabled() {\n            return;\n        }\n\n        let new_severity = if self.diagnostics_max_severity == DiagnosticSeverity::Off {\n            EditorSettings::get_global(cx)\n                .diagnostics_max_severity\n                .filter(|severity| severity != &DiagnosticSeverity::Off)\n                .unwrap_or(DiagnosticSeverity::Hint)\n        } else {\n            DiagnosticSeverity::Off\n        };\n        self.set_max_diagnostics_severity(new_severity, cx);\n        if self.diagnostics_max_severity == DiagnosticSeverity::Off {\n            self.active_diagnostics = ActiveDiagnostic::None;\n            self.inline_diagnostics_update = Task::ready(());\n            self.inline_diagnostics.clear();\n        } else {\n            self.refresh_inline_diagnostics(false, window, cx);\n        }\n\n        cx.notify();\n    }\n\n    pub fn toggle_minimap(\n        &mut self,\n        _: &ToggleMinimap,\n        window: &mut Window,\n        cx: &mut Context<Editor>,\n    ) {\n        if self.supports_minimap(cx) {\n            self.set_minimap_visibility(self.minimap_visibility.toggle_visibility(), window, cx);\n        }\n    }\n\n    fn refresh_inline_diagnostics(\n        &mut self,\n        debounce: bool,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let max_severity = ProjectSettings::get_global(cx)\n            .diagnostics\n            .inline\n            .max_severity\n            .unwrap_or(self.diagnostics_max_severity);\n\n        if !self.inline_diagnostics_enabled()\n            || !self.diagnostics_enabled()\n            || !self.show_inline_diagnostics\n            || max_severity == DiagnosticSeverity::Off\n        {\n            self.inline_diagnostics_update = Task::ready(());\n            self.inline_diagnostics.clear();\n            return;\n        }\n\n        let debounce_ms = ProjectSettings::get_global(cx)\n            .diagnostics\n            .inline\n            .update_debounce_ms;\n        let debounce = if debounce && debounce_ms > 0 {\n            Some(Duration::from_millis(debounce_ms))\n        } else {\n            None\n        };\n        self.inline_diagnostics_update = cx.spawn_in(window, async move |editor, cx| {\n            if let Some(debounce) = debounce {\n                cx.background_executor().timer(debounce).await;\n            }\n            let Some(snapshot) = editor.upgrade().and_then(|editor| {\n                editor\n                    .update(cx, |editor, cx| editor.buffer().read(cx).snapshot(cx))\n                    .ok()\n            }) else {\n                return;\n            };\n\n            let new_inline_diagnostics = cx\n                .background_spawn(async move {\n                    let mut inline_diagnostics = Vec::<(Anchor, InlineDiagnostic)>::new();\n                    for diagnostic_entry in snapshot.diagnostics_in_range(0..snapshot.len()) {\n                        let message = diagnostic_entry\n                            .diagnostic\n                            .message\n                            .split_once('\\n')\n                            .map(|(line, _)| line)\n                            .map(SharedString::new)\n                            .unwrap_or_else(|| {\n                                SharedString::new(&*diagnostic_entry.diagnostic.message)\n                            });\n                        let start_anchor = snapshot.anchor_before(diagnostic_entry.range.start);\n                        let (Ok(i) | Err(i)) = inline_diagnostics\n                            .binary_search_by(|(probe, _)| probe.cmp(&start_anchor, &snapshot));\n                        inline_diagnostics.insert(\n                            i,\n                            (\n                                start_anchor,\n                                InlineDiagnostic {\n                                    message,\n                                    group_id: diagnostic_entry.diagnostic.group_id,\n                                    start: diagnostic_entry.range.start.to_point(&snapshot),\n                                    is_primary: diagnostic_entry.diagnostic.is_primary,\n                                    severity: diagnostic_entry.diagnostic.severity,\n                                },\n                            ),\n                        );\n                    }\n                    inline_diagnostics\n                })\n                .await;\n\n            editor\n                .update(cx, |editor, cx| {\n                    editor.inline_diagnostics = new_inline_diagnostics;\n                    cx.notify();\n                })\n                .ok();\n        });\n    }\n\n    fn pull_diagnostics(\n        &mut self,\n        buffer_id: Option<BufferId>,\n        window: &Window,\n        cx: &mut Context<Self>,\n    ) -> Option<()> {\n        if self.ignore_lsp_data() || !self.diagnostics_enabled() {\n            return None;\n        }\n        let pull_diagnostics_settings = ProjectSettings::get_global(cx)\n            .diagnostics\n            .lsp_pull_diagnostics;\n        if !pull_diagnostics_settings.enabled {\n            return None;\n        }\n        let project = self.project()?.downgrade();\n        let debounce = Duration::from_millis(pull_diagnostics_settings.debounce_ms);\n        let mut buffers = self.buffer.read(cx).all_buffers();\n        buffers.retain(|buffer| {\n            let buffer_id_to_retain = buffer.read(cx).remote_id();\n            buffer_id.is_none_or(|buffer_id| buffer_id == buffer_id_to_retain)\n                && self.registered_buffers.contains_key(&buffer_id_to_retain)\n        });\n        if buffers.is_empty() {\n            self.pull_diagnostics_task = Task::ready(());\n            return None;\n        }\n\n        self.pull_diagnostics_task = cx.spawn_in(window, async move |editor, cx| {\n            cx.background_executor().timer(debounce).await;\n\n            let Ok(mut pull_diagnostics_tasks) = cx.update(|_, cx| {\n                buffers\n                    .into_iter()\n                    .filter_map(|buffer| {\n                        project\n                            .update(cx, |project, cx| {\n                                project.lsp_store().update(cx, |lsp_store, cx| {\n                                    lsp_store.pull_diagnostics_for_buffer(buffer, cx)\n                                })\n                            })\n                            .ok()\n                    })\n                    .collect::<FuturesUnordered<_>>()\n            }) else {\n                return;\n            };\n\n            while let Some(pull_task) = pull_diagnostics_tasks.next().await {\n                match pull_task {\n                    Ok(()) => {\n                        if editor\n                            .update_in(cx, |editor, window, cx| {\n                                editor.update_diagnostics_state(window, cx);\n                            })\n                            .is_err()\n                        {\n                            return;\n                        }\n                    }\n                    Err(e) => log::error!(": "",
        "),\n                }\n            }\n        });\n\n        Some(())\n    }\n\n    pub fn set_selections_from_remote(\n        &mut self,\n        selections: Vec<Selection<Anchor>>,\n        pending_selection: Option<Selection<Anchor>>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let old_cursor_position = self.selections.newest_anchor().head();\n        self.selections\n            .change_with(&self.display_snapshot(cx), |s| {\n                s.select_anchors(selections);\n                if let Some(pending_selection) = pending_selection {\n                    s.set_pending(pending_selection, SelectMode::Character);\n                } else {\n                    s.clear_pending();\n                }\n            });\n        self.selections_did_change(\n            false,\n            &old_cursor_position,\n            SelectionEffects::default(),\n            window,\n            cx,\n        );\n    }\n\n    pub fn transact(\n        &mut self,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n        update: impl FnOnce(&mut Self, &mut Window, &mut Context<Self>),\n    ) -> Option<TransactionId> {\n        self.with_selection_effects_deferred(window, cx, |this, window, cx| {\n            this.start_transaction_at(Instant::now(), window, cx);\n            update(this, window, cx);\n            this.end_transaction_at(Instant::now(), cx)\n        })\n    }\n\n    pub fn start_transaction_at(\n        &mut self,\n        now: Instant,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<TransactionId> {\n        self.end_selection(window, cx);\n        if let Some(tx_id) = self\n            .buffer\n            .update(cx, |buffer, cx| buffer.start_transaction_at(now, cx))\n        {\n            self.selection_history\n                .insert_transaction(tx_id, self.selections.disjoint_anchors_arc());\n            cx.emit(EditorEvent::TransactionBegun {\n                transaction_id: tx_id,\n            });\n            Some(tx_id)\n        } else {\n            None\n        }\n    }\n\n    pub fn end_transaction_at(\n        &mut self,\n        now: Instant,\n        cx: &mut Context<Self>,\n    ) -> Option<TransactionId> {\n        if let Some(transaction_id) = self\n            .buffer\n            .update(cx, |buffer, cx| buffer.end_transaction_at(now, cx))\n        {\n            if let Some((_, end_selections)) =\n                self.selection_history.transaction_mut(transaction_id)\n            {\n                *end_selections = Some(self.selections.disjoint_anchors_arc());\n            } else {\n                log::error!(": "",
        ");\n            }\n\n            cx.emit(EditorEvent::Edited { transaction_id });\n            Some(transaction_id)\n        } else {\n            None\n        }\n    }\n\n    pub fn modify_transaction_selection_history(\n        &mut self,\n        transaction_id: TransactionId,\n        modify: impl FnOnce(&mut (Arc<[Selection<Anchor>]>, Option<Arc<[Selection<Anchor>]>>)),\n    ) -> bool {\n        self.selection_history\n            .transaction_mut(transaction_id)\n            .map(modify)\n            .is_some()\n    }\n\n    pub fn set_mark(&mut self, _: &actions::SetMark, window: &mut Window, cx: &mut Context<Self>) {\n        if self.selection_mark_mode {\n            self.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n                s.move_with(|_, sel| {\n                    sel.collapse_to(sel.head(), SelectionGoal::None);\n                });\n            })\n        }\n        self.selection_mark_mode = true;\n        cx.notify();\n    }\n\n    pub fn swap_selection_ends(\n        &mut self,\n        _: &actions::SwapSelectionEnds,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n            s.move_with(|_, sel| {\n                if sel.start != sel.end {\n                    sel.reversed = !sel.reversed\n                }\n            });\n        });\n        self.request_autoscroll(Autoscroll::newest(), cx);\n        cx.notify();\n    }\n\n    pub fn toggle_focus(\n        workspace: &mut Workspace,\n        _: &actions::ToggleFocus,\n        window: &mut Window,\n        cx: &mut Context<Workspace>,\n    ) {\n        let Some(item) = workspace.recent_active_item_by_type::<Self>(cx) else {\n            return;\n        };\n        workspace.activate_item(&item, true, true, window, cx);\n    }\n\n    pub fn toggle_fold(\n        &mut self,\n        _: &actions::ToggleFold,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if self.buffer_kind(cx) == ItemBufferKind::Singleton {\n            let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n            let selection = self.selections.newest::<Point>(&display_map);\n\n            let range = if selection.is_empty() {\n                let point = selection.head().to_display_point(&display_map);\n                let start = DisplayPoint::new(point.row(), 0).to_point(&display_map);\n                let end = DisplayPoint::new(point.row(), display_map.line_len(point.row()))\n                    .to_point(&display_map);\n                start..end\n            } else {\n                selection.range()\n            };\n            if display_map.folds_in_range(range).next().is_some() {\n                self.unfold_lines(&Default::default(), window, cx)\n            } else {\n                self.fold(&Default::default(), window, cx)\n            }\n        } else {\n            let multi_buffer_snapshot = self.buffer.read(cx).snapshot(cx);\n            let buffer_ids: HashSet<_> = self\n                .selections\n                .disjoint_anchor_ranges()\n                .flat_map(|range| multi_buffer_snapshot.buffer_ids_for_range(range))\n                .collect();\n\n            let should_unfold = buffer_ids\n                .iter()\n                .any(|buffer_id| self.is_buffer_folded(*buffer_id, cx));\n\n            for buffer_id in buffer_ids {\n                if should_unfold {\n                    self.unfold_buffer(buffer_id, cx);\n                } else {\n                    self.fold_buffer(buffer_id, cx);\n                }\n            }\n        }\n    }\n\n    pub fn toggle_fold_recursive(\n        &mut self,\n        _: &actions::ToggleFoldRecursive,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let selection = self.selections.newest::<Point>(&self.display_snapshot(cx));\n\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n        let range = if selection.is_empty() {\n            let point = selection.head().to_display_point(&display_map);\n            let start = DisplayPoint::new(point.row(), 0).to_point(&display_map);\n            let end = DisplayPoint::new(point.row(), display_map.line_len(point.row()))\n                .to_point(&display_map);\n            start..end\n        } else {\n            selection.range()\n        };\n        if display_map.folds_in_range(range).next().is_some() {\n            self.unfold_recursive(&Default::default(), window, cx)\n        } else {\n            self.fold_recursive(&Default::default(), window, cx)\n        }\n    }\n\n    pub fn fold(&mut self, _: &actions::Fold, window: &mut Window, cx: &mut Context<Self>) {\n        if self.buffer_kind(cx) == ItemBufferKind::Singleton {\n            let mut to_fold = Vec::new();\n            let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n            let selections = self.selections.all_adjusted(&display_map);\n\n            for selection in selections {\n                let range = selection.range().sorted();\n                let buffer_start_row = range.start.row;\n\n                if range.start.row != range.end.row {\n                    let mut found = false;\n                    let mut row = range.start.row;\n                    while row <= range.end.row {\n                        if let Some(crease) = display_map.crease_for_buffer_row(MultiBufferRow(row))\n                        {\n                            found = true;\n                            row = crease.range().end.row + 1;\n                            to_fold.push(crease);\n                        } else {\n                            row += 1\n                        }\n                    }\n                    if found {\n                        continue;\n                    }\n                }\n\n                for row in (0..=range.start.row).rev() {\n                    if let Some(crease) = display_map.crease_for_buffer_row(MultiBufferRow(row))\n                        && crease.range().end.row >= buffer_start_row\n                    {\n                        to_fold.push(crease);\n                        if row <= range.start.row {\n                            break;\n                        }\n                    }\n                }\n            }\n\n            self.fold_creases(to_fold, true, window, cx);\n        } else {\n            let multi_buffer_snapshot = self.buffer.read(cx).snapshot(cx);\n            let buffer_ids = self\n                .selections\n                .disjoint_anchor_ranges()\n                .flat_map(|range| multi_buffer_snapshot.buffer_ids_for_range(range))\n                .collect::<HashSet<_>>();\n            for buffer_id in buffer_ids {\n                self.fold_buffer(buffer_id, cx);\n            }\n        }\n    }\n\n    pub fn toggle_fold_all(\n        &mut self,\n        _: &actions::ToggleFoldAll,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if self.buffer.read(cx).is_singleton() {\n            let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n            let has_folds = display_map\n                .folds_in_range(0..display_map.buffer_snapshot().len())\n                .next()\n                .is_some();\n\n            if has_folds {\n                self.unfold_all(&actions::UnfoldAll, window, cx);\n            } else {\n                self.fold_all(&actions::FoldAll, window, cx);\n            }\n        } else {\n            let buffer_ids = self.buffer.read(cx).excerpt_buffer_ids();\n            let should_unfold = buffer_ids\n                .iter()\n                .any(|buffer_id| self.is_buffer_folded(*buffer_id, cx));\n\n            self.toggle_fold_multiple_buffers = cx.spawn_in(window, async move |editor, cx| {\n                editor\n                    .update_in(cx, |editor, _, cx| {\n                        for buffer_id in buffer_ids {\n                            if should_unfold {\n                                editor.unfold_buffer(buffer_id, cx);\n                            } else {\n                                editor.fold_buffer(buffer_id, cx);\n                            }\n                        }\n                    })\n                    .ok();\n            });\n        }\n    }\n\n    fn fold_at_level(\n        &mut self,\n        fold_at: &FoldAtLevel,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if !self.buffer.read(cx).is_singleton() {\n            return;\n        }\n\n        let fold_at_level = fold_at.0;\n        let snapshot = self.buffer.read(cx).snapshot(cx);\n        let mut to_fold = Vec::new();\n        let mut stack = vec![(0, snapshot.max_row().0, 1)];\n\n        let row_ranges_to_keep: Vec<Range<u32>> = self\n            .selections\n            .all::<Point>(&self.display_snapshot(cx))\n            .into_iter()\n            .map(|sel| sel.start.row..sel.end.row)\n            .collect();\n\n        while let Some((mut start_row, end_row, current_level)) = stack.pop() {\n            while start_row < end_row {\n                match self\n                    .snapshot(window, cx)\n                    .crease_for_buffer_row(MultiBufferRow(start_row))\n                {\n                    Some(crease) => {\n                        let nested_start_row = crease.range().start.row + 1;\n                        let nested_end_row = crease.range().end.row;\n\n                        if current_level < fold_at_level {\n                            stack.push((nested_start_row, nested_end_row, current_level + 1));\n                        } else if current_level == fold_at_level {\n                            // Fold iff there is no selection completely contained within the fold region\n                            if !row_ranges_to_keep.iter().any(|selection| {\n                                selection.end >= nested_start_row\n                                    && selection.start <= nested_end_row\n                            }) {\n                                to_fold.push(crease);\n                            }\n                        }\n\n                        start_row = nested_end_row + 1;\n                    }\n                    None => start_row += 1,\n                }\n            }\n        }\n\n        self.fold_creases(to_fold, true, window, cx);\n    }\n\n    pub fn fold_at_level_1(\n        &mut self,\n        _: &actions::FoldAtLevel1,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.fold_at_level(&actions::FoldAtLevel(1), window, cx);\n    }\n\n    pub fn fold_at_level_2(\n        &mut self,\n        _: &actions::FoldAtLevel2,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.fold_at_level(&actions::FoldAtLevel(2), window, cx);\n    }\n\n    pub fn fold_at_level_3(\n        &mut self,\n        _: &actions::FoldAtLevel3,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.fold_at_level(&actions::FoldAtLevel(3), window, cx);\n    }\n\n    pub fn fold_at_level_4(\n        &mut self,\n        _: &actions::FoldAtLevel4,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.fold_at_level(&actions::FoldAtLevel(4), window, cx);\n    }\n\n    pub fn fold_at_level_5(\n        &mut self,\n        _: &actions::FoldAtLevel5,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.fold_at_level(&actions::FoldAtLevel(5), window, cx);\n    }\n\n    pub fn fold_at_level_6(\n        &mut self,\n        _: &actions::FoldAtLevel6,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.fold_at_level(&actions::FoldAtLevel(6), window, cx);\n    }\n\n    pub fn fold_at_level_7(\n        &mut self,\n        _: &actions::FoldAtLevel7,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.fold_at_level(&actions::FoldAtLevel(7), window, cx);\n    }\n\n    pub fn fold_at_level_8(\n        &mut self,\n        _: &actions::FoldAtLevel8,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.fold_at_level(&actions::FoldAtLevel(8), window, cx);\n    }\n\n    pub fn fold_at_level_9(\n        &mut self,\n        _: &actions::FoldAtLevel9,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.fold_at_level(&actions::FoldAtLevel(9), window, cx);\n    }\n\n    pub fn fold_all(&mut self, _: &actions::FoldAll, window: &mut Window, cx: &mut Context<Self>) {\n        if self.buffer.read(cx).is_singleton() {\n            let mut fold_ranges = Vec::new();\n            let snapshot = self.buffer.read(cx).snapshot(cx);\n\n            for row in 0..snapshot.max_row().0 {\n                if let Some(foldable_range) = self\n                    .snapshot(window, cx)\n                    .crease_for_buffer_row(MultiBufferRow(row))\n                {\n                    fold_ranges.push(foldable_range);\n                }\n            }\n\n            self.fold_creases(fold_ranges, true, window, cx);\n        } else {\n            self.toggle_fold_multiple_buffers = cx.spawn_in(window, async move |editor, cx| {\n                editor\n                    .update_in(cx, |editor, _, cx| {\n                        for buffer_id in editor.buffer.read(cx).excerpt_buffer_ids() {\n                            editor.fold_buffer(buffer_id, cx);\n                        }\n                    })\n                    .ok();\n            });\n        }\n    }\n\n    pub fn fold_function_bodies(\n        &mut self,\n        _: &actions::FoldFunctionBodies,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let snapshot = self.buffer.read(cx).snapshot(cx);\n\n        let ranges = snapshot\n            .text_object_ranges(0..snapshot.len(), TreeSitterOptions::default())\n            .filter_map(|(range, obj)| (obj == TextObject::InsideFunction).then_some(range))\n            .collect::<Vec<_>>();\n\n        let creases = ranges\n            .into_iter()\n            .map(|range| Crease::simple(range, self.display_map.read(cx).fold_placeholder.clone()))\n            .collect();\n\n        self.fold_creases(creases, true, window, cx);\n    }\n\n    pub fn fold_recursive(\n        &mut self,\n        _: &actions::FoldRecursive,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let mut to_fold = Vec::new();\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n        let selections = self.selections.all_adjusted(&display_map);\n\n        for selection in selections {\n            let range = selection.range().sorted();\n            let buffer_start_row = range.start.row;\n\n            if range.start.row != range.end.row {\n                let mut found = false;\n                for row in range.start.row..=range.end.row {\n                    if let Some(crease) = display_map.crease_for_buffer_row(MultiBufferRow(row)) {\n                        found = true;\n                        to_fold.push(crease);\n                    }\n                }\n                if found {\n                    continue;\n                }\n            }\n\n            for row in (0..=range.start.row).rev() {\n                if let Some(crease) = display_map.crease_for_buffer_row(MultiBufferRow(row)) {\n                    if crease.range().end.row >= buffer_start_row {\n                        to_fold.push(crease);\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n\n        self.fold_creases(to_fold, true, window, cx);\n    }\n\n    pub fn fold_at(\n        &mut self,\n        buffer_row: MultiBufferRow,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n\n        if let Some(crease) = display_map.crease_for_buffer_row(buffer_row) {\n            let autoscroll = self\n                .selections\n                .all::<Point>(&display_map)\n                .iter()\n                .any(|selection| crease.range().overlaps(&selection.range()));\n\n            self.fold_creases(vec![crease], autoscroll, window, cx);\n        }\n    }\n\n    pub fn unfold_lines(&mut self, _: &UnfoldLines, _window: &mut Window, cx: &mut Context<Self>) {\n        if self.buffer_kind(cx) == ItemBufferKind::Singleton {\n            let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n            let buffer = display_map.buffer_snapshot();\n            let selections = self.selections.all::<Point>(&display_map);\n            let ranges = selections\n                .iter()\n                .map(|s| {\n                    let range = s.display_range(&display_map).sorted();\n                    let mut start = range.start.to_point(&display_map);\n                    let mut end = range.end.to_point(&display_map);\n                    start.column = 0;\n                    end.column = buffer.line_len(MultiBufferRow(end.row));\n                    start..end\n                })\n                .collect::<Vec<_>>();\n\n            self.unfold_ranges(&ranges, true, true, cx);\n        } else {\n            let multi_buffer_snapshot = self.buffer.read(cx).snapshot(cx);\n            let buffer_ids = self\n                .selections\n                .disjoint_anchor_ranges()\n                .flat_map(|range| multi_buffer_snapshot.buffer_ids_for_range(range))\n                .collect::<HashSet<_>>();\n            for buffer_id in buffer_ids {\n                self.unfold_buffer(buffer_id, cx);\n            }\n        }\n    }\n\n    pub fn unfold_recursive(\n        &mut self,\n        _: &UnfoldRecursive,\n        _window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n        let selections = self.selections.all::<Point>(&display_map);\n        let ranges = selections\n            .iter()\n            .map(|s| {\n                let mut range = s.display_range(&display_map).sorted();\n                *range.start.column_mut() = 0;\n                *range.end.column_mut() = display_map.line_len(range.end.row());\n                let start = range.start.to_point(&display_map);\n                let end = range.end.to_point(&display_map);\n                start..end\n            })\n            .collect::<Vec<_>>();\n\n        self.unfold_ranges(&ranges, true, true, cx);\n    }\n\n    pub fn unfold_at(\n        &mut self,\n        buffer_row: MultiBufferRow,\n        _window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n\n        let intersection_range = Point::new(buffer_row.0, 0)\n            ..Point::new(\n                buffer_row.0,\n                display_map.buffer_snapshot().line_len(buffer_row),\n            );\n\n        let autoscroll = self\n            .selections\n            .all::<Point>(&display_map)\n            .iter()\n            .any(|selection| RangeExt::overlaps(&selection.range(), &intersection_range));\n\n        self.unfold_ranges(&[intersection_range], true, autoscroll, cx);\n    }\n\n    pub fn unfold_all(\n        &mut self,\n        _: &actions::UnfoldAll,\n        _window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if self.buffer.read(cx).is_singleton() {\n            let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n            self.unfold_ranges(&[0..display_map.buffer_snapshot().len()], true, true, cx);\n        } else {\n            self.toggle_fold_multiple_buffers = cx.spawn(async move |editor, cx| {\n                editor\n                    .update(cx, |editor, cx| {\n                        for buffer_id in editor.buffer.read(cx).excerpt_buffer_ids() {\n                            editor.unfold_buffer(buffer_id, cx);\n                        }\n                    })\n                    .ok();\n            });\n        }\n    }\n\n    pub fn fold_selected_ranges(\n        &mut self,\n        _: &FoldSelectedRanges,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n        let selections = self.selections.all_adjusted(&display_map);\n        let ranges = selections\n            .into_iter()\n            .map(|s| Crease::simple(s.range(), display_map.fold_placeholder.clone()))\n            .collect::<Vec<_>>();\n        self.fold_creases(ranges, true, window, cx);\n    }\n\n    pub fn fold_ranges<T: ToOffset + Clone>(\n        &mut self,\n        ranges: Vec<Range<T>>,\n        auto_scroll: bool,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n        let ranges = ranges\n            .into_iter()\n            .map(|r| Crease::simple(r, display_map.fold_placeholder.clone()))\n            .collect::<Vec<_>>();\n        self.fold_creases(ranges, auto_scroll, window, cx);\n    }\n\n    pub fn fold_creases<T: ToOffset + Clone>(\n        &mut self,\n        creases: Vec<Crease<T>>,\n        auto_scroll: bool,\n        _window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if creases.is_empty() {\n            return;\n        }\n\n        self.display_map.update(cx, |map, cx| map.fold(creases, cx));\n\n        if auto_scroll {\n            self.request_autoscroll(Autoscroll::fit(), cx);\n        }\n\n        cx.notify();\n\n        self.scrollbar_marker_state.dirty = true;\n        self.folds_did_change(cx);\n    }\n\n    /// Removes any folds whose ranges intersect any of the given ranges.\n    pub fn unfold_ranges<T: ToOffset + Clone>(\n        &mut self,\n        ranges: &[Range<T>],\n        inclusive: bool,\n        auto_scroll: bool,\n        cx: &mut Context<Self>,\n    ) {\n        self.remove_folds_with(ranges, auto_scroll, cx, |map, cx| {\n            map.unfold_intersecting(ranges.iter().cloned(), inclusive, cx)\n        });\n        self.folds_did_change(cx);\n    }\n\n    pub fn fold_buffer(&mut self, buffer_id: BufferId, cx: &mut Context<Self>) {\n        if self.buffer().read(cx).is_singleton() || self.is_buffer_folded(buffer_id, cx) {\n            return;\n        }\n\n        let folded_excerpts = self.buffer().read(cx).excerpts_for_buffer(buffer_id, cx);\n        self.display_map.update(cx, |display_map, cx| {\n            display_map.fold_buffers([buffer_id], cx)\n        });\n\n        let snapshot = self.display_snapshot(cx);\n        self.selections.change_with(&snapshot, |selections| {\n            selections.remove_selections_from_buffer(buffer_id);\n        });\n\n        cx.emit(EditorEvent::BufferFoldToggled {\n            ids: folded_excerpts.iter().map(|&(id, _)| id).collect(),\n            folded: true,\n        });\n        cx.notify();\n    }\n\n    pub fn unfold_buffer(&mut self, buffer_id: BufferId, cx: &mut Context<Self>) {\n        if self.buffer().read(cx).is_singleton() || !self.is_buffer_folded(buffer_id, cx) {\n            return;\n        }\n        let unfolded_excerpts = self.buffer().read(cx).excerpts_for_buffer(buffer_id, cx);\n        self.display_map.update(cx, |display_map, cx| {\n            display_map.unfold_buffers([buffer_id], cx);\n        });\n        cx.emit(EditorEvent::BufferFoldToggled {\n            ids: unfolded_excerpts.iter().map(|&(id, _)| id).collect(),\n            folded: false,\n        });\n        cx.notify();\n    }\n\n    pub fn is_buffer_folded(&self, buffer: BufferId, cx: &App) -> bool {\n        self.display_map.read(cx).is_buffer_folded(buffer)\n    }\n\n    pub fn folded_buffers<'a>(&self, cx: &'a App) -> &'a HashSet<BufferId> {\n        self.display_map.read(cx).folded_buffers()\n    }\n\n    pub fn disable_header_for_buffer(&mut self, buffer_id: BufferId, cx: &mut Context<Self>) {\n        self.display_map.update(cx, |display_map, cx| {\n            display_map.disable_header_for_buffer(buffer_id, cx);\n        });\n        cx.notify();\n    }\n\n    /// Removes any folds with the given ranges.\n    pub fn remove_folds_with_type<T: ToOffset + Clone>(\n        &mut self,\n        ranges: &[Range<T>],\n        type_id: TypeId,\n        auto_scroll: bool,\n        cx: &mut Context<Self>,\n    ) {\n        self.remove_folds_with(ranges, auto_scroll, cx, |map, cx| {\n            map.remove_folds_with_type(ranges.iter().cloned(), type_id, cx)\n        });\n        self.folds_did_change(cx);\n    }\n\n    fn remove_folds_with<T: ToOffset + Clone>(\n        &mut self,\n        ranges: &[Range<T>],\n        auto_scroll: bool,\n        cx: &mut Context<Self>,\n        update: impl FnOnce(&mut DisplayMap, &mut Context<DisplayMap>),\n    ) {\n        if ranges.is_empty() {\n            return;\n        }\n\n        let mut buffers_affected = HashSet::default();\n        let multi_buffer = self.buffer().read(cx);\n        for range in ranges {\n            if let Some((_, buffer, _)) = multi_buffer.excerpt_containing(range.start.clone(), cx) {\n                buffers_affected.insert(buffer.read(cx).remote_id());\n            };\n        }\n\n        self.display_map.update(cx, update);\n\n        if auto_scroll {\n            self.request_autoscroll(Autoscroll::fit(), cx);\n        }\n\n        cx.notify();\n        self.scrollbar_marker_state.dirty = true;\n        self.active_indent_guides_state.dirty = true;\n    }\n\n    pub fn update_renderer_widths(\n        &mut self,\n        widths: impl IntoIterator<Item = (ChunkRendererId, Pixels)>,\n        cx: &mut Context<Self>,\n    ) -> bool {\n        self.display_map\n            .update(cx, |map, cx| map.update_fold_widths(widths, cx))\n    }\n\n    pub fn default_fold_placeholder(&self, cx: &App) -> FoldPlaceholder {\n        self.display_map.read(cx).fold_placeholder.clone()\n    }\n\n    pub fn set_expand_all_diff_hunks(&mut self, cx: &mut App) {\n        self.buffer.update(cx, |buffer, cx| {\n            buffer.set_all_diff_hunks_expanded(cx);\n        });\n    }\n\n    pub fn expand_all_diff_hunks(\n        &mut self,\n        _: &ExpandAllDiffHunks,\n        _window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.buffer.update(cx, |buffer, cx| {\n            buffer.expand_diff_hunks(vec![Anchor::min()..Anchor::max()], cx)\n        });\n    }\n\n    pub fn collapse_all_diff_hunks(\n        &mut self,\n        _: &CollapseAllDiffHunks,\n        _window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.buffer.update(cx, |buffer, cx| {\n            buffer.collapse_diff_hunks(vec![Anchor::min()..Anchor::max()], cx)\n        });\n    }\n\n    pub fn toggle_selected_diff_hunks(\n        &mut self,\n        _: &ToggleSelectedDiffHunks,\n        _window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let ranges: Vec<_> = self\n            .selections\n            .disjoint_anchors()\n            .iter()\n            .map(|s| s.range())\n            .collect();\n        self.toggle_diff_hunks_in_ranges(ranges, cx);\n    }\n\n    pub fn diff_hunks_in_ranges<'a>(\n        &'a self,\n        ranges: &'a [Range<Anchor>],\n        buffer: &'a MultiBufferSnapshot,\n    ) -> impl 'a + Iterator<Item = MultiBufferDiffHunk> {\n        ranges.iter().flat_map(move |range| {\n            let end_excerpt_id = range.end.excerpt_id;\n            let range = range.to_point(buffer);\n            let mut peek_end = range.end;\n            if range.end.row < buffer.max_row().0 {\n                peek_end = Point::new(range.end.row + 1, 0);\n            }\n            buffer\n                .diff_hunks_in_range(range.start..peek_end)\n                .filter(move |hunk| hunk.excerpt_id.cmp(&end_excerpt_id, buffer).is_le())\n        })\n    }\n\n    pub fn has_stageable_diff_hunks_in_ranges(\n        &self,\n        ranges: &[Range<Anchor>],\n        snapshot: &MultiBufferSnapshot,\n    ) -> bool {\n        let mut hunks = self.diff_hunks_in_ranges(ranges, snapshot);\n        hunks.any(|hunk| hunk.status().has_secondary_hunk())\n    }\n\n    pub fn toggle_staged_selected_diff_hunks(\n        &mut self,\n        _: &::git::ToggleStaged,\n        _: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let snapshot = self.buffer.read(cx).snapshot(cx);\n        let ranges: Vec<_> = self\n            .selections\n            .disjoint_anchors()\n            .iter()\n            .map(|s| s.range())\n            .collect();\n        let stage = self.has_stageable_diff_hunks_in_ranges(&ranges, &snapshot);\n        self.stage_or_unstage_diff_hunks(stage, ranges, cx);\n    }\n\n    pub fn set_render_diff_hunk_controls(\n        &mut self,\n        render_diff_hunk_controls: RenderDiffHunkControlsFn,\n        cx: &mut Context<Self>,\n    ) {\n        self.render_diff_hunk_controls = render_diff_hunk_controls;\n        cx.notify();\n    }\n\n    pub fn stage_and_next(\n        &mut self,\n        _: &::git::StageAndNext,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.do_stage_or_unstage_and_next(true, window, cx);\n    }\n\n    pub fn unstage_and_next(\n        &mut self,\n        _: &::git::UnstageAndNext,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.do_stage_or_unstage_and_next(false, window, cx);\n    }\n\n    pub fn stage_or_unstage_diff_hunks(\n        &mut self,\n        stage: bool,\n        ranges: Vec<Range<Anchor>>,\n        cx: &mut Context<Self>,\n    ) {\n        let task = self.save_buffers_for_ranges_if_needed(&ranges, cx);\n        cx.spawn(async move |this, cx| {\n            task.await?;\n            this.update(cx, |this, cx| {\n                let snapshot = this.buffer.read(cx).snapshot(cx);\n                let chunk_by = this\n                    .diff_hunks_in_ranges(&ranges, &snapshot)\n                    .chunk_by(|hunk| hunk.buffer_id);\n                for (buffer_id, hunks) in &chunk_by {\n                    this.do_stage_or_unstage(stage, buffer_id, hunks, cx);\n                }\n            })\n        })\n        .detach_and_log_err(cx);\n    }\n\n    fn save_buffers_for_ranges_if_needed(\n        &mut self,\n        ranges: &[Range<Anchor>],\n        cx: &mut Context<Editor>,\n    ) -> Task<Result<()>> {\n        let multibuffer = self.buffer.read(cx);\n        let snapshot = multibuffer.read(cx);\n        let buffer_ids: HashSet<_> = ranges\n            .iter()\n            .flat_map(|range| snapshot.buffer_ids_for_range(range.clone()))\n            .collect();\n        drop(snapshot);\n\n        let mut buffers = HashSet::default();\n        for buffer_id in buffer_ids {\n            if let Some(buffer_entity) = multibuffer.buffer(buffer_id) {\n                let buffer = buffer_entity.read(cx);\n                if buffer.file().is_some_and(|file| file.disk_state().exists()) && buffer.is_dirty()\n                {\n                    buffers.insert(buffer_entity);\n                }\n            }\n        }\n\n        if let Some(project) = &self.project {\n            project.update(cx, |project, cx| project.save_buffers(buffers, cx))\n        } else {\n            Task::ready(Ok(()))\n        }\n    }\n\n    fn do_stage_or_unstage_and_next(\n        &mut self,\n        stage: bool,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let ranges = self.selections.disjoint_anchor_ranges().collect::<Vec<_>>();\n\n        if ranges.iter().any(|range| range.start != range.end) {\n            self.stage_or_unstage_diff_hunks(stage, ranges, cx);\n            return;\n        }\n\n        self.stage_or_unstage_diff_hunks(stage, ranges, cx);\n        let snapshot = self.snapshot(window, cx);\n        let position = self\n            .selections\n            .newest::<Point>(&snapshot.display_snapshot)\n            .head();\n        let mut row = snapshot\n            .buffer_snapshot()\n            .diff_hunks_in_range(position..snapshot.buffer_snapshot().max_point())\n            .find(|hunk| hunk.row_range.start.0 > position.row)\n            .map(|hunk| hunk.row_range.start);\n\n        let all_diff_hunks_expanded = self.buffer().read(cx).all_diff_hunks_expanded();\n        // Outside of the project diff editor, wrap around to the beginning.\n        if !all_diff_hunks_expanded {\n            row = row.or_else(|| {\n                snapshot\n                    .buffer_snapshot()\n                    .diff_hunks_in_range(Point::zero()..position)\n                    .find(|hunk| hunk.row_range.end.0 < position.row)\n                    .map(|hunk| hunk.row_range.start)\n            });\n        }\n\n        if let Some(row) = row {\n            let destination = Point::new(row.0, 0);\n            let autoscroll = Autoscroll::center();\n\n            self.unfold_ranges(&[destination..destination], false, false, cx);\n            self.change_selections(SelectionEffects::scroll(autoscroll), window, cx, |s| {\n                s.select_ranges([destination..destination]);\n            });\n        }\n    }\n\n    fn do_stage_or_unstage(\n        &self,\n        stage: bool,\n        buffer_id: BufferId,\n        hunks: impl Iterator<Item = MultiBufferDiffHunk>,\n        cx: &mut App,\n    ) -> Option<()> {\n        let project = self.project()?;\n        let buffer = project.read(cx).buffer_for_id(buffer_id, cx)?;\n        let diff = self.buffer.read(cx).diff_for(buffer_id)?;\n        let buffer_snapshot = buffer.read(cx).snapshot();\n        let file_exists = buffer_snapshot\n            .file()\n            .is_some_and(|file| file.disk_state().exists());\n        diff.update(cx, |diff, cx| {\n            diff.stage_or_unstage_hunks(\n                stage,\n                &hunks\n                    .map(|hunk| buffer_diff::DiffHunk {\n                        buffer_range: hunk.buffer_range,\n                        diff_base_byte_range: hunk.diff_base_byte_range,\n                        secondary_status: hunk.secondary_status,\n                        range: Point::zero()..Point::zero(), // unused\n                    })\n                    .collect::<Vec<_>>(),\n                &buffer_snapshot,\n                file_exists,\n                cx,\n            )\n        });\n        None\n    }\n\n    pub fn expand_selected_diff_hunks(&mut self, cx: &mut Context<Self>) {\n        let ranges: Vec<_> = self\n            .selections\n            .disjoint_anchors()\n            .iter()\n            .map(|s| s.range())\n            .collect();\n        self.buffer\n            .update(cx, |buffer, cx| buffer.expand_diff_hunks(ranges, cx))\n    }\n\n    pub fn clear_expanded_diff_hunks(&mut self, cx: &mut Context<Self>) -> bool {\n        self.buffer.update(cx, |buffer, cx| {\n            let ranges = vec![Anchor::min()..Anchor::max()];\n            if !buffer.all_diff_hunks_expanded()\n                && buffer.has_expanded_diff_hunks_in_ranges(&ranges, cx)\n            {\n                buffer.collapse_diff_hunks(ranges, cx);\n                true\n            } else {\n                false\n            }\n        })\n    }\n\n    fn toggle_diff_hunks_in_ranges(\n        &mut self,\n        ranges: Vec<Range<Anchor>>,\n        cx: &mut Context<Editor>,\n    ) {\n        self.buffer.update(cx, |buffer, cx| {\n            let expand = !buffer.has_expanded_diff_hunks_in_ranges(&ranges, cx);\n            buffer.expand_or_collapse_diff_hunks(ranges, expand, cx);\n        })\n    }\n\n    fn toggle_single_diff_hunk(&mut self, range: Range<Anchor>, cx: &mut Context<Self>) {\n        self.buffer.update(cx, |buffer, cx| {\n            let snapshot = buffer.snapshot(cx);\n            let excerpt_id = range.end.excerpt_id;\n            let point_range = range.to_point(&snapshot);\n            let expand = !buffer.single_hunk_is_expanded(range, cx);\n            buffer.expand_or_collapse_diff_hunks_inner([(point_range, excerpt_id)], expand, cx);\n        })\n    }\n\n    pub(crate) fn apply_all_diff_hunks(\n        &mut self,\n        _: &ApplyAllDiffHunks,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::TypingAction, cx);\n\n        let buffers = self.buffer.read(cx).all_buffers();\n        for branch_buffer in buffers {\n            branch_buffer.update(cx, |branch_buffer, cx| {\n                branch_buffer.merge_into_base(Vec::new(), cx);\n            });\n        }\n\n        if let Some(project) = self.project.clone() {\n            self.save(\n                SaveOptions {\n                    format: true,\n                    autosave: false,\n                },\n                project,\n                window,\n                cx,\n            )\n            .detach_and_log_err(cx);\n        }\n    }\n\n    pub(crate) fn apply_selected_diff_hunks(\n        &mut self,\n        _: &ApplyDiffHunk,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::TypingAction, cx);\n        let snapshot = self.snapshot(window, cx);\n        let hunks = snapshot.hunks_for_ranges(\n            self.selections\n                .all(&snapshot.display_snapshot)\n                .into_iter()\n                .map(|selection| selection.range()),\n        );\n        let mut ranges_by_buffer = HashMap::default();\n        self.transact(window, cx, |editor, _window, cx| {\n            for hunk in hunks {\n                if let Some(buffer) = editor.buffer.read(cx).buffer(hunk.buffer_id) {\n                    ranges_by_buffer\n                        .entry(buffer.clone())\n                        .or_insert_with(Vec::new)\n                        .push(hunk.buffer_range.to_offset(buffer.read(cx)));\n                }\n            }\n\n            for (buffer, ranges) in ranges_by_buffer {\n                buffer.update(cx, |buffer, cx| {\n                    buffer.merge_into_base(ranges, cx);\n                });\n            }\n        });\n\n        if let Some(project) = self.project.clone() {\n            self.save(\n                SaveOptions {\n                    format: true,\n                    autosave: false,\n                },\n                project,\n                window,\n                cx,\n            )\n            .detach_and_log_err(cx);\n        }\n    }\n\n    pub fn set_gutter_hovered(&mut self, hovered: bool, cx: &mut Context<Self>) {\n        if hovered != self.gutter_hovered {\n            self.gutter_hovered = hovered;\n            cx.notify();\n        }\n    }\n\n    pub fn insert_blocks(\n        &mut self,\n        blocks: impl IntoIterator<Item = BlockProperties<Anchor>>,\n        autoscroll: Option<Autoscroll>,\n        cx: &mut Context<Self>,\n    ) -> Vec<CustomBlockId> {\n        let blocks = self\n            .display_map\n            .update(cx, |display_map, cx| display_map.insert_blocks(blocks, cx));\n        if let Some(autoscroll) = autoscroll {\n            self.request_autoscroll(autoscroll, cx);\n        }\n        cx.notify();\n        blocks\n    }\n\n    pub fn resize_blocks(\n        &mut self,\n        heights: HashMap<CustomBlockId, u32>,\n        autoscroll: Option<Autoscroll>,\n        cx: &mut Context<Self>,\n    ) {\n        self.display_map\n            .update(cx, |display_map, cx| display_map.resize_blocks(heights, cx));\n        if let Some(autoscroll) = autoscroll {\n            self.request_autoscroll(autoscroll, cx);\n        }\n        cx.notify();\n    }\n\n    pub fn replace_blocks(\n        &mut self,\n        renderers: HashMap<CustomBlockId, RenderBlock>,\n        autoscroll: Option<Autoscroll>,\n        cx: &mut Context<Self>,\n    ) {\n        self.display_map\n            .update(cx, |display_map, _cx| display_map.replace_blocks(renderers));\n        if let Some(autoscroll) = autoscroll {\n            self.request_autoscroll(autoscroll, cx);\n        }\n        cx.notify();\n    }\n\n    pub fn remove_blocks(\n        &mut self,\n        block_ids: HashSet<CustomBlockId>,\n        autoscroll: Option<Autoscroll>,\n        cx: &mut Context<Self>,\n    ) {\n        self.display_map.update(cx, |display_map, cx| {\n            display_map.remove_blocks(block_ids, cx)\n        });\n        if let Some(autoscroll) = autoscroll {\n            self.request_autoscroll(autoscroll, cx);\n        }\n        cx.notify();\n    }\n\n    pub fn row_for_block(\n        &self,\n        block_id: CustomBlockId,\n        cx: &mut Context<Self>,\n    ) -> Option<DisplayRow> {\n        self.display_map\n            .update(cx, |map, cx| map.row_for_block(block_id, cx))\n    }\n\n    pub(crate) fn set_focused_block(&mut self, focused_block: FocusedBlock) {\n        self.focused_block = Some(focused_block);\n    }\n\n    pub(crate) fn take_focused_block(&mut self) -> Option<FocusedBlock> {\n        self.focused_block.take()\n    }\n\n    pub fn insert_creases(\n        &mut self,\n        creases: impl IntoIterator<Item = Crease<Anchor>>,\n        cx: &mut Context<Self>,\n    ) -> Vec<CreaseId> {\n        self.display_map\n            .update(cx, |map, cx| map.insert_creases(creases, cx))\n    }\n\n    pub fn remove_creases(\n        &mut self,\n        ids: impl IntoIterator<Item = CreaseId>,\n        cx: &mut Context<Self>,\n    ) -> Vec<(CreaseId, Range<Anchor>)> {\n        self.display_map\n            .update(cx, |map, cx| map.remove_creases(ids, cx))\n    }\n\n    pub fn longest_row(&self, cx: &mut App) -> DisplayRow {\n        self.display_map\n            .update(cx, |map, cx| map.snapshot(cx))\n            .longest_row()\n    }\n\n    pub fn max_point(&self, cx: &mut App) -> DisplayPoint {\n        self.display_map\n            .update(cx, |map, cx| map.snapshot(cx))\n            .max_point()\n    }\n\n    pub fn text(&self, cx: &App) -> String {\n        self.buffer.read(cx).read(cx).text()\n    }\n\n    pub fn is_empty(&self, cx: &App) -> bool {\n        self.buffer.read(cx).read(cx).is_empty()\n    }\n\n    pub fn text_option(&self, cx: &App) -> Option<String> {\n        let text = self.text(cx);\n        let text = text.trim();\n\n        if text.is_empty() {\n            return None;\n        }\n\n        Some(text.to_string())\n    }\n\n    pub fn set_text(\n        &mut self,\n        text: impl Into<Arc<str>>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.transact(window, cx, |this, _, cx| {\n            this.buffer\n                .read(cx)\n                .as_singleton()\n                .expect(": "",
        ")\n                .update(cx, |buffer, cx| buffer.set_text(text, cx));\n        });\n    }\n\n    pub fn display_text(&self, cx: &mut App) -> String {\n        self.display_map\n            .update(cx, |map, cx| map.snapshot(cx))\n            .text()\n    }\n\n    fn create_minimap(\n        &self,\n        minimap_settings: MinimapSettings,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<Entity<Self>> {\n        (minimap_settings.minimap_enabled() && self.buffer_kind(cx) == ItemBufferKind::Singleton)\n            .then(|| self.initialize_new_minimap(minimap_settings, window, cx))\n    }\n\n    fn initialize_new_minimap(\n        &self,\n        minimap_settings: MinimapSettings,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Entity<Self> {\n        const MINIMAP_FONT_WEIGHT: gpui::FontWeight = gpui::FontWeight::BLACK;\n\n        let mut minimap = Editor::new_internal(\n            EditorMode::Minimap {\n                parent: cx.weak_entity(),\n            },\n            self.buffer.clone(),\n            None,\n            Some(self.display_map.clone()),\n            window,\n            cx,\n        );\n        minimap.scroll_manager.clone_state(&self.scroll_manager);\n        minimap.set_text_style_refinement(TextStyleRefinement {\n            font_size: Some(MINIMAP_FONT_SIZE),\n            font_weight: Some(MINIMAP_FONT_WEIGHT),\n            ..Default::default()\n        });\n        minimap.update_minimap_configuration(minimap_settings, cx);\n        cx.new(|_| minimap)\n    }\n\n    fn update_minimap_configuration(&mut self, minimap_settings: MinimapSettings, cx: &App) {\n        let current_line_highlight = minimap_settings\n            .current_line_highlight\n            .unwrap_or_else(|| EditorSettings::get_global(cx).current_line_highlight);\n        self.set_current_line_highlight(Some(current_line_highlight));\n    }\n\n    pub fn minimap(&self) -> Option<&Entity<Self>> {\n        self.minimap\n            .as_ref()\n            .filter(|_| self.minimap_visibility.visible())\n    }\n\n    pub fn wrap_guides(&self, cx: &App) -> SmallVec<[(usize, bool); 2]> {\n        let mut wrap_guides = smallvec![];\n\n        if self.show_wrap_guides == Some(false) {\n            return wrap_guides;\n        }\n\n        let settings = self.buffer.read(cx).language_settings(cx);\n        if settings.show_wrap_guides {\n            match self.soft_wrap_mode(cx) {\n                SoftWrap::Column(soft_wrap) => {\n                    wrap_guides.push((soft_wrap as usize, true));\n                }\n                SoftWrap::Bounded(soft_wrap) => {\n                    wrap_guides.push((soft_wrap as usize, true));\n                }\n                SoftWrap::GitDiff | SoftWrap::None | SoftWrap::EditorWidth => {}\n            }\n            wrap_guides.extend(settings.wrap_guides.iter().map(|guide| (*guide, false)))\n        }\n\n        wrap_guides\n    }\n\n    pub fn soft_wrap_mode(&self, cx: &App) -> SoftWrap {\n        let settings = self.buffer.read(cx).language_settings(cx);\n        let mode = self.soft_wrap_mode_override.unwrap_or(settings.soft_wrap);\n        match mode {\n            language_settings::SoftWrap::PreferLine | language_settings::SoftWrap::None => {\n                SoftWrap::None\n            }\n            language_settings::SoftWrap::EditorWidth => SoftWrap::EditorWidth,\n            language_settings::SoftWrap::PreferredLineLength => {\n                SoftWrap::Column(settings.preferred_line_length)\n            }\n            language_settings::SoftWrap::Bounded => {\n                SoftWrap::Bounded(settings.preferred_line_length)\n            }\n        }\n    }\n\n    pub fn set_soft_wrap_mode(\n        &mut self,\n        mode: language_settings::SoftWrap,\n\n        cx: &mut Context<Self>,\n    ) {\n        self.soft_wrap_mode_override = Some(mode);\n        cx.notify();\n    }\n\n    pub fn set_hard_wrap(&mut self, hard_wrap: Option<usize>, cx: &mut Context<Self>) {\n        self.hard_wrap = hard_wrap;\n        cx.notify();\n    }\n\n    pub fn set_text_style_refinement(&mut self, style: TextStyleRefinement) {\n        self.text_style_refinement = Some(style);\n    }\n\n    /// called by the Element so we know what style we were most recently rendered with.\n    pub fn set_style(&mut self, style: EditorStyle, window: &mut Window, cx: &mut Context<Self>) {\n        // We intentionally do not inform the display map about the minimap style\n        // so that wrapping is not recalculated and stays consistent for the editor\n        // and its linked minimap.\n        if !self.mode.is_minimap() {\n            let font = style.text.font();\n            let font_size = style.text.font_size.to_pixels(window.rem_size());\n            let display_map = self\n                .placeholder_display_map\n                .as_ref()\n                .filter(|_| self.is_empty(cx))\n                .unwrap_or(&self.display_map);\n\n            display_map.update(cx, |map, cx| map.set_font(font, font_size, cx));\n        }\n        self.style = Some(style);\n    }\n\n    pub fn style(&self) -> Option<&EditorStyle> {\n        self.style.as_ref()\n    }\n\n    // Called by the element. This method is not designed to be called outside of the editor\n    // element's layout code because it does not notify when rewrapping is computed synchronously.\n    pub(crate) fn set_wrap_width(&self, width: Option<Pixels>, cx: &mut App) -> bool {\n        if self.is_empty(cx) {\n            self.placeholder_display_map\n                .as_ref()\n                .map_or(false, |display_map| {\n                    display_map.update(cx, |map, cx| map.set_wrap_width(width, cx))\n                })\n        } else {\n            self.display_map\n                .update(cx, |map, cx| map.set_wrap_width(width, cx))\n        }\n    }\n\n    pub fn set_soft_wrap(&mut self) {\n        self.soft_wrap_mode_override = Some(language_settings::SoftWrap::EditorWidth)\n    }\n\n    pub fn toggle_soft_wrap(&mut self, _: &ToggleSoftWrap, _: &mut Window, cx: &mut Context<Self>) {\n        if self.soft_wrap_mode_override.is_some() {\n            self.soft_wrap_mode_override.take();\n        } else {\n            let soft_wrap = match self.soft_wrap_mode(cx) {\n                SoftWrap::GitDiff => return,\n                SoftWrap::None => language_settings::SoftWrap::EditorWidth,\n                SoftWrap::EditorWidth | SoftWrap::Column(_) | SoftWrap::Bounded(_) => {\n                    language_settings::SoftWrap::None\n                }\n            };\n            self.soft_wrap_mode_override = Some(soft_wrap);\n        }\n        cx.notify();\n    }\n\n    pub fn toggle_tab_bar(&mut self, _: &ToggleTabBar, _: &mut Window, cx: &mut Context<Self>) {\n        let Some(workspace) = self.workspace() else {\n            return;\n        };\n        let fs = workspace.read(cx).app_state().fs.clone();\n        let current_show = TabBarSettings::get_global(cx).show;\n        update_settings_file(fs, cx, move |setting, _| {\n            setting.tab_bar.get_or_insert_default().show = Some(!current_show);\n        });\n    }\n\n    pub fn toggle_indent_guides(\n        &mut self,\n        _: &ToggleIndentGuides,\n        _: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let currently_enabled = self.should_show_indent_guides().unwrap_or_else(|| {\n            self.buffer\n                .read(cx)\n                .language_settings(cx)\n                .indent_guides\n                .enabled\n        });\n        self.show_indent_guides = Some(!currently_enabled);\n        cx.notify();\n    }\n\n    fn should_show_indent_guides(&self) -> Option<bool> {\n        self.show_indent_guides\n    }\n\n    pub fn toggle_line_numbers(\n        &mut self,\n        _: &ToggleLineNumbers,\n        _: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let mut editor_settings = EditorSettings::get_global(cx).clone();\n        editor_settings.gutter.line_numbers = !editor_settings.gutter.line_numbers;\n        EditorSettings::override_global(editor_settings, cx);\n    }\n\n    pub fn line_numbers_enabled(&self, cx: &App) -> bool {\n        if let Some(show_line_numbers) = self.show_line_numbers {\n            return show_line_numbers;\n        }\n        EditorSettings::get_global(cx).gutter.line_numbers\n    }\n\n    pub fn relative_line_numbers(&self, cx: &mut App) -> RelativeLineNumbers {\n        match (\n            self.use_relative_line_numbers,\n            EditorSettings::get_global(cx).relative_line_numbers,\n        ) {\n            (None, setting) => setting,\n            (Some(false), _) => RelativeLineNumbers::Disabled,\n            (Some(true), RelativeLineNumbers::Wrapped) => RelativeLineNumbers::Wrapped,\n            (Some(true), _) => RelativeLineNumbers::Enabled,\n        }\n    }\n\n    pub fn toggle_relative_line_numbers(\n        &mut self,\n        _: &ToggleRelativeLineNumbers,\n        _: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let is_relative = self.relative_line_numbers(cx);\n        self.set_relative_line_number(Some(!is_relative.enabled()), cx)\n    }\n\n    pub fn set_relative_line_number(&mut self, is_relative: Option<bool>, cx: &mut Context<Self>) {\n        self.use_relative_line_numbers = is_relative;\n        cx.notify();\n    }\n\n    pub fn set_show_gutter(&mut self, show_gutter: bool, cx: &mut Context<Self>) {\n        self.show_gutter = show_gutter;\n        cx.notify();\n    }\n\n    pub fn set_show_scrollbars(&mut self, show: bool, cx: &mut Context<Self>) {\n        self.show_scrollbars = ScrollbarAxes {\n            horizontal: show,\n            vertical: show,\n        };\n        cx.notify();\n    }\n\n    pub fn set_show_vertical_scrollbar(&mut self, show: bool, cx: &mut Context<Self>) {\n        self.show_scrollbars.vertical = show;\n        cx.notify();\n    }\n\n    pub fn set_show_horizontal_scrollbar(&mut self, show: bool, cx: &mut Context<Self>) {\n        self.show_scrollbars.horizontal = show;\n        cx.notify();\n    }\n\n    pub fn set_minimap_visibility(\n        &mut self,\n        minimap_visibility: MinimapVisibility,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if self.minimap_visibility != minimap_visibility {\n            if minimap_visibility.visible() && self.minimap.is_none() {\n                let minimap_settings = EditorSettings::get_global(cx).minimap;\n                self.minimap =\n                    self.create_minimap(minimap_settings.with_show_override(), window, cx);\n            }\n            self.minimap_visibility = minimap_visibility;\n            cx.notify();\n        }\n    }\n\n    pub fn disable_scrollbars_and_minimap(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n        self.set_show_scrollbars(false, cx);\n        self.set_minimap_visibility(MinimapVisibility::Disabled, window, cx);\n    }\n\n    pub fn hide_minimap_by_default(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n        self.set_minimap_visibility(self.minimap_visibility.hidden(), window, cx);\n    }\n\n    /// Normally the text in full mode and auto height editors is padded on the\n    /// left side by roughly half a character width for improved hit testing.\n    ///\n    /// Use this method to disable this for cases where this is not wanted (e.g.\n    /// if you want to align the editor text with some other text above or below)\n    /// or if you want to add this padding to single-line editors.\n    pub fn set_offset_content(&mut self, offset_content: bool, cx: &mut Context<Self>) {\n        self.offset_content = offset_content;\n        cx.notify();\n    }\n\n    pub fn set_show_line_numbers(&mut self, show_line_numbers: bool, cx: &mut Context<Self>) {\n        self.show_line_numbers = Some(show_line_numbers);\n        cx.notify();\n    }\n\n    pub fn disable_expand_excerpt_buttons(&mut self, cx: &mut Context<Self>) {\n        self.disable_expand_excerpt_buttons = true;\n        cx.notify();\n    }\n\n    pub fn set_show_git_diff_gutter(&mut self, show_git_diff_gutter: bool, cx: &mut Context<Self>) {\n        self.show_git_diff_gutter = Some(show_git_diff_gutter);\n        cx.notify();\n    }\n\n    pub fn set_show_code_actions(&mut self, show_code_actions: bool, cx: &mut Context<Self>) {\n        self.show_code_actions = Some(show_code_actions);\n        cx.notify();\n    }\n\n    pub fn set_show_runnables(&mut self, show_runnables: bool, cx: &mut Context<Self>) {\n        self.show_runnables = Some(show_runnables);\n        cx.notify();\n    }\n\n    pub fn set_show_breakpoints(&mut self, show_breakpoints: bool, cx: &mut Context<Self>) {\n        self.show_breakpoints = Some(show_breakpoints);\n        cx.notify();\n    }\n\n    pub fn set_masked(&mut self, masked: bool, cx: &mut Context<Self>) {\n        if self.display_map.read(cx).masked != masked {\n            self.display_map.update(cx, |map, _| map.masked = masked);\n        }\n        cx.notify()\n    }\n\n    pub fn set_show_wrap_guides(&mut self, show_wrap_guides: bool, cx: &mut Context<Self>) {\n        self.show_wrap_guides = Some(show_wrap_guides);\n        cx.notify();\n    }\n\n    pub fn set_show_indent_guides(&mut self, show_indent_guides: bool, cx: &mut Context<Self>) {\n        self.show_indent_guides = Some(show_indent_guides);\n        cx.notify();\n    }\n\n    pub fn working_directory(&self, cx: &App) -> Option<PathBuf> {\n        if let Some(buffer) = self.buffer().read(cx).as_singleton() {\n            if let Some(file) = buffer.read(cx).file().and_then(|f| f.as_local())\n                && let Some(dir) = file.abs_path(cx).parent()\n            {\n                return Some(dir.to_owned());\n            }\n        }\n\n        None\n    }\n\n    fn target_file<'a>(&self, cx: &'a App) -> Option<&'a dyn language::LocalFile> {\n        self.active_excerpt(cx)?\n            .1\n            .read(cx)\n            .file()\n            .and_then(|f| f.as_local())\n    }\n\n    pub fn target_file_abs_path(&self, cx: &mut Context<Self>) -> Option<PathBuf> {\n        self.active_excerpt(cx).and_then(|(_, buffer, _)| {\n            let buffer = buffer.read(cx);\n            if let Some(project_path) = buffer.project_path(cx) {\n                let project = self.project()?.read(cx);\n                project.absolute_path(&project_path, cx)\n            } else {\n                buffer\n                    .file()\n                    .and_then(|file| file.as_local().map(|file| file.abs_path(cx)))\n            }\n        })\n    }\n\n    pub fn reveal_in_finder(\n        &mut self,\n        _: &RevealInFileManager,\n        _window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(target) = self.target_file(cx) {\n            cx.reveal_path(&target.abs_path(cx));\n        }\n    }\n\n    pub fn copy_path(\n        &mut self,\n        _: &zed_actions::workspace::CopyPath,\n        _window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(path) = self.target_file_abs_path(cx)\n            && let Some(path) = path.to_str()\n        {\n            cx.write_to_clipboard(ClipboardItem::new_string(path.to_string()));\n        } else {\n            cx.propagate();\n        }\n    }\n\n    pub fn copy_relative_path(\n        &mut self,\n        _: &zed_actions::workspace::CopyRelativePath,\n        _window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(path) = self.active_excerpt(cx).and_then(|(_, buffer, _)| {\n            let project = self.project()?.read(cx);\n            let path = buffer.read(cx).file()?.path();\n            let path = path.display(project.path_style(cx));\n            Some(path)\n        }) {\n            cx.write_to_clipboard(ClipboardItem::new_string(path.to_string()));\n        } else {\n            cx.propagate();\n        }\n    }\n\n    /// Returns the project path for the editor's buffer, if any buffer is\n    /// opened in the editor.\n    pub fn project_path(&self, cx: &App) -> Option<ProjectPath> {\n        if let Some(buffer) = self.buffer.read(cx).as_singleton() {\n            buffer.read(cx).project_path(cx)\n        } else {\n            None\n        }\n    }\n\n    // Returns true if the editor handled a go-to-line request\n    pub fn go_to_active_debug_line(&mut self, window: &mut Window, cx: &mut Context<Self>) -> bool {\n        maybe!({\n            let breakpoint_store = self.breakpoint_store.as_ref()?;\n\n            let Some(active_stack_frame) = breakpoint_store.read(cx).active_position().cloned()\n            else {\n                self.clear_row_highlights::<ActiveDebugLine>();\n                return None;\n            };\n\n            let position = active_stack_frame.position;\n            let buffer_id = position.buffer_id?;\n            let snapshot = self\n                .project\n                .as_ref()?\n                .read(cx)\n                .buffer_for_id(buffer_id, cx)?\n                .read(cx)\n                .snapshot();\n\n            let mut handled = false;\n            for (id, ExcerptRange { context, .. }) in\n                self.buffer.read(cx).excerpts_for_buffer(buffer_id, cx)\n            {\n                if context.start.cmp(&position, &snapshot).is_ge()\n                    || context.end.cmp(&position, &snapshot).is_lt()\n                {\n                    continue;\n                }\n                let snapshot = self.buffer.read(cx).snapshot(cx);\n                let multibuffer_anchor = snapshot.anchor_in_excerpt(id, position)?;\n\n                handled = true;\n                self.clear_row_highlights::<ActiveDebugLine>();\n\n                self.go_to_line::<ActiveDebugLine>(\n                    multibuffer_anchor,\n                    Some(cx.theme().colors().editor_debugger_active_line_background),\n                    window,\n                    cx,\n                );\n\n                cx.notify();\n            }\n\n            handled.then_some(())\n        })\n        .is_some()\n    }\n\n    pub fn copy_file_name_without_extension(\n        &mut self,\n        _: &CopyFileNameWithoutExtension,\n        _: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(file) = self.target_file(cx)\n            && let Some(file_stem) = file.path().file_stem()\n        {\n            cx.write_to_clipboard(ClipboardItem::new_string(file_stem.to_string()));\n        }\n    }\n\n    pub fn copy_file_name(&mut self, _: &CopyFileName, _: &mut Window, cx: &mut Context<Self>) {\n        if let Some(file) = self.target_file(cx)\n            && let Some(name) = file.path().file_name()\n        {\n            cx.write_to_clipboard(ClipboardItem::new_string(name.to_string()));\n        }\n    }\n\n    pub fn toggle_git_blame(\n        &mut self,\n        _: &::git::Blame,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.show_git_blame_gutter = !self.show_git_blame_gutter;\n\n        if self.show_git_blame_gutter && !self.has_blame_entries(cx) {\n            self.start_git_blame(true, window, cx);\n        }\n\n        cx.notify();\n    }\n\n    pub fn toggle_git_blame_inline(\n        &mut self,\n        _: &ToggleGitBlameInline,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.toggle_git_blame_inline_internal(true, window, cx);\n        cx.notify();\n    }\n\n    pub fn open_git_blame_commit(\n        &mut self,\n        _: &OpenGitBlameCommit,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.open_git_blame_commit_internal(window, cx);\n    }\n\n    fn open_git_blame_commit_internal(\n        &mut self,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<()> {\n        let blame = self.blame.as_ref()?;\n        let snapshot = self.snapshot(window, cx);\n        let cursor = self\n            .selections\n            .newest::<Point>(&snapshot.display_snapshot)\n            .head();\n        let (buffer, point, _) = snapshot.buffer_snapshot().point_to_buffer_point(cursor)?;\n        let (_, blame_entry) = blame\n            .update(cx, |blame, cx| {\n                blame\n                    .blame_for_rows(\n                        &[RowInfo {\n                            buffer_id: Some(buffer.remote_id()),\n                            buffer_row: Some(point.row),\n                            ..Default::default()\n                        }],\n                        cx,\n                    )\n                    .next()\n            })\n            .flatten()?;\n        let renderer = cx.global::<GlobalBlameRenderer>().0.clone();\n        let repo = blame.read(cx).repository(cx, buffer.remote_id())?;\n        let workspace = self.workspace()?.downgrade();\n        renderer.open_blame_commit(blame_entry, repo, workspace, window, cx);\n        None\n    }\n\n    pub fn git_blame_inline_enabled(&self) -> bool {\n        self.git_blame_inline_enabled\n    }\n\n    pub fn toggle_selection_menu(\n        &mut self,\n        _: &ToggleSelectionMenu,\n        _: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.show_selection_menu = self\n            .show_selection_menu\n            .map(|show_selections_menu| !show_selections_menu)\n            .or_else(|| Some(!EditorSettings::get_global(cx).toolbar.selections_menu));\n\n        cx.notify();\n    }\n\n    pub fn selection_menu_enabled(&self, cx: &App) -> bool {\n        self.show_selection_menu\n            .unwrap_or_else(|| EditorSettings::get_global(cx).toolbar.selections_menu)\n    }\n\n    fn start_git_blame(\n        &mut self,\n        user_triggered: bool,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(project) = self.project() {\n            if let Some(buffer) = self.buffer().read(cx).as_singleton()\n                && buffer.read(cx).file().is_none()\n            {\n                return;\n            }\n\n            let focused = self.focus_handle(cx).contains_focused(window, cx);\n\n            let project = project.clone();\n            let blame = cx\n                .new(|cx| GitBlame::new(self.buffer.clone(), project, user_triggered, focused, cx));\n            self.blame_subscription =\n                Some(cx.observe_in(&blame, window, |_, _, _, cx| cx.notify()));\n            self.blame = Some(blame);\n        }\n    }\n\n    fn toggle_git_blame_inline_internal(\n        &mut self,\n        user_triggered: bool,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if self.git_blame_inline_enabled {\n            self.git_blame_inline_enabled = false;\n            self.show_git_blame_inline = false;\n            self.show_git_blame_inline_delay_task.take();\n        } else {\n            self.git_blame_inline_enabled = true;\n            self.start_git_blame_inline(user_triggered, window, cx);\n        }\n\n        cx.notify();\n    }\n\n    fn start_git_blame_inline(\n        &mut self,\n        user_triggered: bool,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.start_git_blame(user_triggered, window, cx);\n\n        if ProjectSettings::get_global(cx)\n            .git\n            .inline_blame_delay()\n            .is_some()\n        {\n            self.start_inline_blame_timer(window, cx);\n        } else {\n            self.show_git_blame_inline = true\n        }\n    }\n\n    pub fn blame(&self) -> Option<&Entity<GitBlame>> {\n        self.blame.as_ref()\n    }\n\n    pub fn show_git_blame_gutter(&self) -> bool {\n        self.show_git_blame_gutter\n    }\n\n    pub fn render_git_blame_gutter(&self, cx: &App) -> bool {\n        !self.mode().is_minimap() && self.show_git_blame_gutter && self.has_blame_entries(cx)\n    }\n\n    pub fn render_git_blame_inline(&self, window: &Window, cx: &App) -> bool {\n        self.show_git_blame_inline\n            && (self.focus_handle.is_focused(window) || self.inline_blame_popover.is_some())\n            && !self.newest_selection_head_on_empty_line(cx)\n            && self.has_blame_entries(cx)\n    }\n\n    fn has_blame_entries(&self, cx: &App) -> bool {\n        self.blame()\n            .is_some_and(|blame| blame.read(cx).has_generated_entries())\n    }\n\n    fn newest_selection_head_on_empty_line(&self, cx: &App) -> bool {\n        let cursor_anchor = self.selections.newest_anchor().head();\n\n        let snapshot = self.buffer.read(cx).snapshot(cx);\n        let buffer_row = MultiBufferRow(cursor_anchor.to_point(&snapshot).row);\n\n        snapshot.line_len(buffer_row) == 0\n    }\n\n    fn get_permalink_to_line(&self, cx: &mut Context<Self>) -> Task<Result<url::Url>> {\n        let buffer_and_selection = maybe!({\n            let selection = self.selections.newest::<Point>(&self.display_snapshot(cx));\n            let selection_range = selection.range();\n\n            let multi_buffer = self.buffer().read(cx);\n            let multi_buffer_snapshot = multi_buffer.snapshot(cx);\n            let buffer_ranges = multi_buffer_snapshot.range_to_buffer_ranges(selection_range);\n\n            let (buffer, range, _) = if selection.reversed {\n                buffer_ranges.first()\n            } else {\n                buffer_ranges.last()\n            }?;\n\n            let selection = text::ToPoint::to_point(&range.start, buffer).row\n                ..text::ToPoint::to_point(&range.end, buffer).row;\n            Some((multi_buffer.buffer(buffer.remote_id()).unwrap(), selection))\n        });\n\n        let Some((buffer, selection)) = buffer_and_selection else {\n            return Task::ready(Err(anyhow!(": "",
        ")));\n        };\n\n        let Some(project) = self.project() else {\n            return Task::ready(Err(anyhow!(": "",
        ")));\n        };\n\n        project.update(cx, |project, cx| {\n            project.get_permalink_to_line(&buffer, selection, cx)\n        })\n    }\n\n    pub fn copy_permalink_to_line(\n        &mut self,\n        _: &CopyPermalinkToLine,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let permalink_task = self.get_permalink_to_line(cx);\n        let workspace = self.workspace();\n\n        cx.spawn_in(window, async move |_, cx| match permalink_task.await {\n            Ok(permalink) => {\n                cx.update(|_, cx| {\n                    cx.write_to_clipboard(ClipboardItem::new_string(permalink.to_string()));\n                })\n                .ok();\n            }\n            Err(err) => {\n                let message = format!(": "",
        ");\n\n                anyhow::Result::<()>::Err(err).log_err();\n\n                if let Some(workspace) = workspace {\n                    workspace\n                        .update_in(cx, |workspace, _, cx| {\n                            struct CopyPermalinkToLine;\n\n                            workspace.show_toast(\n                                Toast::new(\n                                    NotificationId::unique::<CopyPermalinkToLine>(),\n                                    message,\n                                ),\n                                cx,\n                            )\n                        })\n                        .ok();\n                }\n            }\n        })\n        .detach();\n    }\n\n    pub fn copy_file_location(\n        &mut self,\n        _: &CopyFileLocation,\n        _: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let selection = self\n            .selections\n            .newest::<Point>(&self.display_snapshot(cx))\n            .start\n            .row\n            + 1;\n        if let Some(file) = self.target_file(cx) {\n            let path = file.path().display(file.path_style(cx));\n            cx.write_to_clipboard(ClipboardItem::new_string(format!(": "",
        ")));\n        }\n    }\n\n    pub fn open_permalink_to_line(\n        &mut self,\n        _: &OpenPermalinkToLine,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let permalink_task = self.get_permalink_to_line(cx);\n        let workspace = self.workspace();\n\n        cx.spawn_in(window, async move |_, cx| match permalink_task.await {\n            Ok(permalink) => {\n                cx.update(|_, cx| {\n                    cx.open_url(permalink.as_ref());\n                })\n                .ok();\n            }\n            Err(err) => {\n                let message = format!(": "",
        ");\n\n                anyhow::Result::<()>::Err(err).log_err();\n\n                if let Some(workspace) = workspace {\n                    workspace\n                        .update(cx, |workspace, cx| {\n                            struct OpenPermalinkToLine;\n\n                            workspace.show_toast(\n                                Toast::new(\n                                    NotificationId::unique::<OpenPermalinkToLine>(),\n                                    message,\n                                ),\n                                cx,\n                            )\n                        })\n                        .ok();\n                }\n            }\n        })\n        .detach();\n    }\n\n    pub fn insert_uuid_v4(\n        &mut self,\n        _: &InsertUuidV4,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.insert_uuid(UuidVersion::V4, window, cx);\n    }\n\n    pub fn insert_uuid_v7(\n        &mut self,\n        _: &InsertUuidV7,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.insert_uuid(UuidVersion::V7, window, cx);\n    }\n\n    fn insert_uuid(&mut self, version: UuidVersion, window: &mut Window, cx: &mut Context<Self>) {\n        self.hide_mouse_cursor(HideMouseCursorOrigin::TypingAction, cx);\n        self.transact(window, cx, |this, window, cx| {\n            let edits = this\n                .selections\n                .all::<Point>(&this.display_snapshot(cx))\n                .into_iter()\n                .map(|selection| {\n                    let uuid = match version {\n                        UuidVersion::V4 => uuid::Uuid::new_v4(),\n                        UuidVersion::V7 => uuid::Uuid::now_v7(),\n                    };\n\n                    (selection.range(), uuid.to_string())\n                });\n            this.edit(edits, cx);\n            this.refresh_edit_prediction(true, false, window, cx);\n        });\n    }\n\n    pub fn open_selections_in_multibuffer(\n        &mut self,\n        _: &OpenSelectionsInMultibuffer,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let multibuffer = self.buffer.read(cx);\n\n        let Some(buffer) = multibuffer.as_singleton() else {\n            return;\n        };\n\n        let Some(workspace) = self.workspace() else {\n            return;\n        };\n\n        let title = multibuffer.title(cx).to_string();\n\n        let locations = self\n            .selections\n            .all_anchors(&self.display_snapshot(cx))\n            .iter()\n            .map(|selection| {\n                (\n                    buffer.clone(),\n                    (selection.start.text_anchor..selection.end.text_anchor)\n                        .to_point(buffer.read(cx)),\n                )\n            })\n            .into_group_map();\n\n        cx.spawn_in(window, async move |_, cx| {\n            workspace.update_in(cx, |workspace, window, cx| {\n                Self::open_locations_in_multibuffer(\n                    workspace,\n                    locations,\n                    format!(": "",
        "),\n                    false,\n                    MultibufferSelectionMode::All,\n                    window,\n                    cx,\n                );\n            })\n        })\n        .detach();\n    }\n\n    /// Adds a row highlight for the given range. If a row has multiple highlights, the\n    /// last highlight added will be used.\n    ///\n    /// If the range ends at the beginning of a line, then that line will not be highlighted.\n    pub fn highlight_rows<T: 'static>(\n        &mut self,\n        range: Range<Anchor>,\n        color: Hsla,\n        options: RowHighlightOptions,\n        cx: &mut Context<Self>,\n    ) {\n        let snapshot = self.buffer().read(cx).snapshot(cx);\n        let row_highlights = self.highlighted_rows.entry(TypeId::of::<T>()).or_default();\n        let ix = row_highlights.binary_search_by(|highlight| {\n            Ordering::Equal\n                .then_with(|| highlight.range.start.cmp(&range.start, &snapshot))\n                .then_with(|| highlight.range.end.cmp(&range.end, &snapshot))\n        });\n\n        if let Err(mut ix) = ix {\n            let index = post_inc(&mut self.highlight_order);\n\n            // If this range intersects with the preceding highlight, then merge it with\n            // the preceding highlight. Otherwise insert a new highlight.\n            let mut merged = false;\n            if ix > 0 {\n                let prev_highlight = &mut row_highlights[ix - 1];\n                if prev_highlight\n                    .range\n                    .end\n                    .cmp(&range.start, &snapshot)\n                    .is_ge()\n                {\n                    ix -= 1;\n                    if prev_highlight.range.end.cmp(&range.end, &snapshot).is_lt() {\n                        prev_highlight.range.end = range.end;\n                    }\n                    merged = true;\n                    prev_highlight.index = index;\n                    prev_highlight.color = color;\n                    prev_highlight.options = options;\n                }\n            }\n\n            if !merged {\n                row_highlights.insert(\n                    ix,\n                    RowHighlight {\n                        range,\n                        index,\n                        color,\n                        options,\n                        type_id: TypeId::of::<T>(),\n                    },\n                );\n            }\n\n            // If any of the following highlights intersect with this one, merge them.\n            while let Some(next_highlight) = row_highlights.get(ix + 1) {\n                let highlight = &row_highlights[ix];\n                if next_highlight\n                    .range\n                    .start\n                    .cmp(&highlight.range.end, &snapshot)\n                    .is_le()\n                {\n                    if next_highlight\n                        .range\n                        .end\n                        .cmp(&highlight.range.end, &snapshot)\n                        .is_gt()\n                    {\n                        row_highlights[ix].range.end = next_highlight.range.end;\n                    }\n                    row_highlights.remove(ix + 1);\n                } else {\n                    break;\n                }\n            }\n        }\n    }\n\n    /// Remove any highlighted row ranges of the given type that intersect the\n    /// given ranges.\n    pub fn remove_highlighted_rows<T: 'static>(\n        &mut self,\n        ranges_to_remove: Vec<Range<Anchor>>,\n        cx: &mut Context<Self>,\n    ) {\n        let snapshot = self.buffer().read(cx).snapshot(cx);\n        let row_highlights = self.highlighted_rows.entry(TypeId::of::<T>()).or_default();\n        let mut ranges_to_remove = ranges_to_remove.iter().peekable();\n        row_highlights.retain(|highlight| {\n            while let Some(range_to_remove) = ranges_to_remove.peek() {\n                match range_to_remove.end.cmp(&highlight.range.start, &snapshot) {\n                    Ordering::Less | Ordering::Equal => {\n                        ranges_to_remove.next();\n                    }\n                    Ordering::Greater => {\n                        match range_to_remove.start.cmp(&highlight.range.end, &snapshot) {\n                            Ordering::Less | Ordering::Equal => {\n                                return false;\n                            }\n                            Ordering::Greater => break,\n                        }\n                    }\n                }\n            }\n\n            true\n        })\n    }\n\n    /// Clear all anchor ranges for a certain highlight context type, so no corresponding rows will be highlighted.\n    pub fn clear_row_highlights<T: 'static>(&mut self) {\n        self.highlighted_rows.remove(&TypeId::of::<T>());\n    }\n\n    /// For a highlight given context type, gets all anchor ranges that will be used for row highlighting.\n    pub fn highlighted_rows<T: 'static>(&self) -> impl '_ + Iterator<Item = (Range<Anchor>, Hsla)> {\n        self.highlighted_rows\n            .get(&TypeId::of::<T>())\n            .map_or(&[] as &[_], |vec| vec.as_slice())\n            .iter()\n            .map(|highlight| (highlight.range.clone(), highlight.color))\n    }\n\n    /// Merges all anchor ranges for all context types ever set, picking the last highlight added in case of a row conflict.\n    /// Returns a map of display rows that are highlighted and their corresponding highlight color.\n    /// Allows to ignore certain kinds of highlights.\n    pub fn highlighted_display_rows(\n        &self,\n        window: &mut Window,\n        cx: &mut App,\n    ) -> BTreeMap<DisplayRow, LineHighlight> {\n        let snapshot = self.snapshot(window, cx);\n        let mut used_highlight_orders = HashMap::default();\n        self.highlighted_rows\n            .iter()\n            .flat_map(|(_, highlighted_rows)| highlighted_rows.iter())\n            .fold(\n                BTreeMap::<DisplayRow, LineHighlight>::new(),\n                |mut unique_rows, highlight| {\n                    let start = highlight.range.start.to_display_point(&snapshot);\n                    let end = highlight.range.end.to_display_point(&snapshot);\n                    let start_row = start.row().0;\n                    let end_row = if highlight.range.end.text_anchor != text::Anchor::MAX\n                        && end.column() == 0\n                    {\n                        end.row().0.saturating_sub(1)\n                    } else {\n                        end.row().0\n                    };\n                    for row in start_row..=end_row {\n                        let used_index =\n                            used_highlight_orders.entry(row).or_insert(highlight.index);\n                        if highlight.index >= *used_index {\n                            *used_index = highlight.index;\n                            unique_rows.insert(\n                                DisplayRow(row),\n                                LineHighlight {\n                                    include_gutter: highlight.options.include_gutter,\n                                    border: None,\n                                    background: highlight.color.into(),\n                                    type_id: Some(highlight.type_id),\n                                },\n                            );\n                        }\n                    }\n                    unique_rows\n                },\n            )\n    }\n\n    pub fn highlighted_display_row_for_autoscroll(\n        &self,\n        snapshot: &DisplaySnapshot,\n    ) -> Option<DisplayRow> {\n        self.highlighted_rows\n            .values()\n            .flat_map(|highlighted_rows| highlighted_rows.iter())\n            .filter_map(|highlight| {\n                if highlight.options.autoscroll {\n                    Some(highlight.range.start.to_display_point(snapshot).row())\n                } else {\n                    None\n                }\n            })\n            .min()\n    }\n\n    pub fn set_search_within_ranges(&mut self, ranges: &[Range<Anchor>], cx: &mut Context<Self>) {\n        self.highlight_background::<SearchWithinRange>(\n            ranges,\n            |colors| colors.colors().editor_document_highlight_read_background,\n            cx,\n        )\n    }\n\n    pub fn set_breadcrumb_header(&mut self, new_header: String) {\n        self.breadcrumb_header = Some(new_header);\n    }\n\n    pub fn clear_search_within_ranges(&mut self, cx: &mut Context<Self>) {\n        self.clear_background_highlights::<SearchWithinRange>(cx);\n    }\n\n    pub fn highlight_background<T: 'static>(\n        &mut self,\n        ranges: &[Range<Anchor>],\n        color_fetcher: fn(&Theme) -> Hsla,\n        cx: &mut Context<Self>,\n    ) {\n        self.background_highlights.insert(\n            HighlightKey::Type(TypeId::of::<T>()),\n            (color_fetcher, Arc::from(ranges)),\n        );\n        self.scrollbar_marker_state.dirty = true;\n        cx.notify();\n    }\n\n    pub fn highlight_background_key<T: 'static>(\n        &mut self,\n        key: usize,\n        ranges: &[Range<Anchor>],\n        color_fetcher: fn(&Theme) -> Hsla,\n        cx: &mut Context<Self>,\n    ) {\n        self.background_highlights.insert(\n            HighlightKey::TypePlus(TypeId::of::<T>(), key),\n            (color_fetcher, Arc::from(ranges)),\n        );\n        self.scrollbar_marker_state.dirty = true;\n        cx.notify();\n    }\n\n    pub fn clear_background_highlights<T: 'static>(\n        &mut self,\n        cx: &mut Context<Self>,\n    ) -> Option<BackgroundHighlight> {\n        let text_highlights = self\n            .background_highlights\n            .remove(&HighlightKey::Type(TypeId::of::<T>()))?;\n        if !text_highlights.1.is_empty() {\n            self.scrollbar_marker_state.dirty = true;\n            cx.notify();\n        }\n        Some(text_highlights)\n    }\n\n    pub fn highlight_gutter<T: 'static>(\n        &mut self,\n        ranges: impl Into<Vec<Range<Anchor>>>,\n        color_fetcher: fn(&App) -> Hsla,\n        cx: &mut Context<Self>,\n    ) {\n        self.gutter_highlights\n            .insert(TypeId::of::<T>(), (color_fetcher, ranges.into()));\n        cx.notify();\n    }\n\n    pub fn clear_gutter_highlights<T: 'static>(\n        &mut self,\n        cx: &mut Context<Self>,\n    ) -> Option<GutterHighlight> {\n        cx.notify();\n        self.gutter_highlights.remove(&TypeId::of::<T>())\n    }\n\n    pub fn insert_gutter_highlight<T: 'static>(\n        &mut self,\n        range: Range<Anchor>,\n        color_fetcher: fn(&App) -> Hsla,\n        cx: &mut Context<Self>,\n    ) {\n        let snapshot = self.buffer().read(cx).snapshot(cx);\n        let mut highlights = self\n            .gutter_highlights\n            .remove(&TypeId::of::<T>())\n            .map(|(_, highlights)| highlights)\n            .unwrap_or_default();\n        let ix = highlights.binary_search_by(|highlight| {\n            Ordering::Equal\n                .then_with(|| highlight.start.cmp(&range.start, &snapshot))\n                .then_with(|| highlight.end.cmp(&range.end, &snapshot))\n        });\n        if let Err(ix) = ix {\n            highlights.insert(ix, range);\n        }\n        self.gutter_highlights\n            .insert(TypeId::of::<T>(), (color_fetcher, highlights));\n    }\n\n    pub fn remove_gutter_highlights<T: 'static>(\n        &mut self,\n        ranges_to_remove: Vec<Range<Anchor>>,\n        cx: &mut Context<Self>,\n    ) {\n        let snapshot = self.buffer().read(cx).snapshot(cx);\n        let Some((color_fetcher, mut gutter_highlights)) =\n            self.gutter_highlights.remove(&TypeId::of::<T>())\n        else {\n            return;\n        };\n        let mut ranges_to_remove = ranges_to_remove.iter().peekable();\n        gutter_highlights.retain(|highlight| {\n            while let Some(range_to_remove) = ranges_to_remove.peek() {\n                match range_to_remove.end.cmp(&highlight.start, &snapshot) {\n                    Ordering::Less | Ordering::Equal => {\n                        ranges_to_remove.next();\n                    }\n                    Ordering::Greater => {\n                        match range_to_remove.start.cmp(&highlight.end, &snapshot) {\n                            Ordering::Less | Ordering::Equal => {\n                                return false;\n                            }\n                            Ordering::Greater => break,\n                        }\n                    }\n                }\n            }\n\n            true\n        });\n        self.gutter_highlights\n            .insert(TypeId::of::<T>(), (color_fetcher, gutter_highlights));\n    }\n\n    #[cfg(feature = ": "",
        ")]\n    pub fn all_text_highlights(\n        &self,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Vec<(HighlightStyle, Vec<Range<DisplayPoint>>)> {\n        let snapshot = self.snapshot(window, cx);\n        self.display_map.update(cx, |display_map, _| {\n            display_map\n                .all_text_highlights()\n                .map(|highlight| {\n                    let (style, ranges) = highlight.as_ref();\n                    (\n                        *style,\n                        ranges\n                            .iter()\n                            .map(|range| range.clone().to_display_points(&snapshot))\n                            .collect(),\n                    )\n                })\n                .collect()\n        })\n    }\n\n    #[cfg(feature = ": "",
        ")]\n    pub fn all_text_background_highlights(\n        &self,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Vec<(Range<DisplayPoint>, Hsla)> {\n        let snapshot = self.snapshot(window, cx);\n        let buffer = &snapshot.buffer_snapshot();\n        let start = buffer.anchor_before(0);\n        let end = buffer.anchor_after(buffer.len());\n        self.sorted_background_highlights_in_range(start..end, &snapshot, cx.theme())\n    }\n\n    #[cfg(any(test, feature = ": "",
        "))]\n    pub fn sorted_background_highlights_in_range(\n        &self,\n        search_range: Range<Anchor>,\n        display_snapshot: &DisplaySnapshot,\n        theme: &Theme,\n    ) -> Vec<(Range<DisplayPoint>, Hsla)> {\n        let mut res = self.background_highlights_in_range(search_range, display_snapshot, theme);\n        res.sort_by(|a, b| {\n            a.0.start\n                .cmp(&b.0.start)\n                .then_with(|| a.0.end.cmp(&b.0.end))\n                .then_with(|| a.1.cmp(&b.1))\n        });\n        res\n    }\n\n    #[cfg(feature = ": "",
        ")]\n    pub fn search_background_highlights(&mut self, cx: &mut Context<Self>) -> Vec<Range<Point>> {\n        let snapshot = self.buffer().read(cx).snapshot(cx);\n\n        let highlights = self\n            .background_highlights\n            .get(&HighlightKey::Type(TypeId::of::<\n                items::BufferSearchHighlights,\n            >()));\n\n        if let Some((_color, ranges)) = highlights {\n            ranges\n                .iter()\n                .map(|range| range.start.to_point(&snapshot)..range.end.to_point(&snapshot))\n                .collect_vec()\n        } else {\n            vec![]\n        }\n    }\n\n    fn document_highlights_for_position<'a>(\n        &'a self,\n        position: Anchor,\n        buffer: &'a MultiBufferSnapshot,\n    ) -> impl 'a + Iterator<Item = &'a Range<Anchor>> {\n        let read_highlights = self\n            .background_highlights\n            .get(&HighlightKey::Type(TypeId::of::<DocumentHighlightRead>()))\n            .map(|h| &h.1);\n        let write_highlights = self\n            .background_highlights\n            .get(&HighlightKey::Type(TypeId::of::<DocumentHighlightWrite>()))\n            .map(|h| &h.1);\n        let left_position = position.bias_left(buffer);\n        let right_position = position.bias_right(buffer);\n        read_highlights\n            .into_iter()\n            .chain(write_highlights)\n            .flat_map(move |ranges| {\n                let start_ix = match ranges.binary_search_by(|probe| {\n                    let cmp = probe.end.cmp(&left_position, buffer);\n                    if cmp.is_ge() {\n                        Ordering::Greater\n                    } else {\n                        Ordering::Less\n                    }\n                }) {\n                    Ok(i) | Err(i) => i,\n                };\n\n                ranges[start_ix..]\n                    .iter()\n                    .take_while(move |range| range.start.cmp(&right_position, buffer).is_le())\n            })\n    }\n\n    pub fn has_background_highlights<T: 'static>(&self) -> bool {\n        self.background_highlights\n            .get(&HighlightKey::Type(TypeId::of::<T>()))\n            .is_some_and(|(_, highlights)| !highlights.is_empty())\n    }\n\n    /// Returns all background highlights for a given range.\n    ///\n    /// The order of highlights is not deterministic, do sort the ranges if needed for the logic.\n    pub fn background_highlights_in_range(\n        &self,\n        search_range: Range<Anchor>,\n        display_snapshot: &DisplaySnapshot,\n        theme: &Theme,\n    ) -> Vec<(Range<DisplayPoint>, Hsla)> {\n        let mut results = Vec::new();\n        for (color_fetcher, ranges) in self.background_highlights.values() {\n            let color = color_fetcher(theme);\n            let start_ix = match ranges.binary_search_by(|probe| {\n                let cmp = probe\n                    .end\n                    .cmp(&search_range.start, &display_snapshot.buffer_snapshot());\n                if cmp.is_gt() {\n                    Ordering::Greater\n                } else {\n                    Ordering::Less\n                }\n            }) {\n                Ok(i) | Err(i) => i,\n            };\n            for range in &ranges[start_ix..] {\n                if range\n                    .start\n                    .cmp(&search_range.end, &display_snapshot.buffer_snapshot())\n                    .is_ge()\n                {\n                    break;\n                }\n\n                let start = range.start.to_display_point(display_snapshot);\n                let end = range.end.to_display_point(display_snapshot);\n                results.push((start..end, color))\n            }\n        }\n        results\n    }\n\n    pub fn gutter_highlights_in_range(\n        &self,\n        search_range: Range<Anchor>,\n        display_snapshot: &DisplaySnapshot,\n        cx: &App,\n    ) -> Vec<(Range<DisplayPoint>, Hsla)> {\n        let mut results = Vec::new();\n        for (color_fetcher, ranges) in self.gutter_highlights.values() {\n            let color = color_fetcher(cx);\n            let start_ix = match ranges.binary_search_by(|probe| {\n                let cmp = probe\n                    .end\n                    .cmp(&search_range.start, &display_snapshot.buffer_snapshot());\n                if cmp.is_gt() {\n                    Ordering::Greater\n                } else {\n                    Ordering::Less\n                }\n            }) {\n                Ok(i) | Err(i) => i,\n            };\n            for range in &ranges[start_ix..] {\n                if range\n                    .start\n                    .cmp(&search_range.end, &display_snapshot.buffer_snapshot())\n                    .is_ge()\n                {\n                    break;\n                }\n\n                let start = range.start.to_display_point(display_snapshot);\n                let end = range.end.to_display_point(display_snapshot);\n                results.push((start..end, color))\n            }\n        }\n        results\n    }\n\n    /// Get the text ranges corresponding to the redaction query\n    pub fn redacted_ranges(\n        &self,\n        search_range: Range<Anchor>,\n        display_snapshot: &DisplaySnapshot,\n        cx: &App,\n    ) -> Vec<Range<DisplayPoint>> {\n        display_snapshot\n            .buffer_snapshot()\n            .redacted_ranges(search_range, |file| {\n                if let Some(file) = file {\n                    file.is_private()\n                        && EditorSettings::get(\n                            Some(SettingsLocation {\n                                worktree_id: file.worktree_id(cx),\n                                path: file.path().as_ref(),\n                            }),\n                            cx,\n                        )\n                        .redact_private_values\n                } else {\n                    false\n                }\n            })\n            .map(|range| {\n                range.start.to_display_point(display_snapshot)\n                    ..range.end.to_display_point(display_snapshot)\n            })\n            .collect()\n    }\n\n    pub fn highlight_text_key<T: 'static>(\n        &mut self,\n        key: usize,\n        ranges: Vec<Range<Anchor>>,\n        style: HighlightStyle,\n        cx: &mut Context<Self>,\n    ) {\n        self.display_map.update(cx, |map, _| {\n            map.highlight_text(\n                HighlightKey::TypePlus(TypeId::of::<T>(), key),\n                ranges,\n                style,\n            );\n        });\n        cx.notify();\n    }\n\n    pub fn highlight_text<T: 'static>(\n        &mut self,\n        ranges: Vec<Range<Anchor>>,\n        style: HighlightStyle,\n        cx: &mut Context<Self>,\n    ) {\n        self.display_map.update(cx, |map, _| {\n            map.highlight_text(HighlightKey::Type(TypeId::of::<T>()), ranges, style)\n        });\n        cx.notify();\n    }\n\n    pub fn text_highlights<'a, T: 'static>(\n        &'a self,\n        cx: &'a App,\n    ) -> Option<(HighlightStyle, &'a [Range<Anchor>])> {\n        self.display_map.read(cx).text_highlights(TypeId::of::<T>())\n    }\n\n    pub fn clear_highlights<T: 'static>(&mut self, cx: &mut Context<Self>) {\n        let cleared = self\n            .display_map\n            .update(cx, |map, _| map.clear_highlights(TypeId::of::<T>()));\n        if cleared {\n            cx.notify();\n        }\n    }\n\n    pub fn show_local_cursors(&self, window: &mut Window, cx: &mut App) -> bool {\n        (self.read_only(cx) || self.blink_manager.read(cx).visible())\n            && self.focus_handle.is_focused(window)\n    }\n\n    pub fn set_show_cursor_when_unfocused(&mut self, is_enabled: bool, cx: &mut Context<Self>) {\n        self.show_cursor_when_unfocused = is_enabled;\n        cx.notify();\n    }\n\n    fn on_buffer_changed(&mut self, _: Entity<MultiBuffer>, cx: &mut Context<Self>) {\n        cx.notify();\n    }\n\n    fn on_debug_session_event(\n        &mut self,\n        _session: Entity<Session>,\n        event: &SessionEvent,\n        cx: &mut Context<Self>,\n    ) {\n        if let SessionEvent::InvalidateInlineValue = event {\n            self.refresh_inline_values(cx);\n        }\n    }\n\n    pub fn refresh_inline_values(&mut self, cx: &mut Context<Self>) {\n        let Some(project) = self.project.clone() else {\n            return;\n        };\n\n        if !self.inline_value_cache.enabled {\n            let inlays = std::mem::take(&mut self.inline_value_cache.inlays);\n            self.splice_inlays(&inlays, Vec::new(), cx);\n            return;\n        }\n\n        let current_execution_position = self\n            .highlighted_rows\n            .get(&TypeId::of::<ActiveDebugLine>())\n            .and_then(|lines| lines.last().map(|line| line.range.end));\n\n        self.inline_value_cache.refresh_task = cx.spawn(async move |editor, cx| {\n            let inline_values = editor\n                .update(cx, |editor, cx| {\n                    let Some(current_execution_position) = current_execution_position else {\n                        return Some(Task::ready(Ok(Vec::new())));\n                    };\n\n                    let buffer = editor.buffer.read_with(cx, |buffer, cx| {\n                        let snapshot = buffer.snapshot(cx);\n\n                        let excerpt = snapshot.excerpt_containing(\n                            current_execution_position..current_execution_position,\n                        )?;\n\n                        editor.buffer.read(cx).buffer(excerpt.buffer_id())\n                    })?;\n\n                    let range =\n                        buffer.read(cx).anchor_before(0)..current_execution_position.text_anchor;\n\n                    project.inline_values(buffer, range, cx)\n                })\n                .ok()\n                .flatten()?\n                .await\n                .context(": "",
        ")\n                .log_err()?;\n\n            let mut buffer_inline_values: HashMap<BufferId, Vec<InlayHint>> = HashMap::default();\n\n            for (buffer_id, inline_value) in inline_values\n                .into_iter()\n                .filter_map(|hint| Some((hint.position.buffer_id?, hint)))\n            {\n                buffer_inline_values\n                    .entry(buffer_id)\n                    .or_default()\n                    .push(inline_value);\n            }\n\n            editor\n                .update(cx, |editor, cx| {\n                    let snapshot = editor.buffer.read(cx).snapshot(cx);\n                    let mut new_inlays = Vec::default();\n\n                    for (excerpt_id, buffer_snapshot, _) in snapshot.excerpts() {\n                        let buffer_id = buffer_snapshot.remote_id();\n                        buffer_inline_values\n                            .get(&buffer_id)\n                            .into_iter()\n                            .flatten()\n                            .for_each(|hint| {\n                                let inlay = Inlay::debugger(\n                                    post_inc(&mut editor.next_inlay_id),\n                                    Anchor::in_buffer(excerpt_id, buffer_id, hint.position),\n                                    hint.text(),\n                                );\n                                if !inlay.text().chars().contains(&'\\n') {\n                                    new_inlays.push(inlay);\n                                }\n                            });\n                    }\n\n                    let mut inlay_ids = new_inlays.iter().map(|inlay| inlay.id).collect();\n                    std::mem::swap(&mut editor.inline_value_cache.inlays, &mut inlay_ids);\n\n                    editor.splice_inlays(&inlay_ids, new_inlays, cx);\n                })\n                .ok()?;\n            Some(())\n        });\n    }\n\n    fn on_buffer_event(\n        &mut self,\n        multibuffer: &Entity<MultiBuffer>,\n        event: &multi_buffer::Event,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        match event {\n            multi_buffer::Event::Edited { edited_buffer } => {\n                self.scrollbar_marker_state.dirty = true;\n                self.active_indent_guides_state.dirty = true;\n                self.refresh_active_diagnostics(cx);\n                self.refresh_code_actions(window, cx);\n                self.refresh_selected_text_highlights(true, window, cx);\n                self.refresh_single_line_folds(window, cx);\n                self.refresh_matching_bracket_highlights(window, cx);\n                if self.has_active_edit_prediction() {\n                    self.update_visible_edit_prediction(window, cx);\n                }\n\n                if let Some(buffer) = edited_buffer {\n                    if buffer.read(cx).file().is_none() {\n                        cx.emit(EditorEvent::TitleChanged);\n                    }\n\n                    if self.project.is_some() {\n                        let buffer_id = buffer.read(cx).remote_id();\n                        self.register_buffer(buffer_id, cx);\n                        self.update_lsp_data(Some(buffer_id), window, cx);\n                        self.refresh_inlay_hints(\n                            InlayHintRefreshReason::BufferEdited(buffer_id),\n                            cx,\n                        );\n                    }\n                }\n\n                cx.emit(EditorEvent::BufferEdited);\n                cx.emit(SearchEvent::MatchesInvalidated);\n\n                let Some(project) = &self.project else { return };\n                let (telemetry, is_via_ssh) = {\n                    let project = project.read(cx);\n                    let telemetry = project.client().telemetry().clone();\n                    let is_via_ssh = project.is_via_remote_server();\n                    (telemetry, is_via_ssh)\n                };\n                telemetry.log_edit_event(": "",
        ", is_via_ssh);\n            }\n            multi_buffer::Event::ExcerptsAdded {\n                buffer,\n                predecessor,\n                excerpts,\n            } => {\n                self.tasks_update_task = Some(self.refresh_runnables(window, cx));\n                let buffer_id = buffer.read(cx).remote_id();\n                if self.buffer.read(cx).diff_for(buffer_id).is_none()\n                    && let Some(project) = &self.project\n                {\n                    update_uncommitted_diff_for_buffer(\n                        cx.entity(),\n                        project,\n                        [buffer.clone()],\n                        self.buffer.clone(),\n                        cx,\n                    )\n                    .detach();\n                }\n                self.update_lsp_data(Some(buffer_id), window, cx);\n                self.refresh_inlay_hints(InlayHintRefreshReason::NewLinesShown, cx);\n                cx.emit(EditorEvent::ExcerptsAdded {\n                    buffer: buffer.clone(),\n                    predecessor: *predecessor,\n                    excerpts: excerpts.clone(),\n                });\n            }\n            multi_buffer::Event::ExcerptsRemoved {\n                ids,\n                removed_buffer_ids,\n            } => {\n                if let Some(inlay_hints) = &mut self.inlay_hints {\n                    inlay_hints.remove_inlay_chunk_data(removed_buffer_ids);\n                }\n                self.refresh_inlay_hints(InlayHintRefreshReason::ExcerptsRemoved(ids.clone()), cx);\n                for buffer_id in removed_buffer_ids {\n                    self.registered_buffers.remove(buffer_id);\n                }\n                jsx_tag_auto_close::refresh_enabled_in_any_buffer(self, multibuffer, cx);\n                cx.emit(EditorEvent::ExcerptsRemoved {\n                    ids: ids.clone(),\n                    removed_buffer_ids: removed_buffer_ids.clone(),\n                });\n            }\n            multi_buffer::Event::ExcerptsEdited {\n                excerpt_ids,\n                buffer_ids,\n            } => {\n                self.display_map.update(cx, |map, cx| {\n                    map.unfold_buffers(buffer_ids.iter().copied(), cx)\n                });\n                cx.emit(EditorEvent::ExcerptsEdited {\n                    ids: excerpt_ids.clone(),\n                });\n            }\n            multi_buffer::Event::ExcerptsExpanded { ids } => {\n                self.refresh_inlay_hints(InlayHintRefreshReason::NewLinesShown, cx);\n                self.refresh_document_highlights(cx);\n                cx.emit(EditorEvent::ExcerptsExpanded { ids: ids.clone() })\n            }\n            multi_buffer::Event::Reparsed(buffer_id) => {\n                self.tasks_update_task = Some(self.refresh_runnables(window, cx));\n                jsx_tag_auto_close::refresh_enabled_in_any_buffer(self, multibuffer, cx);\n\n                cx.emit(EditorEvent::Reparsed(*buffer_id));\n            }\n            multi_buffer::Event::DiffHunksToggled => {\n                self.tasks_update_task = Some(self.refresh_runnables(window, cx));\n            }\n            multi_buffer::Event::LanguageChanged(buffer_id) => {\n                self.registered_buffers.remove(&buffer_id);\n                jsx_tag_auto_close::refresh_enabled_in_any_buffer(self, multibuffer, cx);\n                cx.emit(EditorEvent::Reparsed(*buffer_id));\n                cx.notify();\n            }\n            multi_buffer::Event::DirtyChanged => cx.emit(EditorEvent::DirtyChanged),\n            multi_buffer::Event::Saved => cx.emit(EditorEvent::Saved),\n            multi_buffer::Event::FileHandleChanged\n            | multi_buffer::Event::Reloaded\n            | multi_buffer::Event::BufferDiffChanged => cx.emit(EditorEvent::TitleChanged),\n            multi_buffer::Event::DiagnosticsUpdated => {\n                self.update_diagnostics_state(window, cx);\n            }\n            _ => {}\n        };\n    }\n\n    fn update_diagnostics_state(&mut self, window: &mut Window, cx: &mut Context<'_, Editor>) {\n        if !self.diagnostics_enabled() {\n            return;\n        }\n        self.refresh_active_diagnostics(cx);\n        self.refresh_inline_diagnostics(true, window, cx);\n        self.scrollbar_marker_state.dirty = true;\n        cx.notify();\n    }\n\n    pub fn start_temporary_diff_override(&mut self) {\n        self.load_diff_task.take();\n        self.temporary_diff_override = true;\n    }\n\n    pub fn end_temporary_diff_override(&mut self, cx: &mut Context<Self>) {\n        self.temporary_diff_override = false;\n        self.set_render_diff_hunk_controls(Arc::new(render_diff_hunk_controls), cx);\n        self.buffer.update(cx, |buffer, cx| {\n            buffer.set_all_diff_hunks_collapsed(cx);\n        });\n\n        if let Some(project) = self.project.clone() {\n            self.load_diff_task = Some(\n                update_uncommitted_diff_for_buffer(\n                    cx.entity(),\n                    &project,\n                    self.buffer.read(cx).all_buffers(),\n                    self.buffer.clone(),\n                    cx,\n                )\n                .shared(),\n            );\n        }\n    }\n\n    fn on_display_map_changed(\n        &mut self,\n        _: Entity<DisplayMap>,\n        _: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        cx.notify();\n    }\n\n    fn settings_changed(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n        if self.diagnostics_enabled() {\n            let new_severity = EditorSettings::get_global(cx)\n                .diagnostics_max_severity\n                .unwrap_or(DiagnosticSeverity::Hint);\n            self.set_max_diagnostics_severity(new_severity, cx);\n        }\n        self.tasks_update_task = Some(self.refresh_runnables(window, cx));\n        self.update_edit_prediction_settings(cx);\n        self.refresh_edit_prediction(true, false, window, cx);\n        self.refresh_inline_values(cx);\n        self.refresh_inlay_hints(\n            InlayHintRefreshReason::SettingsChange(inlay_hint_settings(\n                self.selections.newest_anchor().head(),\n                &self.buffer.read(cx).snapshot(cx),\n                cx,\n            )),\n            cx,\n        );\n\n        let old_cursor_shape = self.cursor_shape;\n        let old_show_breadcrumbs = self.show_breadcrumbs;\n\n        {\n            let editor_settings = EditorSettings::get_global(cx);\n            self.scroll_manager.vertical_scroll_margin = editor_settings.vertical_scroll_margin;\n            self.show_breadcrumbs = editor_settings.toolbar.breadcrumbs;\n            self.cursor_shape = editor_settings.cursor_shape.unwrap_or_default();\n            self.hide_mouse_mode = editor_settings.hide_mouse.unwrap_or_default();\n        }\n\n        if old_cursor_shape != self.cursor_shape {\n            cx.emit(EditorEvent::CursorShapeChanged);\n        }\n\n        if old_show_breadcrumbs != self.show_breadcrumbs {\n            cx.emit(EditorEvent::BreadcrumbsChanged);\n        }\n\n        let project_settings = ProjectSettings::get_global(cx);\n        self.buffer_serialization = self\n            .should_serialize_buffer()\n            .then(|| BufferSerialization::new(project_settings.session.restore_unsaved_buffers));\n\n        if self.mode.is_full() {\n            let show_inline_diagnostics = project_settings.diagnostics.inline.enabled;\n            let inline_blame_enabled = project_settings.git.inline_blame.enabled;\n            if self.show_inline_diagnostics != show_inline_diagnostics {\n                self.show_inline_diagnostics = show_inline_diagnostics;\n                self.refresh_inline_diagnostics(false, window, cx);\n            }\n\n            if self.git_blame_inline_enabled != inline_blame_enabled {\n                self.toggle_git_blame_inline_internal(false, window, cx);\n            }\n\n            let minimap_settings = EditorSettings::get_global(cx).minimap;\n            if self.minimap_visibility != MinimapVisibility::Disabled {\n                if self.minimap_visibility.settings_visibility()\n                    != minimap_settings.minimap_enabled()\n                {\n                    self.set_minimap_visibility(\n                        MinimapVisibility::for_mode(self.mode(), cx),\n                        window,\n                        cx,\n                    );\n                } else if let Some(minimap_entity) = self.minimap.as_ref() {\n                    minimap_entity.update(cx, |minimap_editor, cx| {\n                        minimap_editor.update_minimap_configuration(minimap_settings, cx)\n                    })\n                }\n            }\n        }\n\n        if let Some(inlay_splice) = self.colors.as_mut().and_then(|colors| {\n            colors.render_mode_updated(EditorSettings::get_global(cx).lsp_document_colors)\n        }) {\n            if !inlay_splice.is_empty() {\n                self.splice_inlays(&inlay_splice.to_remove, inlay_splice.to_insert, cx);\n            }\n            self.refresh_colors_for_visible_range(None, window, cx);\n        }\n\n        cx.notify();\n    }\n\n    pub fn set_searchable(&mut self, searchable: bool) {\n        self.searchable = searchable;\n    }\n\n    pub fn searchable(&self) -> bool {\n        self.searchable\n    }\n\n    pub fn open_excerpts_in_split(\n        &mut self,\n        _: &OpenExcerptsSplit,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.open_excerpts_common(None, true, window, cx)\n    }\n\n    pub fn open_excerpts(&mut self, _: &OpenExcerpts, window: &mut Window, cx: &mut Context<Self>) {\n        self.open_excerpts_common(None, false, window, cx)\n    }\n\n    fn open_excerpts_common(\n        &mut self,\n        jump_data: Option<JumpData>,\n        split: bool,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let Some(workspace) = self.workspace() else {\n            cx.propagate();\n            return;\n        };\n\n        if self.buffer.read(cx).is_singleton() {\n            cx.propagate();\n            return;\n        }\n\n        let mut new_selections_by_buffer = HashMap::default();\n        match &jump_data {\n            Some(JumpData::MultiBufferPoint {\n                excerpt_id,\n                position,\n                anchor,\n                line_offset_from_top,\n            }) => {\n                let multi_buffer_snapshot = self.buffer.read(cx).snapshot(cx);\n                if let Some(buffer) = multi_buffer_snapshot\n                    .buffer_id_for_excerpt(*excerpt_id)\n                    .and_then(|buffer_id| self.buffer.read(cx).buffer(buffer_id))\n                {\n                    let buffer_snapshot = buffer.read(cx).snapshot();\n                    let jump_to_point = if buffer_snapshot.can_resolve(anchor) {\n                        language::ToPoint::to_point(anchor, &buffer_snapshot)\n                    } else {\n                        buffer_snapshot.clip_point(*position, Bias::Left)\n                    };\n                    let jump_to_offset = buffer_snapshot.point_to_offset(jump_to_point);\n                    new_selections_by_buffer.insert(\n                        buffer,\n                        (\n                            vec![jump_to_offset..jump_to_offset],\n                            Some(*line_offset_from_top),\n                        ),\n                    );\n                }\n            }\n            Some(JumpData::MultiBufferRow {\n                row,\n                line_offset_from_top,\n            }) => {\n                let point = MultiBufferPoint::new(row.0, 0);\n                if let Some((buffer, buffer_point, _)) =\n                    self.buffer.read(cx).point_to_buffer_point(point, cx)\n                {\n                    let buffer_offset = buffer.read(cx).point_to_offset(buffer_point);\n                    new_selections_by_buffer\n                        .entry(buffer)\n                        .or_insert((Vec::new(), Some(*line_offset_from_top)))\n                        .0\n                        .push(buffer_offset..buffer_offset)\n                }\n            }\n            None => {\n                let selections = self.selections.all::<usize>(&self.display_snapshot(cx));\n                let multi_buffer = self.buffer.read(cx);\n                for selection in selections {\n                    for (snapshot, range, _, anchor) in multi_buffer\n                        .snapshot(cx)\n                        .range_to_buffer_ranges_with_deleted_hunks(selection.range())\n                    {\n                        if let Some(anchor) = anchor {\n                            let Some(buffer_handle) = multi_buffer.buffer_for_anchor(anchor, cx)\n                            else {\n                                continue;\n                            };\n                            let offset = text::ToOffset::to_offset(\n                                &anchor.text_anchor,\n                                &buffer_handle.read(cx).snapshot(),\n                            );\n                            let range = offset..offset;\n                            new_selections_by_buffer\n                                .entry(buffer_handle)\n                                .or_insert((Vec::new(), None))\n                                .0\n                                .push(range)\n                        } else {\n                            let Some(buffer_handle) = multi_buffer.buffer(snapshot.remote_id())\n                            else {\n                                continue;\n                            };\n                            new_selections_by_buffer\n                                .entry(buffer_handle)\n                                .or_insert((Vec::new(), None))\n                                .0\n                                .push(range)\n                        }\n                    }\n                }\n            }\n        }\n\n        new_selections_by_buffer\n            .retain(|buffer, _| Self::can_open_excerpts_in_file(buffer.read(cx).file()));\n\n        if new_selections_by_buffer.is_empty() {\n            return;\n        }\n\n        // We defer the pane interaction because we ourselves are a workspace item\n        // and activating a new item causes the pane to call a method on us reentrantly,\n        // which panics if we're on the stack.\n        window.defer(cx, move |window, cx| {\n            workspace.update(cx, |workspace, cx| {\n                let pane = if split {\n                    workspace.adjacent_pane(window, cx)\n                } else {\n                    workspace.active_pane().clone()\n                };\n\n                for (buffer, (ranges, scroll_offset)) in new_selections_by_buffer {\n                    let editor = buffer\n                        .read(cx)\n                        .file()\n                        .is_none()\n                        .then(|| {\n                            // Handle file-less buffers separately: those are not really the project items, so won't have a project path or entity id,\n                            // so `workspace.open_project_item` will never find them, always opening a new editor.\n                            // Instead, we try to activate the existing editor in the pane first.\n                            let (editor, pane_item_index) =\n                                pane.read(cx).items().enumerate().find_map(|(i, item)| {\n                                    let editor = item.downcast::<Editor>()?;\n                                    let singleton_buffer =\n                                        editor.read(cx).buffer().read(cx).as_singleton()?;\n                                    if singleton_buffer == buffer {\n                                        Some((editor, i))\n                                    } else {\n                                        None\n                                    }\n                                })?;\n                            pane.update(cx, |pane, cx| {\n                                pane.activate_item(pane_item_index, true, true, window, cx)\n                            });\n                            Some(editor)\n                        })\n                        .flatten()\n                        .unwrap_or_else(|| {\n                            workspace.open_project_item::<Self>(\n                                pane.clone(),\n                                buffer,\n                                true,\n                                true,\n                                window,\n                                cx,\n                            )\n                        });\n\n                    editor.update(cx, |editor, cx| {\n                        let autoscroll = match scroll_offset {\n                            Some(scroll_offset) => Autoscroll::top_relative(scroll_offset as usize),\n                            None => Autoscroll::newest(),\n                        };\n                        let nav_history = editor.nav_history.take();\n                        editor.change_selections(\n                            SelectionEffects::scroll(autoscroll),\n                            window,\n                            cx,\n                            |s| {\n                                s.select_ranges(ranges);\n                            },\n                        );\n                        editor.nav_history = nav_history;\n                    });\n                }\n            })\n        });\n    }\n\n    // For now, don't allow opening excerpts in buffers that aren't backed by\n    // regular project files.\n    fn can_open_excerpts_in_file(file: Option<&Arc<dyn language::File>>) -> bool {\n        file.is_none_or(|file| project::File::from_dyn(Some(file)).is_some())\n    }\n\n    fn marked_text_ranges(&self, cx: &App) -> Option<Vec<Range<OffsetUtf16>>> {\n        let snapshot = self.buffer.read(cx).read(cx);\n        let (_, ranges) = self.text_highlights::<InputComposition>(cx)?;\n        Some(\n            ranges\n                .iter()\n                .map(move |range| {\n                    range.start.to_offset_utf16(&snapshot)..range.end.to_offset_utf16(&snapshot)\n                })\n                .collect(),\n        )\n    }\n\n    fn selection_replacement_ranges(\n        &self,\n        range: Range<OffsetUtf16>,\n        cx: &mut App,\n    ) -> Vec<Range<OffsetUtf16>> {\n        let selections = self\n            .selections\n            .all::<OffsetUtf16>(&self.display_snapshot(cx));\n        let newest_selection = selections\n            .iter()\n            .max_by_key(|selection| selection.id)\n            .unwrap();\n        let start_delta = range.start.0 as isize - newest_selection.start.0 as isize;\n        let end_delta = range.end.0 as isize - newest_selection.end.0 as isize;\n        let snapshot = self.buffer.read(cx).read(cx);\n        selections\n            .into_iter()\n            .map(|mut selection| {\n                selection.start.0 =\n                    (selection.start.0 as isize).saturating_add(start_delta) as usize;\n                selection.end.0 = (selection.end.0 as isize).saturating_add(end_delta) as usize;\n                snapshot.clip_offset_utf16(selection.start, Bias::Left)\n                    ..snapshot.clip_offset_utf16(selection.end, Bias::Right)\n            })\n            .collect()\n    }\n\n    fn report_editor_event(\n        &self,\n        reported_event: ReportEditorEvent,\n        file_extension: Option<String>,\n        cx: &App,\n    ) {\n        if cfg!(any(test, feature = ": "",
        ")) {\n            return;\n        }\n\n        let Some(project) = &self.project else { return };\n\n        // If None, we are in a file without an extension\n        let file = self\n            .buffer\n            .read(cx)\n            .as_singleton()\n            .and_then(|b| b.read(cx).file());\n        let file_extension = file_extension.or(file\n            .as_ref()\n            .and_then(|file| Path::new(file.file_name(cx)).extension())\n            .and_then(|e| e.to_str())\n            .map(|a| a.to_string()));\n\n        let vim_mode = vim_flavor(cx).is_some();\n\n        let edit_predictions_provider = all_language_settings(file, cx).edit_predictions.provider;\n        let copilot_enabled = edit_predictions_provider\n            == language::language_settings::EditPredictionProvider::Copilot;\n        let copilot_enabled_for_language = self\n            .buffer\n            .read(cx)\n            .language_settings(cx)\n            .show_edit_predictions;\n\n        let project = project.read(cx);\n        let event_type = reported_event.event_type();\n\n        if let ReportEditorEvent::Saved { auto_saved } = reported_event {\n            telemetry::event!(\n                event_type,\n                type = if auto_saved {": "",
        "} else {": "",
        "},\n                file_extension,\n                vim_mode,\n                copilot_enabled,\n                copilot_enabled_for_language,\n                edit_predictions_provider,\n                is_via_ssh = project.is_via_remote_server(),\n            );\n        } else {\n            telemetry::event!(\n                event_type,\n                file_extension,\n                vim_mode,\n                copilot_enabled,\n                copilot_enabled_for_language,\n                edit_predictions_provider,\n                is_via_ssh = project.is_via_remote_server(),\n            );\n        };\n    }\n\n    /// Copy the highlighted chunks to the clipboard as JSON. The format is an array of lines,\n    /// with each line being an array of {text, highlight} objects.\n    fn copy_highlight_json(\n        &mut self,\n        _: &CopyHighlightJson,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        #[derive(Serialize)]\n        struct Chunk<'a> {\n            text: String,\n            highlight: Option<&'a str>,\n        }\n\n        let snapshot = self.buffer.read(cx).snapshot(cx);\n        let range = self\n            .selected_text_range(false, window, cx)\n            .and_then(|selection| {\n                if selection.range.is_empty() {\n                    None\n                } else {\n                    Some(\n                        snapshot.offset_utf16_to_offset(OffsetUtf16(selection.range.start))\n                            ..snapshot.offset_utf16_to_offset(OffsetUtf16(selection.range.end)),\n                    )\n                }\n            })\n            .unwrap_or_else(|| 0..snapshot.len());\n\n        let chunks = snapshot.chunks(range, true);\n        let mut lines = Vec::new();\n        let mut line: VecDeque<Chunk> = VecDeque::new();\n\n        let Some(style) = self.style.as_ref() else {\n            return;\n        };\n\n        for chunk in chunks {\n            let highlight = chunk\n                .syntax_highlight_id\n                .and_then(|id| id.name(&style.syntax));\n            let mut chunk_lines = chunk.text.split('\\n').peekable();\n            while let Some(text) = chunk_lines.next() {\n                let mut merged_with_last_token = false;\n                if let Some(last_token) = line.back_mut()\n                    && last_token.highlight == highlight\n                {\n                    last_token.text.push_str(text);\n                    merged_with_last_token = true;\n                }\n\n                if !merged_with_last_token {\n                    line.push_back(Chunk {\n                        text: text.into(),\n                        highlight,\n                    });\n                }\n\n                if chunk_lines.peek().is_some() {\n                    if line.len() > 1 && line.front().unwrap().text.is_empty() {\n                        line.pop_front();\n                    }\n                    if line.len() > 1 && line.back().unwrap().text.is_empty() {\n                        line.pop_back();\n                    }\n\n                    lines.push(mem::take(&mut line));\n                }\n            }\n        }\n\n        let Some(lines) = serde_json::to_string_pretty(&lines).log_err() else {\n            return;\n        };\n        cx.write_to_clipboard(ClipboardItem::new_string(lines));\n    }\n\n    pub fn open_context_menu(\n        &mut self,\n        _: &OpenContextMenu,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.request_autoscroll(Autoscroll::newest(), cx);\n        let position = self\n            .selections\n            .newest_display(&self.display_snapshot(cx))\n            .start;\n        mouse_context_menu::deploy_context_menu(self, None, position, window, cx);\n    }\n\n    pub fn replay_insert_event(\n        &mut self,\n        text: &str,\n        relative_utf16_range: Option<Range<isize>>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if !self.input_enabled {\n            cx.emit(EditorEvent::InputIgnored { text: text.into() });\n            return;\n        }\n        if let Some(relative_utf16_range) = relative_utf16_range {\n            let selections = self\n                .selections\n                .all::<OffsetUtf16>(&self.display_snapshot(cx));\n            self.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n                let new_ranges = selections.into_iter().map(|range| {\n                    let start = OffsetUtf16(\n                        range\n                            .head()\n                            .0\n                            .saturating_add_signed(relative_utf16_range.start),\n                    );\n                    let end = OffsetUtf16(\n                        range\n                            .head()\n                            .0\n                            .saturating_add_signed(relative_utf16_range.end),\n                    );\n                    start..end\n                });\n                s.select_ranges(new_ranges);\n            });\n        }\n\n        self.handle_input(text, window, cx);\n    }\n\n    pub fn is_focused(&self, window: &Window) -> bool {\n        self.focus_handle.is_focused(window)\n    }\n\n    fn handle_focus(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n        cx.emit(EditorEvent::Focused);\n\n        if let Some(descendant) = self\n            .last_focused_descendant\n            .take()\n            .and_then(|descendant| descendant.upgrade())\n        {\n            window.focus(&descendant);\n        } else {\n            if let Some(blame) = self.blame.as_ref() {\n                blame.update(cx, GitBlame::focus)\n            }\n\n            self.blink_manager.update(cx, BlinkManager::enable);\n            self.show_cursor_names(window, cx);\n            self.buffer.update(cx, |buffer, cx| {\n                buffer.finalize_last_transaction(cx);\n                if self.leader_id.is_none() {\n                    buffer.set_active_selections(\n                        &self.selections.disjoint_anchors_arc(),\n                        self.selections.line_mode(),\n                        self.cursor_shape,\n                        cx,\n                    );\n                }\n            });\n        }\n    }\n\n    fn handle_focus_in(&mut self, _: &mut Window, cx: &mut Context<Self>) {\n        cx.emit(EditorEvent::FocusedIn)\n    }\n\n    fn handle_focus_out(\n        &mut self,\n        event: FocusOutEvent,\n        _window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if event.blurred != self.focus_handle {\n            self.last_focused_descendant = Some(event.blurred);\n        }\n        self.selection_drag_state = SelectionDragState::None;\n        self.refresh_inlay_hints(InlayHintRefreshReason::ModifiersChanged(false), cx);\n    }\n\n    pub fn handle_blur(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n        self.blink_manager.update(cx, BlinkManager::disable);\n        self.buffer\n            .update(cx, |buffer, cx| buffer.remove_active_selections(cx));\n\n        if let Some(blame) = self.blame.as_ref() {\n            blame.update(cx, GitBlame::blur)\n        }\n        if !self.hover_state.focused(window, cx) {\n            hide_hover(self, cx);\n        }\n        if !self\n            .context_menu\n            .borrow()\n            .as_ref()\n            .is_some_and(|context_menu| context_menu.focused(window, cx))\n        {\n            self.hide_context_menu(window, cx);\n        }\n        self.take_active_edit_prediction(cx);\n        cx.emit(EditorEvent::Blurred);\n        cx.notify();\n    }\n\n    pub fn observe_pending_input(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n        let mut pending: String = window\n            .pending_input_keystrokes()\n            .into_iter()\n            .flatten()\n            .filter_map(|keystroke| {\n                if keystroke.modifiers.is_subset_of(&Modifiers::shift()) {\n                    keystroke.key_char.clone()\n                } else {\n                    None\n                }\n            })\n            .collect();\n\n        if !self.input_enabled || self.read_only || !self.focus_handle.is_focused(window) {\n            pending = ": "",
        ".to_string();\n        }\n\n        let existing_pending = self\n            .text_highlights::<PendingInput>(cx)\n            .map(|(_, ranges)| ranges.to_vec());\n        if existing_pending.is_none() && pending.is_empty() {\n            return;\n        }\n        let transaction =\n            self.transact(window, cx, |this, window, cx| {\n                let selections = this.selections.all::<usize>(&this.display_snapshot(cx));\n                let edits = selections\n                    .iter()\n                    .map(|selection| (selection.end..selection.end, pending.clone()));\n                this.edit(edits, cx);\n                this.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n                    s.select_ranges(selections.into_iter().enumerate().map(|(ix, sel)| {\n                        sel.start + ix * pending.len()..sel.end + ix * pending.len()\n                    }));\n                });\n                if let Some(existing_ranges) = existing_pending {\n                    let edits = existing_ranges.iter().map(|range| (range.clone(), ": "",
        "));\n                    this.edit(edits, cx);\n                }\n            });\n\n        let snapshot = self.snapshot(window, cx);\n        let ranges = self\n            .selections\n            .all::<usize>(&snapshot.display_snapshot)\n            .into_iter()\n            .map(|selection| {\n                snapshot.buffer_snapshot().anchor_after(selection.end)\n                    ..snapshot\n                        .buffer_snapshot()\n                        .anchor_before(selection.end + pending.len())\n            })\n            .collect();\n\n        if pending.is_empty() {\n            self.clear_highlights::<PendingInput>(cx);\n        } else {\n            self.highlight_text::<PendingInput>(\n                ranges,\n                HighlightStyle {\n                    underline: Some(UnderlineStyle {\n                        thickness: px(1.),\n                        color: None,\n                        wavy: false,\n                    }),\n                    ..Default::default()\n                },\n                cx,\n            );\n        }\n\n        self.ime_transaction = self.ime_transaction.or(transaction);\n        if let Some(transaction) = self.ime_transaction {\n            self.buffer.update(cx, |buffer, cx| {\n                buffer.group_until_transaction(transaction, cx);\n            });\n        }\n\n        if self.text_highlights::<PendingInput>(cx).is_none() {\n            self.ime_transaction.take();\n        }\n    }\n\n    pub fn register_action_renderer(\n        &mut self,\n        listener: impl Fn(&Editor, &mut Window, &mut Context<Editor>) + 'static,\n    ) -> Subscription {\n        let id = self.next_editor_action_id.post_inc();\n        self.editor_actions\n            .borrow_mut()\n            .insert(id, Box::new(listener));\n\n        let editor_actions = self.editor_actions.clone();\n        Subscription::new(move || {\n            editor_actions.borrow_mut().remove(&id);\n        })\n    }\n\n    pub fn register_action<A: Action>(\n        &mut self,\n        listener: impl Fn(&A, &mut Window, &mut App) + 'static,\n    ) -> Subscription {\n        let id = self.next_editor_action_id.post_inc();\n        let listener = Arc::new(listener);\n        self.editor_actions.borrow_mut().insert(\n            id,\n            Box::new(move |_, window, _| {\n                let listener = listener.clone();\n                window.on_action(TypeId::of::<A>(), move |action, phase, window, cx| {\n                    let action = action.downcast_ref().unwrap();\n                    if phase == DispatchPhase::Bubble {\n                        listener(action, window, cx)\n                    }\n                })\n            }),\n        );\n\n        let editor_actions = self.editor_actions.clone();\n        Subscription::new(move || {\n            editor_actions.borrow_mut().remove(&id);\n        })\n    }\n\n    pub fn file_header_size(&self) -> u32 {\n        FILE_HEADER_HEIGHT\n    }\n\n    pub fn restore(\n        &mut self,\n        revert_changes: HashMap<BufferId, Vec<(Range<text::Anchor>, Rope)>>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let workspace = self.workspace();\n        let project = self.project();\n        let save_tasks = self.buffer().update(cx, |multi_buffer, cx| {\n            let mut tasks = Vec::new();\n            for (buffer_id, changes) in revert_changes {\n                if let Some(buffer) = multi_buffer.buffer(buffer_id) {\n                    buffer.update(cx, |buffer, cx| {\n                        buffer.edit(\n                            changes\n                                .into_iter()\n                                .map(|(range, text)| (range, text.to_string())),\n                            None,\n                            cx,\n                        );\n                    });\n\n                    if let Some(project) =\n                        project.filter(|_| multi_buffer.all_diff_hunks_expanded())\n                    {\n                        project.update(cx, |project, cx| {\n                            tasks.push((buffer.clone(), project.save_buffer(buffer, cx)));\n                        })\n                    }\n                }\n            }\n            tasks\n        });\n        cx.spawn_in(window, async move |_, cx| {\n            for (buffer, task) in save_tasks {\n                let result = task.await;\n                if result.is_err() {\n                    let Some(path) = buffer\n                        .read_with(cx, |buffer, cx| buffer.project_path(cx))\n                        .ok()\n                    else {\n                        continue;\n                    };\n                    if let Some((workspace, path)) = workspace.as_ref().zip(path) {\n                        let Some(task) = cx\n                            .update_window_entity(workspace, |workspace, window, cx| {\n                                workspace\n                                    .open_path_preview(path, None, false, false, false, window, cx)\n                            })\n                            .ok()\n                        else {\n                            continue;\n                        };\n                        task.await.log_err();\n                    }\n                }\n            }\n        })\n        .detach();\n        self.change_selections(SelectionEffects::no_scroll(), window, cx, |selections| {\n            selections.refresh()\n        });\n    }\n\n    pub fn to_pixel_point(\n        &self,\n        source: multi_buffer::Anchor,\n        editor_snapshot: &EditorSnapshot,\n        window: &mut Window,\n    ) -> Option<gpui::Point<Pixels>> {\n        let source_point = source.to_display_point(editor_snapshot);\n        self.display_to_pixel_point(source_point, editor_snapshot, window)\n    }\n\n    pub fn display_to_pixel_point(\n        &self,\n        source: DisplayPoint,\n        editor_snapshot: &EditorSnapshot,\n        window: &mut Window,\n    ) -> Option<gpui::Point<Pixels>> {\n        let line_height = self.style()?.text.line_height_in_pixels(window.rem_size());\n        let text_layout_details = self.text_layout_details(window);\n        let scroll_top = text_layout_details\n            .scroll_anchor\n            .scroll_position(editor_snapshot)\n            .y;\n\n        if source.row().as_f64() < scroll_top.floor() {\n            return None;\n        }\n        let source_x = editor_snapshot.x_for_display_point(source, &text_layout_details);\n        let source_y = line_height * (source.row().as_f64() - scroll_top) as f32;\n        Some(gpui::Point::new(source_x, source_y))\n    }\n\n    pub fn has_visible_completions_menu(&self) -> bool {\n        !self.edit_prediction_preview_is_active()\n            && self.context_menu.borrow().as_ref().is_some_and(|menu| {\n                menu.visible() && matches!(menu, CodeContextMenu::Completions(_))\n            })\n    }\n\n    pub fn register_addon<T: Addon>(&mut self, instance: T) {\n        if self.mode.is_minimap() {\n            return;\n        }\n        self.addons\n            .insert(std::any::TypeId::of::<T>(), Box::new(instance));\n    }\n\n    pub fn unregister_addon<T: Addon>(&mut self) {\n        self.addons.remove(&std::any::TypeId::of::<T>());\n    }\n\n    pub fn addon<T: Addon>(&self) -> Option<&T> {\n        let type_id = std::any::TypeId::of::<T>();\n        self.addons\n            .get(&type_id)\n            .and_then(|item| item.to_any().downcast_ref::<T>())\n    }\n\n    pub fn addon_mut<T: Addon>(&mut self) -> Option<&mut T> {\n        let type_id = std::any::TypeId::of::<T>();\n        self.addons\n            .get_mut(&type_id)\n            .and_then(|item| item.to_any_mut()?.downcast_mut::<T>())\n    }\n\n    fn character_dimensions(&self, window: &mut Window) -> CharacterDimensions {\n        let text_layout_details = self.text_layout_details(window);\n        let style = &text_layout_details.editor_style;\n        let font_id = window.text_system().resolve_font(&style.text.font());\n        let font_size = style.text.font_size.to_pixels(window.rem_size());\n        let line_height = style.text.line_height_in_pixels(window.rem_size());\n        let em_width = window.text_system().em_width(font_id, font_size).unwrap();\n        let em_advance = window.text_system().em_advance(font_id, font_size).unwrap();\n\n        CharacterDimensions {\n            em_width,\n            em_advance,\n            line_height,\n        }\n    }\n\n    pub fn wait_for_diff_to_load(&self) -> Option<Shared<Task<()>>> {\n        self.load_diff_task.clone()\n    }\n\n    fn read_metadata_from_db(\n        &mut self,\n        item_id: u64,\n        workspace_id: WorkspaceId,\n        window: &mut Window,\n        cx: &mut Context<Editor>,\n    ) {\n        if self.buffer_kind(cx) == ItemBufferKind::Singleton\n            && !self.mode.is_minimap()\n            && WorkspaceSettings::get(None, cx).restore_on_startup != RestoreOnStartupBehavior::None\n        {\n            let buffer_snapshot = OnceCell::new();\n\n            if let Some(folds) = DB.get_editor_folds(item_id, workspace_id).log_err()\n                && !folds.is_empty()\n            {\n                let snapshot = buffer_snapshot.get_or_init(|| self.buffer.read(cx).snapshot(cx));\n                self.fold_ranges(\n                    folds\n                        .into_iter()\n                        .map(|(start, end)| {\n                            snapshot.clip_offset(start, Bias::Left)\n                                ..snapshot.clip_offset(end, Bias::Right)\n                        })\n                        .collect(),\n                    false,\n                    window,\n                    cx,\n                );\n            }\n\n            if let Some(selections) = DB.get_editor_selections(item_id, workspace_id).log_err()\n                && !selections.is_empty()\n            {\n                let snapshot = buffer_snapshot.get_or_init(|| self.buffer.read(cx).snapshot(cx));\n                // skip adding the initial selection to selection history\n                self.selection_history.mode = SelectionHistoryMode::Skipping;\n                self.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n                    s.select_ranges(selections.into_iter().map(|(start, end)| {\n                        snapshot.clip_offset(start, Bias::Left)\n                            ..snapshot.clip_offset(end, Bias::Right)\n                    }));\n                });\n                self.selection_history.mode = SelectionHistoryMode::Normal;\n            };\n        }\n\n        self.read_scroll_position_from_db(item_id, workspace_id, window, cx);\n    }\n\n    fn update_lsp_data(\n        &mut self,\n        for_buffer: Option<BufferId>,\n        window: &mut Window,\n        cx: &mut Context<'_, Self>,\n    ) {\n        self.pull_diagnostics(for_buffer, window, cx);\n        self.refresh_colors_for_visible_range(for_buffer, window, cx);\n    }\n\n    fn register_visible_buffers(&mut self, cx: &mut Context<Self>) {\n        if self.ignore_lsp_data() {\n            return;\n        }\n        for (_, (visible_buffer, _, _)) in self.visible_excerpts(cx) {\n            self.register_buffer(visible_buffer.read(cx).remote_id(), cx);\n        }\n    }\n\n    fn register_buffer(&mut self, buffer_id: BufferId, cx: &mut Context<Self>) {\n        if self.ignore_lsp_data() {\n            return;\n        }\n\n        if !self.registered_buffers.contains_key(&buffer_id)\n            && let Some(project) = self.project.as_ref()\n        {\n            if let Some(buffer) = self.buffer.read(cx).buffer(buffer_id) {\n                project.update(cx, |project, cx| {\n                    self.registered_buffers.insert(\n                        buffer_id,\n                        project.register_buffer_with_language_servers(&buffer, cx),\n                    );\n                });\n            } else {\n                self.registered_buffers.remove(&buffer_id);\n            }\n        }\n    }\n\n    fn ignore_lsp_data(&self) -> bool {\n        // `ActiveDiagnostic::All` is a special mode where editor's diagnostics are managed by the external view,\n        // skip any LSP updates for it.\n        self.active_diagnostics == ActiveDiagnostic::All || !self.mode().is_full()\n    }\n}\n\nfn edit_for_markdown_paste<'a>(\n    buffer: &MultiBufferSnapshot,\n    range: Range<usize>,\n    to_insert: &'a str,\n    url: Option<url::Url>,\n) -> (Range<usize>, Cow<'a, str>) {\n    if url.is_none() {\n        return (range, Cow::Borrowed(to_insert));\n    };\n\n    let old_text = buffer.text_for_range(range.clone()).collect::<String>();\n\n    let new_text = if range.is_empty() || url::Url::parse(&old_text).is_ok() {\n        Cow::Borrowed(to_insert)\n    } else {\n        Cow::Owned(format!(": "",
        "))\n    };\n    (range, new_text)\n}\n\n#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\npub enum VimFlavor {\n    Vim,\n    Helix,\n}\n\npub fn vim_flavor(cx: &App) -> Option<VimFlavor> {\n    if vim_mode_setting::HelixModeSetting::try_get(cx)\n        .map(|helix_mode| helix_mode.0)\n        .unwrap_or(false)\n    {\n        Some(VimFlavor::Helix)\n    } else if vim_mode_setting::VimModeSetting::try_get(cx)\n        .map(|vim_mode| vim_mode.0)\n        .unwrap_or(false)\n    {\n        Some(VimFlavor::Vim)\n    } else {\n        None // neither vim nor helix mode\n    }\n}\n\nfn process_completion_for_edit(\n    completion: &Completion,\n    intent: CompletionIntent,\n    buffer: &Entity<Buffer>,\n    cursor_position: &text::Anchor,\n    cx: &mut Context<Editor>,\n) -> CompletionEdit {\n    let buffer = buffer.read(cx);\n    let buffer_snapshot = buffer.snapshot();\n    let (snippet, new_text) = if completion.is_snippet() {\n        let mut snippet_source = completion.new_text.clone();\n        // Workaround for typescript language server issues so that methods don't expand within\n        // strings and functions with type expressions. The previous point is used because the query\n        // for function identifier doesn't match when the cursor is immediately after. See PR #30312\n        let previous_point = text::ToPoint::to_point(cursor_position, &buffer_snapshot);\n        let previous_point = if previous_point.column > 0 {\n            cursor_position.to_previous_offset(&buffer_snapshot)\n        } else {\n            cursor_position.to_offset(&buffer_snapshot)\n        };\n        if let Some(scope) = buffer_snapshot.language_scope_at(previous_point)\n            && scope.prefers_label_for_snippet_in_completion()\n            && let Some(label) = completion.label()\n            && matches!(\n                completion.kind(),\n                Some(CompletionItemKind::FUNCTION) | Some(CompletionItemKind::METHOD)\n            )\n        {\n            snippet_source = label;\n        }\n        match Snippet::parse(&snippet_source).log_err() {\n            Some(parsed_snippet) => (Some(parsed_snippet.clone()), parsed_snippet.text),\n            None => (None, completion.new_text.clone()),\n        }\n    } else {\n        (None, completion.new_text.clone())\n    };\n\n    let mut range_to_replace = {\n        let replace_range = &completion.replace_range;\n        if let CompletionSource::Lsp {\n            insert_range: Some(insert_range),\n            ..\n        } = &completion.source\n        {\n            debug_assert_eq!(\n                insert_range.start, replace_range.start,\n                ": "",
        "\n            );\n            debug_assert!(\n                insert_range\n                    .start\n                    .cmp(cursor_position, &buffer_snapshot)\n                    .is_le(),\n                ": "",
        "\n            );\n            debug_assert!(\n                replace_range\n                    .start\n                    .cmp(cursor_position, &buffer_snapshot)\n                    .is_le(),\n                ": "",
        "\n            );\n\n            let should_replace = match intent {\n                CompletionIntent::CompleteWithInsert => false,\n                CompletionIntent::CompleteWithReplace => true,\n                CompletionIntent::Complete | CompletionIntent::Compose => {\n                    let insert_mode =\n                        language_settings(buffer.language().map(|l| l.name()), buffer.file(), cx)\n                            .completions\n                            .lsp_insert_mode;\n                    match insert_mode {\n                        LspInsertMode::Insert => false,\n                        LspInsertMode::Replace => true,\n                        LspInsertMode::ReplaceSubsequence => {\n                            let mut text_to_replace = buffer.chars_for_range(\n                                buffer.anchor_before(replace_range.start)\n                                    ..buffer.anchor_after(replace_range.end),\n                            );\n                            let mut current_needle = text_to_replace.next();\n                            for haystack_ch in completion.label.text.chars() {\n                                if let Some(needle_ch) = current_needle\n                                    && haystack_ch.eq_ignore_ascii_case(&needle_ch)\n                                {\n                                    current_needle = text_to_replace.next();\n                                }\n                            }\n                            current_needle.is_none()\n                        }\n                        LspInsertMode::ReplaceSuffix => {\n                            if replace_range\n                                .end\n                                .cmp(cursor_position, &buffer_snapshot)\n                                .is_gt()\n                            {\n                                let range_after_cursor = *cursor_position..replace_range.end;\n                                let text_after_cursor = buffer\n                                    .text_for_range(\n                                        buffer.anchor_before(range_after_cursor.start)\n                                            ..buffer.anchor_after(range_after_cursor.end),\n                                    )\n                                    .collect::<String>()\n                                    .to_ascii_lowercase();\n                                completion\n                                    .label\n                                    .text\n                                    .to_ascii_lowercase()\n                                    .ends_with(&text_after_cursor)\n                            } else {\n                                true\n                            }\n                        }\n                    }\n                }\n            };\n\n            if should_replace {\n                replace_range.clone()\n            } else {\n                insert_range.clone()\n            }\n        } else {\n            replace_range.clone()\n        }\n    };\n\n    if range_to_replace\n        .end\n        .cmp(cursor_position, &buffer_snapshot)\n        .is_lt()\n    {\n        range_to_replace.end = *cursor_position;\n    }\n\n    CompletionEdit {\n        new_text,\n        replace_range: range_to_replace.to_offset(buffer),\n        snippet,\n    }\n}\n\nstruct CompletionEdit {\n    new_text: String,\n    replace_range: Range<usize>,\n    snippet: Option<Snippet>,\n}\n\nfn insert_extra_newline_brackets(\n    buffer: &MultiBufferSnapshot,\n    range: Range<usize>,\n    language: &language::LanguageScope,\n) -> bool {\n    let leading_whitespace_len = buffer\n        .reversed_chars_at(range.start)\n        .take_while(|c| c.is_whitespace() && *c != '\\n')\n        .map(|c| c.len_utf8())\n        .sum::<usize>();\n    let trailing_whitespace_len = buffer\n        .chars_at(range.end)\n        .take_while(|c| c.is_whitespace() && *c != '\\n')\n        .map(|c| c.len_utf8())\n        .sum::<usize>();\n    let range = range.start - leading_whitespace_len..range.end + trailing_whitespace_len;\n\n    language.brackets().any(|(pair, enabled)| {\n        let pair_start = pair.start.trim_end();\n        let pair_end = pair.end.trim_start();\n\n        enabled\n            && pair.newline\n            && buffer.contains_str_at(range.end, pair_end)\n            && buffer.contains_str_at(range.start.saturating_sub(pair_start.len()), pair_start)\n    })\n}\n\nfn insert_extra_newline_tree_sitter(buffer: &MultiBufferSnapshot, range: Range<usize>) -> bool {\n    let (buffer, range) = match buffer.range_to_buffer_ranges(range).as_slice() {\n        [(buffer, range, _)] => (*buffer, range.clone()),\n        _ => return false,\n    };\n    let pair = {\n        let mut result: Option<BracketMatch> = None;\n\n        for pair in buffer\n            .all_bracket_ranges(range.clone())\n            .filter(move |pair| {\n                pair.open_range.start <= range.start && pair.close_range.end >= range.end\n            })\n        {\n            let len = pair.close_range.end - pair.open_range.start;\n\n            if let Some(existing) = &result {\n                let existing_len = existing.close_range.end - existing.open_range.start;\n                if len > existing_len {\n                    continue;\n                }\n            }\n\n            result = Some(pair);\n        }\n\n        result\n    };\n    let Some(pair) = pair else {\n        return false;\n    };\n    pair.newline_only\n        && buffer\n            .chars_for_range(pair.open_range.end..range.start)\n            .chain(buffer.chars_for_range(range.end..pair.close_range.start))\n            .all(|c| c.is_whitespace() && c != '\\n')\n}\n\nfn update_uncommitted_diff_for_buffer(\n    editor: Entity<Editor>,\n    project: &Entity<Project>,\n    buffers: impl IntoIterator<Item = Entity<Buffer>>,\n    buffer: Entity<MultiBuffer>,\n    cx: &mut App,\n) -> Task<()> {\n    let mut tasks = Vec::new();\n    project.update(cx, |project, cx| {\n        for buffer in buffers {\n            if project::File::from_dyn(buffer.read(cx).file()).is_some() {\n                tasks.push(project.open_uncommitted_diff(buffer.clone(), cx))\n            }\n        }\n    });\n    cx.spawn(async move |cx| {\n        let diffs = future::join_all(tasks).await;\n        if editor\n            .read_with(cx, |editor, _cx| editor.temporary_diff_override)\n            .unwrap_or(false)\n        {\n            return;\n        }\n\n        buffer\n            .update(cx, |buffer, cx| {\n                for diff in diffs.into_iter().flatten() {\n                    buffer.add_diff(diff, cx);\n                }\n            })\n            .ok();\n    })\n}\n\nfn char_len_with_expanded_tabs(offset: usize, text: &str, tab_size: NonZeroU32) -> usize {\n    let tab_size = tab_size.get() as usize;\n    let mut width = offset;\n\n    for ch in text.chars() {\n        width += if ch == '\\t' {\n            tab_size - (width % tab_size)\n        } else {\n            1\n        };\n    }\n\n    width - offset\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_string_size_with_expanded_tabs() {\n        let nz = |val| NonZeroU32::new(val).unwrap();\n        assert_eq!(char_len_with_expanded_tabs(0, ": "",
        ", nz(4)), 0);\n        assert_eq!(char_len_with_expanded_tabs(0, ": "",
        ", nz(4)), 5);\n        assert_eq!(char_len_with_expanded_tabs(0, ": "",
        ", nz(4)), 9);\n        assert_eq!(char_len_with_expanded_tabs(0, ": "",
        ", nz(4)), 6);\n        assert_eq!(char_len_with_expanded_tabs(0, ": "",
        ", nz(4)), 8);\n        assert_eq!(char_len_with_expanded_tabs(0, ": "",
        ", nz(8)), 16);\n        assert_eq!(char_len_with_expanded_tabs(0, ": "",
        ", nz(8)), 8);\n        assert_eq!(char_len_with_expanded_tabs(7, ": "",
        ", nz(8)), 9);\n    }\n}\n\n/// Tokenizes a string into runs of text that should stick together, or that is whitespace.\nstruct WordBreakingTokenizer<'a> {\n    input: &'a str,\n}\n\nimpl<'a> WordBreakingTokenizer<'a> {\n    fn new(input: &'a str) -> Self {\n        Self { input }\n    }\n}\n\nfn is_char_ideographic(ch: char) -> bool {\n    use unicode_script::Script::*;\n    use unicode_script::UnicodeScript;\n    matches!(ch.script(), Han | Tangut | Yi)\n}\n\nfn is_grapheme_ideographic(text: &str) -> bool {\n    text.chars().any(is_char_ideographic)\n}\n\nfn is_grapheme_whitespace(text: &str) -> bool {\n    text.chars().any(|x| x.is_whitespace())\n}\n\nfn should_stay_with_preceding_ideograph(text: &str) -> bool {\n    text.chars()\n        .next()\n        .is_some_and(|ch| matches!(ch, '。' | '、' | '，' | '？' | '！' | '：' | '；' | '…'))\n}\n\n#[derive(PartialEq, Eq, Debug, Clone, Copy)]\nenum WordBreakToken<'a> {\n    Word { token: &'a str, grapheme_len: usize },\n    InlineWhitespace { token: &'a str, grapheme_len: usize },\n    Newline,\n}\n\nimpl<'a> Iterator for WordBreakingTokenizer<'a> {\n    /// Yields a span, the count of graphemes in the token, and whether it was\n    /// whitespace. Note that it also breaks at word boundaries.\n    type Item = WordBreakToken<'a>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        use unicode_segmentation::UnicodeSegmentation;\n        if self.input.is_empty() {\n            return None;\n        }\n\n        let mut iter = self.input.graphemes(true).peekable();\n        let mut offset = 0;\n        let mut grapheme_len = 0;\n        if let Some(first_grapheme) = iter.next() {\n            let is_newline = first_grapheme == ": "",
        ";\n            let is_whitespace = is_grapheme_whitespace(first_grapheme);\n            offset += first_grapheme.len();\n            grapheme_len += 1;\n            if is_grapheme_ideographic(first_grapheme) && !is_whitespace {\n                if let Some(grapheme) = iter.peek().copied()\n                    && should_stay_with_preceding_ideograph(grapheme)\n                {\n                    offset += grapheme.len();\n                    grapheme_len += 1;\n                }\n            } else {\n                let mut words = self.input[offset..].split_word_bound_indices().peekable();\n                let mut next_word_bound = words.peek().copied();\n                if next_word_bound.is_some_and(|(i, _)| i == 0) {\n                    next_word_bound = words.next();\n                }\n                while let Some(grapheme) = iter.peek().copied() {\n                    if next_word_bound.is_some_and(|(i, _)| i == offset) {\n                        break;\n                    };\n                    if is_grapheme_whitespace(grapheme) != is_whitespace\n                        || (grapheme == ": "",
        ") != is_newline\n                    {\n                        break;\n                    };\n                    offset += grapheme.len();\n                    grapheme_len += 1;\n                    iter.next();\n                }\n            }\n            let token = &self.input[..offset];\n            self.input = &self.input[offset..];\n            if token == ": "",
        " {\n                Some(WordBreakToken::Newline)\n            } else if is_whitespace {\n                Some(WordBreakToken::InlineWhitespace {\n                    token,\n                    grapheme_len,\n                })\n            } else {\n                Some(WordBreakToken::Word {\n                    token,\n                    grapheme_len,\n                })\n            }\n        } else {\n            None\n        }\n    }\n}\n\n#[test]\nfn test_word_breaking_tokenizer() {\n    let tests: &[(&str, &[WordBreakToken<'static>])] = &[\n        (": "",
        ", &[]),\n        (": "",
        ", &[whitespace(": "",
        ", 2)]),\n        (": "",
        ", &[word(": "",
        ", 1)]),\n        (": "",
        ", 2)]),\n        (\n            ": "",
        ",\n            &[word(": "",
        ", 1), word(": "",
        ", 2), word(": "",
        ", 1)],\n        ),\n        (\n            ": "",
        ", 5), whitespace(": "",
        ", 5)],\n        ),\n        (\n            ": "",
        ", 6), whitespace(": "",
        ",\n            &[\n                whitespace(": "",
        ", 2),\n                word(": "",
        ", 5),\n                whitespace(": "",
        ", 1),\n                word(": "",
        ", 5),\n            ],\n        ),\n        (\n            ": "",
        ",\n            &[\n                word(": "",
        ", 1),\n                whitespace(": "",
        ", 1),\n                newline(),\n                whitespace(": "",
        ", 1),\n            ],\n        ),\n        (": "",
        ", 6)]),\n    ];\n\n    fn word(token: &'static str, grapheme_len: usize) -> WordBreakToken<'static> {\n        WordBreakToken::Word {\n            token,\n            grapheme_len,\n        }\n    }\n\n    fn whitespace(token: &'static str, grapheme_len: usize) -> WordBreakToken<'static> {\n        WordBreakToken::InlineWhitespace {\n            token,\n            grapheme_len,\n        }\n    }\n\n    fn newline() -> WordBreakToken<'static> {\n        WordBreakToken::Newline\n    }\n\n    for (input, result) in tests {\n        assert_eq!(\n            WordBreakingTokenizer::new(input)\n                .collect::<Vec<_>>()\n                .as_slice(),\n            *result,\n        );\n    }\n}\n\nfn wrap_with_prefix(\n    first_line_prefix: String,\n    subsequent_lines_prefix: String,\n    unwrapped_text: String,\n    wrap_column: usize,\n    tab_size: NonZeroU32,\n    preserve_existing_whitespace: bool,\n) -> String {\n    let first_line_prefix_len = char_len_with_expanded_tabs(0, &first_line_prefix, tab_size);\n    let subsequent_lines_prefix_len =\n        char_len_with_expanded_tabs(0, &subsequent_lines_prefix, tab_size);\n    let mut wrapped_text = String::new();\n    let mut current_line = first_line_prefix;\n    let mut is_first_line = true;\n\n    let tokenizer = WordBreakingTokenizer::new(&unwrapped_text);\n    let mut current_line_len = first_line_prefix_len;\n    let mut in_whitespace = false;\n    for token in tokenizer {\n        let have_preceding_whitespace = in_whitespace;\n        match token {\n            WordBreakToken::Word {\n                token,\n                grapheme_len,\n            } => {\n                in_whitespace = false;\n                let current_prefix_len = if is_first_line {\n                    first_line_prefix_len\n                } else {\n                    subsequent_lines_prefix_len\n                };\n                if current_line_len + grapheme_len > wrap_column\n                    && current_line_len != current_prefix_len\n                {\n                    wrapped_text.push_str(current_line.trim_end());\n                    wrapped_text.push('\\n');\n                    is_first_line = false;\n                    current_line = subsequent_lines_prefix.clone();\n                    current_line_len = subsequent_lines_prefix_len;\n                }\n                current_line.push_str(token);\n                current_line_len += grapheme_len;\n            }\n            WordBreakToken::InlineWhitespace {\n                mut token,\n                mut grapheme_len,\n            } => {\n                in_whitespace = true;\n                if have_preceding_whitespace && !preserve_existing_whitespace {\n                    continue;\n                }\n                if !preserve_existing_whitespace {\n                    // Keep a single whitespace grapheme as-is\n                    if let Some(first) =\n                        unicode_segmentation::UnicodeSegmentation::graphemes(token, true).next()\n                    {\n                        token = first;\n                    } else {\n                        token = ": "",
        ";\n                    }\n                    grapheme_len = 1;\n                }\n                let current_prefix_len = if is_first_line {\n                    first_line_prefix_len\n                } else {\n                    subsequent_lines_prefix_len\n                };\n                if current_line_len + grapheme_len > wrap_column {\n                    wrapped_text.push_str(current_line.trim_end());\n                    wrapped_text.push('\\n');\n                    is_first_line = false;\n                    current_line = subsequent_lines_prefix.clone();\n                    current_line_len = subsequent_lines_prefix_len;\n                } else if current_line_len != current_prefix_len || preserve_existing_whitespace {\n                    current_line.push_str(token);\n                    current_line_len += grapheme_len;\n                }\n            }\n            WordBreakToken::Newline => {\n                in_whitespace = true;\n                let current_prefix_len = if is_first_line {\n                    first_line_prefix_len\n                } else {\n                    subsequent_lines_prefix_len\n                };\n                if preserve_existing_whitespace {\n                    wrapped_text.push_str(current_line.trim_end());\n                    wrapped_text.push('\\n');\n                    is_first_line = false;\n                    current_line = subsequent_lines_prefix.clone();\n                    current_line_len = subsequent_lines_prefix_len;\n                } else if have_preceding_whitespace {\n                    continue;\n                } else if current_line_len + 1 > wrap_column\n                    && current_line_len != current_prefix_len\n                {\n                    wrapped_text.push_str(current_line.trim_end());\n                    wrapped_text.push('\\n');\n                    is_first_line = false;\n                    current_line = subsequent_lines_prefix.clone();\n                    current_line_len = subsequent_lines_prefix_len;\n                } else if current_line_len != current_prefix_len {\n                    current_line.push(' ');\n                    current_line_len += 1;\n                }\n            }\n        }\n    }\n\n    if !current_line.is_empty() {\n        wrapped_text.push_str(&current_line);\n    }\n    wrapped_text\n}\n\n#[test]\nfn test_wrap_with_prefix() {\n    assert_eq!(\n        wrap_with_prefix(\n            ": "",
        ".to_string(),\n            ": "",
        ".to_string(),\n            4,\n            NonZeroU32::new(4).unwrap(),\n            false,\n        ),\n        ": "",
        "\n    );\n    assert_eq!(\n        wrap_with_prefix(\n            ": "",
        ".to_string(),\n            8,\n            NonZeroU32::new(4).unwrap(),\n            false,\n        ),\n        ": "",
        ".to_string(),\n            12,\n            NonZeroU32::new(4).unwrap(),\n            false,\n        ),\n        ": "",
        "\n    );\n    assert_eq!(\n        wrap_with_prefix(\n            String::new(),\n            String::new(),\n            ": "",
        ".to_string(),\n            3,\n            NonZeroU32::new(4).unwrap(),\n            false,\n        ),\n        ": "",
        "\n    );\n    assert_eq!(\n        wrap_with_prefix(\n            String::new(),\n            String::new(),\n            format!(": "",
        ", '\\u{2009}'), // thin space\n            80,\n            NonZeroU32::new(4).unwrap(),\n            false,\n        ),\n        format!(": "",
        ", '\\u{2009}')\n    );\n}\n\npub trait CollaborationHub {\n    fn collaborators<'a>(&self, cx: &'a App) -> &'a HashMap<PeerId, Collaborator>;\n    fn user_participant_indices<'a>(&self, cx: &'a App) -> &'a HashMap<u64, ParticipantIndex>;\n    fn user_names(&self, cx: &App) -> HashMap<u64, SharedString>;\n}\n\nimpl CollaborationHub for Entity<Project> {\n    fn collaborators<'a>(&self, cx: &'a App) -> &'a HashMap<PeerId, Collaborator> {\n        self.read(cx).collaborators()\n    }\n\n    fn user_participant_indices<'a>(&self, cx: &'a App) -> &'a HashMap<u64, ParticipantIndex> {\n        self.read(cx).user_store().read(cx).participant_indices()\n    }\n\n    fn user_names(&self, cx: &App) -> HashMap<u64, SharedString> {\n        let this = self.read(cx);\n        let user_ids = this.collaborators().values().map(|c| c.user_id);\n        this.user_store().read(cx).participant_names(user_ids, cx)\n    }\n}\n\npub trait SemanticsProvider {\n    fn hover(\n        &self,\n        buffer: &Entity<Buffer>,\n        position: text::Anchor,\n        cx: &mut App,\n    ) -> Option<Task<Option<Vec<project::Hover>>>>;\n\n    fn inline_values(\n        &self,\n        buffer_handle: Entity<Buffer>,\n        range: Range<text::Anchor>,\n        cx: &mut App,\n    ) -> Option<Task<anyhow::Result<Vec<InlayHint>>>>;\n\n    fn applicable_inlay_chunks(\n        &self,\n        buffer: &Entity<Buffer>,\n        ranges: &[Range<text::Anchor>],\n        cx: &mut App,\n    ) -> Vec<Range<BufferRow>>;\n\n    fn invalidate_inlay_hints(&self, for_buffers: &HashSet<BufferId>, cx: &mut App);\n\n    fn inlay_hints(\n        &self,\n        invalidate: InvalidationStrategy,\n        buffer: Entity<Buffer>,\n        ranges: Vec<Range<text::Anchor>>,\n        known_chunks: Option<(clock::Global, HashSet<Range<BufferRow>>)>,\n        cx: &mut App,\n    ) -> Option<HashMap<Range<BufferRow>, Task<Result<CacheInlayHints>>>>;\n\n    fn supports_inlay_hints(&self, buffer: &Entity<Buffer>, cx: &mut App) -> bool;\n\n    fn document_highlights(\n        &self,\n        buffer: &Entity<Buffer>,\n        position: text::Anchor,\n        cx: &mut App,\n    ) -> Option<Task<Result<Vec<DocumentHighlight>>>>;\n\n    fn definitions(\n        &self,\n        buffer: &Entity<Buffer>,\n        position: text::Anchor,\n        kind: GotoDefinitionKind,\n        cx: &mut App,\n    ) -> Option<Task<Result<Option<Vec<LocationLink>>>>>;\n\n    fn range_for_rename(\n        &self,\n        buffer: &Entity<Buffer>,\n        position: text::Anchor,\n        cx: &mut App,\n    ) -> Option<Task<Result<Option<Range<text::Anchor>>>>>;\n\n    fn perform_rename(\n        &self,\n        buffer: &Entity<Buffer>,\n        position: text::Anchor,\n        new_name: String,\n        cx: &mut App,\n    ) -> Option<Task<Result<ProjectTransaction>>>;\n}\n\npub trait CompletionProvider {\n    fn completions(\n        &self,\n        excerpt_id: ExcerptId,\n        buffer: &Entity<Buffer>,\n        buffer_position: text::Anchor,\n        trigger: CompletionContext,\n        window: &mut Window,\n        cx: &mut Context<Editor>,\n    ) -> Task<Result<Vec<CompletionResponse>>>;\n\n    fn resolve_completions(\n        &self,\n        _buffer: Entity<Buffer>,\n        _completion_indices: Vec<usize>,\n        _completions: Rc<RefCell<Box<[Completion]>>>,\n        _cx: &mut Context<Editor>,\n    ) -> Task<Result<bool>> {\n        Task::ready(Ok(false))\n    }\n\n    fn apply_additional_edits_for_completion(\n        &self,\n        _buffer: Entity<Buffer>,\n        _completions: Rc<RefCell<Box<[Completion]>>>,\n        _completion_index: usize,\n        _push_to_history: bool,\n        _cx: &mut Context<Editor>,\n    ) -> Task<Result<Option<language::Transaction>>> {\n        Task::ready(Ok(None))\n    }\n\n    fn is_completion_trigger(\n        &self,\n        buffer: &Entity<Buffer>,\n        position: language::Anchor,\n        text: &str,\n        trigger_in_words: bool,\n        menu_is_open: bool,\n        cx: &mut Context<Editor>,\n    ) -> bool;\n\n    fn selection_changed(&self, _mat: Option<&StringMatch>, _window: &mut Window, _cx: &mut App) {}\n\n    fn sort_completions(&self) -> bool {\n        true\n    }\n\n    fn filter_completions(&self) -> bool {\n        true\n    }\n\n    fn show_snippets(&self) -> bool {\n        false\n    }\n}\n\npub trait CodeActionProvider {\n    fn id(&self) -> Arc<str>;\n\n    fn code_actions(\n        &self,\n        buffer: &Entity<Buffer>,\n        range: Range<text::Anchor>,\n        window: &mut Window,\n        cx: &mut App,\n    ) -> Task<Result<Vec<CodeAction>>>;\n\n    fn apply_code_action(\n        &self,\n        buffer_handle: Entity<Buffer>,\n        action: CodeAction,\n        excerpt_id: ExcerptId,\n        push_to_history: bool,\n        window: &mut Window,\n        cx: &mut App,\n    ) -> Task<Result<ProjectTransaction>>;\n}\n\nimpl CodeActionProvider for Entity<Project> {\n    fn id(&self) -> Arc<str> {\n        ": "",
        ".into()\n    }\n\n    fn code_actions(\n        &self,\n        buffer: &Entity<Buffer>,\n        range: Range<text::Anchor>,\n        _window: &mut Window,\n        cx: &mut App,\n    ) -> Task<Result<Vec<CodeAction>>> {\n        self.update(cx, |project, cx| {\n            let code_lens_actions = project.code_lens_actions(buffer, range.clone(), cx);\n            let code_actions = project.code_actions(buffer, range, None, cx);\n            cx.background_spawn(async move {\n                let (code_lens_actions, code_actions) = join(code_lens_actions, code_actions).await;\n                Ok(code_lens_actions\n                    .context(": "",
        ")?\n                    .into_iter()\n                    .flatten()\n                    .chain(\n                        code_actions\n                            .context(": "",
        ")?\n                            .into_iter()\n                            .flatten(),\n                    )\n                    .collect())\n            })\n        })\n    }\n\n    fn apply_code_action(\n        &self,\n        buffer_handle: Entity<Buffer>,\n        action: CodeAction,\n        _excerpt_id: ExcerptId,\n        push_to_history: bool,\n        _window: &mut Window,\n        cx: &mut App,\n    ) -> Task<Result<ProjectTransaction>> {\n        self.update(cx, |project, cx| {\n            project.apply_code_action(buffer_handle, action, push_to_history, cx)\n        })\n    }\n}\n\nfn snippet_completions(\n    project: &Project,\n    buffer: &Entity<Buffer>,\n    buffer_position: text::Anchor,\n    cx: &mut App,\n) -> Task<Result<CompletionResponse>> {\n    let languages = buffer.read(cx).languages_at(buffer_position);\n    let snippet_store = project.snippets().read(cx);\n\n    let scopes: Vec<_> = languages\n        .iter()\n        .filter_map(|language| {\n            let language_name = language.lsp_id();\n            let snippets = snippet_store.snippets_for(Some(language_name), cx);\n\n            if snippets.is_empty() {\n                None\n            } else {\n                Some((language.default_scope(), snippets))\n            }\n        })\n        .collect();\n\n    if scopes.is_empty() {\n        return Task::ready(Ok(CompletionResponse {\n            completions: vec![],\n            display_options: CompletionDisplayOptions::default(),\n            is_incomplete: false,\n        }));\n    }\n\n    let snapshot = buffer.read(cx).text_snapshot();\n    let executor = cx.background_executor().clone();\n\n    cx.background_spawn(async move {\n        let mut is_incomplete = false;\n        let mut completions: Vec<Completion> = Vec::new();\n        for (scope, snippets) in scopes.into_iter() {\n            let classifier =\n                CharClassifier::new(Some(scope)).scope_context(Some(CharScopeContext::Completion));\n\n            const MAX_WORD_PREFIX_LEN: usize = 128;\n            let last_word: String = snapshot\n                .reversed_chars_for_range(text::Anchor::MIN..buffer_position)\n                .take(MAX_WORD_PREFIX_LEN)\n                .take_while(|c| classifier.is_word(*c))\n                .collect::<String>()\n                .chars()\n                .rev()\n                .collect();\n\n            if last_word.is_empty() {\n                return Ok(CompletionResponse {\n                    completions: vec![],\n                    display_options: CompletionDisplayOptions::default(),\n                    is_incomplete: true,\n                });\n            }\n\n            let as_offset = text::ToOffset::to_offset(&buffer_position, &snapshot);\n            let to_lsp = |point: &text::Anchor| {\n                let end = text::ToPointUtf16::to_point_utf16(point, &snapshot);\n                point_to_lsp(end)\n            };\n            let lsp_end = to_lsp(&buffer_position);\n\n            let candidates = snippets\n                .iter()\n                .enumerate()\n                .flat_map(|(ix, snippet)| {\n                    snippet\n                        .prefix\n                        .iter()\n                        .map(move |prefix| StringMatchCandidate::new(ix, prefix))\n                })\n                .collect::<Vec<StringMatchCandidate>>();\n\n            const MAX_RESULTS: usize = 100;\n            let mut matches = fuzzy::match_strings(\n                &candidates,\n                &last_word,\n                last_word.chars().any(|c| c.is_uppercase()),\n                true,\n                MAX_RESULTS,\n                &Default::default(),\n                executor.clone(),\n            )\n            .await;\n\n            if matches.len() >= MAX_RESULTS {\n                is_incomplete = true;\n            }\n\n            // Remove all candidates where the query's start does not match the start of any word in the candidate\n            if let Some(query_start) = last_word.chars().next() {\n                matches.retain(|string_match| {\n                    split_words(&string_match.string).any(|word| {\n                        // Check that the first codepoint of the word as lowercase matches the first\n                        // codepoint of the query as lowercase\n                        word.chars()\n                            .flat_map(|codepoint| codepoint.to_lowercase())\n                            .zip(query_start.to_lowercase())\n                            .all(|(word_cp, query_cp)| word_cp == query_cp)\n                    })\n                });\n            }\n\n            let matched_strings = matches\n                .into_iter()\n                .map(|m| m.string)\n                .collect::<HashSet<_>>();\n\n            completions.extend(snippets.iter().filter_map(|snippet| {\n                let matching_prefix = snippet\n                    .prefix\n                    .iter()\n                    .find(|prefix| matched_strings.contains(*prefix))?;\n                let start = as_offset - last_word.len();\n                let start = snapshot.anchor_before(start);\n                let range = start..buffer_position;\n                let lsp_start = to_lsp(&start);\n                let lsp_range = lsp::Range {\n                    start: lsp_start,\n                    end: lsp_end,\n                };\n                Some(Completion {\n                    replace_range: range,\n                    new_text: snippet.body.clone(),\n                    source: CompletionSource::Lsp {\n                        insert_range: None,\n                        server_id: LanguageServerId(usize::MAX),\n                        resolved: true,\n                        lsp_completion: Box::new(lsp::CompletionItem {\n                            label: snippet.prefix.first().unwrap().clone(),\n                            kind: Some(CompletionItemKind::SNIPPET),\n                            label_details: snippet.description.as_ref().map(|description| {\n                                lsp::CompletionItemLabelDetails {\n                                    detail: Some(description.clone()),\n                                    description: None,\n                                }\n                            }),\n                            insert_text_format: Some(InsertTextFormat::SNIPPET),\n                            text_edit: Some(lsp::CompletionTextEdit::InsertAndReplace(\n                                lsp::InsertReplaceEdit {\n                                    new_text: snippet.body.clone(),\n                                    insert: lsp_range,\n                                    replace: lsp_range,\n                                },\n                            )),\n                            filter_text: Some(snippet.body.clone()),\n                            sort_text: Some(char::MAX.to_string()),\n                            ..lsp::CompletionItem::default()\n                        }),\n                        lsp_defaults: None,\n                    },\n                    label: CodeLabel::plain(matching_prefix.clone(), None),\n                    icon_path: None,\n                    documentation: Some(CompletionDocumentation::SingleLineAndMultiLinePlainText {\n                        single_line: snippet.name.clone().into(),\n                        plain_text: snippet\n                            .description\n                            .clone()\n                            .map(|description| description.into()),\n                    }),\n                    insert_text_mode: None,\n                    confirm: None,\n                })\n            }))\n        }\n\n        Ok(CompletionResponse {\n            completions,\n            display_options: CompletionDisplayOptions::default(),\n            is_incomplete,\n        })\n    })\n}\n\nimpl CompletionProvider for Entity<Project> {\n    fn completions(\n        &self,\n        _excerpt_id: ExcerptId,\n        buffer: &Entity<Buffer>,\n        buffer_position: text::Anchor,\n        options: CompletionContext,\n        _window: &mut Window,\n        cx: &mut Context<Editor>,\n    ) -> Task<Result<Vec<CompletionResponse>>> {\n        self.update(cx, |project, cx| {\n            let task = project.completions(buffer, buffer_position, options, cx);\n            cx.background_spawn(task)\n        })\n    }\n\n    fn resolve_completions(\n        &self,\n        buffer: Entity<Buffer>,\n        completion_indices: Vec<usize>,\n        completions: Rc<RefCell<Box<[Completion]>>>,\n        cx: &mut Context<Editor>,\n    ) -> Task<Result<bool>> {\n        self.update(cx, |project, cx| {\n            project.lsp_store().update(cx, |lsp_store, cx| {\n                lsp_store.resolve_completions(buffer, completion_indices, completions, cx)\n            })\n        })\n    }\n\n    fn apply_additional_edits_for_completion(\n        &self,\n        buffer: Entity<Buffer>,\n        completions: Rc<RefCell<Box<[Completion]>>>,\n        completion_index: usize,\n        push_to_history: bool,\n        cx: &mut Context<Editor>,\n    ) -> Task<Result<Option<language::Transaction>>> {\n        self.update(cx, |project, cx| {\n            project.lsp_store().update(cx, |lsp_store, cx| {\n                lsp_store.apply_additional_edits_for_completion(\n                    buffer,\n                    completions,\n                    completion_index,\n                    push_to_history,\n                    cx,\n                )\n            })\n        })\n    }\n\n    fn is_completion_trigger(\n        &self,\n        buffer: &Entity<Buffer>,\n        position: language::Anchor,\n        text: &str,\n        trigger_in_words: bool,\n        menu_is_open: bool,\n        cx: &mut Context<Editor>,\n    ) -> bool {\n        let mut chars = text.chars();\n        let char = if let Some(char) = chars.next() {\n            char\n        } else {\n            return false;\n        };\n        if chars.next().is_some() {\n            return false;\n        }\n\n        let buffer = buffer.read(cx);\n        let snapshot = buffer.snapshot();\n        if !menu_is_open && !snapshot.settings_at(position, cx).show_completions_on_input {\n            return false;\n        }\n        let classifier = snapshot\n            .char_classifier_at(position)\n            .scope_context(Some(CharScopeContext::Completion));\n        if trigger_in_words && classifier.is_word(char) {\n            return true;\n        }\n\n        buffer.completion_triggers().contains(text)\n    }\n\n    fn show_snippets(&self) -> bool {\n        true\n    }\n}\n\nimpl SemanticsProvider for Entity<Project> {\n    fn hover(\n        &self,\n        buffer: &Entity<Buffer>,\n        position: text::Anchor,\n        cx: &mut App,\n    ) -> Option<Task<Option<Vec<project::Hover>>>> {\n        Some(self.update(cx, |project, cx| project.hover(buffer, position, cx)))\n    }\n\n    fn document_highlights(\n        &self,\n        buffer: &Entity<Buffer>,\n        position: text::Anchor,\n        cx: &mut App,\n    ) -> Option<Task<Result<Vec<DocumentHighlight>>>> {\n        Some(self.update(cx, |project, cx| {\n            project.document_highlights(buffer, position, cx)\n        }))\n    }\n\n    fn definitions(\n        &self,\n        buffer: &Entity<Buffer>,\n        position: text::Anchor,\n        kind: GotoDefinitionKind,\n        cx: &mut App,\n    ) -> Option<Task<Result<Option<Vec<LocationLink>>>>> {\n        Some(self.update(cx, |project, cx| match kind {\n            GotoDefinitionKind::Symbol => project.definitions(buffer, position, cx),\n            GotoDefinitionKind::Declaration => project.declarations(buffer, position, cx),\n            GotoDefinitionKind::Type => project.type_definitions(buffer, position, cx),\n            GotoDefinitionKind::Implementation => project.implementations(buffer, position, cx),\n        }))\n    }\n\n    fn supports_inlay_hints(&self, buffer: &Entity<Buffer>, cx: &mut App) -> bool {\n        self.update(cx, |project, cx| {\n            if project\n                .active_debug_session(cx)\n                .is_some_and(|(session, _)| session.read(cx).any_stopped_thread())\n            {\n                return true;\n            }\n\n            buffer.update(cx, |buffer, cx| {\n                project.any_language_server_supports_inlay_hints(buffer, cx)\n            })\n        })\n    }\n\n    fn inline_values(\n        &self,\n        buffer_handle: Entity<Buffer>,\n        range: Range<text::Anchor>,\n        cx: &mut App,\n    ) -> Option<Task<anyhow::Result<Vec<InlayHint>>>> {\n        self.update(cx, |project, cx| {\n            let (session, active_stack_frame) = project.active_debug_session(cx)?;\n\n            Some(project.inline_values(session, active_stack_frame, buffer_handle, range, cx))\n        })\n    }\n\n    fn applicable_inlay_chunks(\n        &self,\n        buffer: &Entity<Buffer>,\n        ranges: &[Range<text::Anchor>],\n        cx: &mut App,\n    ) -> Vec<Range<BufferRow>> {\n        self.read(cx).lsp_store().update(cx, |lsp_store, cx| {\n            lsp_store.applicable_inlay_chunks(buffer, ranges, cx)\n        })\n    }\n\n    fn invalidate_inlay_hints(&self, for_buffers: &HashSet<BufferId>, cx: &mut App) {\n        self.read(cx).lsp_store().update(cx, |lsp_store, _| {\n            lsp_store.invalidate_inlay_hints(for_buffers)\n        });\n    }\n\n    fn inlay_hints(\n        &self,\n        invalidate: InvalidationStrategy,\n        buffer: Entity<Buffer>,\n        ranges: Vec<Range<text::Anchor>>,\n        known_chunks: Option<(clock::Global, HashSet<Range<BufferRow>>)>,\n        cx: &mut App,\n    ) -> Option<HashMap<Range<BufferRow>, Task<Result<CacheInlayHints>>>> {\n        Some(self.read(cx).lsp_store().update(cx, |lsp_store, cx| {\n            lsp_store.inlay_hints(invalidate, buffer, ranges, known_chunks, cx)\n        }))\n    }\n\n    fn range_for_rename(\n        &self,\n        buffer: &Entity<Buffer>,\n        position: text::Anchor,\n        cx: &mut App,\n    ) -> Option<Task<Result<Option<Range<text::Anchor>>>>> {\n        Some(self.update(cx, |project, cx| {\n            let buffer = buffer.clone();\n            let task = project.prepare_rename(buffer.clone(), position, cx);\n            cx.spawn(async move |_, cx| {\n                Ok(match task.await? {\n                    PrepareRenameResponse::Success(range) => Some(range),\n                    PrepareRenameResponse::InvalidPosition => None,\n                    PrepareRenameResponse::OnlyUnpreparedRenameSupported => {\n                        // Fallback on using TreeSitter info to determine identifier range\n                        buffer.read_with(cx, |buffer, _| {\n                            let snapshot = buffer.snapshot();\n                            let (range, kind) = snapshot.surrounding_word(position, None);\n                            if kind != Some(CharKind::Word) {\n                                return None;\n                            }\n                            Some(\n                                snapshot.anchor_before(range.start)\n                                    ..snapshot.anchor_after(range.end),\n                            )\n                        })?\n                    }\n                })\n            })\n        }))\n    }\n\n    fn perform_rename(\n        &self,\n        buffer: &Entity<Buffer>,\n        position: text::Anchor,\n        new_name: String,\n        cx: &mut App,\n    ) -> Option<Task<Result<ProjectTransaction>>> {\n        Some(self.update(cx, |project, cx| {\n            project.perform_rename(buffer.clone(), position, new_name, cx)\n        }))\n    }\n}\n\nfn consume_contiguous_rows(\n    contiguous_row_selections: &mut Vec<Selection<Point>>,\n    selection: &Selection<Point>,\n    display_map: &DisplaySnapshot,\n    selections: &mut Peekable<std::slice::Iter<Selection<Point>>>,\n) -> (MultiBufferRow, MultiBufferRow) {\n    contiguous_row_selections.push(selection.clone());\n    let start_row = starting_row(selection, display_map);\n    let mut end_row = ending_row(selection, display_map);\n\n    while let Some(next_selection) = selections.peek() {\n        if next_selection.start.row <= end_row.0 {\n            end_row = ending_row(next_selection, display_map);\n            contiguous_row_selections.push(selections.next().unwrap().clone());\n        } else {\n            break;\n        }\n    }\n    (start_row, end_row)\n}\n\nfn starting_row(selection: &Selection<Point>, display_map: &DisplaySnapshot) -> MultiBufferRow {\n    if selection.start.column > 0 {\n        MultiBufferRow(display_map.prev_line_boundary(selection.start).0.row)\n    } else {\n        MultiBufferRow(selection.start.row)\n    }\n}\n\nfn ending_row(next_selection: &Selection<Point>, display_map: &DisplaySnapshot) -> MultiBufferRow {\n    if next_selection.end.column > 0 || next_selection.is_empty() {\n        MultiBufferRow(display_map.next_line_boundary(next_selection.end).0.row + 1)\n    } else {\n        MultiBufferRow(next_selection.end.row)\n    }\n}\n\nimpl EditorSnapshot {\n    pub fn remote_selections_in_range<'a>(\n        &'a self,\n        range: &'a Range<Anchor>,\n        collaboration_hub: &dyn CollaborationHub,\n        cx: &'a App,\n    ) -> impl 'a + Iterator<Item = RemoteSelection> {\n        let participant_names = collaboration_hub.user_names(cx);\n        let participant_indices = collaboration_hub.user_participant_indices(cx);\n        let collaborators_by_peer_id = collaboration_hub.collaborators(cx);\n        let collaborators_by_replica_id = collaborators_by_peer_id\n            .values()\n            .map(|collaborator| (collaborator.replica_id, collaborator))\n            .collect::<HashMap<_, _>>();\n        self.buffer_snapshot()\n            .selections_in_range(range, false)\n            .filter_map(move |(replica_id, line_mode, cursor_shape, selection)| {\n                if replica_id == ReplicaId::AGENT {\n                    Some(RemoteSelection {\n                        replica_id,\n                        selection,\n                        cursor_shape,\n                        line_mode,\n                        collaborator_id: CollaboratorId::Agent,\n                        user_name: Some(": "",
        ".into()),\n                        color: cx.theme().players().agent(),\n                    })\n                } else {\n                    let collaborator = collaborators_by_replica_id.get(&replica_id)?;\n                    let participant_index = participant_indices.get(&collaborator.user_id).copied();\n                    let user_name = participant_names.get(&collaborator.user_id).cloned();\n                    Some(RemoteSelection {\n                        replica_id,\n                        selection,\n                        cursor_shape,\n                        line_mode,\n                        collaborator_id: CollaboratorId::PeerId(collaborator.peer_id),\n                        user_name,\n                        color: if let Some(index) = participant_index {\n                            cx.theme().players().color_for_participant(index.0)\n                        } else {\n                            cx.theme().players().absent()\n                        },\n                    })\n                }\n            })\n    }\n\n    pub fn hunks_for_ranges(\n        &self,\n        ranges: impl IntoIterator<Item = Range<Point>>,\n    ) -> Vec<MultiBufferDiffHunk> {\n        let mut hunks = Vec::new();\n        let mut processed_buffer_rows: HashMap<BufferId, HashSet<Range<text::Anchor>>> =\n            HashMap::default();\n        for query_range in ranges {\n            let query_rows =\n                MultiBufferRow(query_range.start.row)..MultiBufferRow(query_range.end.row + 1);\n            for hunk in self.buffer_snapshot().diff_hunks_in_range(\n                Point::new(query_rows.start.0, 0)..Point::new(query_rows.end.0, 0),\n            ) {\n                // Include deleted hunks that are adjacent to the query range, because\n                // otherwise they would be missed.\n                let mut intersects_range = hunk.row_range.overlaps(&query_rows);\n                if hunk.status().is_deleted() {\n                    intersects_range |= hunk.row_range.start == query_rows.end;\n                    intersects_range |= hunk.row_range.end == query_rows.start;\n                }\n                if intersects_range {\n                    if !processed_buffer_rows\n                        .entry(hunk.buffer_id)\n                        .or_default()\n                        .insert(hunk.buffer_range.start..hunk.buffer_range.end)\n                    {\n                        continue;\n                    }\n                    hunks.push(hunk);\n                }\n            }\n        }\n\n        hunks\n    }\n\n    fn display_diff_hunks_for_rows<'a>(\n        &'a self,\n        display_rows: Range<DisplayRow>,\n        folded_buffers: &'a HashSet<BufferId>,\n    ) -> impl 'a + Iterator<Item = DisplayDiffHunk> {\n        let buffer_start = DisplayPoint::new(display_rows.start, 0).to_point(self);\n        let buffer_end = DisplayPoint::new(display_rows.end, 0).to_point(self);\n\n        self.buffer_snapshot()\n            .diff_hunks_in_range(buffer_start..buffer_end)\n            .filter_map(|hunk| {\n                if folded_buffers.contains(&hunk.buffer_id) {\n                    return None;\n                }\n\n                let hunk_start_point = Point::new(hunk.row_range.start.0, 0);\n                let hunk_end_point = Point::new(hunk.row_range.end.0, 0);\n\n                let hunk_display_start = self.point_to_display_point(hunk_start_point, Bias::Left);\n                let hunk_display_end = self.point_to_display_point(hunk_end_point, Bias::Right);\n\n                let display_hunk = if hunk_display_start.column() != 0 {\n                    DisplayDiffHunk::Folded {\n                        display_row: hunk_display_start.row(),\n                    }\n                } else {\n                    let mut end_row = hunk_display_end.row();\n                    if hunk_display_end.column() > 0 {\n                        end_row.0 += 1;\n                    }\n                    let is_created_file = hunk.is_created_file();\n                    DisplayDiffHunk::Unfolded {\n                        status: hunk.status(),\n                        diff_base_byte_range: hunk.diff_base_byte_range,\n                        display_row_range: hunk_display_start.row()..end_row,\n                        multi_buffer_range: Anchor::range_in_buffer(\n                            hunk.excerpt_id,\n                            hunk.buffer_id,\n                            hunk.buffer_range,\n                        ),\n                        is_created_file,\n                    }\n                };\n\n                Some(display_hunk)\n            })\n    }\n\n    pub fn language_at<T: ToOffset>(&self, position: T) -> Option<&Arc<Language>> {\n        self.display_snapshot\n            .buffer_snapshot()\n            .language_at(position)\n    }\n\n    pub fn is_focused(&self) -> bool {\n        self.is_focused\n    }\n\n    pub fn placeholder_text(&self) -> Option<String> {\n        self.placeholder_display_snapshot\n            .as_ref()\n            .map(|display_map| display_map.text())\n    }\n\n    pub fn scroll_position(&self) -> gpui::Point<ScrollOffset> {\n        self.scroll_anchor.scroll_position(&self.display_snapshot)\n    }\n\n    fn gutter_dimensions(\n        &self,\n        font_id: FontId,\n        font_size: Pixels,\n        max_line_number_width: Pixels,\n        cx: &App,\n    ) -> Option<GutterDimensions> {\n        if !self.show_gutter {\n            return None;\n        }\n\n        let ch_width = cx.text_system().ch_width(font_id, font_size).log_err()?;\n        let ch_advance = cx.text_system().ch_advance(font_id, font_size).log_err()?;\n\n        let show_git_gutter = self.show_git_diff_gutter.unwrap_or_else(|| {\n            matches!(\n                ProjectSettings::get_global(cx).git.git_gutter,\n                GitGutterSetting::TrackedFiles\n            )\n        });\n        let gutter_settings = EditorSettings::get_global(cx).gutter;\n        let show_line_numbers = self\n            .show_line_numbers\n            .unwrap_or(gutter_settings.line_numbers);\n        let line_gutter_width = if show_line_numbers {\n            // Avoid flicker-like gutter resizes when the line number gains another digit by\n            // only resizing the gutter on files with > 10**min_line_number_digits lines.\n            let min_width_for_number_on_gutter =\n                ch_advance * gutter_settings.min_line_number_digits as f32;\n            max_line_number_width.max(min_width_for_number_on_gutter)\n        } else {\n            0.0.into()\n        };\n\n        let show_runnables = self.show_runnables.unwrap_or(gutter_settings.runnables);\n        let show_breakpoints = self.show_breakpoints.unwrap_or(gutter_settings.breakpoints);\n\n        let git_blame_entries_width =\n            self.git_blame_gutter_max_author_length\n                .map(|max_author_length| {\n                    let renderer = cx.global::<GlobalBlameRenderer>().0.clone();\n                    const MAX_RELATIVE_TIMESTAMP: &str = ": "",
        ";\n\n                    /// The number of characters to dedicate to gaps and margins.\n                    const SPACING_WIDTH: usize = 4;\n\n                    let max_char_count = max_author_length.min(renderer.max_author_length())\n                        + ::git::SHORT_SHA_LENGTH\n                        + MAX_RELATIVE_TIMESTAMP.len()\n                        + SPACING_WIDTH;\n\n                    ch_advance * max_char_count\n                });\n\n        let is_singleton = self.buffer_snapshot().is_singleton();\n\n        let mut left_padding = git_blame_entries_width.unwrap_or(Pixels::ZERO);\n        left_padding += if !is_singleton {\n            ch_width * 4.0\n        } else if show_runnables || show_breakpoints {\n            ch_width * 3.0\n        } else if show_git_gutter && show_line_numbers {\n            ch_width * 2.0\n        } else if show_git_gutter || show_line_numbers {\n            ch_width\n        } else {\n            px(0.)\n        };\n\n        let shows_folds = is_singleton && gutter_settings.folds;\n\n        let right_padding = if shows_folds && show_line_numbers {\n            ch_width * 4.0\n        } else if shows_folds || (!is_singleton && show_line_numbers) {\n            ch_width * 3.0\n        } else if show_line_numbers {\n            ch_width\n        } else {\n            px(0.)\n        };\n\n        Some(GutterDimensions {\n            left_padding,\n            right_padding,\n            width: line_gutter_width + left_padding + right_padding,\n            margin: GutterDimensions::default_gutter_margin(font_id, font_size, cx),\n            git_blame_entries_width,\n        })\n    }\n\n    pub fn render_crease_toggle(\n        &self,\n        buffer_row: MultiBufferRow,\n        row_contains_cursor: bool,\n        editor: Entity<Editor>,\n        window: &mut Window,\n        cx: &mut App,\n    ) -> Option<AnyElement> {\n        let folded = self.is_line_folded(buffer_row);\n        let mut is_foldable = false;\n\n        if let Some(crease) = self\n            .crease_snapshot\n            .query_row(buffer_row, self.buffer_snapshot())\n        {\n            is_foldable = true;\n            match crease {\n                Crease::Inline { render_toggle, .. } | Crease::Block { render_toggle, .. } => {\n                    if let Some(render_toggle) = render_toggle {\n                        let toggle_callback =\n                            Arc::new(move |folded, window: &mut Window, cx: &mut App| {\n                                if folded {\n                                    editor.update(cx, |editor, cx| {\n                                        editor.fold_at(buffer_row, window, cx)\n                                    });\n                                } else {\n                                    editor.update(cx, |editor, cx| {\n                                        editor.unfold_at(buffer_row, window, cx)\n                                    });\n                                }\n                            });\n                        return Some((render_toggle)(\n                            buffer_row,\n                            folded,\n                            toggle_callback,\n                            window,\n                            cx,\n                        ));\n                    }\n                }\n            }\n        }\n\n        is_foldable |= self.starts_indent(buffer_row);\n\n        if folded || (is_foldable && (row_contains_cursor || self.gutter_hovered)) {\n            Some(\n                Disclosure::new((": "",
        ", buffer_row.0), !folded)\n                    .toggle_state(folded)\n                    .on_click(window.listener_for(&editor, move |this, _e, window, cx| {\n                        if folded {\n                            this.unfold_at(buffer_row, window, cx);\n                        } else {\n                            this.fold_at(buffer_row, window, cx);\n                        }\n                    }))\n                    .into_any_element(),\n            )\n        } else {\n            None\n        }\n    }\n\n    pub fn render_crease_trailer(\n        &self,\n        buffer_row: MultiBufferRow,\n        window: &mut Window,\n        cx: &mut App,\n    ) -> Option<AnyElement> {\n        let folded = self.is_line_folded(buffer_row);\n        if let Crease::Inline { render_trailer, .. } = self\n            .crease_snapshot\n            .query_row(buffer_row, self.buffer_snapshot())?\n        {\n            let render_trailer = render_trailer.as_ref()?;\n            Some(render_trailer(buffer_row, folded, window, cx))\n        } else {\n            None\n        }\n    }\n}\n\nimpl Deref for EditorSnapshot {\n    type Target = DisplaySnapshot;\n\n    fn deref(&self) -> &Self::Target {\n        &self.display_snapshot\n    }\n}\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub enum EditorEvent {\n    InputIgnored {\n        text: Arc<str>,\n    },\n    InputHandled {\n        utf16_range_to_replace: Option<Range<isize>>,\n        text: Arc<str>,\n    },\n    ExcerptsAdded {\n        buffer: Entity<Buffer>,\n        predecessor: ExcerptId,\n        excerpts: Vec<(ExcerptId, ExcerptRange<language::Anchor>)>,\n    },\n    ExcerptsRemoved {\n        ids: Vec<ExcerptId>,\n        removed_buffer_ids: Vec<BufferId>,\n    },\n    BufferFoldToggled {\n        ids: Vec<ExcerptId>,\n        folded: bool,\n    },\n    ExcerptsEdited {\n        ids: Vec<ExcerptId>,\n    },\n    ExcerptsExpanded {\n        ids: Vec<ExcerptId>,\n    },\n    BufferEdited,\n    Edited {\n        transaction_id: clock::Lamport,\n    },\n    Reparsed(BufferId),\n    Focused,\n    FocusedIn,\n    Blurred,\n    DirtyChanged,\n    Saved,\n    TitleChanged,\n    SelectionsChanged {\n        local: bool,\n    },\n    ScrollPositionChanged {\n        local: bool,\n        autoscroll: bool,\n    },\n    TransactionUndone {\n        transaction_id: clock::Lamport,\n    },\n    TransactionBegun {\n        transaction_id: clock::Lamport,\n    },\n    CursorShapeChanged,\n    BreadcrumbsChanged,\n    PushedToNavHistory {\n        anchor: Anchor,\n        is_deactivate: bool,\n    },\n}\n\nimpl EventEmitter<EditorEvent> for Editor {}\n\nimpl Focusable for Editor {\n    fn focus_handle(&self, _cx: &App) -> FocusHandle {\n        self.focus_handle.clone()\n    }\n}\n\nimpl Render for Editor {\n    fn render(&mut self, _: &mut Window, cx: &mut Context<Self>) -> impl IntoElement {\n        let settings = ThemeSettings::get_global(cx);\n\n        let mut text_style = match self.mode {\n            EditorMode::SingleLine | EditorMode::AutoHeight { .. } => TextStyle {\n                color: cx.theme().colors().editor_foreground,\n                font_family: settings.ui_font.family.clone(),\n                font_features: settings.ui_font.features.clone(),\n                font_fallbacks: settings.ui_font.fallbacks.clone(),\n                font_size: rems(0.875).into(),\n                font_weight: settings.ui_font.weight,\n                line_height: relative(settings.buffer_line_height.value()),\n                ..Default::default()\n            },\n            EditorMode::Full { .. } | EditorMode::Minimap { .. } => TextStyle {\n                color: cx.theme().colors().editor_foreground,\n                font_family: settings.buffer_font.family.clone(),\n                font_features: settings.buffer_font.features.clone(),\n                font_fallbacks: settings.buffer_font.fallbacks.clone(),\n                font_size: settings.buffer_font_size(cx).into(),\n                font_weight: settings.buffer_font.weight,\n                line_height: relative(settings.buffer_line_height.value()),\n                ..Default::default()\n            },\n        };\n        if let Some(text_style_refinement) = &self.text_style_refinement {\n            text_style.refine(text_style_refinement)\n        }\n\n        let background = match self.mode {\n            EditorMode::SingleLine => cx.theme().system().transparent,\n            EditorMode::AutoHeight { .. } => cx.theme().system().transparent,\n            EditorMode::Full { .. } => cx.theme().colors().editor_background,\n            EditorMode::Minimap { .. } => cx.theme().colors().editor_background.opacity(0.7),\n        };\n\n        EditorElement::new(\n            &cx.entity(),\n            EditorStyle {\n                background,\n                border: cx.theme().colors().border,\n                local_player: cx.theme().players().local(),\n                text: text_style,\n                scrollbar_width: EditorElement::SCROLLBAR_WIDTH,\n                syntax: cx.theme().syntax().clone(),\n                status: cx.theme().status().clone(),\n                inlay_hints_style: make_inlay_hints_style(cx),\n                edit_prediction_styles: make_suggestion_styles(cx),\n                unnecessary_code_fade: ThemeSettings::get_global(cx).unnecessary_code_fade,\n                show_underlines: self.diagnostics_enabled(),\n            },\n        )\n    }\n}\n\nimpl EntityInputHandler for Editor {\n    fn text_for_range(\n        &mut self,\n        range_utf16: Range<usize>,\n        adjusted_range: &mut Option<Range<usize>>,\n        _: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<String> {\n        let snapshot = self.buffer.read(cx).read(cx);\n        let start = snapshot.clip_offset_utf16(OffsetUtf16(range_utf16.start), Bias::Left);\n        let end = snapshot.clip_offset_utf16(OffsetUtf16(range_utf16.end), Bias::Right);\n        if (start.0..end.0) != range_utf16 {\n            adjusted_range.replace(start.0..end.0);\n        }\n        Some(snapshot.text_for_range(start..end).collect())\n    }\n\n    fn selected_text_range(\n        &mut self,\n        ignore_disabled_input: bool,\n        _: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<UTF16Selection> {\n        // Prevent the IME menu from appearing when holding down an alphabetic key\n        // while input is disabled.\n        if !ignore_disabled_input && !self.input_enabled {\n            return None;\n        }\n\n        let selection = self\n            .selections\n            .newest::<OffsetUtf16>(&self.display_snapshot(cx));\n        let range = selection.range();\n\n        Some(UTF16Selection {\n            range: range.start.0..range.end.0,\n            reversed: selection.reversed,\n        })\n    }\n\n    fn marked_text_range(&self, _: &mut Window, cx: &mut Context<Self>) -> Option<Range<usize>> {\n        let snapshot = self.buffer.read(cx).read(cx);\n        let range = self.text_highlights::<InputComposition>(cx)?.1.first()?;\n        Some(range.start.to_offset_utf16(&snapshot).0..range.end.to_offset_utf16(&snapshot).0)\n    }\n\n    fn unmark_text(&mut self, _: &mut Window, cx: &mut Context<Self>) {\n        self.clear_highlights::<InputComposition>(cx);\n        self.ime_transaction.take();\n    }\n\n    fn replace_text_in_range(\n        &mut self,\n        range_utf16: Option<Range<usize>>,\n        text: &str,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if !self.input_enabled {\n            cx.emit(EditorEvent::InputIgnored { text: text.into() });\n            return;\n        }\n\n        self.transact(window, cx, |this, window, cx| {\n            let new_selected_ranges = if let Some(range_utf16) = range_utf16 {\n                let range_utf16 = OffsetUtf16(range_utf16.start)..OffsetUtf16(range_utf16.end);\n                Some(this.selection_replacement_ranges(range_utf16, cx))\n            } else {\n                this.marked_text_ranges(cx)\n            };\n\n            let range_to_replace = new_selected_ranges.as_ref().and_then(|ranges_to_replace| {\n                let newest_selection_id = this.selections.newest_anchor().id;\n                this.selections\n                    .all::<OffsetUtf16>(&this.display_snapshot(cx))\n                    .iter()\n                    .zip(ranges_to_replace.iter())\n                    .find_map(|(selection, range)| {\n                        if selection.id == newest_selection_id {\n                            Some(\n                                (range.start.0 as isize - selection.head().0 as isize)\n                                    ..(range.end.0 as isize - selection.head().0 as isize),\n                            )\n                        } else {\n                            None\n                        }\n                    })\n            });\n\n            cx.emit(EditorEvent::InputHandled {\n                utf16_range_to_replace: range_to_replace,\n                text: text.into(),\n            });\n\n            if let Some(new_selected_ranges) = new_selected_ranges {\n                this.change_selections(SelectionEffects::no_scroll(), window, cx, |selections| {\n                    selections.select_ranges(new_selected_ranges)\n                });\n                this.backspace(&Default::default(), window, cx);\n            }\n\n            this.handle_input(text, window, cx);\n        });\n\n        if let Some(transaction) = self.ime_transaction {\n            self.buffer.update(cx, |buffer, cx| {\n                buffer.group_until_transaction(transaction, cx);\n            });\n        }\n\n        self.unmark_text(window, cx);\n    }\n\n    fn replace_and_mark_text_in_range(\n        &mut self,\n        range_utf16: Option<Range<usize>>,\n        text: &str,\n        new_selected_range_utf16: Option<Range<usize>>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if !self.input_enabled {\n            return;\n        }\n\n        let transaction = self.transact(window, cx, |this, window, cx| {\n            let ranges_to_replace = if let Some(mut marked_ranges) = this.marked_text_ranges(cx) {\n                let snapshot = this.buffer.read(cx).read(cx);\n                if let Some(relative_range_utf16) = range_utf16.as_ref() {\n                    for marked_range in &mut marked_ranges {\n                        marked_range.end.0 = marked_range.start.0 + relative_range_utf16.end;\n                        marked_range.start.0 += relative_range_utf16.start;\n                        marked_range.start =\n                            snapshot.clip_offset_utf16(marked_range.start, Bias::Left);\n                        marked_range.end =\n                            snapshot.clip_offset_utf16(marked_range.end, Bias::Right);\n                    }\n                }\n                Some(marked_ranges)\n            } else if let Some(range_utf16) = range_utf16 {\n                let range_utf16 = OffsetUtf16(range_utf16.start)..OffsetUtf16(range_utf16.end);\n                Some(this.selection_replacement_ranges(range_utf16, cx))\n            } else {\n                None\n            };\n\n            let range_to_replace = ranges_to_replace.as_ref().and_then(|ranges_to_replace| {\n                let newest_selection_id = this.selections.newest_anchor().id;\n                this.selections\n                    .all::<OffsetUtf16>(&this.display_snapshot(cx))\n                    .iter()\n                    .zip(ranges_to_replace.iter())\n                    .find_map(|(selection, range)| {\n                        if selection.id == newest_selection_id {\n                            Some(\n                                (range.start.0 as isize - selection.head().0 as isize)\n                                    ..(range.end.0 as isize - selection.head().0 as isize),\n                            )\n                        } else {\n                            None\n                        }\n                    })\n            });\n\n            cx.emit(EditorEvent::InputHandled {\n                utf16_range_to_replace: range_to_replace,\n                text: text.into(),\n            });\n\n            if let Some(ranges) = ranges_to_replace {\n                this.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n                    s.select_ranges(ranges)\n                });\n            }\n\n            let marked_ranges = {\n                let snapshot = this.buffer.read(cx).read(cx);\n                this.selections\n                    .disjoint_anchors_arc()\n                    .iter()\n                    .map(|selection| {\n                        selection.start.bias_left(&snapshot)..selection.end.bias_right(&snapshot)\n                    })\n                    .collect::<Vec<_>>()\n            };\n\n            if text.is_empty() {\n                this.unmark_text(window, cx);\n            } else {\n                this.highlight_text::<InputComposition>(\n                    marked_ranges.clone(),\n                    HighlightStyle {\n                        underline: Some(UnderlineStyle {\n                            thickness: px(1.),\n                            color: None,\n                            wavy: false,\n                        }),\n                        ..Default::default()\n                    },\n                    cx,\n                );\n            }\n\n            // Disable auto-closing when composing text (i.e. typing a `": "",
        "Message to log when a breakpoint is hit. Expressions within {} are interpolated.": "",
        "Condition when a breakpoint is hit. Expressions within {} are interpolated.": "",
        "How many breakpoint hits to ignore": "",
        "A multi buffer in breakpoint prompt isn't possible": "",
        "Conflict with Accept Keybinding": "",
        "Your keymap currently overrides the default accept keybinding. To continue, assign one keybinding for the `editor::AcceptEditPrediction` action.": "",
        "open-keymap": "",
        "Assign Keybinding": "",
        "see-docs": "",
        "See Docs": "",
        "stage": "",
        "Stage": "",
        "Stage Hunk": "",
        "unstage": "",
        "Unstage": "",
        "Unstage Hunk": "",
        "restore": "",
        "Restore": "",
        "Restore Hunk": "",
        "next-hunk": "",
        "Next Hunk": "",
        "prev-hunk": "",
        "Previous Hunk": ""
    },
    "zed/crates/editor/src/element.rs": {
        "drag state can never be in ready state after drag": "",
        "The cfg-block below makes this a false positive": "",
        "diagnostic": "",
        "expand": "",
        "Expand Excerpt": "",
        "{number}": "",
        "expects single-row ranges": "",
        "toggle-buffer-fold": "",
        "Toggle Excerpt Fold": "",
        "{} to toggle all": "",
        "click": "",
        "path header block": "",
        "untitled": "",
        "filename-button": "",
        "open-file-button": "",
        "Open file": "",
        "buffer-header-context-menu": "",
        "Copy Path": "",
        "Copy Relative Path": "",
        "Reveal In Project Panel": "",
        "Open in Terminal": "",
        "Visible context menu should always render.": "",
        "crease_toggles": "",
        "expand_toggles": "",
        "crease_trailers": "",
        "minimap": "",
        " ": "",
        "Text": "",
        "Element": "",
        "size": "",
        "len": "",
        "you can't prepaint LineWithInvisibles twice": "",
        "modified diff status for row info": "",
        "blocks": "",
        ",\n                                    line_ix,\n                                    row_infos.len(),\n                                    line_layouts.len(),\n                                    crease_trailers.len(),\n                                );\n                            }\n                        }\n                    }\n\n                    let blamed_display_rows = self.layout_blame_entries(\n                        &row_infos,\n                        em_width,\n                        scroll_position,\n                        line_height,\n                        &gutter_hitbox,\n                        gutter_dimensions.git_blame_entries_width,\n                        window,\n                        cx,\n                    );\n\n                    let line_elements = self.prepaint_lines(\n                        start_row,\n                        &mut line_layouts,\n                        line_height,\n                        scroll_position,\n                        scroll_pixel_position,\n                        content_origin,\n                        window,\n                        cx,\n                    );\n\n                    window.with_element_namespace(": "",
        ", |window| {\n                        self.layout_blocks(\n                            &mut blocks,\n                            &hitbox,\n                            line_height,\n                            scroll_position,\n                            scroll_pixel_position,\n                            window,\n                            cx,\n                        );\n                    });\n\n                    let cursors = self.collect_cursors(&snapshot, cx);\n                    let visible_row_range = start_row..end_row;\n                    let non_visible_cursors = cursors\n                        .iter()\n                        .any(|c| !visible_row_range.contains(&c.0.row()));\n\n                    let visible_cursors = self.layout_visible_cursors(\n                        &snapshot,\n                        &selections,\n                        &row_block_types,\n                        start_row..end_row,\n                        &line_layouts,\n                        &text_hitbox,\n                        content_origin,\n                        scroll_position,\n                        scroll_pixel_position,\n                        line_height,\n                        em_width,\n                        em_advance,\n                        autoscroll_containing_element,\n                        window,\n                        cx,\n                    );\n\n                    let scrollbars_layout = self.layout_scrollbars(\n                        &snapshot,\n                        &scrollbar_layout_information,\n                        content_offset,\n                        scroll_position,\n                        non_visible_cursors,\n                        right_margin,\n                        editor_width,\n                        window,\n                        cx,\n                    );\n\n                    let gutter_settings = EditorSettings::get_global(cx).gutter;\n\n                    let context_menu_layout =\n                        if let Some(newest_selection_head) = newest_selection_head {\n                            let newest_selection_point =\n                                newest_selection_head.to_point(&snapshot.display_snapshot);\n                            if (start_row..end_row).contains(&newest_selection_head.row()) {\n                                self.layout_cursor_popovers(\n                                    line_height,\n                                    &text_hitbox,\n                                    content_origin,\n                                    right_margin,\n                                    start_row,\n                                    scroll_pixel_position,\n                                    &line_layouts,\n                                    newest_selection_head,\n                                    newest_selection_point,\n                                    style,\n                                    window,\n                                    cx,\n                                )\n                            } else {\n                                None\n                            }\n                        } else {\n                            None\n                        };\n\n                    self.layout_gutter_menu(\n                        line_height,\n                        &text_hitbox,\n                        content_origin,\n                        right_margin,\n                        scroll_pixel_position,\n                        gutter_dimensions.width - gutter_dimensions.left_padding,\n                        window,\n                        cx,\n                    );\n\n                    let test_indicators = if gutter_settings.runnables {\n                        self.layout_run_indicators(\n                            line_height,\n                            start_row..end_row,\n                            &row_infos,\n                            scroll_position,\n                            &gutter_dimensions,\n                            &gutter_hitbox,\n                            &display_hunks,\n                            &snapshot,\n                            &mut breakpoint_rows,\n                            window,\n                            cx,\n                        )\n                    } else {\n                        Vec::new()\n                    };\n\n                    let show_breakpoints = snapshot\n                        .show_breakpoints\n                        .unwrap_or(gutter_settings.breakpoints);\n                    let breakpoints = if show_breakpoints {\n                        self.layout_breakpoints(\n                            line_height,\n                            start_row..end_row,\n                            scroll_position,\n                            &gutter_dimensions,\n                            &gutter_hitbox,\n                            &display_hunks,\n                            &snapshot,\n                            breakpoint_rows,\n                            &row_infos,\n                            window,\n                            cx,\n                        )\n                    } else {\n                        Vec::new()\n                    };\n\n                    self.layout_signature_help(\n                        &hitbox,\n                        content_origin,\n                        scroll_pixel_position,\n                        newest_selection_head,\n                        start_row,\n                        &line_layouts,\n                        line_height,\n                        em_width,\n                        context_menu_layout,\n                        window,\n                        cx,\n                    );\n\n                    if !cx.has_active_drag() {\n                        self.layout_hover_popovers(\n                            &snapshot,\n                            &hitbox,\n                            start_row..end_row,\n                            content_origin,\n                            scroll_pixel_position,\n                            &line_layouts,\n                            line_height,\n                            em_width,\n                            context_menu_layout,\n                            window,\n                            cx,\n                        );\n                    }\n\n                    let mouse_context_menu = self.layout_mouse_context_menu(\n                        &snapshot,\n                        start_row..end_row,\n                        content_origin,\n                        window,\n                        cx,\n                    );\n\n                    window.with_element_namespace(": "",
        ", |window| {\n                        self.prepaint_crease_toggles(\n                            &mut crease_toggles,\n                            line_height,\n                            &gutter_dimensions,\n                            gutter_settings,\n                            scroll_pixel_position,\n                            &gutter_hitbox,\n                            window,\n                            cx,\n                        )\n                    });\n\n                    window.with_element_namespace(": "",
        ", |window| {\n                        self.prepaint_expand_toggles(&mut expand_toggles, window, cx)\n                    });\n\n                    let wrap_guides = self.layout_wrap_guides(\n                        em_advance,\n                        scroll_position,\n                        content_origin,\n                        scrollbars_layout.as_ref(),\n                        vertical_scrollbar_width,\n                        &hitbox,\n                        window,\n                        cx,\n                    );\n\n                    let minimap = window.with_element_namespace(": "",
        ", |window| {\n                        self.layout_minimap(\n                            &snapshot,\n                            minimap_width,\n                            scroll_position,\n                            &scrollbar_layout_information,\n                            scrollbars_layout.as_ref(),\n                            window,\n                            cx,\n                        )\n                    });\n\n                    let invisible_symbol_font_size = font_size / 2.;\n                    let whitespace_map = &self\n                        .editor\n                        .read(cx)\n                        .buffer\n                        .read(cx)\n                        .language_settings(cx)\n                        .whitespace_map;\n\n                    let tab_char = whitespace_map.tab.clone();\n                    let tab_len = tab_char.len();\n                    let tab_invisible = window.text_system().shape_line(\n                        tab_char,\n                        invisible_symbol_font_size,\n                        &[TextRun {\n                            len: tab_len,\n                            font: self.style.text.font(),\n                            color: cx.theme().colors().editor_invisible,\n                            ..Default::default()\n                        }],\n                        None,\n                    );\n\n                    let space_char = whitespace_map.space.clone();\n                    let space_len = space_char.len();\n                    let space_invisible = window.text_system().shape_line(\n                        space_char,\n                        invisible_symbol_font_size,\n                        &[TextRun {\n                            len: space_len,\n                            font: self.style.text.font(),\n                            color: cx.theme().colors().editor_invisible,\n                            ..Default::default()\n                        }],\n                        None,\n                    );\n\n                    let mode = snapshot.mode.clone();\n\n                    let (diff_hunk_controls, diff_hunk_control_bounds) = if is_read_only {\n                        (vec![], vec![])\n                    } else {\n                        self.layout_diff_hunk_controls(\n                            start_row..end_row,\n                            &row_infos,\n                            &text_hitbox,\n                            newest_selection_head,\n                            line_height,\n                            right_margin,\n                            scroll_pixel_position,\n                            &display_hunks,\n                            &highlighted_rows,\n                            self.editor.clone(),\n                            window,\n                            cx,\n                        )\n                    };\n\n                    let position_map = Rc::new(PositionMap {\n                        size: bounds.size,\n                        visible_row_range,\n                        scroll_position,\n                        scroll_pixel_position,\n                        scroll_max,\n                        line_layouts,\n                        line_height,\n                        em_width,\n                        em_advance,\n                        snapshot,\n                        gutter_hitbox: gutter_hitbox.clone(),\n                        text_hitbox: text_hitbox.clone(),\n                        inline_blame_bounds: inline_blame_layout\n                            .as_ref()\n                            .map(|layout| (layout.bounds, layout.buffer_id, layout.entry.clone())),\n                        display_hunks: display_hunks.clone(),\n                        diff_hunk_control_bounds,\n                    });\n\n                    self.editor.update(cx, |editor, _| {\n                        editor.last_position_map = Some(position_map.clone())\n                    });\n\n                    EditorLayout {\n                        mode,\n                        position_map,\n                        visible_display_row_range: start_row..end_row,\n                        wrap_guides,\n                        indent_guides,\n                        hitbox,\n                        gutter_hitbox,\n                        display_hunks,\n                        content_origin,\n                        scrollbars_layout,\n                        minimap,\n                        active_rows,\n                        highlighted_rows,\n                        highlighted_ranges,\n                        highlighted_gutter_ranges,\n                        redacted_ranges,\n                        document_colors,\n                        line_elements,\n                        line_numbers,\n                        blamed_display_rows,\n                        inline_diagnostics,\n                        inline_blame_layout,\n                        inline_code_actions,\n                        blocks,\n                        cursors,\n                        visible_cursors,\n                        selections,\n                        edit_prediction_popover,\n                        diff_hunk_controls,\n                        mouse_context_menu,\n                        test_indicators,\n                        breakpoints,\n                        crease_toggles,\n                        crease_trailers,\n                        tab_invisible,\n                        space_invisible,\n                        sticky_buffer_header,\n                        sticky_headers,\n                        expand_toggles,\n                    }\n                })\n            })\n        })\n    }\n\n    fn paint(\n        &mut self,\n        _: Option<&GlobalElementId>,\n        _inspector_id: Option<&gpui::InspectorElementId>,\n        bounds: Bounds<gpui::Pixels>,\n        _: &mut Self::RequestLayoutState,\n        layout: &mut Self::PrepaintState,\n        window: &mut Window,\n        cx: &mut App,\n    ) {\n        if !layout.mode.is_minimap() {\n            let focus_handle = self.editor.focus_handle(cx);\n            let key_context = self\n                .editor\n                .update(cx, |editor, cx| editor.key_context(window, cx));\n\n            window.set_key_context(key_context);\n            window.handle_input(\n                &focus_handle,\n                ElementInputHandler::new(bounds, self.editor.clone()),\n                cx,\n            );\n            self.register_actions(window, cx);\n            self.register_key_listeners(window, cx, layout);\n        }\n\n        let text_style = TextStyleRefinement {\n            font_size: Some(self.style.text.font_size),\n            line_height: Some(self.style.text.line_height),\n            ..Default::default()\n        };\n        let rem_size = self.rem_size(cx);\n        window.with_rem_size(rem_size, |window| {\n            window.with_text_style(Some(text_style), |window| {\n                window.with_content_mask(Some(ContentMask { bounds }), |window| {\n                    self.paint_mouse_listeners(layout, window, cx);\n                    self.paint_background(layout, window, cx);\n                    self.paint_indent_guides(layout, window, cx);\n\n                    if layout.gutter_hitbox.size.width > Pixels::ZERO {\n                        self.paint_blamed_display_rows(layout, window, cx);\n                        self.paint_line_numbers(layout, window, cx);\n                    }\n\n                    self.paint_text(layout, window, cx);\n\n                    if layout.gutter_hitbox.size.width > Pixels::ZERO {\n                        self.paint_gutter_highlights(layout, window, cx);\n                        self.paint_gutter_indicators(layout, window, cx);\n                    }\n\n                    if !layout.blocks.is_empty() {\n                        window.with_element_namespace(": "",
        ", |window| {\n                            self.paint_blocks(layout, window, cx);\n                        });\n                    }\n\n                    window.with_element_namespace(": "",
        ", |window| {\n                        if let Some(mut sticky_header) = layout.sticky_buffer_header.take() {\n                            sticky_header.paint(window, cx)\n                        }\n                    });\n\n                    self.paint_sticky_headers(layout, window, cx);\n                    self.paint_minimap(layout, window, cx);\n                    self.paint_scrollbars(layout, window, cx);\n                    self.paint_edit_prediction_popover(layout, window, cx);\n                    self.paint_mouse_context_menu(layout, window, cx);\n                });\n            })\n        })\n    }\n}\n\npub(super) fn gutter_bounds(\n    editor_bounds: Bounds<Pixels>,\n    gutter_dimensions: GutterDimensions,\n) -> Bounds<Pixels> {\n    Bounds {\n        origin: editor_bounds.origin,\n        size: size(gutter_dimensions.width, editor_bounds.size.height),\n    }\n}\n\n#[derive(Clone, Copy)]\nstruct ContextMenuLayout {\n    y_flipped: bool,\n    bounds: Bounds<Pixels>,\n}\n\n/// Holds information required for layouting the editor scrollbars.\nstruct ScrollbarLayoutInformation {\n    /// The bounds of the editor area (excluding the content offset).\n    editor_bounds: Bounds<Pixels>,\n    /// The available range to scroll within the document.\n    scroll_range: Size<Pixels>,\n    /// The space available for one glyph in the editor.\n    glyph_grid_cell: Size<Pixels>,\n}\n\nimpl ScrollbarLayoutInformation {\n    pub fn new(\n        editor_bounds: Bounds<Pixels>,\n        glyph_grid_cell: Size<Pixels>,\n        document_size: Size<Pixels>,\n        longest_line_blame_width: Pixels,\n        settings: &EditorSettings,\n    ) -> Self {\n        let vertical_overscroll = match settings.scroll_beyond_last_line {\n            ScrollBeyondLastLine::OnePage => editor_bounds.size.height,\n            ScrollBeyondLastLine::Off => glyph_grid_cell.height,\n            ScrollBeyondLastLine::VerticalScrollMargin => {\n                (1.0 + settings.vertical_scroll_margin) as f32 * glyph_grid_cell.height\n            }\n        };\n\n        let overscroll = size(longest_line_blame_width, vertical_overscroll);\n\n        ScrollbarLayoutInformation {\n            editor_bounds,\n            scroll_range: document_size + overscroll,\n            glyph_grid_cell,\n        }\n    }\n}\n\nimpl IntoElement for EditorElement {\n    type Element = Self;\n\n    fn into_element(self) -> Self::Element {\n        self\n    }\n}\n\npub struct EditorLayout {\n    position_map: Rc<PositionMap>,\n    hitbox: Hitbox,\n    gutter_hitbox: Hitbox,\n    content_origin: gpui::Point<Pixels>,\n    scrollbars_layout: Option<EditorScrollbars>,\n    minimap: Option<MinimapLayout>,\n    mode: EditorMode,\n    wrap_guides: SmallVec<[(Pixels, bool); 2]>,\n    indent_guides: Option<Vec<IndentGuideLayout>>,\n    visible_display_row_range: Range<DisplayRow>,\n    active_rows: BTreeMap<DisplayRow, LineHighlightSpec>,\n    highlighted_rows: BTreeMap<DisplayRow, LineHighlight>,\n    line_elements: SmallVec<[AnyElement; 1]>,\n    line_numbers: Arc<HashMap<MultiBufferRow, LineNumberLayout>>,\n    display_hunks: Vec<(DisplayDiffHunk, Option<Hitbox>)>,\n    blamed_display_rows: Option<Vec<AnyElement>>,\n    inline_diagnostics: HashMap<DisplayRow, AnyElement>,\n    inline_blame_layout: Option<InlineBlameLayout>,\n    inline_code_actions: Option<AnyElement>,\n    blocks: Vec<BlockLayout>,\n    highlighted_ranges: Vec<(Range<DisplayPoint>, Hsla)>,\n    highlighted_gutter_ranges: Vec<(Range<DisplayPoint>, Hsla)>,\n    redacted_ranges: Vec<Range<DisplayPoint>>,\n    cursors: Vec<(DisplayPoint, Hsla)>,\n    visible_cursors: Vec<CursorLayout>,\n    selections: Vec<(PlayerColor, Vec<SelectionLayout>)>,\n    test_indicators: Vec<AnyElement>,\n    breakpoints: Vec<AnyElement>,\n    crease_toggles: Vec<Option<AnyElement>>,\n    expand_toggles: Vec<Option<(AnyElement, gpui::Point<Pixels>)>>,\n    diff_hunk_controls: Vec<AnyElement>,\n    crease_trailers: Vec<Option<CreaseTrailerLayout>>,\n    edit_prediction_popover: Option<AnyElement>,\n    mouse_context_menu: Option<AnyElement>,\n    tab_invisible: ShapedLine,\n    space_invisible: ShapedLine,\n    sticky_buffer_header: Option<AnyElement>,\n    sticky_headers: Option<StickyHeaders>,\n    document_colors: Option<(DocumentColorsRenderMode, Vec<(Range<DisplayPoint>, Hsla)>)>,\n}\n\nstruct StickyHeaders {\n    lines: Vec<StickyHeaderLine>,\n    gutter_background: Hsla,\n    content_background: Hsla,\n    gutter_right_padding: Pixels,\n}\n\nstruct StickyHeaderLine {\n    row: DisplayRow,\n    offset: Pixels,\n    line: LineWithInvisibles,\n    line_number: Option<ShapedLine>,\n    elements: SmallVec<[AnyElement; 1]>,\n    available_text_width: Pixels,\n    target_anchor: Anchor,\n    hitbox: Hitbox,\n}\n\nimpl EditorLayout {\n    fn line_end_overshoot(&self) -> Pixels {\n        0.15 * self.position_map.line_height\n    }\n}\n\nimpl StickyHeaders {\n    fn paint(\n        &mut self,\n        layout: &mut EditorLayout,\n        whitespace_setting: ShowWhitespaceSetting,\n        window: &mut Window,\n        cx: &mut App,\n    ) {\n        let line_height = layout.position_map.line_height;\n\n        for line in self.lines.iter_mut().rev() {\n            window.paint_layer(\n                Bounds::new(\n                    layout.gutter_hitbox.origin + point(Pixels::ZERO, line.offset),\n                    size(line.hitbox.size.width, line_height),\n                ),\n                |window| {\n                    let gutter_bounds = Bounds::new(\n                        layout.gutter_hitbox.origin + point(Pixels::ZERO, line.offset),\n                        size(layout.gutter_hitbox.size.width, line_height),\n                    );\n                    window.paint_quad(fill(gutter_bounds, self.gutter_background));\n\n                    let text_bounds = Bounds::new(\n                        layout.position_map.text_hitbox.origin + point(Pixels::ZERO, line.offset),\n                        size(line.available_text_width, line_height),\n                    );\n                    window.paint_quad(fill(text_bounds, self.content_background));\n\n                    if line.hitbox.is_hovered(window) {\n                        let hover_overlay = cx.theme().colors().panel_overlay_hover;\n                        window.paint_quad(fill(gutter_bounds, hover_overlay));\n                        window.paint_quad(fill(text_bounds, hover_overlay));\n                    }\n\n                    line.paint(\n                        layout,\n                        self.gutter_right_padding,\n                        line.available_text_width,\n                        layout.content_origin,\n                        line_height,\n                        whitespace_setting,\n                        window,\n                        cx,\n                    );\n                },\n            );\n\n            window.set_cursor_style(CursorStyle::PointingHand, &line.hitbox);\n        }\n    }\n}\n\nimpl StickyHeaderLine {\n    fn new(\n        row: DisplayRow,\n        offset: Pixels,\n        mut line: LineWithInvisibles,\n        line_number: Option<ShapedLine>,\n        target_anchor: Anchor,\n        line_height: Pixels,\n        scroll_pixel_position: gpui::Point<ScrollPixelOffset>,\n        content_origin: gpui::Point<Pixels>,\n        gutter_hitbox: &Hitbox,\n        text_hitbox: &Hitbox,\n        window: &mut Window,\n        cx: &mut App,\n    ) -> Self {\n        let mut elements = SmallVec::<[AnyElement; 1]>::new();\n        line.prepaint_with_custom_offset(\n            line_height,\n            scroll_pixel_position,\n            content_origin,\n            offset,\n            &mut elements,\n            window,\n            cx,\n        );\n\n        let hitbox_bounds = Bounds::new(\n            gutter_hitbox.origin + point(Pixels::ZERO, offset),\n            size(text_hitbox.right() - gutter_hitbox.left(), line_height),\n        );\n        let available_text_width =\n            (hitbox_bounds.size.width - gutter_hitbox.size.width).max(Pixels::ZERO);\n\n        Self {\n            row,\n            offset,\n            line,\n            line_number,\n            elements,\n            available_text_width,\n            target_anchor,\n            hitbox: window.insert_hitbox(hitbox_bounds, HitboxBehavior::BlockMouseExceptScroll),\n        }\n    }\n\n    fn paint(\n        &mut self,\n        layout: &EditorLayout,\n        gutter_right_padding: Pixels,\n        available_text_width: Pixels,\n        content_origin: gpui::Point<Pixels>,\n        line_height: Pixels,\n        whitespace_setting: ShowWhitespaceSetting,\n        window: &mut Window,\n        cx: &mut App,\n    ) {\n        window.with_content_mask(\n            Some(ContentMask {\n                bounds: Bounds::new(\n                    layout.position_map.text_hitbox.bounds.origin\n                        + point(Pixels::ZERO, self.offset),\n                    size(available_text_width, line_height),\n                ),\n            }),\n            |window| {\n                self.line.draw_with_custom_offset(\n                    layout,\n                    self.row,\n                    content_origin,\n                    self.offset,\n                    whitespace_setting,\n                    &[],\n                    window,\n                    cx,\n                );\n                for element in &mut self.elements {\n                    element.paint(window, cx);\n                }\n            },\n        );\n\n        if let Some(line_number) = &self.line_number {\n            let gutter_origin = layout.gutter_hitbox.origin + point(Pixels::ZERO, self.offset);\n            let gutter_width = layout.gutter_hitbox.size.width;\n            let origin = point(\n                gutter_origin.x + gutter_width - gutter_right_padding - line_number.width,\n                gutter_origin.y,\n            );\n            line_number.paint(origin, line_height, window, cx).log_err();\n        }\n    }\n}\n\n#[derive(Debug)]\nstruct LineNumberSegment {\n    shaped_line: ShapedLine,\n    hitbox: Option<Hitbox>,\n}\n\n#[derive(Debug)]\nstruct LineNumberLayout {\n    segments: SmallVec<[LineNumberSegment; 1]>,\n}\n\nstruct ColoredRange<T> {\n    start: T,\n    end: T,\n    color: Hsla,\n}\n\nimpl Along for ScrollbarAxes {\n    type Unit = bool;\n\n    fn along(&self, axis: ScrollbarAxis) -> Self::Unit {\n        match axis {\n            ScrollbarAxis::Horizontal => self.horizontal,\n            ScrollbarAxis::Vertical => self.vertical,\n        }\n    }\n\n    fn apply_along(&self, axis: ScrollbarAxis, f: impl FnOnce(Self::Unit) -> Self::Unit) -> Self {\n        match axis {\n            ScrollbarAxis::Horizontal => ScrollbarAxes {\n                horizontal: f(self.horizontal),\n                vertical: self.vertical,\n            },\n            ScrollbarAxis::Vertical => ScrollbarAxes {\n                horizontal: self.horizontal,\n                vertical: f(self.vertical),\n            },\n        }\n    }\n}\n\n#[derive(Clone)]\nstruct EditorScrollbars {\n    pub vertical: Option<ScrollbarLayout>,\n    pub horizontal: Option<ScrollbarLayout>,\n    pub visible: bool,\n}\n\nimpl EditorScrollbars {\n    pub fn from_scrollbar_axes(\n        show_scrollbar: ScrollbarAxes,\n        layout_information: &ScrollbarLayoutInformation,\n        content_offset: gpui::Point<Pixels>,\n        scroll_position: gpui::Point<f64>,\n        scrollbar_width: Pixels,\n        right_margin: Pixels,\n        editor_width: Pixels,\n        show_scrollbars: bool,\n        scrollbar_state: Option<&ActiveScrollbarState>,\n        window: &mut Window,\n    ) -> Self {\n        let ScrollbarLayoutInformation {\n            editor_bounds,\n            scroll_range,\n            glyph_grid_cell,\n        } = layout_information;\n\n        let viewport_size = size(editor_width, editor_bounds.size.height);\n\n        let scrollbar_bounds_for = |axis: ScrollbarAxis| match axis {\n            ScrollbarAxis::Horizontal => Bounds::from_corner_and_size(\n                Corner::BottomLeft,\n                editor_bounds.bottom_left(),\n                size(\n                    // The horizontal viewport size differs from the space available for the\n                    // horizontal scrollbar, so we have to manually stitch it together here.\n                    editor_bounds.size.width - right_margin,\n                    scrollbar_width,\n                ),\n            ),\n            ScrollbarAxis::Vertical => Bounds::from_corner_and_size(\n                Corner::TopRight,\n                editor_bounds.top_right(),\n                size(scrollbar_width, viewport_size.height),\n            ),\n        };\n\n        let mut create_scrollbar_layout = |axis| {\n            let viewport_size = viewport_size.along(axis);\n            let scroll_range = scroll_range.along(axis);\n\n            // We always want a vertical scrollbar track for scrollbar diagnostic visibility.\n            (show_scrollbar.along(axis)\n                && (axis == ScrollbarAxis::Vertical || scroll_range > viewport_size))\n                .then(|| {\n                    ScrollbarLayout::new(\n                        window.insert_hitbox(scrollbar_bounds_for(axis), HitboxBehavior::Normal),\n                        viewport_size,\n                        scroll_range,\n                        glyph_grid_cell.along(axis),\n                        content_offset.along(axis),\n                        scroll_position.along(axis),\n                        show_scrollbars,\n                        axis,\n                    )\n                    .with_thumb_state(\n                        scrollbar_state.and_then(|state| state.thumb_state_for_axis(axis)),\n                    )\n                })\n        };\n\n        Self {\n            vertical: create_scrollbar_layout(ScrollbarAxis::Vertical),\n            horizontal: create_scrollbar_layout(ScrollbarAxis::Horizontal),\n            visible: show_scrollbars,\n        }\n    }\n\n    pub fn iter_scrollbars(&self) -> impl Iterator<Item = (&ScrollbarLayout, ScrollbarAxis)> + '_ {\n        [\n            (&self.vertical, ScrollbarAxis::Vertical),\n            (&self.horizontal, ScrollbarAxis::Horizontal),\n        ]\n        .into_iter()\n        .filter_map(|(scrollbar, axis)| scrollbar.as_ref().map(|s| (s, axis)))\n    }\n\n    /// Returns the currently hovered scrollbar axis, if any.\n    pub fn get_hovered_axis(&self, window: &Window) -> Option<(&ScrollbarLayout, ScrollbarAxis)> {\n        self.iter_scrollbars()\n            .find(|s| s.0.hitbox.is_hovered(window))\n    }\n}\n\n#[derive(Clone)]\nstruct ScrollbarLayout {\n    hitbox: Hitbox,\n    visible_range: Range<ScrollOffset>,\n    text_unit_size: Pixels,\n    thumb_bounds: Option<Bounds<Pixels>>,\n    thumb_state: ScrollbarThumbState,\n}\n\nimpl ScrollbarLayout {\n    const BORDER_WIDTH: Pixels = px(1.0);\n    const LINE_MARKER_HEIGHT: Pixels = px(2.0);\n    const MIN_MARKER_HEIGHT: Pixels = px(5.0);\n    const MIN_THUMB_SIZE: Pixels = px(25.0);\n\n    fn new(\n        scrollbar_track_hitbox: Hitbox,\n        viewport_size: Pixels,\n        scroll_range: Pixels,\n        glyph_space: Pixels,\n        content_offset: Pixels,\n        scroll_position: ScrollOffset,\n        show_thumb: bool,\n        axis: ScrollbarAxis,\n    ) -> Self {\n        let track_bounds = scrollbar_track_hitbox.bounds;\n        // The length of the track available to the scrollbar thumb. We deliberately\n        // exclude the content size here so that the thumb aligns with the content.\n        let track_length = track_bounds.size.along(axis) - content_offset;\n\n        Self::new_with_hitbox_and_track_length(\n            scrollbar_track_hitbox,\n            track_length,\n            viewport_size,\n            scroll_range.into(),\n            glyph_space,\n            content_offset.into(),\n            scroll_position,\n            show_thumb,\n            axis,\n        )\n    }\n\n    fn for_minimap(\n        minimap_track_hitbox: Hitbox,\n        visible_lines: f64,\n        total_editor_lines: f64,\n        minimap_line_height: Pixels,\n        scroll_position: ScrollOffset,\n        minimap_scroll_top: ScrollOffset,\n        show_thumb: bool,\n    ) -> Self {\n        // The scrollbar thumb size is calculated as\n        // (visible_content/total_content) × scrollbar_track_length.\n        //\n        // For the minimap's thumb layout, we leverage this by setting the\n        // scrollbar track length to the entire document size (using minimap line\n        // height). This creates a thumb that exactly represents the editor\n        // viewport scaled to minimap proportions.\n        //\n        // We adjust the thumb position relative to `minimap_scroll_top` to\n        // accommodate for the deliberately oversized track.\n        //\n        // This approach ensures that the minimap thumb accurately reflects the\n        // editor's current scroll position whilst nicely synchronizing the minimap\n        // thumb and scrollbar thumb.\n        let scroll_range = total_editor_lines * f64::from(minimap_line_height);\n        let viewport_size = visible_lines * f64::from(minimap_line_height);\n\n        let track_top_offset = -minimap_scroll_top * f64::from(minimap_line_height);\n\n        Self::new_with_hitbox_and_track_length(\n            minimap_track_hitbox,\n            Pixels::from(scroll_range),\n            Pixels::from(viewport_size),\n            scroll_range,\n            minimap_line_height,\n            track_top_offset,\n            scroll_position,\n            show_thumb,\n            ScrollbarAxis::Vertical,\n        )\n    }\n\n    fn new_with_hitbox_and_track_length(\n        scrollbar_track_hitbox: Hitbox,\n        track_length: Pixels,\n        viewport_size: Pixels,\n        scroll_range: f64,\n        glyph_space: Pixels,\n        content_offset: ScrollOffset,\n        scroll_position: ScrollOffset,\n        show_thumb: bool,\n        axis: ScrollbarAxis,\n    ) -> Self {\n        let text_units_per_page = f64::from(viewport_size / glyph_space);\n        let visible_range = scroll_position..scroll_position + text_units_per_page;\n        let total_text_units = scroll_range / f64::from(glyph_space);\n\n        let thumb_percentage = text_units_per_page / total_text_units;\n        let thumb_size = Pixels::from(ScrollOffset::from(track_length) * thumb_percentage)\n            .max(ScrollbarLayout::MIN_THUMB_SIZE)\n            .min(track_length);\n\n        let text_unit_divisor = (total_text_units - text_units_per_page).max(0.);\n\n        let content_larger_than_viewport = text_unit_divisor > 0.;\n\n        let text_unit_size = if content_larger_than_viewport {\n            Pixels::from(ScrollOffset::from(track_length - thumb_size) / text_unit_divisor)\n        } else {\n            glyph_space\n        };\n\n        let thumb_bounds = (show_thumb && content_larger_than_viewport).then(|| {\n            Self::thumb_bounds(\n                &scrollbar_track_hitbox,\n                content_offset,\n                visible_range.start,\n                text_unit_size,\n                thumb_size,\n                axis,\n            )\n        });\n\n        ScrollbarLayout {\n            hitbox: scrollbar_track_hitbox,\n            visible_range,\n            text_unit_size,\n            thumb_bounds,\n            thumb_state: Default::default(),\n        }\n    }\n\n    fn with_thumb_state(self, thumb_state: Option<ScrollbarThumbState>) -> Self {\n        if let Some(thumb_state) = thumb_state {\n            Self {\n                thumb_state,\n                ..self\n            }\n        } else {\n            self\n        }\n    }\n\n    fn thumb_bounds(\n        scrollbar_track: &Hitbox,\n        content_offset: f64,\n        visible_range_start: f64,\n        text_unit_size: Pixels,\n        thumb_size: Pixels,\n        axis: ScrollbarAxis,\n    ) -> Bounds<Pixels> {\n        let thumb_origin = scrollbar_track.origin.apply_along(axis, |origin| {\n            origin\n                + Pixels::from(\n                    content_offset + visible_range_start * ScrollOffset::from(text_unit_size),\n                )\n        });\n        Bounds::new(\n            thumb_origin,\n            scrollbar_track.size.apply_along(axis, |_| thumb_size),\n        )\n    }\n\n    fn thumb_hovered(&self, position: &gpui::Point<Pixels>) -> bool {\n        self.thumb_bounds\n            .is_some_and(|bounds| bounds.contains(position))\n    }\n\n    fn marker_quads_for_ranges(\n        &self,\n        row_ranges: impl IntoIterator<Item = ColoredRange<DisplayRow>>,\n        column: Option<usize>,\n    ) -> Vec<PaintQuad> {\n        struct MinMax {\n            min: Pixels,\n            max: Pixels,\n        }\n        let (x_range, height_limit) = if let Some(column) = column {\n            let column_width = ((self.hitbox.size.width - Self::BORDER_WIDTH) / 3.0).floor();\n            let start = Self::BORDER_WIDTH + (column as f32 * column_width);\n            let end = start + column_width;\n            (\n                Range { start, end },\n                MinMax {\n                    min: Self::MIN_MARKER_HEIGHT,\n                    max: px(f32::MAX),\n                },\n            )\n        } else {\n            (\n                Range {\n                    start: Self::BORDER_WIDTH,\n                    end: self.hitbox.size.width,\n                },\n                MinMax {\n                    min: Self::LINE_MARKER_HEIGHT,\n                    max: Self::LINE_MARKER_HEIGHT,\n                },\n            )\n        };\n\n        let row_to_y = |row: DisplayRow| row.as_f64() as f32 * self.text_unit_size;\n        let mut pixel_ranges = row_ranges\n            .into_iter()\n            .map(|range| {\n                let start_y = row_to_y(range.start);\n                let end_y = row_to_y(range.end)\n                    + self\n                        .text_unit_size\n                        .max(height_limit.min)\n                        .min(height_limit.max);\n                ColoredRange {\n                    start: start_y,\n                    end: end_y,\n                    color: range.color,\n                }\n            })\n            .peekable();\n\n        let mut quads = Vec::new();\n        while let Some(mut pixel_range) = pixel_ranges.next() {\n            while let Some(next_pixel_range) = pixel_ranges.peek() {\n                if pixel_range.end >= next_pixel_range.start - px(1.0)\n                    && pixel_range.color == next_pixel_range.color\n                {\n                    pixel_range.end = next_pixel_range.end.max(pixel_range.end);\n                    pixel_ranges.next();\n                } else {\n                    break;\n                }\n            }\n\n            let bounds = Bounds::from_corners(\n                point(x_range.start, pixel_range.start),\n                point(x_range.end, pixel_range.end),\n            );\n            quads.push(quad(\n                bounds,\n                Corners::default(),\n                pixel_range.color,\n                Edges::default(),\n                Hsla::transparent_black(),\n                BorderStyle::default(),\n            ));\n        }\n\n        quads\n    }\n}\n\nstruct MinimapLayout {\n    pub minimap: AnyElement,\n    pub thumb_layout: ScrollbarLayout,\n    pub minimap_scroll_top: ScrollOffset,\n    pub minimap_line_height: Pixels,\n    pub thumb_border_style: MinimapThumbBorder,\n    pub max_scroll_top: ScrollOffset,\n}\n\nimpl MinimapLayout {\n    /// The minimum width of the minimap in columns. If the minimap is smaller than this, it will be hidden.\n    const MINIMAP_MIN_WIDTH_COLUMNS: f32 = 20.;\n    /// The minimap width as a percentage of the editor width.\n    const MINIMAP_WIDTH_PCT: f32 = 0.15;\n    /// Calculates the scroll top offset the minimap editor has to have based on the\n    /// current scroll progress.\n    fn calculate_minimap_top_offset(\n        document_lines: f64,\n        visible_editor_lines: f64,\n        visible_minimap_lines: f64,\n        scroll_position: f64,\n    ) -> ScrollOffset {\n        let non_visible_document_lines = (document_lines - visible_editor_lines).max(0.);\n        if non_visible_document_lines == 0. {\n            0.\n        } else {\n            let scroll_percentage = (scroll_position / non_visible_document_lines).clamp(0., 1.);\n            scroll_percentage * (document_lines - visible_minimap_lines).max(0.)\n        }\n    }\n}\n\nstruct CreaseTrailerLayout {\n    element: AnyElement,\n    bounds: Bounds<Pixels>,\n}\n\npub(crate) struct PositionMap {\n    pub size: Size<Pixels>,\n    pub line_height: Pixels,\n    pub scroll_position: gpui::Point<ScrollOffset>,\n    pub scroll_pixel_position: gpui::Point<ScrollPixelOffset>,\n    pub scroll_max: gpui::Point<ScrollOffset>,\n    pub em_width: Pixels,\n    pub em_advance: Pixels,\n    pub visible_row_range: Range<DisplayRow>,\n    pub line_layouts: Vec<LineWithInvisibles>,\n    pub snapshot: EditorSnapshot,\n    pub text_hitbox: Hitbox,\n    pub gutter_hitbox: Hitbox,\n    pub inline_blame_bounds: Option<(Bounds<Pixels>, BufferId, BlameEntry)>,\n    pub display_hunks: Vec<(DisplayDiffHunk, Option<Hitbox>)>,\n    pub diff_hunk_control_bounds: Vec<(DisplayRow, Bounds<Pixels>)>,\n}\n\n#[derive(Debug, Copy, Clone)]\npub struct PointForPosition {\n    pub previous_valid: DisplayPoint,\n    pub next_valid: DisplayPoint,\n    pub exact_unclipped: DisplayPoint,\n    pub column_overshoot_after_line_end: u32,\n}\n\nimpl PointForPosition {\n    pub fn as_valid(&self) -> Option<DisplayPoint> {\n        if self.previous_valid == self.exact_unclipped && self.next_valid == self.exact_unclipped {\n            Some(self.previous_valid)\n        } else {\n            None\n        }\n    }\n\n    pub fn intersects_selection(&self, selection: &Selection<DisplayPoint>) -> bool {\n        let Some(valid_point) = self.as_valid() else {\n            return false;\n        };\n        let range = selection.range();\n\n        let candidate_row = valid_point.row();\n        let candidate_col = valid_point.column();\n\n        let start_row = range.start.row();\n        let start_col = range.start.column();\n        let end_row = range.end.row();\n        let end_col = range.end.column();\n\n        if candidate_row < start_row || candidate_row > end_row {\n            false\n        } else if start_row == end_row {\n            candidate_col >= start_col && candidate_col < end_col\n        } else if candidate_row == start_row {\n            candidate_col >= start_col\n        } else if candidate_row == end_row {\n            candidate_col < end_col\n        } else {\n            true\n        }\n    }\n}\n\nimpl PositionMap {\n    pub(crate) fn point_for_position(&self, position: gpui::Point<Pixels>) -> PointForPosition {\n        let text_bounds = self.text_hitbox.bounds;\n        let scroll_position = self.snapshot.scroll_position();\n        let position = position - text_bounds.origin;\n        let y = position.y.max(px(0.)).min(self.size.height);\n        let x = position.x + (scroll_position.x as f32 * self.em_advance);\n        let row = ((y / self.line_height) as f64 + scroll_position.y) as u32;\n\n        let (column, x_overshoot_after_line_end) = if let Some(line) = self\n            .line_layouts\n            .get(row as usize - scroll_position.y as usize)\n        {\n            if let Some(ix) = line.index_for_x(x) {\n                (ix as u32, px(0.))\n            } else {\n                (line.len as u32, px(0.).max(x - line.width))\n            }\n        } else {\n            (0, x)\n        };\n\n        let mut exact_unclipped = DisplayPoint::new(DisplayRow(row), column);\n        let previous_valid = self.snapshot.clip_point(exact_unclipped, Bias::Left);\n        let next_valid = self.snapshot.clip_point(exact_unclipped, Bias::Right);\n\n        let column_overshoot_after_line_end = (x_overshoot_after_line_end / self.em_advance) as u32;\n        *exact_unclipped.column_mut() += column_overshoot_after_line_end;\n        PointForPosition {\n            previous_valid,\n            next_valid,\n            exact_unclipped,\n            column_overshoot_after_line_end,\n        }\n    }\n}\n\nstruct BlockLayout {\n    id: BlockId,\n    x_offset: Pixels,\n    row: Option<DisplayRow>,\n    element: AnyElement,\n    available_space: Size<AvailableSpace>,\n    style: BlockStyle,\n    overlaps_gutter: bool,\n    is_buffer_header: bool,\n}\n\npub fn layout_line(\n    row: DisplayRow,\n    snapshot: &EditorSnapshot,\n    style: &EditorStyle,\n    text_width: Pixels,\n    is_row_soft_wrapped: impl Copy + Fn(usize) -> bool,\n    window: &mut Window,\n    cx: &mut App,\n) -> LineWithInvisibles {\n    let chunks = snapshot.highlighted_chunks(row..row + DisplayRow(1), true, style);\n    LineWithInvisibles::from_chunks(\n        chunks,\n        style,\n        MAX_LINE_LEN,\n        1,\n        &snapshot.mode,\n        text_width,\n        is_row_soft_wrapped,\n        &[],\n        window,\n        cx,\n    )\n    .pop()\n    .unwrap()\n}\n\n#[derive(Debug)]\npub struct IndentGuideLayout {\n    origin: gpui::Point<Pixels>,\n    length: Pixels,\n    single_indent_width: Pixels,\n    depth: u32,\n    active: bool,\n    settings: IndentGuideSettings,\n}\n\npub struct CursorLayout {\n    origin: gpui::Point<Pixels>,\n    block_width: Pixels,\n    line_height: Pixels,\n    color: Hsla,\n    shape: CursorShape,\n    block_text: Option<ShapedLine>,\n    cursor_name: Option<AnyElement>,\n}\n\n#[derive(Debug)]\npub struct CursorName {\n    string: SharedString,\n    color: Hsla,\n    is_top_row: bool,\n}\n\nimpl CursorLayout {\n    pub fn new(\n        origin: gpui::Point<Pixels>,\n        block_width: Pixels,\n        line_height: Pixels,\n        color: Hsla,\n        shape: CursorShape,\n        block_text: Option<ShapedLine>,\n    ) -> CursorLayout {\n        CursorLayout {\n            origin,\n            block_width,\n            line_height,\n            color,\n            shape,\n            block_text,\n            cursor_name: None,\n        }\n    }\n\n    pub fn bounding_rect(&self, origin: gpui::Point<Pixels>) -> Bounds<Pixels> {\n        Bounds {\n            origin: self.origin + origin,\n            size: size(self.block_width, self.line_height),\n        }\n    }\n\n    fn bounds(&self, origin: gpui::Point<Pixels>) -> Bounds<Pixels> {\n        match self.shape {\n            CursorShape::Bar => Bounds {\n                origin: self.origin + origin,\n                size: size(px(2.0), self.line_height),\n            },\n            CursorShape::Block | CursorShape::Hollow => Bounds {\n                origin: self.origin + origin,\n                size: size(self.block_width, self.line_height),\n            },\n            CursorShape::Underline => Bounds {\n                origin: self.origin\n                    + origin\n                    + gpui::Point::new(Pixels::ZERO, self.line_height - px(2.0)),\n                size: size(self.block_width, px(2.0)),\n            },\n        }\n    }\n\n    pub fn layout(\n        &mut self,\n        origin: gpui::Point<Pixels>,\n        cursor_name: Option<CursorName>,\n        window: &mut Window,\n        cx: &mut App,\n    ) {\n        if let Some(cursor_name) = cursor_name {\n            let bounds = self.bounds(origin);\n            let text_size = self.line_height / 1.5;\n\n            let name_origin = if cursor_name.is_top_row {\n                point(bounds.right() - px(1.), bounds.top())\n            } else {\n                match self.shape {\n                    CursorShape::Bar => point(\n                        bounds.right() - px(2.),\n                        bounds.top() - text_size / 2. - px(1.),\n                    ),\n                    _ => point(\n                        bounds.right() - px(1.),\n                        bounds.top() - text_size / 2. - px(1.),\n                    ),\n                }\n            };\n            let mut name_element = div()\n                .bg(self.color)\n                .text_size(text_size)\n                .px_0p5()\n                .line_height(text_size + px(2.))\n                .text_color(cursor_name.color)\n                .child(cursor_name.string)\n                .into_any_element();\n\n            name_element.prepaint_as_root(name_origin, AvailableSpace::min_size(), window, cx);\n\n            self.cursor_name = Some(name_element);\n        }\n    }\n\n    pub fn paint(&mut self, origin: gpui::Point<Pixels>, window: &mut Window, cx: &mut App) {\n        let bounds = self.bounds(origin);\n\n        //Draw background or border quad\n        let cursor = if matches!(self.shape, CursorShape::Hollow) {\n            outline(bounds, self.color, BorderStyle::Solid)\n        } else {\n            fill(bounds, self.color)\n        };\n\n        if let Some(name) = &mut self.cursor_name {\n            name.paint(window, cx);\n        }\n\n        window.paint_quad(cursor);\n\n        if let Some(block_text) = &self.block_text {\n            block_text\n                .paint(self.origin + origin, self.line_height, window, cx)\n                .log_err();\n        }\n    }\n\n    pub fn shape(&self) -> CursorShape {\n        self.shape\n    }\n}\n\n#[derive(Debug)]\npub struct HighlightedRange {\n    pub start_y: Pixels,\n    pub line_height: Pixels,\n    pub lines: Vec<HighlightedRangeLine>,\n    pub color: Hsla,\n    pub corner_radius: Pixels,\n}\n\n#[derive(Debug)]\npub struct HighlightedRangeLine {\n    pub start_x: Pixels,\n    pub end_x: Pixels,\n}\n\nimpl HighlightedRange {\n    pub fn paint(&self, fill: bool, bounds: Bounds<Pixels>, window: &mut Window) {\n        if self.lines.len() >= 2 && self.lines[0].start_x > self.lines[1].end_x {\n            self.paint_lines(self.start_y, &self.lines[0..1], fill, bounds, window);\n            self.paint_lines(\n                self.start_y + self.line_height,\n                &self.lines[1..],\n                fill,\n                bounds,\n                window,\n            );\n        } else {\n            self.paint_lines(self.start_y, &self.lines, fill, bounds, window);\n        }\n    }\n\n    fn paint_lines(\n        &self,\n        start_y: Pixels,\n        lines: &[HighlightedRangeLine],\n        fill: bool,\n        _bounds: Bounds<Pixels>,\n        window: &mut Window,\n    ) {\n        if lines.is_empty() {\n            return;\n        }\n\n        let first_line = lines.first().unwrap();\n        let last_line = lines.last().unwrap();\n\n        let first_top_left = point(first_line.start_x, start_y);\n        let first_top_right = point(first_line.end_x, start_y);\n\n        let curve_height = point(Pixels::ZERO, self.corner_radius);\n        let curve_width = |start_x: Pixels, end_x: Pixels| {\n            let max = (end_x - start_x) / 2.;\n            let width = if max < self.corner_radius {\n                max\n            } else {\n                self.corner_radius\n            };\n\n            point(width, Pixels::ZERO)\n        };\n\n        let top_curve_width = curve_width(first_line.start_x, first_line.end_x);\n        let mut builder = if fill {\n            gpui::PathBuilder::fill()\n        } else {\n            gpui::PathBuilder::stroke(px(1.))\n        };\n        builder.move_to(first_top_right - top_curve_width);\n        builder.curve_to(first_top_right + curve_height, first_top_right);\n\n        let mut iter = lines.iter().enumerate().peekable();\n        while let Some((ix, line)) = iter.next() {\n            let bottom_right = point(line.end_x, start_y + (ix + 1) as f32 * self.line_height);\n\n            if let Some((_, next_line)) = iter.peek() {\n                let next_top_right = point(next_line.end_x, bottom_right.y);\n\n                match next_top_right.x.partial_cmp(&bottom_right.x).unwrap() {\n                    Ordering::Equal => {\n                        builder.line_to(bottom_right);\n                    }\n                    Ordering::Less => {\n                        let curve_width = curve_width(next_top_right.x, bottom_right.x);\n                        builder.line_to(bottom_right - curve_height);\n                        if self.corner_radius > Pixels::ZERO {\n                            builder.curve_to(bottom_right - curve_width, bottom_right);\n                        }\n                        builder.line_to(next_top_right + curve_width);\n                        if self.corner_radius > Pixels::ZERO {\n                            builder.curve_to(next_top_right + curve_height, next_top_right);\n                        }\n                    }\n                    Ordering::Greater => {\n                        let curve_width = curve_width(bottom_right.x, next_top_right.x);\n                        builder.line_to(bottom_right - curve_height);\n                        if self.corner_radius > Pixels::ZERO {\n                            builder.curve_to(bottom_right + curve_width, bottom_right);\n                        }\n                        builder.line_to(next_top_right - curve_width);\n                        if self.corner_radius > Pixels::ZERO {\n                            builder.curve_to(next_top_right + curve_height, next_top_right);\n                        }\n                    }\n                }\n            } else {\n                let curve_width = curve_width(line.start_x, line.end_x);\n                builder.line_to(bottom_right - curve_height);\n                if self.corner_radius > Pixels::ZERO {\n                    builder.curve_to(bottom_right - curve_width, bottom_right);\n                }\n\n                let bottom_left = point(line.start_x, bottom_right.y);\n                builder.line_to(bottom_left + curve_width);\n                if self.corner_radius > Pixels::ZERO {\n                    builder.curve_to(bottom_left - curve_height, bottom_left);\n                }\n            }\n        }\n\n        if first_line.start_x > last_line.start_x {\n            let curve_width = curve_width(last_line.start_x, first_line.start_x);\n            let second_top_left = point(last_line.start_x, start_y + self.line_height);\n            builder.line_to(second_top_left + curve_height);\n            if self.corner_radius > Pixels::ZERO {\n                builder.curve_to(second_top_left + curve_width, second_top_left);\n            }\n            let first_bottom_left = point(first_line.start_x, second_top_left.y);\n            builder.line_to(first_bottom_left - curve_width);\n            if self.corner_radius > Pixels::ZERO {\n                builder.curve_to(first_bottom_left - curve_height, first_bottom_left);\n            }\n        }\n\n        builder.line_to(first_top_left + curve_height);\n        if self.corner_radius > Pixels::ZERO {\n            builder.curve_to(first_top_left + top_curve_width, first_top_left);\n        }\n        builder.line_to(first_top_right - top_curve_width);\n\n        if let Ok(path) = builder.build() {\n            window.paint_path(path, self.color);\n        }\n    }\n}\n\npub(crate) struct StickyHeader {\n    pub item: language::OutlineItem<Anchor>,\n    pub sticky_row: DisplayRow,\n    pub start_point: Point,\n    pub offset: ScrollOffset,\n}\n\nenum CursorPopoverType {\n    CodeContextMenu,\n    EditPrediction,\n}\n\npub fn scale_vertical_mouse_autoscroll_delta(delta: Pixels) -> f32 {\n    (delta.pow(1.2) / 100.0).min(px(3.0)).into()\n}\n\nfn scale_horizontal_mouse_autoscroll_delta(delta: Pixels) -> f32 {\n    (delta.pow(1.2) / 300.0).into()\n}\n\npub fn register_action<T: Action>(\n    editor: &Entity<Editor>,\n    window: &mut Window,\n    listener: impl Fn(&mut Editor, &T, &mut Window, &mut Context<Editor>) + 'static,\n) {\n    let editor = editor.clone();\n    window.on_action(TypeId::of::<T>(), move |action, phase, window, cx| {\n        let action = action.downcast_ref().unwrap();\n        if phase == DispatchPhase::Bubble {\n            editor.update(cx, |editor, cx| {\n                listener(editor, action, window, cx);\n            })\n        }\n    })\n}\n\nfn compute_auto_height_layout(\n    editor: &mut Editor,\n    min_lines: usize,\n    max_lines: Option<usize>,\n    max_line_number_width: Pixels,\n    known_dimensions: Size<Option<Pixels>>,\n    available_width: AvailableSpace,\n    window: &mut Window,\n    cx: &mut Context<Editor>,\n) -> Option<Size<Pixels>> {\n    let width = known_dimensions.width.or({\n        if let AvailableSpace::Definite(available_width) = available_width {\n            Some(available_width)\n        } else {\n            None\n        }\n    })?;\n    if let Some(height) = known_dimensions.height {\n        return Some(size(width, height));\n    }\n\n    let style = editor.style.as_ref().unwrap();\n    let font_id = window.text_system().resolve_font(&style.text.font());\n    let font_size = style.text.font_size.to_pixels(window.rem_size());\n    let line_height = style.text.line_height_in_pixels(window.rem_size());\n    let em_width = window.text_system().em_width(font_id, font_size).unwrap();\n\n    let mut snapshot = editor.snapshot(window, cx);\n    let gutter_dimensions = snapshot\n        .gutter_dimensions(font_id, font_size, max_line_number_width, cx)\n        .or_else(|| {\n            editor\n                .offset_content\n                .then(|| GutterDimensions::default_with_margin(font_id, font_size, cx))\n        })\n        .unwrap_or_default();\n\n    editor.gutter_dimensions = gutter_dimensions;\n    let text_width = width - gutter_dimensions.width;\n    let overscroll = size(em_width, px(0.));\n\n    let editor_width = text_width - gutter_dimensions.margin - overscroll.width - em_width;\n    if !matches!(editor.soft_wrap_mode(cx), SoftWrap::None)\n        && editor.set_wrap_width(Some(editor_width), cx)\n    {\n        snapshot = editor.snapshot(window, cx);\n    }\n\n    let scroll_height = (snapshot.max_point().row().next_row().0 as f32) * line_height;\n\n    let min_height = line_height * min_lines as f32;\n    let content_height = scroll_height.max(min_height);\n\n    let final_height = if let Some(max_lines) = max_lines {\n        let max_height = line_height * max_lines as f32;\n        content_height.min(max_height)\n    } else {\n        content_height\n    };\n\n    Some(size(width, final_height))\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{\n        Editor, MultiBuffer, SelectionEffects,\n        display_map::{BlockPlacement, BlockProperties},\n        editor_tests::{init_test, update_test_language_settings},\n    };\n    use gpui::{TestAppContext, VisualTestContext};\n    use language::language_settings;\n    use log::info;\n    use std::num::NonZeroU32;\n    use util::test::sample_text;\n\n    #[gpui::test]\n    async fn test_soft_wrap_editor_width_auto_height_editor(cx: &mut TestAppContext) {\n        init_test(cx, |_| {});\n\n        let window = cx.add_window(|window, cx| {\n            let buffer = MultiBuffer::build_simple(&": "",
        ".to_string().repeat(100), cx);\n            let mut editor = Editor::new(\n                EditorMode::AutoHeight {\n                    min_lines: 1,\n                    max_lines: None,\n                },\n                buffer,\n                None,\n                window,\n                cx,\n            );\n            editor.set_soft_wrap_mode(language_settings::SoftWrap::EditorWidth, cx);\n            editor\n        });\n        let cx = &mut VisualTestContext::from_window(*window, cx);\n        let editor = window.root(cx).unwrap();\n        let style = cx.update(|_, cx| editor.read(cx).style().unwrap().clone());\n\n        for x in 1..=100 {\n            let (_, state) = cx.draw(\n                Default::default(),\n                size(px(200. + 0.13 * x as f32), px(500.)),\n                |_, _| EditorElement::new(&editor, style.clone()),\n            );\n\n            assert!(\n                state.position_map.scroll_max.x == 0.,\n                ": "",
        "\n            );\n        }\n    }\n\n    #[gpui::test]\n    async fn test_soft_wrap_editor_width_full_editor(cx: &mut TestAppContext) {\n        init_test(cx, |_| {});\n\n        let window = cx.add_window(|window, cx| {\n            let buffer = MultiBuffer::build_simple(&": "",
        ".to_string().repeat(100), cx);\n            let mut editor = Editor::new(EditorMode::full(), buffer, None, window, cx);\n            editor.set_soft_wrap_mode(language_settings::SoftWrap::EditorWidth, cx);\n            editor\n        });\n        let cx = &mut VisualTestContext::from_window(*window, cx);\n        let editor = window.root(cx).unwrap();\n        let style = cx.update(|_, cx| editor.read(cx).style().unwrap().clone());\n\n        for x in 1..=100 {\n            let (_, state) = cx.draw(\n                Default::default(),\n                size(px(200. + 0.13 * x as f32), px(500.)),\n                |_, _| EditorElement::new(&editor, style.clone()),\n            );\n\n            assert!(\n                state.position_map.scroll_max.x == 0.,\n                ": "",
        "\n            );\n        }\n    }\n\n    #[gpui::test]\n    fn test_shape_line_numbers(cx: &mut TestAppContext) {\n        init_test(cx, |_| {});\n        let window = cx.add_window(|window, cx| {\n            let buffer = MultiBuffer::build_simple(&sample_text(6, 6, 'a'), cx);\n            Editor::new(EditorMode::full(), buffer, None, window, cx)\n        });\n\n        let editor = window.root(cx).unwrap();\n        let style = cx.update(|cx| editor.read(cx).style().unwrap().clone());\n        let line_height = window\n            .update(cx, |_, window, _| {\n                style.text.line_height_in_pixels(window.rem_size())\n            })\n            .unwrap();\n        let element = EditorElement::new(&editor, style);\n        let snapshot = window\n            .update(cx, |editor, window, cx| editor.snapshot(window, cx))\n            .unwrap();\n\n        let layouts = cx\n            .update_window(*window, |_, window, cx| {\n                element.layout_line_numbers(\n                    None,\n                    GutterDimensions {\n                        left_padding: Pixels::ZERO,\n                        right_padding: Pixels::ZERO,\n                        width: px(30.0),\n                        margin: Pixels::ZERO,\n                        git_blame_entries_width: None,\n                    },\n                    line_height,\n                    gpui::Point::default(),\n                    DisplayRow(0)..DisplayRow(6),\n                    &(0..6)\n                        .map(|row| RowInfo {\n                            buffer_row: Some(row),\n                            ..Default::default()\n                        })\n                        .collect::<Vec<_>>(),\n                    &BTreeMap::default(),\n                    Some(DisplayPoint::new(DisplayRow(0), 0)),\n                    &snapshot,\n                    window,\n                    cx,\n                )\n            })\n            .unwrap();\n        assert_eq!(layouts.len(), 6);\n\n        let relative_rows = window\n            .update(cx, |editor, window, cx| {\n                let snapshot = editor.snapshot(window, cx);\n                element.calculate_relative_line_numbers(\n                    &snapshot,\n                    &(DisplayRow(0)..DisplayRow(6)),\n                    Some(DisplayRow(3)),\n                    false,\n                )\n            })\n            .unwrap();\n        assert_eq!(relative_rows[&DisplayRow(0)], 3);\n        assert_eq!(relative_rows[&DisplayRow(1)], 2);\n        assert_eq!(relative_rows[&DisplayRow(2)], 1);\n        // current line has no relative number\n        assert_eq!(relative_rows[&DisplayRow(4)], 1);\n        assert_eq!(relative_rows[&DisplayRow(5)], 2);\n\n        // works if cursor is before screen\n        let relative_rows = window\n            .update(cx, |editor, window, cx| {\n                let snapshot = editor.snapshot(window, cx);\n                element.calculate_relative_line_numbers(\n                    &snapshot,\n                    &(DisplayRow(3)..DisplayRow(6)),\n                    Some(DisplayRow(1)),\n                    false,\n                )\n            })\n            .unwrap();\n        assert_eq!(relative_rows.len(), 3);\n        assert_eq!(relative_rows[&DisplayRow(3)], 2);\n        assert_eq!(relative_rows[&DisplayRow(4)], 3);\n        assert_eq!(relative_rows[&DisplayRow(5)], 4);\n\n        // works if cursor is after screen\n        let relative_rows = window\n            .update(cx, |editor, window, cx| {\n                let snapshot = editor.snapshot(window, cx);\n                element.calculate_relative_line_numbers(\n                    &snapshot,\n                    &(DisplayRow(0)..DisplayRow(3)),\n                    Some(DisplayRow(6)),\n                    false,\n                )\n            })\n            .unwrap();\n        assert_eq!(relative_rows.len(), 3);\n        assert_eq!(relative_rows[&DisplayRow(0)], 5);\n        assert_eq!(relative_rows[&DisplayRow(1)], 4);\n        assert_eq!(relative_rows[&DisplayRow(2)], 3);\n\n        const DELETED_LINE: u32 = 3;\n        let layouts = cx\n            .update_window(*window, |_, window, cx| {\n                element.layout_line_numbers(\n                    None,\n                    GutterDimensions {\n                        left_padding: Pixels::ZERO,\n                        right_padding: Pixels::ZERO,\n                        width: px(30.0),\n                        margin: Pixels::ZERO,\n                        git_blame_entries_width: None,\n                    },\n                    line_height,\n                    gpui::Point::default(),\n                    DisplayRow(0)..DisplayRow(6),\n                    &(0..6)\n                        .map(|row| RowInfo {\n                            buffer_row: Some(row),\n                            diff_status: (row == DELETED_LINE).then(|| {\n                                DiffHunkStatus::deleted(\n                                    buffer_diff::DiffHunkSecondaryStatus::NoSecondaryHunk,\n                                )\n                            }),\n                            ..Default::default()\n                        })\n                        .collect::<Vec<_>>(),\n                    &BTreeMap::default(),\n                    Some(DisplayPoint::new(DisplayRow(0), 0)),\n                    &snapshot,\n                    window,\n                    cx,\n                )\n            })\n            .unwrap();\n        assert_eq!(layouts.len(), 5,);\n        assert!(\n            layouts.get(&MultiBufferRow(DELETED_LINE)).is_none(),\n            ": "",
        "\n        );\n    }\n\n    #[gpui::test]\n    fn test_shape_line_numbers_wrapping(cx: &mut TestAppContext) {\n        init_test(cx, |_| {});\n        let window = cx.add_window(|window, cx| {\n            let buffer = MultiBuffer::build_simple(&sample_text(6, 6, 'a'), cx);\n            Editor::new(EditorMode::full(), buffer, None, window, cx)\n        });\n\n        update_test_language_settings(cx, |s| {\n            s.defaults.preferred_line_length = Some(5_u32);\n            s.defaults.soft_wrap = Some(language_settings::SoftWrap::PreferredLineLength);\n        });\n\n        let editor = window.root(cx).unwrap();\n        let style = cx.update(|cx| editor.read(cx).style().unwrap().clone());\n        let line_height = window\n            .update(cx, |_, window, _| {\n                style.text.line_height_in_pixels(window.rem_size())\n            })\n            .unwrap();\n        let element = EditorElement::new(&editor, style);\n        let snapshot = window\n            .update(cx, |editor, window, cx| editor.snapshot(window, cx))\n            .unwrap();\n\n        let layouts = cx\n            .update_window(*window, |_, window, cx| {\n                element.layout_line_numbers(\n                    None,\n                    GutterDimensions {\n                        left_padding: Pixels::ZERO,\n                        right_padding: Pixels::ZERO,\n                        width: px(30.0),\n                        margin: Pixels::ZERO,\n                        git_blame_entries_width: None,\n                    },\n                    line_height,\n                    gpui::Point::default(),\n                    DisplayRow(0)..DisplayRow(6),\n                    &(0..6)\n                        .map(|row| RowInfo {\n                            buffer_row: Some(row),\n                            ..Default::default()\n                        })\n                        .collect::<Vec<_>>(),\n                    &BTreeMap::default(),\n                    Some(DisplayPoint::new(DisplayRow(0), 0)),\n                    &snapshot,\n                    window,\n                    cx,\n                )\n            })\n            .unwrap();\n        assert_eq!(layouts.len(), 3);\n\n        let relative_rows = window\n            .update(cx, |editor, window, cx| {\n                let snapshot = editor.snapshot(window, cx);\n                element.calculate_relative_line_numbers(\n                    &snapshot,\n                    &(DisplayRow(0)..DisplayRow(6)),\n                    Some(DisplayRow(3)),\n                    true,\n                )\n            })\n            .unwrap();\n\n        assert_eq!(relative_rows[&DisplayRow(0)], 3);\n        assert_eq!(relative_rows[&DisplayRow(1)], 2);\n        assert_eq!(relative_rows[&DisplayRow(2)], 1);\n        // current line has no relative number\n        assert_eq!(relative_rows[&DisplayRow(4)], 1);\n        assert_eq!(relative_rows[&DisplayRow(5)], 2);\n\n        let layouts = cx\n            .update_window(*window, |_, window, cx| {\n                element.layout_line_numbers(\n                    None,\n                    GutterDimensions {\n                        left_padding: Pixels::ZERO,\n                        right_padding: Pixels::ZERO,\n                        width: px(30.0),\n                        margin: Pixels::ZERO,\n                        git_blame_entries_width: None,\n                    },\n                    line_height,\n                    gpui::Point::default(),\n                    DisplayRow(0)..DisplayRow(6),\n                    &(0..6)\n                        .map(|row| RowInfo {\n                            buffer_row: Some(row),\n                            diff_status: Some(DiffHunkStatus::deleted(\n                                buffer_diff::DiffHunkSecondaryStatus::NoSecondaryHunk,\n                            )),\n                            ..Default::default()\n                        })\n                        .collect::<Vec<_>>(),\n                    &BTreeMap::from_iter([(DisplayRow(0), LineHighlightSpec::default())]),\n                    Some(DisplayPoint::new(DisplayRow(0), 0)),\n                    &snapshot,\n                    window,\n                    cx,\n                )\n            })\n            .unwrap();\n        assert!(\n            layouts.is_empty(),\n            ": "",
        "\n        );\n\n        let relative_rows = window\n            .update(cx, |editor, window, cx| {\n                let snapshot = editor.snapshot(window, cx);\n                element.calculate_relative_line_numbers(\n                    &snapshot,\n                    &(DisplayRow(0)..DisplayRow(6)),\n                    Some(DisplayRow(3)),\n                    true,\n                )\n            })\n            .unwrap();\n\n        // Deleted lines should still have relative numbers\n        assert_eq!(relative_rows[&DisplayRow(0)], 3);\n        assert_eq!(relative_rows[&DisplayRow(1)], 2);\n        assert_eq!(relative_rows[&DisplayRow(2)], 1);\n        // current line, even if deleted, has no relative number\n        assert_eq!(relative_rows[&DisplayRow(4)], 1);\n        assert_eq!(relative_rows[&DisplayRow(5)], 2);\n    }\n\n    #[gpui::test]\n    async fn test_vim_visual_selections(cx: &mut TestAppContext) {\n        init_test(cx, |_| {});\n\n        let window = cx.add_window(|window, cx| {\n            let buffer = MultiBuffer::build_simple(&(sample_text(6, 6, 'a') + ": "",
        "), cx);\n            Editor::new(EditorMode::full(), buffer, None, window, cx)\n        });\n        let cx = &mut VisualTestContext::from_window(*window, cx);\n        let editor = window.root(cx).unwrap();\n        let style = cx.update(|_, cx| editor.read(cx).style().unwrap().clone());\n\n        window\n            .update(cx, |editor, window, cx| {\n                editor.cursor_shape = CursorShape::Block;\n                editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n                    s.select_ranges([\n                        Point::new(0, 0)..Point::new(1, 0),\n                        Point::new(3, 2)..Point::new(3, 3),\n                        Point::new(5, 6)..Point::new(6, 0),\n                    ]);\n                });\n            })\n            .unwrap();\n\n        let (_, state) = cx.draw(\n            point(px(500.), px(500.)),\n            size(px(500.), px(500.)),\n            |_, _| EditorElement::new(&editor, style),\n        );\n\n        assert_eq!(state.selections.len(), 1);\n        let local_selections = &state.selections[0].1;\n        assert_eq!(local_selections.len(), 3);\n        // moves cursor back one line\n        assert_eq!(\n            local_selections[0].head,\n            DisplayPoint::new(DisplayRow(0), 6)\n        );\n        assert_eq!(\n            local_selections[0].range,\n            DisplayPoint::new(DisplayRow(0), 0)..DisplayPoint::new(DisplayRow(1), 0)\n        );\n\n        // moves cursor back one column\n        assert_eq!(\n            local_selections[1].range,\n            DisplayPoint::new(DisplayRow(3), 2)..DisplayPoint::new(DisplayRow(3), 3)\n        );\n        assert_eq!(\n            local_selections[1].head,\n            DisplayPoint::new(DisplayRow(3), 2)\n        );\n\n        // leaves cursor on the max point\n        assert_eq!(\n            local_selections[2].range,\n            DisplayPoint::new(DisplayRow(5), 6)..DisplayPoint::new(DisplayRow(6), 0)\n        );\n        assert_eq!(\n            local_selections[2].head,\n            DisplayPoint::new(DisplayRow(6), 0)\n        );\n\n        // active lines does not include 1 (even though the range of the selection does)\n        assert_eq!(\n            state.active_rows.keys().cloned().collect::<Vec<_>>(),\n            vec![DisplayRow(0), DisplayRow(3), DisplayRow(5), DisplayRow(6)]\n        );\n    }\n\n    #[gpui::test]\n    fn test_layout_with_placeholder_text_and_blocks(cx: &mut TestAppContext) {\n        init_test(cx, |_| {});\n\n        let window = cx.add_window(|window, cx| {\n            let buffer = MultiBuffer::build_simple(": "",
        ", cx);\n            Editor::new(EditorMode::full(), buffer, None, window, cx)\n        });\n        let cx = &mut VisualTestContext::from_window(*window, cx);\n        let editor = window.root(cx).unwrap();\n        let style = cx.update(|_, cx| editor.read(cx).style().unwrap().clone());\n        window\n            .update(cx, |editor, window, cx| {\n                editor.set_placeholder_text(": "",
        ", window, cx);\n                editor.insert_blocks(\n                    [BlockProperties {\n                        style: BlockStyle::Fixed,\n                        placement: BlockPlacement::Above(Anchor::min()),\n                        height: Some(3),\n                        render: Arc::new(|cx| div().h(3. * cx.window.line_height()).into_any()),\n                        priority: 0,\n                    }],\n                    None,\n                    cx,\n                );\n\n                // Blur the editor so that it displays placeholder text.\n                window.blur();\n            })\n            .unwrap();\n\n        let (_, state) = cx.draw(\n            point(px(500.), px(500.)),\n            size(px(500.), px(500.)),\n            |_, _| EditorElement::new(&editor, style),\n        );\n        assert_eq!(state.position_map.line_layouts.len(), 4);\n        assert_eq!(state.line_numbers.len(), 1);\n        assert_eq!(\n            state\n                .line_numbers\n                .get(&MultiBufferRow(0))\n                .map(|line_number| line_number\n                    .segments\n                    .first()\n                    .unwrap()\n                    .shaped_line\n                    .text\n                    .as_ref()),\n            Some(": "",
        ")\n        );\n    }\n\n    #[gpui::test]\n    fn test_all_invisibles_drawing(cx: &mut TestAppContext) {\n        const TAB_SIZE: u32 = 4;\n\n        let input_text = ": "",
        ";\n        let expected_invisibles = vec![\n            Invisible::Tab {\n                line_start_offset: 0,\n                line_end_offset: TAB_SIZE as usize,\n            },\n            Invisible::Whitespace {\n                line_offset: TAB_SIZE as usize,\n            },\n            Invisible::Tab {\n                line_start_offset: TAB_SIZE as usize + 1,\n                line_end_offset: TAB_SIZE as usize * 2,\n            },\n            Invisible::Tab {\n                line_start_offset: TAB_SIZE as usize * 2 + 1,\n                line_end_offset: TAB_SIZE as usize * 3,\n            },\n            Invisible::Whitespace {\n                line_offset: TAB_SIZE as usize * 3 + 1,\n            },\n            Invisible::Whitespace {\n                line_offset: TAB_SIZE as usize * 3 + 3,\n            },\n        ];\n        assert_eq!(\n            expected_invisibles.len(),\n            input_text\n                .chars()\n                .filter(|initial_char| initial_char.is_whitespace())\n                .count(),\n            ": "",
        "\n        );\n\n        for show_line_numbers in [true, false] {\n            init_test(cx, |s| {\n                s.defaults.show_whitespaces = Some(ShowWhitespaceSetting::All);\n                s.defaults.tab_size = NonZeroU32::new(TAB_SIZE);\n            });\n\n            let actual_invisibles = collect_invisibles_from_new_editor(\n                cx,\n                EditorMode::full(),\n                input_text,\n                px(500.0),\n                show_line_numbers,\n            );\n\n            assert_eq!(expected_invisibles, actual_invisibles);\n        }\n    }\n\n    #[gpui::test]\n    fn test_invisibles_dont_appear_in_certain_editors(cx: &mut TestAppContext) {\n        init_test(cx, |s| {\n            s.defaults.show_whitespaces = Some(ShowWhitespaceSetting::All);\n            s.defaults.tab_size = NonZeroU32::new(4);\n        });\n\n        for editor_mode_without_invisibles in [\n            EditorMode::SingleLine,\n            EditorMode::AutoHeight {\n                min_lines: 1,\n                max_lines: Some(100),\n            },\n        ] {\n            for show_line_numbers in [true, false] {\n                let invisibles = collect_invisibles_from_new_editor(\n                    cx,\n                    editor_mode_without_invisibles.clone(),\n                    ": "",
        ",\n                    px(500.0),\n                    show_line_numbers,\n                );\n                assert!(\n                    invisibles.is_empty(),\n                    ": "",
        "\n                );\n            }\n        }\n    }\n\n    #[gpui::test]\n    fn test_wrapped_invisibles_drawing(cx: &mut TestAppContext) {\n        let tab_size = 4;\n        let input_text = ": "",
        ".repeat(9);\n        let repeated_invisibles = [\n            Invisible::Tab {\n                line_start_offset: 1,\n                line_end_offset: tab_size as usize,\n            },\n            Invisible::Whitespace {\n                line_offset: tab_size as usize + 3,\n            },\n            Invisible::Whitespace {\n                line_offset: tab_size as usize + 4,\n            },\n            Invisible::Whitespace {\n                line_offset: tab_size as usize + 5,\n            },\n            Invisible::Whitespace {\n                line_offset: tab_size as usize + 6,\n            },\n            Invisible::Whitespace {\n                line_offset: tab_size as usize + 7,\n            },\n        ];\n        let expected_invisibles = std::iter::once(repeated_invisibles)\n            .cycle()\n            .take(9)\n            .flatten()\n            .collect::<Vec<_>>();\n        assert_eq!(\n            expected_invisibles.len(),\n            input_text\n                .chars()\n                .filter(|initial_char| initial_char.is_whitespace())\n                .count(),\n            ": "",
        "\n        );\n        info!(": "",
        ");\n\n        init_test(cx, |_| {});\n\n        // Put the same string with repeating whitespace pattern into editors of various size,\n        // take deliberately small steps during resizing, to put all whitespace kinds near the wrap point.\n        let resize_step = 10.0;\n        let mut editor_width = 200.0;\n        while editor_width <= 1000.0 {\n            for show_line_numbers in [true, false] {\n                update_test_language_settings(cx, |s| {\n                    s.defaults.tab_size = NonZeroU32::new(tab_size);\n                    s.defaults.show_whitespaces = Some(ShowWhitespaceSetting::All);\n                    s.defaults.preferred_line_length = Some(editor_width as u32);\n                    s.defaults.soft_wrap = Some(language_settings::SoftWrap::PreferredLineLength);\n                });\n\n                let actual_invisibles = collect_invisibles_from_new_editor(\n                    cx,\n                    EditorMode::full(),\n                    &input_text,\n                    px(editor_width),\n                    show_line_numbers,\n                );\n\n                // Whatever the editor size is, ensure it has the same invisible kinds in the same order\n                // (no good guarantees about the offsets: wrapping could trigger padding and its tests should check the offsets).\n                let mut i = 0;\n                for (actual_index, actual_invisible) in actual_invisibles.iter().enumerate() {\n                    i = actual_index;\n                    match expected_invisibles.get(i) {\n                        Some(expected_invisible) => match (expected_invisible, actual_invisible) {\n                            (Invisible::Whitespace { .. }, Invisible::Whitespace { .. })\n                            | (Invisible::Tab { .. }, Invisible::Tab { .. }) => {}\n                            _ => {\n                                panic!(\n                                    ": "",
        "\n                                )\n                            }\n                        },\n                        None => {\n                            panic!(": "",
        ")\n                        }\n                    }\n                }\n                let missing_expected_invisibles = &expected_invisibles[i + 1..];\n                assert!(\n                    missing_expected_invisibles.is_empty(),\n                    ": "",
        "\n                );\n\n                editor_width += resize_step;\n            }\n        }\n    }\n\n    fn collect_invisibles_from_new_editor(\n        cx: &mut TestAppContext,\n        editor_mode: EditorMode,\n        input_text: &str,\n        editor_width: Pixels,\n        show_line_numbers: bool,\n    ) -> Vec<Invisible> {\n        info!(\n            ": "",
        ",\n            f32::from(editor_width)\n        );\n        let window = cx.add_window(|window, cx| {\n            let buffer = MultiBuffer::build_simple(input_text, cx);\n            Editor::new(editor_mode, buffer, None, window, cx)\n        });\n        let cx = &mut VisualTestContext::from_window(*window, cx);\n        let editor = window.root(cx).unwrap();\n\n        let style = cx.update(|_, cx| editor.read(cx).style().unwrap().clone());\n        window\n            .update(cx, |editor, _, cx| {\n                editor.set_soft_wrap_mode(language_settings::SoftWrap::EditorWidth, cx);\n                editor.set_wrap_width(Some(editor_width), cx);\n                editor.set_show_line_numbers(show_line_numbers, cx);\n            })\n            .unwrap();\n        let (_, state) = cx.draw(\n            point(px(500.), px(500.)),\n            size(px(500.), px(500.)),\n            |_, _| EditorElement::new(&editor, style),\n        );\n        state\n            .position_map\n            .line_layouts\n            .iter()\n            .flat_map(|line_with_invisibles| &line_with_invisibles.invisibles)\n            .cloned()\n            .collect()\n    }\n\n    #[gpui::test]\n    fn test_merge_overlapping_ranges() {\n        let base_bg = Hsla::white();\n        let color1 = Hsla {\n            h: 0.0,\n            s: 0.5,\n            l: 0.5,\n            a: 0.5,\n        };\n        let color2 = Hsla {\n            h: 120.0,\n            s: 0.5,\n            l: 0.5,\n            a: 0.5,\n        };\n\n        let display_point = |col| DisplayPoint::new(DisplayRow(0), col);\n        let cols = |v: &Vec<(Range<DisplayPoint>, Hsla)>| -> Vec<(u32, u32)> {\n            v.iter()\n                .map(|(r, _)| (r.start.column(), r.end.column()))\n                .collect()\n        };\n\n        // Test overlapping ranges blend colors\n        let overlapping = vec![\n            (display_point(5)..display_point(15), color1),\n            (display_point(10)..display_point(20), color2),\n        ];\n        let result = EditorElement::merge_overlapping_ranges(overlapping, base_bg);\n        assert_eq!(cols(&result), vec![(5, 10), (10, 15), (15, 20)]);\n\n        // Test middle segment should have blended color\n        let blended = Hsla::blend(Hsla::blend(base_bg, color1), color2);\n        assert_eq!(result[1].1, blended);\n\n        // Test adjacent same-color ranges merge\n        let adjacent_same = vec![\n            (display_point(5)..display_point(10), color1),\n            (display_point(10)..display_point(15), color1),\n        ];\n        let result = EditorElement::merge_overlapping_ranges(adjacent_same, base_bg);\n        assert_eq!(cols(&result), vec![(5, 15)]);\n\n        // Test contained range splits\n        let contained = vec![\n            (display_point(5)..display_point(20), color1),\n            (display_point(10)..display_point(15), color2),\n        ];\n        let result = EditorElement::merge_overlapping_ranges(contained, base_bg);\n        assert_eq!(cols(&result), vec![(5, 10), (10, 15), (15, 20)]);\n\n        // Test multiple overlaps split at every boundary\n        let color3 = Hsla {\n            h: 240.0,\n            s: 0.5,\n            l: 0.5,\n            a: 0.5,\n        };\n        let complex = vec![\n            (display_point(5)..display_point(12), color1),\n            (display_point(8)..display_point(16), color2),\n            (display_point(10)..display_point(14), color3),\n        ];\n        let result = EditorElement::merge_overlapping_ranges(complex, base_bg);\n        assert_eq!(\n            cols(&result),\n            vec![(5, 8), (8, 10), (10, 12), (12, 14), (14, 16)]\n        );\n    }\n\n    #[gpui::test]\n    fn test_bg_segments_per_row() {\n        let base_bg = Hsla::white();\n\n        // Case A: selection spans three display rows: row 1 [5, end), full row 2, row 3 [0, 7)\n        {\n            let selection_color = Hsla {\n                h: 200.0,\n                s: 0.5,\n                l: 0.5,\n                a: 0.5,\n            };\n            let player_color = PlayerColor {\n                cursor: selection_color,\n                background: selection_color,\n                selection: selection_color,\n            };\n\n            let spanning_selection = SelectionLayout {\n                head: DisplayPoint::new(DisplayRow(3), 7),\n                cursor_shape: CursorShape::Bar,\n                is_newest: true,\n                is_local: true,\n                range: DisplayPoint::new(DisplayRow(1), 5)..DisplayPoint::new(DisplayRow(3), 7),\n                active_rows: DisplayRow(1)..DisplayRow(4),\n                user_name: None,\n            };\n\n            let selections = vec![(player_color, vec![spanning_selection])];\n            let result = EditorElement::bg_segments_per_row(\n                DisplayRow(0)..DisplayRow(5),\n                &selections,\n                &[],\n                base_bg,\n            );\n\n            assert_eq!(result.len(), 5);\n            assert!(result[0].is_empty());\n            assert_eq!(result[1].len(), 1);\n            assert_eq!(result[2].len(), 1);\n            assert_eq!(result[3].len(), 1);\n            assert!(result[4].is_empty());\n\n            assert_eq!(result[1][0].0.start, DisplayPoint::new(DisplayRow(1), 5));\n            assert_eq!(result[1][0].0.end.row(), DisplayRow(1));\n            assert_eq!(result[1][0].0.end.column(), u32::MAX);\n            assert_eq!(result[2][0].0.start, DisplayPoint::new(DisplayRow(2), 0));\n            assert_eq!(result[2][0].0.end.row(), DisplayRow(2));\n            assert_eq!(result[2][0].0.end.column(), u32::MAX);\n            assert_eq!(result[3][0].0.start, DisplayPoint::new(DisplayRow(3), 0));\n            assert_eq!(result[3][0].0.end, DisplayPoint::new(DisplayRow(3), 7));\n        }\n\n        // Case B: selection ends exactly at the start of row 3, excluding row 3\n        {\n            let selection_color = Hsla {\n                h: 120.0,\n                s: 0.5,\n                l: 0.5,\n                a: 0.5,\n            };\n            let player_color = PlayerColor {\n                cursor: selection_color,\n                background: selection_color,\n                selection: selection_color,\n            };\n\n            let selection = SelectionLayout {\n                head: DisplayPoint::new(DisplayRow(2), 0),\n                cursor_shape: CursorShape::Bar,\n                is_newest: true,\n                is_local: true,\n                range: DisplayPoint::new(DisplayRow(1), 5)..DisplayPoint::new(DisplayRow(3), 0),\n                active_rows: DisplayRow(1)..DisplayRow(3),\n                user_name: None,\n            };\n\n            let selections = vec![(player_color, vec![selection])];\n            let result = EditorElement::bg_segments_per_row(\n                DisplayRow(0)..DisplayRow(4),\n                &selections,\n                &[],\n                base_bg,\n            );\n\n            assert_eq!(result.len(), 4);\n            assert!(result[0].is_empty());\n            assert_eq!(result[1].len(), 1);\n            assert_eq!(result[2].len(), 1);\n            assert!(result[3].is_empty());\n\n            assert_eq!(result[1][0].0.start, DisplayPoint::new(DisplayRow(1), 5));\n            assert_eq!(result[1][0].0.end.row(), DisplayRow(1));\n            assert_eq!(result[1][0].0.end.column(), u32::MAX);\n            assert_eq!(result[2][0].0.start, DisplayPoint::new(DisplayRow(2), 0));\n            assert_eq!(result[2][0].0.end.row(), DisplayRow(2));\n            assert_eq!(result[2][0].0.end.column(), u32::MAX);\n        }\n    }\n\n    #[cfg(test)]\n    fn generate_test_run(len: usize, color: Hsla) -> TextRun {\n        TextRun {\n            len,\n            color,\n            ..Default::default()\n        }\n    }\n\n    #[gpui::test]\n    fn test_split_runs_by_bg_segments(cx: &mut gpui::TestAppContext) {\n        init_test(cx, |_| {});\n\n        let dx = |start: u32, end: u32| {\n            DisplayPoint::new(DisplayRow(0), start)..DisplayPoint::new(DisplayRow(0), end)\n        };\n\n        let text_color = Hsla {\n            h: 210.0,\n            s: 0.1,\n            l: 0.4,\n            a: 1.0,\n        };\n        let bg_1 = Hsla {\n            h: 30.0,\n            s: 0.6,\n            l: 0.8,\n            a: 1.0,\n        };\n        let bg_2 = Hsla {\n            h: 200.0,\n            s: 0.6,\n            l: 0.2,\n            a: 1.0,\n        };\n        let min_contrast = 45.0;\n        let adjusted_bg1 = ensure_minimum_contrast(text_color, bg_1, min_contrast);\n        let adjusted_bg2 = ensure_minimum_contrast(text_color, bg_2, min_contrast);\n\n        // Case A: single run; disjoint segments inside the run\n        {\n            let runs = vec![generate_test_run(20, text_color)];\n            let segs = vec![(dx(5, 10), bg_1), (dx(12, 16), bg_2)];\n            let out = LineWithInvisibles::split_runs_by_bg_segments(&runs, &segs, min_contrast, 0);\n            // Expected slices: [0,5) [5,10) [10,12) [12,16) [16,20)\n            assert_eq!(\n                out.iter().map(|r| r.len).collect::<Vec<_>>(),\n                vec![5, 5, 2, 4, 4]\n            );\n            assert_eq!(out[0].color, text_color);\n            assert_eq!(out[1].color, adjusted_bg1);\n            assert_eq!(out[2].color, text_color);\n            assert_eq!(out[3].color, adjusted_bg2);\n            assert_eq!(out[4].color, text_color);\n        }\n\n        // Case B: multiple runs; segment extends to end of line (u32::MAX)\n        {\n            let runs = vec![\n                generate_test_run(8, text_color),\n                generate_test_run(7, text_color),\n            ];\n            let segs = vec![(dx(6, u32::MAX), bg_1)];\n            let out = LineWithInvisibles::split_runs_by_bg_segments(&runs, &segs, min_contrast, 0);\n            // Expected slices across runs: [0,6) [6,8) | [0,7)\n            assert_eq!(out.iter().map(|r| r.len).collect::<Vec<_>>(), vec![6, 2, 7]);\n            assert_eq!(out[0].color, text_color);\n            assert_eq!(out[1].color, adjusted_bg1);\n            assert_eq!(out[2].color, adjusted_bg1);\n        }\n\n        // Case C: multi-byte characters\n        {\n            // for text: ": "",
        "\n            let runs = vec![\n                generate_test_run(5, text_color), // ": "",
        "\n                generate_test_run(6, text_color), // ": "",
        "\n                generate_test_run(1, text_color), // ": "",
        "\n            ];\n            // selecting ": "",
        "\n            let segs = vec![(dx(6, 14), bg_1)];\n            let out = LineWithInvisibles::split_runs_by_bg_segments(&runs, &segs, min_contrast, 0);\n            // ": "",
        " | ": "",
        "\n            assert_eq!(\n                out.iter().map(|r| r.len).collect::<Vec<_>>(),\n                vec![5, 1, 5, 3, 3, 1]\n            );\n            assert_eq!(out[0].color, text_color); // ": "",
        "\n            assert_eq!(out[2].color, adjusted_bg1); // ": "",
        "\n            assert_eq!(out[3].color, adjusted_bg1); // ": "",
        "\n            assert_eq!(out[4].color, text_color); // ": "",
        "\n            assert_eq!(out[5].color, text_color); // ": "",
        "\n        }\n\n        // Case D: split multiple consecutive text runs with segments\n        {\n            let segs = vec![\n                (dx(2, 4), bg_1),   // selecting ": "",
        "\n                (dx(4, 8), bg_2),   // selecting ": "",
        "\n                (dx(9, 11), bg_1),  // selecting ": "",
        "\n                (dx(12, 16), bg_2), // selecting ": "",
        "\n                (dx(18, 19), bg_1), // selecting ": "",
        "\n            ];\n\n            // for text: ": "",
        "\n            let runs = vec![\n                generate_test_run(2, text_color), // ab\n                generate_test_run(4, text_color), // cdef\n            ];\n            let out = LineWithInvisibles::split_runs_by_bg_segments(&runs, &segs, min_contrast, 0);\n            // new splits ": "",
        ", ": "",
        "\n            assert_eq!(out.iter().map(|r| r.len).collect::<Vec<_>>(), vec![2, 2, 2]);\n            assert_eq!(out[0].color, text_color);\n            assert_eq!(out[1].color, adjusted_bg1);\n            assert_eq!(out[2].color, adjusted_bg2);\n\n            // for text: ": "",
        "\n            let runs = vec![\n                generate_test_run(3, text_color), // ghi\n                generate_test_run(2, text_color), // jk\n                generate_test_run(3, text_color), // lmn\n            ];\n            let out = LineWithInvisibles::split_runs_by_bg_segments(&runs, &segs, min_contrast, 6); // 2 + 4 from first run\n            // new splits ": "",
        "\n            assert_eq!(\n                out.iter().map(|r| r.len).collect::<Vec<_>>(),\n                vec![2, 1, 2, 1, 2]\n            );\n            assert_eq!(out[0].color, adjusted_bg2);\n            assert_eq!(out[1].color, text_color);\n            assert_eq!(out[2].color, adjusted_bg1);\n            assert_eq!(out[3].color, text_color);\n            assert_eq!(out[4].color, adjusted_bg2);\n\n            // for text: ": "",
        "\n            let runs = vec![\n                generate_test_run(1, text_color), // o\n                generate_test_run(4, text_color), // pqrs\n            ];\n            let out = LineWithInvisibles::split_runs_by_bg_segments(&runs, &segs, min_contrast, 14); // 6 + 3 + 2 + 3 from first two runs\n            // new splits ": ""
    },
    "zed/crates/editor/src/git.rs": {},
    "zed/crates/editor/src/hover_links.rs": {
        ".{suffix}": "",
        "{candidate_file_path}.{suffix}": "",
        "' || ch == '\\'') && !inside_quotes {\n            found_start = true;\n            inside_quotes = true;\n            break;\n        }\n\n        filename.push(ch);\n        token_start -= ch.len_utf8();\n    }\n    if !found_start && token_start != 0 {\n        return None;\n    }\n\n    filename = filename.chars().rev().collect();\n\n    let mut forwards = snapshot\n        .chars_at(offset)\n        .take(LIMIT - (offset - token_start))\n        .peekable();\n    while let Some(ch) = forwards.next() {\n        // Skip escaped whitespace\n        if ch == '\\\\' && forwards.peek().is_some_and(|ch| ch.is_whitespace()) {\n            token_end += ch.len_utf8();\n            let whitespace = forwards.next().unwrap();\n            token_end += whitespace.len_utf8();\n            filename.push(whitespace);\n            continue;\n        }\n\n        if ch.is_whitespace() {\n            found_end = true;\n            break;\n        }\n        if ch == '": "",
        "\n            struct A;\n            let vˇariable = A;\n        ": "",
        "\n            struct A;\n            let «variable» = A;\n        ": "",
        "\n            struct «A»;\n            let variable = A;\n        ": "",
        "\n            struct A;\n            let variable = A;\n        ": "",
        "\n            struct «Aˇ»;\n            let variable = A;\n        ": "",
        "\n                fn ˇtest() { do_work(); }\n                fn do_work() { test(); }\n            ": "",
        "\n                fn test() { do_wˇork(); }\n                fn do_work() { test(); }\n            ": "",
        "\n                fn test() { «do_work»(); }\n                fn do_work() { test(); }\n            ": "",
        "\n                fn test() { do_work(); }\n                fn «do_work»() { test(); }\n            ": "",
        "\n                fn test() { do_work(); }\n                fn do_work() { test(); }\n            ": "",
        "\n                fˇn test() { do_work(); }\n                fn do_work() { test(); }\n            ": "",
        "\n                fn test() { do_work(); }\n                fn do_work() { teˇst(); }\n            ": "",
        "\n                fn test() { do_work(); }\n                fn do_work() { «test»(); }\n            ": "",
        "\n                fn «test»() { do_work(); }\n                fn do_work() { test(); }\n            ": "",
        "\n                fn test() { do_work(); }\n                fn do_work() { tesˇt(); }\n            ": "",
        "\n                fn «testˇ»() { do_work(); }\n                fn do_work() { test(); }\n            ": "",
        "\n                fn test() { do_work(); }\n                fn «do_workˇ»() { test(); }\n            ": "",
        "\n                fn «test() { do_w»ork(); }\n                fn do_work() { test(); }\n            ": "",
        "\n                struct TestStruct;\n\n                fn main() {\n                    let variableˇ = TestStruct;\n                }\n            ": "",
        "\n                struct «TestStruct»;\n\n                fn main() {\n                    let variable = TestStruct;\n                }\n            ": "",
        ": TestStruct": "",
        "\n                struct TestStruct;\n\n                fn main() {\n                    let variable« »= TestStruct;\n                }\n            ": "",
        "When no cmd is pressed, should have no hint label selected, but got: {actual_ranges:?}": "",
        "\n                struct «TestStructˇ»;\n\n                fn main() {\n                    let variable = TestStruct;\n                }\n            ": "",
        "\n            Let's test a [complex](https://zed.dev/channel/had-(oops)) caseˇ.\n        ": "",
        "\n            Let's test a [complex](https://zed.dev/channel/had-(ˇoops)) case.\n            ": "",
        "\n            Let's test a [complex](«https://zed.dev/channel/had-(oops)ˇ») case.\n        ": "",
        "«https://zed.dev/releasesˇ» is a cool webpage.": "",
        "A cool ˇwebpage is https://zed.dev/releases": "",
        "A cool webpage is https://zed.dev/releˇases": "",
        "A cool webpage is «https://zed.dev/releasesˇ»": "",
        "file ˇ name": "",
        "ˇfile name": "",
        "file": "",
        "file ˇname": "",
        "name": "",
        "fiˇle name": "",
        "filenˇame": "",
        "filename": "",
        "foobar ˇ/home/user/f.txt": "",
        "foobar /home/useˇr/f.txt": "",
        "ˇfile\\\\ -\\\\ name.txt": "",
        "file - name.txt": "",
        "file\\\\ -\\\\ naˇme.txt": "",
        "ˇ~/file.txt": "",
        "~/file.txt": "",
        "~/fiˇle.txt": "",
        "\\\"fˇile.txt\\\"": "",
        "file.txt": "",
        "ˇ\\\"file.txt\\\"": "",
        "ˇ\\\"fi\\\\ le.txt\\\"": "",
        "fi le.txt": "",
        "'fˇile.txt'": "",
        "ˇ'file.txt'": "",
        "ˇ'fi\\\\ le.txt'": "",
        " ˇ\\\"常\\\"": "",
        "常": "",
        " \\\"ˇ常\\\"": "",
        "ˇ\\\"常\\\"": "",
        "Failed to find file path: {}": "",
        "Incorrect file path for input: {}": "",
        "Expected no result, but got one: {:?}": "",
        "This is file2.rs": "",
        "\n            You can't go to a file that does_not_exist.txt.\n            Go to file2.rs if you want.\n            Or go to ../dir/file2.rs if you want.\n            Or go to /root/dir/file2.rs if project is local.\n            Or go to /root/dir/file2 if this is a Rust file.ˇ\n            ": "",
        "\n            You can't go to a file that does_not_exist.txt.\n            Go to file2.rs if you want.\n            Or go to ../dir/file2.rs if you want.\n            Or go to C:/root/dir/file2.rs if project is local.\n            Or go to C:/root/dir/file2 if this is a Rust file.ˇ\n        ": "",
        "\n            You can't go to a file that dˇoes_not_exist.txt.\n            Go to file2.rs if you want.\n            Or go to ../dir/file2.rs if you want.\n            Or go to /root/dir/file2.rs if project is local.\n            Or go to /root/dir/file2 if this is a Rust file.\n        ": "",
        "\n            You can't go to a file that dˇoes_not_exist.txt.\n            Go to file2.rs if you want.\n            Or go to ../dir/file2.rs if you want.\n            Or go to C:/root/dir/file2.rs if project is local.\n            Or go to C:/root/dir/file2 if this is a Rust file.\n        ": "",
        "\n            You can't go to a file that does_not_exist.txt.\n            Go to fˇile2.rs if you want.\n            Or go to ../dir/file2.rs if you want.\n            Or go to /root/dir/file2.rs if project is local.\n            Or go to /root/dir/file2 if this is a Rust file.\n        ": "",
        "\n            You can't go to a file that does_not_exist.txt.\n            Go to fˇile2.rs if you want.\n            Or go to ../dir/file2.rs if you want.\n            Or go to C:/root/dir/file2.rs if project is local.\n            Or go to C:/root/dir/file2 if this is a Rust file.\n        ": "",
        "\n            You can't go to a file that does_not_exist.txt.\n            Go to «file2.rsˇ» if you want.\n            Or go to ../dir/file2.rs if you want.\n            Or go to /root/dir/file2.rs if project is local.\n            Or go to /root/dir/file2 if this is a Rust file.\n        ": "",
        "\n            You can't go to a file that does_not_exist.txt.\n            Go to «file2.rsˇ» if you want.\n            Or go to ../dir/file2.rs if you want.\n            Or go to C:/root/dir/file2.rs if project is local.\n            Or go to C:/root/dir/file2 if this is a Rust file.\n        ": "",
        "\n            You can't go to a file that does_not_exist.txt.\n            Go to file2.rs if you want.\n            Or go to ../dir/fˇile2.rs if you want.\n            Or go to /root/dir/file2.rs if project is local.\n            Or go to /root/dir/file2 if this is a Rust file.\n        ": "",
        "\n            You can't go to a file that does_not_exist.txt.\n            Go to file2.rs if you want.\n            Or go to ../dir/fˇile2.rs if you want.\n            Or go to C:/root/dir/file2.rs if project is local.\n            Or go to C:/root/dir/file2 if this is a Rust file.\n        ": "",
        "\n            You can't go to a file that does_not_exist.txt.\n            Go to file2.rs if you want.\n            Or go to «../dir/file2.rsˇ» if you want.\n            Or go to /root/dir/file2.rs if project is local.\n            Or go to /root/dir/file2 if this is a Rust file.\n        ": "",
        "\n            You can't go to a file that does_not_exist.txt.\n            Go to file2.rs if you want.\n            Or go to «../dir/file2.rsˇ» if you want.\n            Or go to C:/root/dir/file2.rs if project is local.\n            Or go to C:/root/dir/file2 if this is a Rust file.\n        ": "",
        "\n            You can't go to a file that does_not_exist.txt.\n            Go to file2.rs if you want.\n            Or go to ../dir/file2.rs if you want.\n            Or go to /root/diˇr/file2.rs if project is local.\n            Or go to /root/dir/file2 if this is a Rust file.\n        ": "",
        "\n            You can't go to a file that does_not_exist.txt.\n            Go to file2.rs if you want.\n            Or go to ../dir/file2.rs if you want.\n            Or go to C:/root/diˇr/file2.rs if project is local.\n            Or go to C:/root/dir/file2 if this is a Rust file.\n        ": "",
        "\n            You can't go to a file that does_not_exist.txt.\n            Go to file2.rs if you want.\n            Or go to ../dir/file2.rs if you want.\n            Or go to «/root/dir/file2.rsˇ» if project is local.\n            Or go to /root/dir/file2 if this is a Rust file.\n        ": "",
        "\n            You can't go to a file that does_not_exist.txt.\n            Go to file2.rs if you want.\n            Or go to ../dir/file2.rs if you want.\n            Or go to «C:/root/dir/file2.rsˇ» if project is local.\n            Or go to C:/root/dir/file2 if this is a Rust file.\n        ": "",
        "\n            You can't go to a file that does_not_exist.txt.\n            Go to file2.rs if you want.\n            Or go to ../dir/file2.rs if you want.\n            Or go to /root/dir/file2.rs if project is local.\n            Or go to /root/diˇr/file2 if this is a Rust file.\n        ": "",
        "\n            You can't go to a file that does_not_exist.txt.\n            Go to file2.rs if you want.\n            Or go to ../dir/file2.rs if you want.\n            Or go to C:/root/dir/file2.rs if project is local.\n            Or go to C:/root/diˇr/file2 if this is a Rust file.\n        ": "",
        "\n            You can't go to a file that does_not_exist.txt.\n            Go to file2.rs if you want.\n            Or go to ../dir/file2.rs if you want.\n            Or go to /root/dir/file2.rs if project is local.\n            Or go to «/root/dir/file2ˇ» if this is a Rust file.\n        ": "",
        "\n            You can't go to a file that does_not_exist.txt.\n            Go to file2.rs if you want.\n            Or go to ../dir/file2.rs if you want.\n            Or go to C:/root/dir/file2.rs if project is local.\n            Or go to «C:/root/dir/file2ˇ» if this is a Rust file.\n        ": "",
        "\n            You can't open ../diˇr because it's a directory.\n        ": "",
        "\n            You can't open ˇ\\\"🤩\\\" because it's an emoji.\n        ": ""
    },
    "zed/crates/editor/src/hover_popover.rs": {
        "no rendered diagnostic": "",
        "Unicode character U+{:02X}": "",
        "```{}\\n{}\\n```": "",
        "\\n\\n": "",
        "file": "",
        "Hover popover point out of bounds after moving": "",
        "info_popover": "",
        "info-md-container": "",
        "diagnostic": "",
        "diagnostic-content-container": "",
        "\n                oneˇ\n                two\n                three\n                fn test() { println!(); }\n            ": "",
        "\n                        one.|<>\n                        two\n                        three\n                    ": "",
        "first_completion": "",
        "second_completion": "",
        "\n                one.\n                two\n                three\n                fn test() { printˇln!(); }\n            ": "",
        "\n                one.\n                two\n                three\n                fn test() { «println!»(); }\n            ": "",
        "some basic docs": "",
        "Expected exactly one hover but got: {:?}": "",
        "\n            one.second_completionˇ\n            two\n            three\n            fn test() { println!(); }\n        ": "",
        "\n                one.second_completionˇ\n                two\n                three\n                fn teˇst() { println!(); }\n            ": "",
        "\n            fn ˇtest() { println!(); }\n        ": "",
        "\n            fn test() { printˇln!(); }\n        ": "",
        "\n            fn test() { «println!»(); }\n        ": "",
        "\n            fn teˇst() { println!(); }\n        ": "",
        "\n            fˇn test() { println!(); }\n        ": "",
        "\n            «fn» test() { println!(); }\n        ": "",
        "Expected no hovers but got but got: {:?}": "",
        "some other basic docs": "",
        "regular text for hover to show": "",
        "No empty string hovers should be shown": "",
        "\\nlet hovered_point: Vector2F // size = 8, align = 0x4\\n": "",
        "\\n```rust\\n{code_str}```": "",
        "Should not have extra line breaks at end of rendered hover": "",
        "\n            fn fuˇnc(abc def: i32) -> u32 {\n            }\n        ": "",
        "\n                    ### function `errands_data_read`\n\n                    ---\n                    → `char *`\n                    Function to read a file into a string\n\n                    ---\n                    ```cpp\n                    static char *errands_data_read()\n                    ```\n                    ": "",
        "Function to read a file": "",
        "\n            struct TestStruct;\n\n            // ==================\n\n            struct TestNewType<T>(T);\n\n            fn main() {\n                let variableˇ = TestNewType(TestStruct);\n            }\n        ": "",
        "\n            struct TestStruct;\n\n            // ==================\n\n            struct «TestNewType»<T>(T);\n\n            fn main() {\n                let variable = TestNewType(TestStruct);\n            }\n        ": "",
        "\n            struct «TestStruct»;\n\n            // ==================\n\n            struct TestNewType<T>(T);\n\n            fn main() {\n                let variable = TestNewType(TestStruct);\n            }\n        ": "",
        "TestNewType": "",
        "TestStruct": "",
        ": TestNewType<TestStruct>": "",
        "\n                struct TestStruct;\n\n                // ==================\n\n                struct TestNewType<T>(T);\n\n                fn main() {\n                    let variable« »= TestNewType(TestStruct);\n                }\n        ": "",
        "Hint {hint_to_resolve:?} was resolved twice": "",
        ": ": "",
        "A tooltip for `{new_type_label}`": "",
        "A tooltip for `{struct_label}`": "",
        "Popover range should match the new type label part": "",
        "A tooltip for {new_type_label}": "",
        "Popover range should match the struct label part": "",
        "A tooltip for {struct_label}": "",
        "Rendered markdown element should remove backticks from text": ""
    },
    "zed/crates/editor/src/indent_guides.rs": {},
    "zed/crates/editor/src/items.rs": {
        "leaders don't share views for unshared buffers": "",
        "cannot call save_as on an excerpt list": "",
        "untitled": "",
        "Editor": "",
        "editors": "",
        "Failed to query editor state": "",
        "Unable to deserialize editor: No entry in database for item_id: {item_id} and workspace_id {workspace_id:?}": "",
        "Deserialized editor {item_id:?} in workspace {workspace_id:?}, {serialized_editor:?}": "",
        "Failed to create buffer while deserializing editor": "",
        "Failed to open path in project": "",
        "Failed to downcast to Editor after opening abs path {abs_path:?}": "",
        "Failed to create buffer": "",
        "Serializing editor {item_id:?} in workspace {workspace_id:?}": "",
        "failed to save serialized editor": "",
        "failed to save contents of buffer": "",
        "just written the type downcasted to": "",
        "fn main() {}": "",
        "hello": ""
    },
    "zed/crates/editor/src/linked_editing_ranges.rs": {},
    "zed/crates/editor/src/lsp_ext.rs": {
        "Timed out waiting for LSP tasks": ""
    },
    "zed/crates/editor/src/mouse_context_menu.rs": {
        "MouseContextMenu": "",
        "position": "",
        "context_menu": "",
        "Run to Cursor": "",
        "Evaluate Selection": "",
        "Go to Definition": "",
        "Go to Declaration": "",
        "Go to Type Definition": "",
        "Go to Implementation": "",
        "Find All References": "",
        "Rename Symbol": "",
        "Format Buffer": "",
        "Format Selections": "",
        "Show Code Actions": "",
        "Add to Agent Thread": "",
        "Cut": "",
        "Copy": "",
        "Copy and Trim": "",
        "Paste": "",
        "Reveal in Finder": "",
        "Reveal in File Manager": "",
        "Open in Terminal": "",
        "Copy Permalink": "",
        "\n            fn teˇst() {\n                do_work();\n            }\n        ": "",
        "\n            fn test() {\n                do_wˇork();\n            }\n        ": ""
    },
    "zed/crates/editor/src/movement.rs": {
        "move left": "",
        "subkind": "",
        "previous_word_start mismatch for '{}': actual={:?}, expected={:?}": "",
        "\\nˇ   ˇlorem": "",
        "ˇ\\nˇ   lorem": "",
        "    ˇloremˇ": "",
        "ˇ    ˇlorem": "",
        "    ˇlorˇem": "",
        "\\nlorem\\nˇ   ˇipsum": "",
        "\\n\\nˇ\\nˇ": "",
        "    ˇlorem  ˇipsum": "",
        "ˇlorem-ˇipsum": "",
        "loremˇ-#$@ˇipsum": "",
        "ˇlorem_ˇipsum": "",
        " ˇdefγˇ": "",
        " ˇbcΔˇ": "",
        "ˇhello.ˇ": "",
        "helloˇ...ˇ": "",
        "helloˇ.---..ˇtest": "",
        "test  ˇ.--ˇtest": "",
        "oneˇ,;:!?ˇtwo": "",
        "lorem_ˇipˇsum": "",
        "lorem_ˇipsumˇ": "",
        "lorem_ˇipsum_ˇdolor": "",
        "loremˇIpˇsum": "",
        "loremˇIpsumˇ": "",
        "loremˇ-ˇipsum": "",
        " bcˇΔˇ": "",
        " ˇbcδˇ": "",
        " abˇ——ˇcd": "",
        "abcˇdef\\ngh\\nijˇk": "",
        "abcdef\\nˇgh\\nijˇk": "",
        "abcdefghijklmnopqrstuvwxys": "",
        "Helvetica": "",
        "test": "",
        "Should not stop at inlays when looking for boundaries": "",
        "next_word_end mismatch for '{}': actual={:?}, expected={:?}": "",
        "\\nˇ   loremˇ": "",
        "    lorˇemˇ": "",
        "    loremˇ    ˇ\\nipsum\\n": "",
        "\\nˇ\\nˇ\\n\\n": "",
        "loremˇ    ipsumˇ   ": "",
        "loremˇ-ipsumˇ": "",
        "loremˇ#$@-ˇipsum": "",
        "loremˇ_ipsumˇ": "",
        "ˇ.helloˇ": "",
        "display_pointsˇ[0ˇ]": "",
        "ˇ...ˇhello": "",
        "testˇ.--ˇ test": "",
        "loˇremˇ_ipsum": "",
        "ˇloremˇ_ipsum": "",
        "loremˇ_ipsumˇ_dolor": "",
        "loˇremˇIpsum": "",
        "loremˇIpsumˇDolor": "",
        " ˇbcˇΔ": "",
        "abˇcdef\\ngh\\nˇijk": "",
        "abcˇdef\\ngh\\nˇijk": "",
        "abc\\ndefg\\nhijkl\\nmn": "",
        "abc\\ndefg\\n\\nhijkl\\nmn": ""
    },
    "zed/crates/editor/src/persistence.rs": {
        "NOT NULL": "",
        "Saving selections for editor {editor_id} in workspace {workspace_id:?}": "",
        "(?1, ?2, ?, ?)": "",
        ", ": "",
        "\nDELETE FROM editor_selections WHERE editor_id = ?1 AND workspace_id = ?2;\n\nINSERT OR IGNORE INTO editor_selections (editor_id, workspace_id, start, end)\nVALUES {placeholders};\n": "",
        "Saving folds for editor {editor_id} in workspace {workspace_id:?}": "",
        "\nDELETE FROM editor_folds WHERE editor_id = ?1 AND workspace_id = ?2;\n\nINSERT OR IGNORE INTO editor_folds (editor_id, workspace_id, start, end)\nVALUES {placeholders};\n": "",
        "testing.txt": "",
        "Test": "",
        "Go": ""
    },
    "zed/crates/editor/src/rust_analyzer_ext.rs": {
        "lsp ext go to parent module proto request": "",
        "go to parent module via collab": "",
        "go to parent module": "",
        "lsp ext expand macro proto request": "",
        "expand macro": "",
        "Empty macro expansion for position {:?}": "",
        "lsp ext open docs proto request": "",
        "open docs": "",
        "Empty docs urls for position {:?}": ""
    },
    "zed/crates/extension/src/extension_builder.rs": {
        "wasm32-wasip2": "",
        "x86_64": "",
        "wasi-sdk-25.0-x86_64-macos.tar.gz": "",
        "aarch64": "",
        "wasi-sdk-25.0-arm64-macos.tar.gz": "",
        "wasi-sdk-25.0-x86_64-linux.tar.gz": "",
        "wasi-sdk-25.0-arm64-linux.tar.gz": "",
        "wasi-sdk-25.0-x86_64-windows.tar.gz": "",
        "extension dir {} is not an absolute path": "",
        "failed to create cache dir": "",
        "compiling Rust extension {}": "",
        "failed to compile Rust extension": "",
        "compiled Rust extension {}": "",
        "failed to read debug adapter schema for `{debug_adapter_name}` from `{debug_adapter_schema_path:?}`": "",
        "Debug adapter schema for `{debug_adapter_name}` (path: `{debug_adapter_schema_path:?}`) is not a valid JSON": "",
        "grammar name '{grammar_name}' must be written in snake_case: {snake_cased_grammar_name}": "",
        "compiling grammar {grammar_name} for extension {}": "",
        "failed to compile grammar '{grammar_name}'": "",
        "compiled grammar {grammar_name} for extension {}": "",
        "finished compiling extension {}": "",
        "Cargo.toml": "",
        "compiling Rust crate for extension {}": "",
        "cargo": "",
        "build": "",
        "--target": "",
        "--release": "",
        "--target-dir": "",
        "target": "",
        "RUSTC_WRAPPER": "",
        "failed to run `cargo`": "",
        "failed to build extension {}": "",
        "compiled Rust crate for extension {}": "",
        "release": "",
        "debug": "",
        "_": "",
        "wasm": "",
        "encoding wasm component for extension {}": "",
        "failed to read output module `{}`": "",
        "failed to strip debug sections from wasm component": "",
        "compiled wasm did not contain a valid zed extension api version": "",
        "extension.wasm": "",
        "failed to write extension.wasm": "",
        "extension {} written to {}": "",
        "grammars": "",
        "checking out {grammar_name} parser": "",
        "src": "",
        "parser.c": "",
        "scanner.c": "",
        "compiling {grammar_name} parser": "",
        "-fPIC": "",
        "-shared": "",
        "-Os": "",
        "-Wl,--export=tree_sitter_{grammar_name}": "",
        "-o": "",
        "-I": "",
        "failed to run clang": "",
        "failed to compile {} parser with clang: {}": "",
        ".git": "",
        "git": "",
        "--git-dir": "",
        "remote": "",
        "-v": "",
        "origin": "",
        "grammar directory '{}' already exists, but is not a git clone of '{}'": "",
        "failed to create grammar directory {}": "",
        "init": "",
        "failed to run `git init` in directory '{}'": "",
        "add": "",
        "failed to execute `git remote add`": "",
        "failed to add remote {url} for git repository {}": "",
        "fetch": "",
        "--depth": "",
        "failed to execute `git fetch`": "",
        "checkout": "",
        "failed to execute `git checkout`": "",
        "failed to fetch revision {} in directory '{}'": "",
        "failed to checkout revision {} in directory '{}': {}": "",
        "rustc": "",
        "--print": "",
        "sysroot": "",
        "failed to run rustc": "",
        "failed to retrieve rust sysroot: {}": "",
        "lib/rustlib": "",
        "rustup": "",
        "failed to run `rustup target add`": "",
        "failed to install the `{RUST_TARGET}` target: {}": "",
        "{WASI_SDK_URL}{asset_name}": "",
        "wasi-sdk is not available for platform {}": "",
        "wasi-sdk": "",
        "bin": "",
        "clang{}": "",
        "downloading wasi-sdk to {}": "",
        "wasi-sdk-temp": "",
        "failed to create extraction directory": "",
        "wasi-sdk.tar.gz": "",
        "failed to create temporary tar.gz file": "",
        "un-tarring wasi-sdk to {}": "",
        "tar": "",
        "-xzf": "",
        "-C": "",
        "failed to run tar": "",
        "failed to extract wasi-sdk archive: {}": "",
        "finished downloading wasi-sdk": "",
        "no content": "",
        "failed to read contents of extracted wasi archive directory": "",
        "failed to move extracted wasi dir": "",
        "name": "",
        "component-type:": "",
        "dylink.0": "",
        "zed:api-version": "",
        "languages": "",
        "failed to list languages dir": "",
        "config.toml": "",
        "themes": "",
        "failed to list themes dir": "",
        "json": "",
        "icon_themes": "",
        "failed to list icon themes dir": "",
        "snippets.json": "",
        "failed to list grammars dir": "",
        "toml": "",
        "no grammar name": ""
    },
    "zed/crates/extension/src/extension_host_proxy.rs": {},
    "zed/crates/extension/src/extension_manifest.rs": {
        "BTreeMap::is_empty": "",
        "capability for process:exec {desired_command} {desired_args:?} was not listed in the extension manifest": "",
        "debug_adapter_schemas": "",
        "json": "",
        "ai.svg": "",
        "{os}-{arch}": "",
        "darwin": "",
        "aarch64": "",
        "x86_64": "",
        "./myagent": "",
        "--serve": "",
        "abc123...": "",
        "node": "",
        "index.js": "",
        "--port": "",
        "commit": "",
        "invalid extension name": "",
        "extension.json": "",
        "loading {extension_name} extension.json, {extension_manifest_path:?}": "",
        "invalid extension.json for extension {extension_name}": "",
        "toml": "",
        "loading {extension_name} extension.toml, {extension_manifest_path:?}": "",
        "Invalid extension.toml for extension {extension_name}:\\n{err}": "",
        "test": "",
        "Test": "",
        "1.0.0": "",
        "my_adapter": "",
        "foo/bar": "",
        "my_adapter.json": "",
        "ls": "",
        "-la": "",
        "-l": "",
        "pwd": "",
        "git": "",
        "status": "",
        "-s": "",
        "npm": "",
        "install": "",
        "cargo": "",
        "--all": "",
        "--no-fail-fast": "",
        "build": "",
        "docker": "",
        "run": "",
        "nginx": "",
        "ubuntu": "",
        "bash": "",
        "alpine": "",
        "sh": "",
        "-c": "",
        "echo hello": "",
        "ps": "",
        "\nid = ": "",
        "\nname = ": "",
        "\nversion = ": "",
        "\nschema_version = 0\n\n[agent_servers.foo]\nname = ": "",
        "\n\n[agent_servers.foo.targets.linux-x86_64]\narchive = ": "",
        "\ncmd = ": "",
        "\nargs = [": "",
        "manifest should parse": "",
        "example.agent-server-ext": "",
        "linux-x86_64": "",
        "./agent": ""
    },
    "zed/crates/extension/src/extension.rs": {
        "error parsing wasm extension": "",
        "zed:api-version": "",
        "extension {} has invalid zed:api-version section: {:?}": "",
        "extension {extension_id} has no zed:api-version section": ""
    },
    "zed/crates/extension/src/types.rs": {
        "[REDACTED]": "",
        "Command": "",
        "command": "",
        "args": "",
        "env": ""
    },
    "zed/crates/extension_api/src/extension_api.rs": {
        "`language_server_command` not implemented": "",
        "`run_slash_command` not implemented": "",
        "`context_server_command` not implemented": "",
        "`index_docs` not implemented": "",
        "`get_dap_binary` not implemented": "",
        "`dap_request_kind` not implemented": "",
        "low-level": "",
        "`dap_config_to_scenario` not implemented": "",
        "`run_dap_locator` not implemented": "",
        "wasi": "",
        "C": "",
        "PWD": "",
        "init-extension": "",
        "wasm32": "",
        "zed:api-version": "",
        "OUT_DIR": "",
        "/version_bytes": "",
        "Failed to parse config: {e}": ""
    },
    "zed/crates/extension_api/src/http_client.rs": {
        "Method not set": "",
        "URL not set": ""
    },
    "zed/crates/extension_api/src/settings.rs": {
        "language": "",
        "lsp": "",
        "context_servers": ""
    },
    "zed/crates/extension_cli/src/main.rs": {
        "zed-extension": "",
        "failed to canonicalize source_dir": "",
        "failed to canonicalize scratch_dir": "",
        "loading extension manifest": "",
        "compiling extension": "",
        "Zed Extension CLI/{} ({}; {})": "",
        "CARGO_PKG_VERSION": "",
        "failed to compile extension": "",
        "archive": "",
        "failed to copy extension resources": "",
        "tar": "",
        "-czvf": "",
        "archive.tar.gz": "",
        "-C": "",
        "failed to run tar": "",
        "failed to create archive.tar.gz: {}": "",
        "missing repository in extension manifest": "",
        "manifest.json": "",
        "failed to create output dir": "",
        "failed to serialize manifest": "",
        "extension.toml": "",
        "failed to write extension.toml": "",
        "extension.wasm": "",
        "failed to copy extension.wasm": "",
        "grammars": "",
        "wasm": "",
        "failed to copy grammar '{}'": "",
        "themes": "",
        "invalid theme path": "",
        "failed to copy theme '{}'": "",
        "icon_themes": "",
        "invalid icon theme path": "",
        "failed to copy icon theme '{}'": "",
        "icons": "",
        "failed to copy icons": "",
        "failed to copy agent server icon '{}'": "",
        "languages": "",
        "invalid language path": "",
        "failed to copy language dir '{}'": "",
        "debug_adapter_schemas": "",
        "json": "",
        "invalid empty schema path for {debug_adapter}": "",
        "failed to copy debug adapter schema '{}'": "",
        "failed to copy snippets from '{}'": "",
        "loaded grammar {grammar_name}": "",
        "config.toml": "",
        "grammar not found: '{name}'": "",
        "scm": "",
        "language {} provides query {} but no grammar": "",
        "loaded language {}": "",
        "loaded theme family {}": "",
        "Theme ": "",
        " is using a deprecated style property: scrollbar_thumb.background. Use `scrollbar.thumb.background` instead.": ""
    },
    "zed/crates/extensions_ui/src/components/extension_card.rs": {
        "Overridden by dev extension.": ""
    },
    "zed/crates/extensions_ui/src/extension_suggest.rs": {
        "astro": "",
        "beancount": "",
        "clojure": "",
        "bb": "",
        "clj": "",
        "cljc": "",
        "cljs": "",
        "edn": "",
        "neocmake": "",
        "CMakeLists.txt": "",
        "cmake": "",
        "csharp": "",
        "cs": "",
        "cython": "",
        "pyx": "",
        "pxd": "",
        "pxi": "",
        "dart": "",
        "dockerfile": "",
        "Dockerfile": "",
        "elisp": "",
        "el": "",
        "elixir": "",
        "ex": "",
        "exs": "",
        "heex": "",
        "elm": "",
        "erlang": "",
        "erl": "",
        "hrl": "",
        "fish": "",
        "git-firefly": "",
        ".gitconfig": "",
        ".gitignore": "",
        "COMMIT_EDITMSG": "",
        "EDIT_DESCRIPTION": "",
        "MERGE_MSG": "",
        "NOTES_EDITMSG": "",
        "TAG_EDITMSG": "",
        "git-rebase-todo": "",
        "gleam": "",
        "glsl": "",
        "vert": "",
        "frag": "",
        "graphql": "",
        "gql": "",
        "haskell": "",
        "hs": "",
        "html": "",
        "htm": "",
        "shtml": "",
        "java": "",
        "kotlin": "",
        "kt": "",
        "latex": "",
        "tex": "",
        "log": "",
        "lua": "",
        "make": "",
        "Makefile": "",
        "nim": "",
        "nix": "",
        "nu": "",
        "ocaml": "",
        "ml": "",
        "mli": "",
        "php": "",
        "powershell": "",
        "ps1": "",
        "psm1": "",
        "prisma": "",
        "proto": "",
        "purescript": "",
        "purs": "",
        "r": "",
        "R": "",
        "racket": "",
        "rkt": "",
        "rescript": "",
        "res": "",
        "resi": "",
        "rst": "",
        "ruby": "",
        "rb": "",
        "erb": "",
        "scheme": "",
        "scm": "",
        "scss": "",
        "sql": "",
        "svelte": "",
        "swift": "",
        "templ": "",
        "terraform": "",
        "tf": "",
        "tfvars": "",
        "hcl": "",
        "toml": "",
        "Cargo.lock": "",
        "typst": "",
        "typ": "",
        "vue": "",
        "wgsl": "",
        "wit": "",
        "zig": "",
        "{}_extension_suggest": "",
        "Do you want to install the recommended '{}' extension for '{}' files?": "",
        "Yes, install extension": "",
        "No, don't install it": "",
        "dismissed": "",
        "Cargo.toml": "",
        "a/b/c/d/.gitignore": "",
        "a/b/c/d/test.gleam": ""
    },
    "zed/crates/extensions_ui/src/extension_version_selector.rs": {
        "v{}": "",
        "Select extension version...": "",
        "Incompatible": "",
        "%Y-%m-%d": ""
    },
    "zed/crates/extensions_ui/src/extensions_ui.rs": {
        "Failed to install dev extension: {:?}": "",
        "Failed to install dev extension: {}": "",
        "Themes": "",
        "Icon Themes": "",
        "Languages": "",
        "Grammars": "",
        "Language Servers": "",
        "MCP Servers": "",
        "Agent Servers": "",
        "Slash Commands": "",
        "Indexed Docs Providers": "",
        "Snippets": "",
        "Debug Adapters": "",
        "claude": "",
        "claude code": "",
        "codex": "",
        "codex cli": "",
        "gemini": "",
        "gemini cli": "",
        "ruff": "",
        "tail": "",
        "tailwind": "",
        "git": "",
        "sh": "",
        "bash": "",
        "c": "",
        "clang": "",
        "c++": "",
        "cpp": "",
        "go": "",
        "golang": "",
        "python": "",
        "py": "",
        "react": "",
        "rust": "",
        "type": "",
        "typescript": "",
        "ts": "",
        "github": "",
        "gitlab": "",
        "bitbucket": "",
        "codeberg": "",
        "sourcehut": "",
        "permalink": "",
        "link": "",
        "open in": "",
        "vim": "",
        "Search extensions...": "",
        "id:{id}": "",
        "id:": "",
        "no extension found": "",
        "v{}": "",
        "rebuild-{}": "",
        "Rebuild": "",
        "Uninstall": "",
        "configure-{}": "",
        "Configure": "",
        "{}: {}": "",
        "Authors": "",
        "Author": "",
        ", ": "",
        "repository-{}": "",
        "v{version}": "",
        "(v{installed_version} installed)": "",
        "Downloads: {}": "",
        "more-{}": "",
        "Install Another Version...": "",
        "Copy Extension ID": "",
        "Copy Author Info": "",
        "Install": "",
        "Extension Installed": "",
        "Upgrade": "",
        "Extension Uninstalled": "",
        "v{version} is not compatible with this version of Zed.": "",
        "BufferSearchBar": "",
        "no extensions": "",
        "Loading extensions...": "",
        "No extensions that match your search.": "",
        "No extensions.": "",
        "No installed extensions that match your search.": "",
        "No installed extensions.": "",
        "No not installed extensions that match your search.": "",
        "No not installed extensions.": "",
        "open_docs": "",
        "View Documentation": "",
        "Documentation Viewed": "",
        "Feature Upsell": "",
        "Enable Vim mode": "",
        "enable-vim": "",
        "Vim Mode Toggled": "",
        "Claude Code support is built-in to Zed!": "",
        "Codex CLI support is built-in to Zed!": "",
        "Gemini CLI support is built-in to Zed!": "",
        "Ruff (linter for Python) support is built-in to Zed!": "",
        "Tailwind CSS support is built-in to Zed!": "",
        "Zed comes with basic Git support—more features are coming in the future.": "",
        "Shell support is built-in to Zed!": "",
        "C support is built-in to Zed!": "",
        "C++ support is built-in to Zed!": "",
        "Go support is built-in to Zed!": "",
        "Python support is built-in to Zed!": "",
        "React support is built-in to Zed!": "",
        "Rust support is built-in to Zed!": "",
        "Typescript support is built-in to Zed!": "",
        "Zed supports linking to a source line on GitHub and others.": "",
        "Vim support is built-in to Zed!": "",
        "Extensions": "",
        "install-dev-extension": "",
        "Install Dev Extension": "",
        "filter-all": "",
        "All": "",
        "Show all extensions": "",
        "filter-installed": "",
        "Installed": "",
        "Show installed extensions": "",
        "filter-not-installed": "",
        "Not Installed": "",
        "Show not installed extensions": "",
        "filter-row": "",
        "filter-all-categories": "",
        "filter-category-{}": "",
        "entries": "",
        "Extensions Page Opened": ""
    },
    "zed/crates/feedback/src/feedback.rs": {
        "template=10_bug_report.yml": "",
        "environment={}": "",
        "mailto:hi@zed.dev": "",
        "body={}": "",
        "\\n\\nSystem Information:\\n\\n{}": "",
        "Copied into clipboard": "",
        "OK": ""
    },
    "zed/crates/file_finder/src/file_finder_tests.rs": {
        "p/a/b/c/d/": "",
        "p/…/d/": "",
        "p/a/…/c/d/": "",
        "p/…/c/d/": "",
        "p/a/b/c/d": "",
        "p/…/d": "",
        "p/a/…/c/d": "",
        "p/…/c/d": "",
        "/p/a/b/c/d/": "",
        "/p/…/d/": "",
        "/p/a/…/c/d/": "",
        "/p/…/c/d/": "",
        "project/dir/child/grandchild": "",
        "project/one/two/X/three/sub": "",
        "project/…/X/three/sub": "",
        "project/one/two/three/X/sub": "",
        "project/…/three/X/sub": "",
        "b0.5": "",
        "c1.0": "",
        "a1.0": "",
        "a0.5": "",
        "b1.0": "",
        "/root": "",
        "a": "",
        "banana": "",
        "bandana": "",
        "bna": "",
        "./bandana": "",
        ".\\\\bandana": "",
        "a/bandana": "",
        "b/bandana": "",
        "b\\\\bandana": "",
        " bandana": "",
        "bandana ": "",
        " bandana ": "",
        " ndan ": "",
        " band ": "",
        "a bandana": "",
        "bandana:": "",
        "Wrong number of matches for bandana query '{bandana_query}'. Matches: {:?}": "",
        "Wrong match for bandana query '{bandana_query}'": "",
        "foo:bar.rs": "",
        "foo.rs": "",
        "foo:": "",
        "b": "",
        "İg": "",
        " ": "",
        "g": "",
        "file1.txt": "",
        "file2.txt": "",
        "a/b/file2.txt": "",
        "Matching abs path should be the only match": "",
        "Mismatching abs path should produce no matches": "",
        "其他": "",
        "S数据表格": "",
        "task.xlsx": "",
        "some content": "",
        "t": "",
        "其他/S数据表格/task.xlsx": "",
        "first.rs": "",
        "// First Rust file": "",
        "/src": "",
        "test": "",
        "second.rs": "",
        "// Second Rust file": "",
        "{file_query}:{file_row}:{file_column}": "",
        "Finder should have a query after the update_matches call": "",
        "Expected to have 1 selection (caret) after file finder confirm, but got: {all_selections:?}": "",
        "Caret selection should have its start and end at the same position": "",
        "Query inside file should get caret with the same focus row": "",
        "Query inside file should get caret with the same focus column": "",
        "Excessive rows (as in query outside file borders) should get trimmed to last file row": "",
        "Excessive columns (as in query outside file borders) should get trimmed to selected row's last column": "",
        "/dir": "",
        "hello": "",
        "goodbye": "",
        "halogen-light": "",
        "happiness": "",
        "height": "",
        "hi": "",
        "hiccup": "",
        "height_demo/**/hi_bonjour": "",
        "**/height_1": "",
        "/ancestor": "",
        ".gitignore": "",
        "ignored-root": "",
        "tracked-root": "",
        "height*": "",
        "heights": "",
        "height_1": "",
        "height_2": "",
        "height_demo": "",
        "test_1": "",
        "hi_bonjour": "",
        "hihi": "",
        "bye": "",
        "test_2": "",
        "hoi": "",
        "nl": "",
        "height_include": "",
        "height_1_include": "",
        "height_2_include": "",
        "/ancestor/tracked-root": "",
        "/ancestor/ignored-root": "",
        "ignored-root/hi": "",
        "tracked-root/hi": "",
        "ignored-root/hiccup": "",
        "tracked-root/hiccup": "",
        "tracked-root/height_demo/test_1/hi_bonjour": "",
        "ignored-root/height": "",
        "tracked-root/heights/height_1": "",
        "ignored-root/happiness": "",
        "tracked-root/happiness": "",
        "All ignored files that were indexed are found for default ignored mode": "",
        "**/.env": "",
        "node_modules": "",
        "package.json": "",
        ".env": "",
        "BAR=FOO": "",
        "FOO=BAR": "",
        "json": "",
        "tracked-root/height": "",
        "All ignored files should be found, for the toggled on ignored mode": "",
        "Only non-ignored files should be found for the turned off ignored mode": "",
        "/ancestor/tracked-root/heights/height_1": "",
        "Only for the worktree with the ignored root, all indexed ignored files are found in the auto ignored mode": "",
        "tracked-root/heights/height_2": "",
        "All ignored files that were indexed are found in the turned on ignored mode": "",
        "the-parent-dir": "",
        "the-file": "",
        "/root/the-parent-dir/the-file": "",
        "thf": "",
        "thf/": "",
        "/repo1": "",
        ": ": "",
        "src": "",
        "index.js": "",
        "// Repo 1 index": "",
        "/repo2": "",
        "// Repo 2 index": "",
        "Expected 1 history match + 1 search matches, but got {} matches: {:?}": "",
        "Should have exactly 1 history match": "",
        "Should have exactly 1 search match (the other package.json)": "",
        "/roota": "",
        "the-parent-dira": "",
        "filea": "",
        "/rootb": "",
        "the-parent-dirb": "",
        "fileb": "",
        "the-parent-dirb/fileb": "",
        "the-parent-dirb/filec": "",
        "rootb/filec": "",
        "filec": "",
        "dir1": "",
        "a.txt": "",
        "dir2": "",
        "b.txt": "",
        "dir2/b.txt": "",
        "dir2/a.txt": "",
        "dir1/a.txt": "",
        "dir3": "",
        "dir": "",
        "third.rs": "",
        "// Third Rust file": "",
        "fir": "",
        "Should have no history before opening any files": "",
        "sec": "",
        "test/first.rs": "",
        "Should show 1st opened item in the history when opening the 2nd item": "",
        "thi": "",
        "test/second.rs": "",
        "\n    );\n\n    let history_after_third =\n        open_close_queried_buffer(": "",
        ", 1, ": "",
        ", &workspace, cx).await;\n    assert_eq!(\n        history_after_third,\n        vec![\n            FoundPath::new(\n                ProjectPath {\n                    worktree_id,\n                    path: rel_path(": "",
        ").into(),\n                },\n                PathBuf::from(path!(": "",
        "))\n            ),\n            FoundPath::new(\n                ProjectPath {\n                    worktree_id,\n                    path: rel_path(": "",
        "))\n            ),\n        ],\n        ": "",
        "\n    );\n\n    let history_after_second_again =\n        open_close_queried_buffer(": "",
        ", &workspace, cx).await;\n    assert_eq!(\n        history_after_second_again,\n        vec![\n            FoundPath::new(\n                ProjectPath {\n                    worktree_id,\n                    path: rel_path(": "",
        "\n    );\n}\n\n#[gpui::test]\nasync fn test_history_match_positions(cx: &mut gpui::TestAppContext) {\n    let app_state = init_test(cx);\n\n    app_state\n        .fs\n        .as_fake()\n        .insert_tree(\n            path!(": "",
        "),\n            json!({\n                ": "",
        ": {\n                    ": "",
        ",\n                    ": "",
        ",\n                }\n            }),\n        )\n        .await;\n\n    let project = Project::test(app_state.fs.clone(), [path!(": "",
        ").as_ref()], cx).await;\n    let (workspace, cx) = cx.add_window_view(|window, cx| Workspace::test_new(project, window, cx));\n\n    workspace.update_in(cx, |_workspace, window, cx| window.focused(cx));\n\n    open_close_queried_buffer(": "",
        ", &workspace, cx).await;\n    let history = open_close_queried_buffer(": "",
        ", &workspace, cx).await;\n    assert_eq!(history.len(), 1);\n\n    let picker = open_file_picker(&workspace, cx);\n    cx.simulate_input(": "",
        ");\n    picker.update_in(cx, |finder, window, cx| {\n        let matches = &finder.delegate.matches.matches;\n        assert_matches!(\n            matches.as_slice(),\n            [Match::History { .. }, Match::CreateNew { .. }]\n        );\n        assert_eq!(\n            matches[0].panel_match().unwrap().0.path.as_ref(),\n            rel_path(": "",
        ")\n        );\n        assert_eq!(matches[0].panel_match().unwrap().0.positions, &[5, 6, 7]);\n\n        let (file_label, path_label) =\n            finder\n                .delegate\n                .labels_for_match(&finder.delegate.matches.matches[0], window, cx);\n        assert_eq!(file_label.text(), ": "",
        ");\n        assert_eq!(file_label.highlight_indices(), &[0, 1, 2]);\n        assert_eq!(\n            path_label.text(),\n            format!(": "",
        ", PathStyle::local().separator())\n        );\n        assert_eq!(path_label.highlight_indices(), &[] as &[usize]);\n    });\n}\n\n#[gpui::test]\nasync fn test_external_files_history(cx: &mut gpui::TestAppContext) {\n    let app_state = init_test(cx);\n\n    app_state\n        .fs\n        .as_fake()\n        .insert_tree(\n            path!(": "",
        ",\n                }\n            }),\n        )\n        .await;\n\n    app_state\n        .fs\n        .as_fake()\n        .insert_tree(\n            path!(": "",
        ").as_ref()], cx).await;\n    cx.update(|cx| {\n        project.update(cx, |project, cx| {\n            project.find_or_create_worktree(path!(": "",
        "), false, cx)\n        })\n    })\n    .detach();\n    cx.background_executor.run_until_parked();\n\n    let (workspace, cx) = cx.add_window_view(|window, cx| Workspace::test_new(project, window, cx));\n    let worktree_id = cx.read(|cx| {\n        let worktrees = workspace.read(cx).worktrees(cx).collect::<Vec<_>>();\n        assert_eq!(worktrees.len(), 1,);\n\n        WorktreeId::from_usize(worktrees[0].entity_id().as_u64() as usize)\n    });\n    workspace\n        .update_in(cx, |workspace, window, cx| {\n            workspace.open_abs_path(\n                PathBuf::from(path!(": "",
        ")),\n                OpenOptions {\n                    visible: Some(OpenVisible::None),\n                    ..Default::default()\n                },\n                window,\n                cx,\n            )\n        })\n        .detach();\n    cx.background_executor.run_until_parked();\n    let external_worktree_id = cx.read(|cx| {\n        let worktrees = workspace.read(cx).worktrees(cx).collect::<Vec<_>>();\n        assert_eq!(\n            worktrees.len(),\n            2,\n            ": "",
        "\n        );\n\n        WorktreeId::from_usize(\n            worktrees\n                .into_iter()\n                .find(|worktree| worktree.entity_id().as_u64() as usize != worktree_id.to_usize())\n                .expect(": "",
        ")\n                .entity_id()\n                .as_u64() as usize,\n        )\n    });\n    cx.dispatch_action(workspace::CloseActiveItem {\n        save_intent: None,\n        close_pinned: false,\n    });\n\n    let initial_history_items =\n        open_close_queried_buffer(": "",
        ", &workspace, cx).await;\n    assert_eq!(\n        initial_history_items,\n        vec![FoundPath::new(\n            ProjectPath {\n                worktree_id: external_worktree_id,\n                path: rel_path(": "",
        ").into(),\n            },\n            PathBuf::from(path!(": "",
        "))\n        )],\n        ": "",
        "\n    );\n\n    let updated_history_items =\n        open_close_queried_buffer(": "",
        ", &workspace, cx).await;\n    assert_eq!(\n        updated_history_items,\n        vec![\n            FoundPath::new(\n                ProjectPath {\n                    worktree_id,\n                    path: rel_path(": "",
        "))\n            ),\n            FoundPath::new(\n                ProjectPath {\n                    worktree_id: external_worktree_id,\n                    path: rel_path(": "",
        ",\n    );\n}\n\n#[gpui::test]\nasync fn test_toggle_panel_new_selections(cx: &mut gpui::TestAppContext) {\n    let app_state = init_test(cx);\n\n    app_state\n        .fs\n        .as_fake()\n        .insert_tree(\n            path!(": "",
        ").as_ref()], cx).await;\n    let (workspace, cx) = cx.add_window_view(|window, cx| Workspace::test_new(project, window, cx));\n\n    // generate some history to select from\n    open_close_queried_buffer(": "",
        ", &workspace, cx).await;\n    open_close_queried_buffer(": "",
        ", &workspace, cx).await;\n    let current_history = open_close_queried_buffer(": "",
        ", &workspace, cx).await;\n\n    for expected_selected_index in 0..current_history.len() {\n        cx.dispatch_action(ToggleFileFinder::default());\n        let picker = active_file_picker(&workspace, cx);\n        let selected_index = picker.update(cx, |picker, _| picker.delegate.selected_index());\n        assert_eq!(\n            selected_index, expected_selected_index,\n            ": "",
        "\n        );\n    }\n\n    cx.dispatch_action(ToggleFileFinder::default());\n    let selected_index = workspace.update(cx, |workspace, cx| {\n        workspace\n            .active_modal::<FileFinder>(cx)\n            .unwrap()\n            .read(cx)\n            .picker\n            .read(cx)\n            .delegate\n            .selected_index()\n    });\n    assert_eq!(\n        selected_index, 0,\n        ": "",
        "\n    );\n}\n\n#[gpui::test]\nasync fn test_search_preserves_history_items(cx: &mut gpui::TestAppContext) {\n    let app_state = init_test(cx);\n\n    app_state\n        .fs\n        .as_fake()\n        .insert_tree(\n            path!(": "",
        ").as_ref()], cx).await;\n    let (workspace, cx) = cx.add_window_view(|window, cx| Workspace::test_new(project, window, cx));\n    let worktree_id = cx.read(|cx| {\n        let worktrees = workspace.read(cx).worktrees(cx).collect::<Vec<_>>();\n        assert_eq!(worktrees.len(), 1,);\n\n        WorktreeId::from_usize(worktrees[0].entity_id().as_u64() as usize)\n    });\n\n    // generate some history to select from\n    open_close_queried_buffer(": "",
        ", &workspace, cx).await;\n\n    let finder = open_file_picker(&workspace, cx);\n    let first_query = ": "",
        ";\n    finder\n        .update_in(cx, |finder, window, cx| {\n            finder\n                .delegate\n                .update_matches(first_query.to_string(), window, cx)\n        })\n        .await;\n    finder.update(cx, |picker, _| {\n            let matches = collect_search_matches(picker);\n            assert_eq!(matches.history.len(), 1, ": "",
        ");\n            let history_match = matches.history_found_paths.first().expect(": "",
        ");\n            assert_eq!(history_match, &FoundPath::new(\n                ProjectPath {\n                    worktree_id,\n                    path: rel_path(": "",
        ")),\n            ));\n            assert_eq!(matches.search.len(), 1, ": "",
        ");\n            assert_eq!(matches.search.first().unwrap().as_ref(), rel_path(": "",
        "));\n        });\n\n    let second_query = ": "",
        ";\n    let finder = active_file_picker(&workspace, cx);\n    finder\n        .update_in(cx, |finder, window, cx| {\n            finder\n                .delegate\n                .update_matches(second_query.to_string(), window, cx)\n        })\n        .await;\n    finder.update(cx, |picker, _| {\n        assert!(\n            collect_search_matches(picker)\n                .search_paths_only()\n                .is_empty(),\n            ": "",
        "\n        );\n    });\n\n    let first_query_again = first_query;\n\n    let finder = active_file_picker(&workspace, cx);\n    finder\n        .update_in(cx, |finder, window, cx| {\n            finder\n                .delegate\n                .update_matches(first_query_again.to_string(), window, cx)\n        })\n        .await;\n    finder.update(cx, |picker, _| {\n            let matches = collect_search_matches(picker);\n            assert_eq!(matches.history.len(), 1, ": "",
        "))\n            ));\n            assert_eq!(matches.search.len(), 1, ": "",
        "));\n        });\n}\n\n#[gpui::test]\nasync fn test_search_sorts_history_items(cx: &mut gpui::TestAppContext) {\n    let app_state = init_test(cx);\n\n    app_state\n        .fs\n        .as_fake()\n        .insert_tree(\n            path!(": "",
        ").as_ref()], cx).await;\n    let (workspace, cx) = cx.add_window_view(|window, cx| Workspace::test_new(project, window, cx));\n    // generate some history to select from\n    open_close_queried_buffer(": "",
        ", &workspace, cx).await;\n\n    let finder = open_file_picker(&workspace, cx);\n    let query = ": "",
        ";\n    finder\n        .update_in(cx, |finder, window, cx| {\n            finder\n                .delegate\n                .update_matches(query.to_string(), window, cx)\n        })\n        .await;\n    finder.update(cx, |finder, _| {\n        let search_matches = collect_search_matches(finder);\n        assert_eq!(\n            search_matches.history,\n            vec![\n                rel_path(": "",
        ").into(),\n                rel_path(": "",
        ").into()\n            ],\n        );\n        assert_eq!(\n            search_matches.search,\n            vec![\n                rel_path(": "",
        ").into()\n            ],\n        );\n    });\n}\n\n#[gpui::test]\nasync fn test_select_current_open_file_when_no_history(cx: &mut gpui::TestAppContext) {\n    let app_state = init_test(cx);\n\n    app_state\n        .fs\n        .as_fake()\n        .insert_tree(\n            path!(": "",
        ").as_ref()], cx).await;\n    let (workspace, cx) = cx.add_window_view(|window, cx| Workspace::test_new(project, window, cx));\n    // Open new buffer\n    open_queried_buffer(": "",
        ", &workspace, cx).await;\n\n    let picker = open_file_picker(&workspace, cx);\n    picker.update(cx, |finder, _| {\n        assert_match_selection(finder, 0, ": "",
        ");\n    });\n}\n\n#[gpui::test]\nasync fn test_keep_opened_file_on_top_of_search_results_and_select_next_one(\n    cx: &mut TestAppContext,\n) {\n    let app_state = init_test(cx);\n\n    app_state\n        .fs\n        .as_fake()\n        .insert_tree(\n            path!(": "",
        ").as_ref()], cx).await;\n    let (workspace, cx) = cx.add_window_view(|window, cx| Workspace::test_new(project, window, cx));\n\n    open_close_queried_buffer(": "",
        ", &workspace, cx).await;\n    open_queried_buffer(": "",
        ", &workspace, cx).await;\n\n    // main.rs is on top, previously used is selected\n    let picker = open_file_picker(&workspace, cx);\n    picker.update(cx, |finder, _| {\n        assert_eq!(finder.delegate.matches.len(), 3);\n        assert_match_selection(finder, 0, ": "",
        ");\n        assert_match_at_position(finder, 1, ": "",
        ");\n        assert_match_at_position(finder, 2, ": "",
        ");\n    });\n\n    // all files match, main.rs is still on top, but the second item is selected\n    picker\n        .update_in(cx, |finder, window, cx| {\n            finder\n                .delegate\n                .update_matches(": "",
        ".to_string(), window, cx)\n        })\n        .await;\n    picker.update(cx, |finder, _| {\n        assert_eq!(finder.delegate.matches.len(), 6);\n        assert_match_at_position(finder, 0, ": "",
        ");\n        assert_match_selection(finder, 1, ": "",
        ");\n        assert_match_at_position(finder, 3, ": "",
        ");\n        assert_match_at_position(finder, 4, ": "",
        ");\n        assert_match_at_position(finder, 5, ": "",
        ");\n    });\n\n    // main.rs is not among matches, select top item\n    picker\n        .update_in(cx, |finder, window, cx| {\n            finder.delegate.update_matches(": "",
        ".to_string(), window, cx)\n        })\n        .await;\n    picker.update(cx, |finder, _| {\n        assert_eq!(finder.delegate.matches.len(), 3);\n        assert_match_at_position(finder, 0, ": "",
        ");\n    });\n\n    // main.rs is back, put it on top and select next item\n    picker\n        .update_in(cx, |finder, window, cx| {\n            finder.delegate.update_matches(": "",
        ".to_string(), window, cx)\n        })\n        .await;\n    picker.update(cx, |finder, _| {\n        assert_eq!(finder.delegate.matches.len(), 4);\n        assert_match_at_position(finder, 0, ": "",
        ");\n    });\n\n    // get back to the initial state\n    picker\n        .update_in(cx, |finder, window, cx| {\n            finder.delegate.update_matches(": "",
        ".to_string(), window, cx)\n        })\n        .await;\n    picker.update(cx, |finder, _| {\n        assert_eq!(finder.delegate.matches.len(), 3);\n        assert_match_selection(finder, 0, ": "",
        ");\n    });\n}\n\n#[gpui::test]\nasync fn test_setting_auto_select_first_and_select_active_file(cx: &mut TestAppContext) {\n    let app_state = init_test(cx);\n\n    cx.update(|cx| {\n        let settings = *FileFinderSettings::get_global(cx);\n\n        FileFinderSettings::override_global(\n            FileFinderSettings {\n                skip_focus_for_active_in_search: false,\n                ..settings\n            },\n            cx,\n        );\n    });\n\n    app_state\n        .fs\n        .as_fake()\n        .insert_tree(\n            path!(": "",
        ");\n    });\n\n    // all files match, main.rs is on top, and is selected\n    picker\n        .update_in(cx, |finder, window, cx| {\n            finder\n                .delegate\n                .update_matches(": "",
        ".to_string(), window, cx)\n        })\n        .await;\n    picker.update(cx, |finder, _| {\n        assert_eq!(finder.delegate.matches.len(), 6);\n        assert_match_selection(finder, 0, ": "",
        ");\n    });\n}\n\n#[gpui::test]\nasync fn test_non_separate_history_items(cx: &mut TestAppContext) {\n    let app_state = init_test(cx);\n\n    app_state\n        .fs\n        .as_fake()\n        .insert_tree(\n            path!(": "",
        ", &workspace, cx).await;\n\n    cx.dispatch_action(ToggleFileFinder::default());\n    let picker = active_file_picker(&workspace, cx);\n    // main.rs is on top, previously used is selected\n    picker.update(cx, |finder, _| {\n        assert_eq!(finder.delegate.matches.len(), 3);\n        assert_match_selection(finder, 0, ": "",
        ");\n    });\n}\n\n#[gpui::test]\nasync fn test_history_items_shown_in_order_of_open(cx: &mut TestAppContext) {\n    let app_state = init_test(cx);\n\n    app_state\n        .fs\n        .as_fake()\n        .insert_tree(\n            path!(": "",
        ").as_ref()], cx).await;\n    let (workspace, cx) = cx.add_window_view(|window, cx| Workspace::test_new(project, window, cx));\n\n    open_queried_buffer(": "",
        ", &workspace, cx).await;\n\n    let picker = open_file_picker(&workspace, cx);\n    picker.update(cx, |finder, _| {\n        assert_eq!(finder.delegate.matches.len(), 3);\n        assert_match_selection(finder, 0, ": "",
        ");\n    });\n\n    cx.dispatch_action(SelectNext);\n    cx.dispatch_action(Confirm); // Open 2.txt\n\n    let picker = open_file_picker(&workspace, cx);\n    picker.update(cx, |finder, _| {\n        assert_eq!(finder.delegate.matches.len(), 3);\n        assert_match_selection(finder, 0, ": "",
        ");\n    });\n\n    cx.dispatch_action(SelectNext);\n    cx.dispatch_action(SelectNext);\n    cx.dispatch_action(Confirm); // Open 1.txt\n\n    let picker = open_file_picker(&workspace, cx);\n    picker.update(cx, |finder, _| {\n        assert_eq!(finder.delegate.matches.len(), 3);\n        assert_match_selection(finder, 0, ": "",
        ");\n    });\n}\n\n#[gpui::test]\nasync fn test_selected_history_item_stays_selected_on_worktree_updated(cx: &mut TestAppContext) {\n    let app_state = init_test(cx);\n\n    app_state\n        .fs\n        .as_fake()\n        .insert_tree(\n            path!(": "",
        ");\n    });\n\n    cx.dispatch_action(SelectNext);\n\n    // Add more files to the worktree to trigger update matches\n    for i in 0..5 {\n        let filename = if cfg!(windows) {\n            format!(": "",
        ", 4 + i)\n        } else {\n            format!(": "",
        ", 4 + i)\n        };\n        app_state\n            .fs\n            .create_file(Path::new(&filename), Default::default())\n            .await\n            .expect(": "",
        ");\n    }\n\n    cx.executor().advance_clock(FS_WATCH_LATENCY);\n\n    picker.update(cx, |finder, _| {\n        assert_eq!(finder.delegate.matches.len(), 3);\n        assert_match_at_position(finder, 0, ": "",
        ");\n    });\n}\n\n#[gpui::test]\nasync fn test_history_items_vs_very_good_external_match(cx: &mut gpui::TestAppContext) {\n    let app_state = init_test(cx);\n\n    app_state\n        .fs\n        .as_fake()\n        .insert_tree(\n            path!(": "",
        ";\n    cx.simulate_input(query);\n    finder.update(cx, |picker, _| {\n            let search_entries = collect_search_matches(picker).search_paths_only();\n            assert_eq!(\n                search_entries,\n                vec![\n                    rel_path(": "",
        ").into(),\n                    rel_path(": "",
        ").into(),\n                ],\n                ": "",
        "\n            );\n        });\n}\n\n#[gpui::test]\nasync fn test_nonexistent_history_items_not_shown(cx: &mut gpui::TestAppContext) {\n    let app_state = init_test(cx);\n\n    app_state\n        .fs\n        .as_fake()\n        .insert_tree(\n            path!(": "",
        ").as_ref()], cx).await;\n    let (workspace, cx) = cx.add_window_view(|window, cx| Workspace::test_new(project, window, cx)); // generate some history to select from\n    open_close_queried_buffer(": "",
        ", &workspace, cx).await;\n    app_state\n        .fs\n        .remove_file(\n            Path::new(path!(": "",
        ")),\n            RemoveOptions::default(),\n        )\n        .await\n        .unwrap();\n    cx.run_until_parked();\n\n    let picker = open_file_picker(&workspace, cx);\n    cx.simulate_input(": "",
        ");\n\n    picker.update(cx, |picker, _| {\n        assert_eq!(\n            collect_search_matches(picker).history,\n            vec![\n                rel_path(": "",
        ").into()\n            ],\n            ": "",
        "\n        );\n    });\n}\n\n#[gpui::test]\nasync fn test_search_results_refreshed_on_worktree_updates(cx: &mut gpui::TestAppContext) {\n    let app_state = init_test(cx);\n\n    app_state\n        .fs\n        .as_fake()\n        .insert_tree(\n            ": "",
        ",\n            json!({\n                ": "",
        ",\n                ": "",
        ",\n            }),\n        )\n        .await;\n\n    let project = Project::test(app_state.fs.clone(), [": "",
        ".as_ref()], cx).await;\n    let (workspace, cx) =\n        cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n\n    // Initial state\n    let picker = open_file_picker(&workspace, cx);\n    cx.simulate_input(": "",
        ");\n    picker.update(cx, |finder, _| {\n        assert_eq!(finder.delegate.matches.len(), 3);\n        assert_match_at_position(finder, 0, ": "",
        ");\n    });\n    // Delete main.rs\n    app_state\n        .fs\n        .remove_file(": "",
        ".as_ref(), Default::default())\n        .await\n        .expect(": "",
        ");\n    cx.executor().advance_clock(FS_WATCH_LATENCY);\n\n    // main.rs is in not among search results anymore\n    picker.update(cx, |finder, _| {\n        assert_eq!(finder.delegate.matches.len(), 2);\n        assert_match_at_position(finder, 0, ": "",
        ");\n    });\n\n    // Create util.rs\n    app_state\n        .fs\n        .create_file(": "",
        ");\n    cx.executor().advance_clock(FS_WATCH_LATENCY);\n\n    // util.rs is among search results\n    picker.update(cx, |finder, _| {\n        assert_eq!(finder.delegate.matches.len(), 3);\n        assert_match_at_position(finder, 0, ": "",
        ");\n    });\n}\n\n#[gpui::test]\nasync fn test_search_results_refreshed_on_standalone_file_creation(cx: &mut gpui::TestAppContext) {\n    let app_state = init_test(cx);\n\n    app_state\n        .fs\n        .as_fake()\n        .insert_tree(\n            ": "",
        ",\n            }),\n        )\n        .await;\n    app_state\n        .fs\n        .as_fake()\n        .insert_tree(\n            ": "",
        ".as_ref()], cx).await;\n    let (workspace, cx) =\n        cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n\n    cx.update(|_, cx| {\n        open_paths(\n            &[PathBuf::from(path!(": "",
        "))],\n            app_state,\n            workspace::OpenOptions::default(),\n            cx,\n        )\n    })\n    .await\n    .unwrap();\n    assert_eq!(cx.update(|_, cx| cx.windows().len()), 1);\n\n    let initial_history = open_close_queried_buffer(": "",
        ", &workspace, cx).await;\n    assert_eq!(\n        initial_history.first().unwrap().absolute,\n        PathBuf::from(path!(": "",
        ")),\n        ": "",
        "\n    );\n\n    let history_after_first = open_close_queried_buffer(": "",
        ", &workspace, cx).await;\n    assert_eq!(\n        history_after_first.first().unwrap().absolute,\n        PathBuf::from(path!(": "",
        "\n    );\n}\n\n#[gpui::test]\nasync fn test_search_results_refreshed_on_adding_and_removing_worktrees(\n    cx: &mut gpui::TestAppContext,\n) {\n    let app_state = init_test(cx);\n\n    app_state\n        .fs\n        .as_fake()\n        .insert_tree(\n            ": "",
        ",\n                },\n                ": "",
        ",\n                }\n            }),\n        )\n        .await;\n\n    let project = Project::test(app_state.fs.clone(), [": "",
        ".as_ref()], cx).await;\n    let (workspace, cx) =\n        cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n    let worktree_1_id = project.update(cx, |project, cx| {\n        let worktree = project.worktrees(cx).last().expect(": "",
        ");\n        worktree.read(cx).id()\n    });\n\n    // Initial state\n    let picker = open_file_picker(&workspace, cx);\n    cx.simulate_input(": "",
        ");\n    });\n\n    // Add new worktree\n    project\n        .update(cx, |project, cx| {\n            project\n                .find_or_create_worktree(": "",
        ", true, cx)\n                .into_future()\n        })\n        .await\n        .expect(": "",
        ");\n    cx.executor().advance_clock(FS_WATCH_LATENCY);\n\n    // main.rs is among search results\n    picker.update(cx, |finder, _| {\n        assert_eq!(finder.delegate.matches.len(), 4);\n        assert_match_at_position(finder, 0, ": "",
        ");\n    });\n\n    // Remove the first worktree\n    project.update(cx, |project, cx| {\n        project.remove_worktree(worktree_1_id, cx);\n    });\n    cx.executor().advance_clock(FS_WATCH_LATENCY);\n\n    // Files from the first worktree are not in the search results anymore\n    picker.update(cx, |finder, _| {\n        assert_eq!(finder.delegate.matches.len(), 2);\n        assert_match_at_position(finder, 0, ": "",
        ");\n    });\n}\n\n#[gpui::test]\nasync fn test_history_items_uniqueness_for_multiple_worktree_open_all_files(\n    cx: &mut TestAppContext,\n) {\n    let app_state = init_test(cx);\n    app_state\n        .fs\n        .as_fake()\n        .insert_tree(\n            path!(": "",
        ": r#": "",
        "name": "",
        "repo1": "",
        "#,\n                ": "",
        "repo2": "",
        ",\n                }\n            }),\n        )\n        .await;\n\n    let project = Project::test(\n        app_state.fs.clone(),\n        [path!(": "",
        ").as_ref(), path!(": "",
        ").as_ref()],\n        cx,\n    )\n    .await;\n\n    let (workspace, cx) = cx.add_window_view(|window, cx| Workspace::test_new(project, window, cx));\n    let (worktree_id1, worktree_id2) = cx.read(|cx| {\n        let worktrees = workspace.read(cx).worktrees(cx).collect::<Vec<_>>();\n        (worktrees[0].read(cx).id(), worktrees[1].read(cx).id())\n    });\n\n    workspace\n        .update_in(cx, |workspace, window, cx| {\n            workspace.open_path(\n                ProjectPath {\n                    worktree_id: worktree_id1,\n                    path: rel_path(": "",
        ").into(),\n                },\n                None,\n                true,\n                window,\n                cx,\n            )\n        })\n        .await\n        .unwrap();\n\n    cx.dispatch_action(workspace::CloseActiveItem {\n        save_intent: None,\n        close_pinned: false,\n    });\n    workspace\n        .update_in(cx, |workspace, window, cx| {\n            workspace.open_path(\n                ProjectPath {\n                    worktree_id: worktree_id2,\n                    path: rel_path(": "",
        ").into(),\n                },\n                None,\n                true,\n                window,\n                cx,\n            )\n        })\n        .await\n        .unwrap();\n\n    cx.dispatch_action(workspace::CloseActiveItem {\n        save_intent: None,\n        close_pinned: false,\n    });\n\n    let picker = open_file_picker(&workspace, cx);\n    cx.simulate_input(": "",
        ");\n\n    picker.update(cx, |finder, _| {\n        let matches = &finder.delegate.matches.matches;\n\n        assert_eq!(\n            matches.len(),\n            2,\n            ": "",
        ",\n            matches.len(),\n            matches\n        );\n\n        assert_matches!(matches[0], Match::History { .. });\n\n        let search_matches = collect_search_matches(finder);\n        assert_eq!(\n            search_matches.history.len(),\n            2,\n            ": "",
        "\n        );\n        assert_eq!(\n            search_matches.search.len(),\n            0,\n            ": "",
        "\n        );\n\n        if let Match::History { path, panel_match } = &matches[0] {\n            assert_eq!(path.project.worktree_id, worktree_id2);\n            assert_eq!(path.project.path.as_ref(), rel_path(": "",
        "));\n            let panel_match = panel_match.as_ref().unwrap();\n            assert_eq!(panel_match.0.path_prefix, rel_path(": "",
        ").into());\n            assert_eq!(panel_match.0.path, rel_path(": "",
        ").into());\n            assert_eq!(\n                panel_match.0.positions,\n                vec![6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]\n            );\n        }\n\n        if let Match::History { path, panel_match } = &matches[1] {\n            assert_eq!(path.project.worktree_id, worktree_id1);\n            assert_eq!(path.project.path.as_ref(), rel_path(": "",
        ").into());\n            assert_eq!(\n                panel_match.0.positions,\n                vec![6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]\n            );\n        }\n    });\n}\n\n#[gpui::test]\nasync fn test_selected_match_stays_selected_after_matches_refreshed(cx: &mut gpui::TestAppContext) {\n    let app_state = init_test(cx);\n\n    app_state.fs.as_fake().insert_tree(": "",
        ", json!({})).await;\n\n    app_state\n        .fs\n        .create_dir(": "",
        ".as_ref())\n        .await\n        .expect(": "",
        ");\n\n    let initial_files_num = 5;\n    for i in 0..initial_files_num {\n        let filename = format!(": "",
        ", 10 + i);\n        app_state\n            .fs\n            .create_file(Path::new(&filename), Default::default())\n            .await\n            .expect(": "",
        ");\n    }\n\n    let project = Project::test(app_state.fs.clone(), [": "",
        ");\n    let selected_index = 3;\n    // Checking only the filename, not the whole path\n    let selected_file = format!(": "",
        ", 10 + selected_index);\n    // Select even/file_13.txt\n    for _ in 0..selected_index {\n        cx.dispatch_action(SelectNext);\n    }\n\n    picker.update(cx, |finder, _| {\n        assert_match_selection(finder, selected_index, &selected_file)\n    });\n\n    // Add more matches to the search results\n    let files_to_add = 10;\n    for i in 0..files_to_add {\n        let filename = format!(": "",
        ", 20 + i);\n        app_state\n            .fs\n            .create_file(Path::new(&filename), Default::default())\n            .await\n            .expect(": "",
        ");\n    }\n    cx.executor().advance_clock(FS_WATCH_LATENCY);\n\n    // file_13.txt is still selected\n    picker.update(cx, |finder, _| {\n        let expected_selected_index = selected_index + files_to_add;\n        assert_match_selection(finder, expected_selected_index, &selected_file);\n    });\n}\n\n#[gpui::test]\nasync fn test_first_match_selected_if_previous_one_is_not_in_the_match_list(\n    cx: &mut gpui::TestAppContext,\n) {\n    let app_state = init_test(cx);\n\n    app_state\n        .fs\n        .as_fake()\n        .insert_tree(\n            ": "",
        ");\n    // Select even/file_2.txt\n    cx.dispatch_action(SelectNext);\n\n    // Remove the selected entry\n    app_state\n        .fs\n        .remove_file(": "",
        ");\n    cx.executor().advance_clock(FS_WATCH_LATENCY);\n\n    // file_1.txt is now selected\n    picker.update(cx, |finder, _| {\n        assert_match_selection(finder, 0, ": "",
        ");\n    });\n}\n\n#[gpui::test]\nasync fn test_keeps_file_finder_open_after_modifier_keys_release(cx: &mut gpui::TestAppContext) {\n    let app_state = init_test(cx);\n\n    app_state\n        .fs\n        .as_fake()\n        .insert_tree(\n            path!(": "",
        ",\n            }),\n        )\n        .await;\n\n    let project = Project::test(app_state.fs.clone(), [path!(": "",
        ", &workspace, cx).await;\n\n    cx.simulate_modifiers_change(Modifiers::secondary_key());\n    open_file_picker(&workspace, cx);\n\n    cx.simulate_modifiers_change(Modifiers::none());\n    active_file_picker(&workspace, cx);\n}\n\n#[gpui::test]\nasync fn test_opens_file_on_modifier_keys_release(cx: &mut gpui::TestAppContext) {\n    let app_state = init_test(cx);\n\n    app_state\n        .fs\n        .as_fake()\n        .insert_tree(\n            path!(": "",
        ", &workspace, cx).await;\n\n    cx.simulate_modifiers_change(Modifiers::secondary_key());\n    let picker = open_file_picker(&workspace, cx);\n    picker.update(cx, |finder, _| {\n        assert_eq!(finder.delegate.matches.len(), 2);\n        assert_match_selection(finder, 0, ": "",
        ");\n    });\n\n    cx.dispatch_action(SelectNext);\n    cx.simulate_modifiers_change(Modifiers::none());\n    cx.read(|cx| {\n        let active_editor = workspace.read(cx).active_item_as::<Editor>(cx).unwrap();\n        assert_eq!(active_editor.read(cx).title(cx), ": "",
        ");\n    });\n}\n\n#[gpui::test]\nasync fn test_switches_between_release_norelease_modes_on_forward_nav(\n    cx: &mut gpui::TestAppContext,\n) {\n    let app_state = init_test(cx);\n\n    app_state\n        .fs\n        .as_fake()\n        .insert_tree(\n            path!(": "",
        ", &workspace, cx).await;\n\n    // Open with a shortcut\n    cx.simulate_modifiers_change(Modifiers::secondary_key());\n    let picker = open_file_picker(&workspace, cx);\n    picker.update(cx, |finder, _| {\n        assert_eq!(finder.delegate.matches.len(), 2);\n        assert_match_selection(finder, 0, ": "",
        ");\n    });\n\n    // Switch to navigating with other shortcuts\n    // Don't open file on modifiers release\n    cx.simulate_modifiers_change(Modifiers::control());\n    cx.dispatch_action(SelectNext);\n    cx.simulate_modifiers_change(Modifiers::none());\n    picker.update(cx, |finder, _| {\n        assert_eq!(finder.delegate.matches.len(), 2);\n        assert_match_at_position(finder, 0, ": "",
        ");\n    });\n\n    // Back to navigation with initial shortcut\n    // Open file on modifiers release\n    cx.simulate_modifiers_change(Modifiers::secondary_key());\n    cx.dispatch_action(ToggleFileFinder::default());\n    cx.simulate_modifiers_change(Modifiers::none());\n    cx.read(|cx| {\n        let active_editor = workspace.read(cx).active_item_as::<Editor>(cx).unwrap();\n        assert_eq!(active_editor.read(cx).title(cx), ": "",
        ");\n    });\n}\n\n#[gpui::test]\nasync fn test_switches_between_release_norelease_modes_on_backward_nav(\n    cx: &mut gpui::TestAppContext,\n) {\n    let app_state = init_test(cx);\n\n    app_state\n        .fs\n        .as_fake()\n        .insert_tree(\n            path!(": "",
        "\n            }),\n        )\n        .await;\n\n    let project = Project::test(app_state.fs.clone(), [path!(": "",
        ", &workspace, cx).await;\n\n    // Open with a shortcut\n    cx.simulate_modifiers_change(Modifiers::secondary_key());\n    let picker = open_file_picker(&workspace, cx);\n    picker.update(cx, |finder, _| {\n        assert_eq!(finder.delegate.matches.len(), 3);\n        assert_match_selection(finder, 0, ": "",
        ");\n    });\n\n    // Switch to navigating with other shortcuts\n    // Don't open file on modifiers release\n    cx.simulate_modifiers_change(Modifiers::control());\n    cx.dispatch_action(menu::SelectPrevious);\n    cx.simulate_modifiers_change(Modifiers::none());\n    picker.update(cx, |finder, _| {\n        assert_eq!(finder.delegate.matches.len(), 3);\n        assert_match_at_position(finder, 0, ": "",
        ");\n        assert_match_selection(finder, 2, ": "",
        ");\n    });\n\n    // Back to navigation with initial shortcut\n    // Open file on modifiers release\n    cx.simulate_modifiers_change(Modifiers::secondary_key());\n    cx.dispatch_action(SelectPrevious); // <-- File Finder's SelectPrevious, not menu's\n    cx.simulate_modifiers_change(Modifiers::none());\n    cx.read(|cx| {\n        let active_editor = workspace.read(cx).active_item_as::<Editor>(cx).unwrap();\n        assert_eq!(active_editor.read(cx).title(cx), ": "",
        ");\n    });\n}\n\n#[gpui::test]\nasync fn test_extending_modifiers_does_not_confirm_selection(cx: &mut gpui::TestAppContext) {\n    let app_state = init_test(cx);\n\n    app_state\n        .fs\n        .as_fake()\n        .insert_tree(\n            path!(": "",
        ", &workspace, cx).await;\n\n    cx.simulate_modifiers_change(Modifiers::secondary_key());\n    open_file_picker(&workspace, cx);\n\n    cx.simulate_modifiers_change(Modifiers::command_shift());\n    active_file_picker(&workspace, cx);\n}\n\n#[gpui::test]\nasync fn test_repeat_toggle_action(cx: &mut gpui::TestAppContext) {\n    let app_state = init_test(cx);\n    app_state\n        .fs\n        .as_fake()\n        .insert_tree(\n            ": "",
        ".as_ref()], cx).await;\n    let (workspace, cx) = cx.add_window_view(|window, cx| Workspace::test_new(project, window, cx));\n\n    cx.dispatch_action(ToggleFileFinder::default());\n    let picker = active_file_picker(&workspace, cx);\n\n    picker.update_in(cx, |picker, window, cx| {\n        picker.update_matches(": "",
        ".to_string(), window, cx)\n    });\n\n    cx.run_until_parked();\n\n    picker.update(cx, |picker, _| {\n        assert_eq!(picker.delegate.matches.len(), 7);\n        assert_eq!(picker.delegate.selected_index, 0);\n    });\n\n    // When toggling repeatedly, the picker scrolls to reveal the selected item.\n    cx.dispatch_action(ToggleFileFinder::default());\n    cx.dispatch_action(ToggleFileFinder::default());\n    cx.dispatch_action(ToggleFileFinder::default());\n\n    cx.run_until_parked();\n\n    picker.update(cx, |picker, _| {\n        assert_eq!(picker.delegate.matches.len(), 7);\n        assert_eq!(picker.delegate.selected_index, 3);\n    });\n}\n\nasync fn open_close_queried_buffer(\n    input: &str,\n    expected_matches: usize,\n    expected_editor_title: &str,\n    workspace: &Entity<Workspace>,\n    cx: &mut gpui::VisualTestContext,\n) -> Vec<FoundPath> {\n    let history_items = open_queried_buffer(\n        input,\n        expected_matches,\n        expected_editor_title,\n        workspace,\n        cx,\n    )\n    .await;\n\n    cx.dispatch_action(workspace::CloseActiveItem {\n        save_intent: None,\n        close_pinned: false,\n    });\n\n    history_items\n}\n\nasync fn open_queried_buffer(\n    input: &str,\n    expected_matches: usize,\n    expected_editor_title: &str,\n    workspace: &Entity<Workspace>,\n    cx: &mut gpui::VisualTestContext,\n) -> Vec<FoundPath> {\n    let picker = open_file_picker(workspace, cx);\n    cx.simulate_input(input);\n\n    let history_items = picker.update(cx, |finder, _| {\n        assert_eq!(\n            finder.delegate.matches.len(),\n            expected_matches + 1, // +1 from CreateNew option\n            ": "",
        ",\n            finder.delegate.matches\n        );\n        finder.delegate.history_items.clone()\n    });\n\n    cx.dispatch_action(Confirm);\n\n    cx.read(|cx| {\n        let active_editor = workspace.read(cx).active_item_as::<Editor>(cx).unwrap();\n        let active_editor_title = active_editor.read(cx).title(cx);\n        assert_eq!(\n            expected_editor_title, active_editor_title,\n            ": "",
        "\n        );\n    });\n\n    history_items\n}\n\nfn init_test(cx: &mut TestAppContext) -> Arc<AppState> {\n    cx.update(|cx| {\n        let state = AppState::test(cx);\n        theme::init(theme::LoadThemes::JustBase, cx);\n        super::init(cx);\n        editor::init(cx);\n        state\n    })\n}\n\nfn test_path_position(test_str: &str) -> FileSearchQuery {\n    let path_position = PathWithPosition::parse_str(test_str);\n\n    FileSearchQuery {\n        raw_query: test_str.to_owned(),\n        file_query_end: if path_position.path.to_str().unwrap() == test_str {\n            None\n        } else {\n            Some(path_position.path.to_str().unwrap().len())\n        },\n        path_position,\n    }\n}\n\nfn build_find_picker(\n    project: Entity<Project>,\n    cx: &mut TestAppContext,\n) -> (\n    Entity<Picker<FileFinderDelegate>>,\n    Entity<Workspace>,\n    &mut VisualTestContext,\n) {\n    let (workspace, cx) = cx.add_window_view(|window, cx| Workspace::test_new(project, window, cx));\n    let picker = open_file_picker(&workspace, cx);\n    (picker, workspace, cx)\n}\n\n#[track_caller]\nfn open_file_picker(\n    workspace: &Entity<Workspace>,\n    cx: &mut VisualTestContext,\n) -> Entity<Picker<FileFinderDelegate>> {\n    cx.dispatch_action(ToggleFileFinder {\n        separate_history: true,\n    });\n    active_file_picker(workspace, cx)\n}\n\n#[track_caller]\nfn active_file_picker(\n    workspace: &Entity<Workspace>,\n    cx: &mut VisualTestContext,\n) -> Entity<Picker<FileFinderDelegate>> {\n    workspace.update(cx, |workspace, cx| {\n        workspace\n            .active_modal::<FileFinder>(cx)\n            .expect(": "",
        ")\n            .read(cx)\n            .picker\n            .clone()\n    })\n}\n\n#[derive(Debug, Default)]\nstruct SearchEntries {\n    history: Vec<Arc<RelPath>>,\n    history_found_paths: Vec<FoundPath>,\n    search: Vec<Arc<RelPath>>,\n    search_matches: Vec<PathMatch>,\n}\n\nimpl SearchEntries {\n    #[track_caller]\n    fn search_paths_only(self) -> Vec<Arc<RelPath>> {\n        assert!(\n            self.history.is_empty(),\n            ": "",
        ",\n            self.history\n        );\n        self.search\n    }\n\n    #[track_caller]\n    fn search_matches_only(self) -> Vec<PathMatch> {\n        assert!(\n            self.history.is_empty(),\n            ": "",
        ",\n            self.history\n        );\n        self.search_matches\n    }\n}\n\nfn collect_search_matches(picker: &Picker<FileFinderDelegate>) -> SearchEntries {\n    let mut search_entries = SearchEntries::default();\n    for m in &picker.delegate.matches.matches {\n        match &m {\n            Match::History {\n                path: history_path,\n                panel_match: path_match,\n            } => {\n                if let Some(path_match) = path_match.as_ref() {\n                    search_entries\n                        .history\n                        .push(path_match.0.path_prefix.join(&path_match.0.path));\n                } else {\n                    // This occurs when the query is empty and we show history matches\n                    // that are outside the project.\n                    panic!(": "",
        ");\n                }\n                search_entries\n                    .history_found_paths\n                    .push(history_path.clone());\n            }\n            Match::Search(path_match) => {\n                search_entries\n                    .search\n                    .push(path_match.0.path_prefix.join(&path_match.0.path));\n                search_entries.search_matches.push(path_match.0.clone());\n            }\n            Match::CreateNew(_) => {}\n        }\n    }\n    search_entries\n}\n\n#[track_caller]\nfn assert_match_selection(\n    finder: &Picker<FileFinderDelegate>,\n    expected_selection_index: usize,\n    expected_file_name: &str,\n) {\n    assert_eq!(\n        finder.delegate.selected_index(),\n        expected_selection_index,\n        ": "",
        "\n    );\n    assert_match_at_position(finder, expected_selection_index, expected_file_name);\n}\n\n#[track_caller]\nfn assert_match_at_position(\n    finder: &Picker<FileFinderDelegate>,\n    match_index: usize,\n    expected_file_name: &str,\n) {\n    let match_item = finder\n        .delegate\n        .matches\n        .get(match_index)\n        .unwrap_or_else(|| panic!(": "",
        "));\n    let match_file_name = match &match_item {\n        Match::History { path, .. } => path.absolute.file_name().and_then(|s| s.to_str()),\n        Match::Search(path_match) => path_match.0.path.file_name(),\n        Match::CreateNew(project_path) => project_path.path.file_name(),\n    }\n    .unwrap();\n    assert_eq!(match_file_name, expected_file_name);\n}\n\n#[gpui::test]\nasync fn test_filename_precedence(cx: &mut TestAppContext) {\n    let app_state = init_test(cx);\n\n    app_state\n        .fs\n        .as_fake()\n        .insert_tree(\n            path!(": "",
        ").as_ref()], cx).await;\n    let (picker, _, cx) = build_find_picker(project, cx);\n\n    cx.simulate_input(": "",
        ");\n\n    picker.update(cx, |finder, _| {\n        let search_matches = collect_search_matches(finder).search_paths_only();\n\n        assert_eq!(\n            search_matches,\n            vec![\n                rel_path(": "",
        ").into(),\n            ],\n            ": "",
        "\n        );\n    });\n}\n\n#[gpui::test]\nasync fn test_paths_with_starting_slash(cx: &mut TestAppContext) {\n    let app_state = init_test(cx);\n    app_state\n        .fs\n        .as_fake()\n        .insert_tree(\n            path!(": "",
        ": {\n                        ": "",
        ",\n                    },\n                }\n            }),\n        )\n        .await;\n\n    let project = Project::test(app_state.fs.clone(), [path!(": "",
        ").as_ref()], cx).await;\n\n    let (picker, workspace, cx) = build_find_picker(project, cx);\n\n    let matching_abs_path = ": "",
        ".to_string();\n    picker\n        .update_in(cx, |picker, window, cx| {\n            picker\n                .delegate\n                .update_matches(matching_abs_path, window, cx)\n        })\n        .await;\n    picker.update(cx, |picker, _| {\n        assert_eq!(\n            collect_search_matches(picker).search_paths_only(),\n            vec![rel_path(": "",
        ").into()],\n            ": "",
        "\n        )\n    });\n    cx.dispatch_action(SelectNext);\n    cx.dispatch_action(Confirm);\n    cx.read(|cx| {\n        let active_editor = workspace.read(cx).active_item_as::<Editor>(cx).unwrap();\n        assert_eq!(active_editor.read(cx).title(cx), ": "",
        ");\n    });\n}\n\n#[gpui::test]\nasync fn test_clear_navigation_history(cx: &mut TestAppContext) {\n    let app_state = init_test(cx);\n    app_state\n        .fs\n        .as_fake()\n        .insert_tree(\n            path!(": "",
        ").as_ref()], cx).await;\n    let (workspace, cx) = cx.add_window_view(|window, cx| Workspace::test_new(project, window, cx));\n\n    workspace.update_in(cx, |_workspace, window, cx| window.focused(cx));\n\n    // Open some files to generate navigation history\n    open_close_queried_buffer(": "",
        ", &workspace, cx).await;\n    let history_before_clear =\n        open_close_queried_buffer(": "",
        ", &workspace, cx).await;\n\n    assert_eq!(\n        history_before_clear.len(),\n        2,\n        ": "",
        "\n    );\n\n    // Verify that file finder shows history items\n    let picker = open_file_picker(&workspace, cx);\n    cx.simulate_input(": "",
        ");\n    picker.update(cx, |finder, _| {\n        let matches = collect_search_matches(finder);\n        assert!(\n            !matches.history.is_empty(),\n            ": "",
        "\n        );\n    });\n    workspace.update_in(cx, |_, window, cx| {\n        window.dispatch_action(menu::Cancel.boxed_clone(), cx);\n    });\n\n    // Verify navigation state before clear\n    workspace.update(cx, |workspace, cx| {\n        let pane = workspace.active_pane();\n        pane.read(cx).can_navigate_backward()\n    });\n\n    // Clear navigation history\n    cx.dispatch_action(workspace::ClearNavigationHistory);\n\n    // Verify that navigation is disabled immediately after clear\n    workspace.update(cx, |workspace, cx| {\n        let pane = workspace.active_pane();\n        assert!(\n            !pane.read(cx).can_navigate_backward(),\n            ": "",
        "\n        );\n        assert!(\n            !pane.read(cx).can_navigate_forward(),\n            ": "",
        "\n        );\n    });\n\n    // Verify that file finder no longer shows history items\n    let picker = open_file_picker(&workspace, cx);\n    cx.simulate_input(": "",
        ");\n    picker.update(cx, |finder, _| {\n        let matches = collect_search_matches(finder);\n        assert!(\n            matches.history.is_empty(),\n            ": "",
        "\n        );\n    });\n    workspace.update_in(cx, |_, window, cx| {\n        window.dispatch_action(menu::Cancel.boxed_clone(), cx);\n    });\n\n    // Verify history is empty by opening a new file\n    // (this should not show any previous history)\n    let history_after_clear =\n        open_close_queried_buffer(": "",
        ", &workspace, cx).await;\n    assert_eq!(\n        history_after_clear.len(),\n        0,\n        ": ""
    },
    "zed/crates/file_finder/src/file_finder.rs": {
        "c/d": "",
        "/a/b": "",
        "Create file: {}": "",
        "invalid file name positions {file_name:?} {file_name_positions:?}": "",
        "invalid path positions {full_path:?} {path_positions:?}": "",
        "FileFinder": "",
        "filter_menu_open": "",
        "split_menu_open": "",
        "Search project files...": "",
        "a\\\\": "",
        "a/": "",
        "b\\\\": "",
        "b/": "",
        "filter-menu-popover": "",
        "filter-trigger": "",
        "Filter Options": "",
        "Include Ignored Files": "",
        "split-menu-popover": "",
        "split-trigger": "",
        "Split…": "",
        "Split Left": "",
        "Split Right": "",
        "Split Up": "",
        "Split Down": "",
        "open-selection": "",
        "Open": ""
    },
    "zed/crates/file_finder/src/open_path_prompt.rs": {
        "C:\\\\": "",
        "{prompted_path:?} already exists. Do you want to replace it?": "",
        "A file or folder with the same name already exists. Replacing it will overwrite its current contents.": "",
        "Replace": "",
        "Cancel": "",
        "open this directory": "",
        "{label} (replace)": "",
        "{label} (create)": "",
        "Type a path…": "",
        "No such file or directory": "",
        "[directory{}]filename.ext": "",
        "C:": "",
        "C:\\\\Use": "",
        "Use": "",
        "C:\\\\Users\\\\Junkui\\\\Docum": "",
        "C:\\\\Users\\\\Junkui\\\\": "",
        "Docum": "",
        "C:\\\\Users\\\\Junkui\\\\Documents": "",
        "Documents": "",
        "C:\\\\Users\\\\Junkui\\\\Documents\\\\": "",
        "/Use": "",
        "/Users/Junkui/Docum": "",
        "/Users/Junkui/": "",
        "/Users/Junkui/Documents": "",
        "/Users/Junkui/Documents/": ""
    },
    "zed/crates/fsevent/examples/events.rs": {
        "Must pass 1 or more paths as arguments": "",
        "event batch": "",
        "  {:?}": "",
        "This example only works on macOS": ""
    },
    "zed/crates/fsevent/src/fsevent.rs": {
        "Failed to create CFURL for path: {}": "",
        "C": "",
        "dropped": "",
        "unknown flag set for fs event: {}": "",
        "MUST_SCAN_SUBDIRS ": "",
        "USER_DROPPED ": "",
        "KERNEL_DROPPED ": "",
        "IDS_WRAPPED ": "",
        "HISTORY_DONE ": "",
        "ROOT_CHANGED ": "",
        "MOUNT ": "",
        "UNMOUNT ": "",
        "ITEM_CREATED ": "",
        "ITEM_REMOVED ": "",
        "INODE_META_MOD ": "",
        "ITEM_RENAMED ": "",
        "ITEM_MODIFIED ": "",
        "FINDER_INFO_MOD ": "",
        "ITEM_CHANGE_OWNER ": "",
        "ITEM_XATTR_MOD ": "",
        "IS_FILE ": "",
        "IS_DIR ": "",
        "IS_SYMLINK ": "",
        "OWN_EVENT ": "",
        "IS_LAST_HARDLINK ": "",
        "IS_HARDLINK ": "",
        "ITEM_CLONED ": "",
        "CoreServices": "",
        "framework": "",
        "test-event-stream": "",
        "existing-file-{}": "",
        "new-file": "",
        "existing-file-5": "",
        "running": "",
        "stopped": "",
        "CI": ""
    },
    "zed/crates/fuzzy/src/strings.rs": {
        "Invariant violation: Index {start} out of range or not on a utf-8 boundary in string {:?}": "",
        "Invariant violation: Index {end} out of range or not on a utf-8 boundary in string {:?}": ""
    },
    "zed/crates/git/src/blame.rs": {
        "failed to get commit messages": "",
        "fatal: no such ref: HEAD": "",
        "fatal: no such path": "",
        "blame": "",
        "--incremental": "",
        "-w": "",
        "--contents": "",
        "starting git blame process": "",
        "failed to get pipe to stdin of git blame command": "",
        "reading git blame output": "",
        "git blame process failed: {stderr}": "",
        "parsing sha": "",
        "parsing original line number": "",
        "parsing final line number": "",
        "parsing line count": "",
        "[offset_hour][offset_minute]": "",
        "filename": "",
        "previous": "",
        "summary": "",
        "author": "",
        "author-mail": "",
        "author-time": "",
        "author-tz": "",
        "committer": "",
        "committer-mail": "",
        "committer-time": "",
        "committer-tz": "",
        "CARGO_MANIFEST_DIR": "",
        "test_data": "",
        "Could not read test data at {:?}. Is it generated?": "",
        "golden": "",
        "{}.json": "",
        "could not serialize entries to JSON": "",
        "UPDATE_GOLDEN": "",
        "true": "",
        "could not create golden test data directory": "",
        "could not write out golden data": "",
        "could not read golden test data file at {:?}. Did you run the test with UPDATE_GOLDEN=true before?": "",
        "\\r\\n": "",
        "wrong blame entries": "",
        "blame_incremental_not_committed": "",
        "blame_incremental_simple": "",
        "blame_incremental_complex": ""
    },
    "zed/crates/git/src/commit.rs": {
        "<MARKER>": "",
        "git": "",
        "show": "",
        "-s": "",
        "--format=%B{}": "",
        "starting git blame process: {:?}": "",
        "'git show' failed with error {:?}": "",
        "&lt;": "",
        "&gt;": "",
        "M": "",
        "A": "",
        "D": "",
        "M\\x00Cargo.lock\\x00": "",
        "M\\x00crates/project/Cargo.toml\\x00": "",
        "M\\x00crates/project/src/buffer_store.rs\\x00": "",
        "D\\x00crates/project/src/git.rs\\x00": "",
        "A\\x00crates/project/src/git_store.rs\\x00": "",
        "A\\x00crates/project/src/git_store/git_traversal.rs\\x00": "",
        "M\\x00crates/project/src/project.rs\\x00": "",
        "M\\x00crates/project/src/worktree_store.rs\\x00": "",
        "M\\x00crates/project_panel/src/project_panel.rs\\x00": "",
        "Cargo.lock": "",
        "crates/project/Cargo.toml": "",
        "crates/project/src/buffer_store.rs": "",
        "crates/project/src/git.rs": "",
        "crates/project/src/git_store.rs": "",
        "crates/project/src/git_store/git_traversal.rs": "",
        "crates/project/src/project.rs": "",
        "crates/project/src/worktree_store.rs": "",
        "crates/project_panel/src/project_panel.rs": ""
    },
    "zed/crates/git/src/git.rs": {
        ".git": "",
        ".gitignore": "",
        "fsmonitor--daemon": "",
        "lfs": "",
        "COMMIT_EDITMSG": "",
        "index.lock": "",
        "editor::RevertSelectedHunks": "",
        "editor::ToggleGitBlame": "",
        "editor::RevertFile": "",
        "failed to parse bytes into git oid": "",
        "parsing git oid": ""
    },
    "zed/crates/git/src/remote.rs": {
        "^[0-9a-zA-Z\\-_]+@": "",
        "Failed to create USERNAME_REGEX": "",
        "ssh://{}": "",
        "https": "",
        "github.com": "",
        "git@github.com:octocat/zed.git": "",
        "ssh": "",
        "org-000000@github.com:octocat/zed.git": "",
        "ssh://git@github.com/octocat/zed.git": "",
        "file:///path/to/local/zed": "",
        "file": "",
        "/path/to/local/zed": "",
        "failed to parse URL": "",
        "unexpected scheme for {input:?}": "",
        "unexpected host for {input:?}": "",
        "unexpected path for {input:?}": "",
        "not_a_url": "",
        "expected \\\"{url}\\\" to not parse as a Git remote URL": ""
    },
    "zed/crates/git/src/repository.rs": {
        "Operation cancelled by user": "",
        "refs/heads/": "",
        "refs/remotes/": "",
        "\\n\\n": "",
        "Fetch all remotes": "",
        "--all": "",
        "\\n\\n#  ====== Auto-added by Zed: =======\\n": "",
        "\\n#  ====== End of auto-added by Zed =======\\n": "",
        "{already_added}\\n{excludes}": "",
        "./checkpoint.gitignore": "",
        "HEAD": "",
        "dyn GitRepository<...>": "",
        "failed to read git work directory": "",
        "ZED_BUNDLE": "",
        "true": "",
        "git": "",
        "could not find git binary path": "",
        "config": "",
        "--global": "",
        "user.name": "",
        "user.email": "",
        "--no-optional-locks": "",
        "show": "",
        "--no-patch": "",
        "--format=%H%x00%B%x00%at%x00%ae%x00%an%x00": "",
        "unexpected git-show output for {commit:?}: {output:?}": "",
        "no working directory": "",
        "--format=": "",
        "-z": "",
        "--no-renames": "",
        "--name-status": "",
        "--first-parent": "",
        "starting git show process": "",
        "cat-file": "",
        "--batch=%(objectsize)": "",
        "starting git cat-file process": "",
        "invalid object size output from cat-file {info_line}": "",
        "invalid object size output from cat-file {}": "",
        "--mixed": "",
        "--soft": "",
        "reset": "",
        "Failed to reset:\\n{}": "",
        "checkout": "",
        "Failed to checkout files:\\n{}": "",
        "Error loading index text: {:?}": "",
        "hash-object": "",
        "-w": "",
        "--stdin": "",
        "indexing SHA: {sha}, path {path:?}": "",
        "update-index": "",
        "--add": "",
        "--cacheinfo": "",
        "Failed to stage:\\n{}": "",
        "removing path {path:?} from the index": "",
        "--force-remove": "",
        "Failed to unstage:\\n{}": "",
        "--batch-check=%(objectname)": "",
        "no stdin for git cat-file subprocess": "",
        "missing": "",
        "unexpected number of shas": "",
        "MERGE_MSG": "",
        "Checking for git status in {path_prefixes:?}": "",
        "git status failed: {stderr}": "",
        "diff-tree": "",
        "-r": "",
        "--merge-base": "",
        "stash": "",
        "list": "",
        "--pretty=format:%gd%x00%H%x00%ct%x00%s": "",
        "%(HEAD)": "",
        "%(objectname)": "",
        "%(parent)": "",
        "%(refname)": "",
        "%(upstream)": "",
        "%(upstream:track)": "",
        "%(committerdate:unix)": "",
        "%(authorname)": "",
        "%(contents:subject)": "",
        "%00": "",
        "for-each-ref": "",
        "refs/heads/**/*": "",
        "refs/remotes/**/*": "",
        "--format": "",
        "Failed to git git branches:\\n{}": "",
        "symbolic-ref": "",
        "--quiet": "",
        "worktree": "",
        "--porcelain": "",
        "git worktree list failed: {stderr}": "",
        "add": "",
        "-b": "",
        "Unexpected branch format": "",
        "Branch '{}' not found": "",
        "cannot checkout anonymous branch": "",
        "switch": "",
        "-c": "",
        "branch": "",
        "-m": "",
        "upstream": "",
        "origin": "",
        "--staged": "",
        "diff": "",
        "Failed to run git diff:\\n{}": "",
        "--remove": "",
        "Failed to stage paths:\\n{}": "",
        "push": "",
        "--include-untracked": "",
        "Failed to stash:\\n{}": "",
        "pop": "",
        "stash@{{{}}}": "",
        "Failed to stash pop:\\n{}": "",
        "apply": "",
        "Failed to apply stash:\\n{}": "",
        "drop": "",
        "Failed to stash drop:\\n{}": "",
        "commit": "",
        "--cleanup=strip": "",
        "--amend": "",
        "--signoff": "",
        "--author": "",
        "{name} <{email}>": "",
        "git not found on $PATH, can't push": "",
        "--set-upstream": "",
        "--force-with-lease": "",
        "git not found on $PATH, can't pull": "",
        "pull": "",
        "--rebase": "",
        "git not found on $PATH, can't fetch": "",
        "fetch": "",
        "--get": "",
        "branch.{}.remote": "",
        "remote": "",
        "Failed to get remotes:\\n{}": "",
        "rev-parse": "",
        "Failed to get HEAD": "",
        "merge-base": "",
        "Failed to get remotes": "",
        "refs/remotes/{remote}/HEAD": "",
        "--symbolic-full-name": "",
        "@{u}": "",
        "write-tree": "",
        "commit-tree": "",
        "-p": "",
        "Checkpoint": "",
        "restore": "",
        "--source": "",
        "--worktree": "",
        "read-tree": "",
        "clean": "",
        "-d": "",
        "--force": "",
        "--find-renames": "",
        "--patch": "",
        "refs/remotes/upstream/HEAD": "",
        "refs/remotes/upstream/": "",
        "refs/remotes/origin/HEAD": "",
        "refs/remotes/origin/": "",
        "init.defaultBranch": "",
        "master": "",
        "status": "",
        "--porcelain=v1": "",
        "--untracked-files=all": "",
        "?? ": "",
        ".git": "",
        "index": "",
        "info": "",
        "exclude": "",
        "index-{}.tmp": "",
        "GIT_INDEX_FILE": "",
        "Git command failed:\\n{stdout}{stderr}\\n": "",
        "GIT_ASKPASS": "",
        "SSH_ASKPASS": "",
        "SSH_ASKPASS_REQUIRE": "",
        "force": "",
        "Connecting to host timed out": "",
        "no HEAD": "",
        "no objectname": "",
        "no parent": "",
        "no refname": "",
        "no upstream": "",
        "no upstream:track": "",
        "no committerdate": "",
        "no authorname": "",
        "no contents:subject": "",
        "missing [": "",
        ", ": "",
        "gone": "",
        "ahead ": "",
        "behind ": "",
        "GIT_AUTHOR_NAME": "",
        "GIT_AUTHOR_EMAIL": "",
        "hi@zed.dev": "",
        "GIT_COMMITTER_NAME": "",
        "GIT_COMMITTER_EMAIL": "",
        "GIT_CONFIG_GLOBAL": "",
        "GIT_CONFIG_SYSTEM": "",
        "file": "",
        "initial": "",
        "Initial commit": "",
        "modified before checkpoint": "",
        "new_file_before_checkpoint": "",
        "modified after checkpoint": "",
        "Commit after checkpoint": "",
        "new_file_after_checkpoint": "",
        "bar": "",
        "baz": "",
        "qux": "",
        "file1": "",
        "content1": "",
        "file2": "",
        "content2": "",
        "main.rs": "",
        "binary.o": "",
        "fn main() {}": "",
        "some binary file here": "",
        "fn main() { println!(\\\"Modified\\\"); }": "",
        "Modified binary file": "",
        "help: octal escapes are not supported, `\\0` is always null": "",
        "*\\0060964da10574cd9bf06463a53bf6e0769c5c45e\\0\\0refs/heads/zed-patches\\0refs/remotes/origin/zed-patches\\0\\01733187470\\0John Doe\\0generated protobuf\\n": "",
        "refs/heads/zed-patches": "",
        "refs/remotes/origin/zed-patches": "",
        "060964da10574cd9bf06463a53bf6e0769c5c45e": "",
        "generated protobuf": "",
        "John Doe": "",
        "gc": "",
        "--prune": ""
    },
    "zed/crates/git/src/status.rs": {
        "Invalid status code: {byte}": "",
        "Invalid unmerged status code: {byte}": "",
        " ": "",
        "summary": "",
        "Unexpected duplicated status entries: {a_status:?} and {b_status:?}": "",
        "expected to find old_sha": "",
        "expected to find new_sha": "",
        "expected to find status": "",
        ":000000 100644 0000000000000000000000000000000000000000 0062c311b8727c3a2e3cd7a41bc9904feacf8f98 A\\x00.zed/settings.json\\x00": "",
        ":100644 000000 bb3e9ed2e97a8c02545bae243264d342c069afb3 0000000000000000000000000000000000000000 D\\x00README.md\\x00": "",
        ":100644 100644 42f097005a1f21eb2260fad02ec8c991282beee8 a437d85f63bb8c62bd78f83f40c506631fabf005 M\\x00parallel.go\\x00": "",
        ".zed/settings.json": "",
        "README.md": "",
        "bb3e9ed2e97a8c02545bae243264d342c069afb3": "",
        "parallel.go": "",
        "42f097005a1f21eb2260fad02ec8c991282beee8": ""
    },
    "zed/crates/git_hosting_providers/src/providers/github.rs": {
        "\\(#(\\d+)\\)$": "",
        "This field was found to be unused with serde library bump; it's left as is due to insufficient context on PO's side, but it *may* be fine to remove": "",
        "GitHub": "",
        "github.com": "",
        "the GitHub instance is not self-hosted": "",
        "github": "",
        "not a GitHub URL": "",
        "GitHub Self-Hosted": "",
        "failed to get host from github base url": "",
        "Content-Type": "",
        "application/json": "",
        "GITHUB_TOKEN": "",
        "Authorization": "",
        "error fetching GitHub commit details at {:?}": "",
        "status error {}, response: {text:?}": "",
        "failed to deserialize GitHub commit details": "",
        "L{line}": "",
        "L{start_line}-L{end_line}": "",
        ".git": "",
        "{owner}/{repo}/commit/{sha}": "",
        "{owner}/{repo}/blob/{sha}/{path}": "",
        ".md": "",
        "plain=1": "",
        "/{}/{}/pull/{}": "",
        "size=128": "",
        "git@github.com:/zed-industries/zed": "",
        "zed-industries": "",
        "git@github.com:zed-industries/zed.git": "",
        "git@github.my-enterprise.com:zed-industries/zed.git": "",
        "some-org": "",
        "some-repo": "",
        "e6ebe7974deb6bb6cc0e2595c8ec31f0c71084b7": "",
        "crates/editor/src/git/permalink.rs": "",
        "b2efec9824c45fcc90c9a7eb107a50d1772a60aa": "",
        "crates/zed/src/main.rs": "",
        "This does not contain a pull request": "",
        "\n            project panel: do not expand collapsed worktrees on ": "",
        " (#10687)\n\n            Fixes #10597\n\n            Release Notes:\n\n            - Fixed ": "",
        " expanding collapsed worktrees.\n            ": "",
        "\n            Follow-up to #10687 to fix problems\n\n            See the original PR, this is a fix.\n            ": "",
        "nonexistent": "",
        "3ef1539900037dd3601be7149b2b39ed6d0ce3db": "",
        "app/blog/[slug]/page.tsx": ""
    },
    "zed/crates/git_hosting_providers/src/providers/gitlab.rs": {
        "GitLab": "",
        "gitlab.com": "",
        "the GitLab instance is not self-hosted": "",
        "gitlab": "",
        "not a GitLab URL": "",
        "GitLab Self-Hosted": "",
        "failed to get host from gitlab base url": "",
        "Content-Type": "",
        "application/json": "",
        "error fetching GitLab commit details at {:?}": "",
        "status error {}, response: {text:?}": "",
        "failed to deserialize GitLab commit details": "",
        "error fetching GitLab avatar info at {:?}": "",
        "failed to deserialize GitLab avatar info": "",
        "L{line}": "",
        "L{start_line}-{end_line}": "",
        ".git": "",
        "{owner}/{repo}/-/commit/{sha}": "",
        "{owner}/{repo}/-/blob/{sha}/{path}": "",
        ".md": "",
        "plain=1": "",
        "gravatar": "",
        "libravatar": "",
        "s=128": "",
        "width=128": "",
        "git@gitlab.com:zed-industries/zed.git": "",
        "zed-industries": "",
        "git@gitlab.my-enterprise.com:zed-industries/zed.git": "",
        "group/subgroup": "",
        "e6ebe7974deb6bb6cc0e2595c8ec31f0c71084b7": "",
        "crates/editor/src/git/permalink.rs": "",
        "git@gitlab.some-enterprise.com:zed-industries/zed.git": "",
        "b2efec9824c45fcc90c9a7eb107a50d1772a60aa": "",
        "crates/zed/src/main.rs": ""
    },
    "zed/crates/git_ui/src/branch_picker.rs": {
        "No active repository": "",
        "GitBranchSelector": "",
        "Failed to create branch": "",
        "Select branch…": "",
        "refs/heads/{query}": "",
        "Failed to change branch": "",
        "branch-from-default": "",
        "Create branch based off default: {default_branch}": "",
        "Create branch \\\"{}\\\"…": "",
        "vcs-menu-{ix}": "",
        "Create branch \\\"{}\\\"": "",
        "based off {}": "",
        "based off the current branch": "",
        "no commits found": "",
        "{} • {}": ""
    },
    "zed/crates/git_ui/src/git_panel.rs": {
        "title_case": "",
        "Stage All": "",
        "Unstage All": "",
        "Stash All": "",
        "Stash Pop": "",
        "View Stash": "",
        "Open Diff": "",
        "Discard Tracked Changes": "",
        "Trash Untracked Files": "",
        "Sort by Status": "",
        "Sort by Path": "",
        "GitPanel": "",
        "Conflicts": "",
        "Tracked": "",
        "Untracked": "",
        "Enter commit message": "",
        "menu": "",
        "ChangesList": "",
        "CommitEditor": "",
        "Failed to open file": "",
        "{e}": "",
        "Are you sure you want to restore {}?": "",
        "Restore": "",
        "Cancel": "",
        ".gitignore": "",
        "{}\\n": "",
        "\\n{}\\n": "",
        "Trash {}?": "",
        "Failed to trash file": "",
        "HEAD": "",
        "checkout": "",
        "\\nand {} more…": "",
        "Discard changes to these files?": "",
        "Trash these files?": "",
        "Failed to trash files": "",
        "add": "",
        "reset": "",
        "stash pop": "",
        "stash apply": "",
        "stash": "",
        "Git Committed": "",
        "Git Panel": "",
        "Git Amended": "",
        "Ok": "",
        "There are still conflicts. You must stage these before committing": "",
        "git commit": "",
        "No changes to commit": "",
        "commit": "",
        "Git Uncommitted": "",
        "HEAD^": "",
        "No active repository": "",
        "This commit was already pushed to {}.": "",
        ", ": "",
        "Are you sure?": "",
        "Delete": "",
        "Create": "",
        "Update": "",
        "{} {}": "",
        "Git Commit Message Generated": "",
        "{PROMPT}\\nHere are the changes in this commit:\\n{diff_text}": "",
        "{PROMPT}\\nHere is the user's subject line:\\n{subject}\\nHere are the changes in this commit:\\n{diff_text}\\n": "",
        "commit_message_prompt.txt": "",
        "Pick which remote to fetch": "",
        "Git Fetched": "",
        "git fetch": "",
        "Error while fetching {:?}": "",
        "Select as Repository Destination": "",
        ".git": "",
        "Git Clone: {}": "",
        "Add repo to project": "",
        "Open repo in new project": "",
        "Unable to initialize a git repository": "",
        "Open a directory first": "",
        "Where would you like to initialize this git repository?": "",
        "init": "",
        "Git Pulled": "",
        "Failed to get current remote: {}": "",
        "pull": "",
        "git pull {}": "",
        "Error while pulling {:?}": "",
        "Git Pushed": "",
        "push": "",
        "git push {}": "",
        "Error while pushing {:?}": "",
        "No active branch": "",
        "Pick which remote to push to": "",
        "Co-authored-by: ": "",
        " <": "",
        "git {} failed": "",
        "View Log": "",
        "Failed to generate commit message: {err}": "",
        "stdout:\\n{}\\nstderr:\\n{}": "",
        "Output from git {operation}": "",
        "overflow-menu-trigger": "",
        "Generating Commit...": "",
        "generate-commit-message": "",
        "Generate Commit Message": "",
        "Remove co-authored-by": "",
        "Add co-authored-by": "",
        "co-authors": "",
        " {} <{}>": "",
        "commit-split-button-right": "",
        "Amend": "",
        "Signoff": "",
        "You must resolve conflicts before committing": "",
        "Commit in progress": "",
        "No commit message": "",
        "You do not have write access to this project": "",
        "Amend Tracked": "",
        "Commit": "",
        "Commit Tracked": "",
        "git reset": "",
        "git add --all .": "",
        "No Changes": "",
        "1 Change": "",
        "{} Changes": "",
        "overflow_menu": "",
        "remote-button": "",
        "commit-editor-container": "",
        "commit-footer": "",
        "expand-commit-editor": "",
        "Open Commit Modal": "",
        "commit-wrapper": "",
        "split-button-left-{}": "",
        "git commit{}{}": "",
        " --amend": "",
        " --signoff": "",
        "split-button-right-{}": "",
        "This will update your most recent commit.": "",
        "commit-msg-hover": "",
        "undo": "",
        "Uncommit": "",
        "git reset HEAD^ --soft": "",
        "git reset HEAD^": "",
        "No Git repositories": "",
        "Initialize Repository": "",
        "git init": "",
        "stage-file": "",
        "start-slot": "",
        "entries": "",
        "header_{}": "",
        "no active repo": "",
        "Unstage File": "",
        "Stage File": "",
        "Trash File": "",
        "Restore File": "",
        "Add to .gitignore": "",
        "Open File": "",
        "entry_{}_{}": "",
        "entry_{}_{}_checkbox_wrapper": "",
        "entry_{}_{}_checkbox": "",
        "active repository must be set": "",
        "Unstage": "",
        "Stage": "",
        "{parent}{}": "",
        "loading git panel": "",
        "git_panel": "",
        " (no branch)": "",
        "repo-selector": "",
        "repository-switcher": "",
        "Switch Active Repository": "",
        "branch-selector": "",
        "popover-button": "",
        "Switch Branch": "",
        "some-branch": "",
        "origin/some-branch": "",
        "abc123": "",
        "Modify stuff": "",
        "John Doe": "",
        "zed/{}": "",
        "repo-{}": "",
        "Action Button States": "",
        "No Branch": "",
        "Remote status unknown": "",
        "No Remote Upstream": "",
        "Not Ahead or Behind": "",
        "Behind remote": "",
        "Ahead of remote": "",
        "Ahead and behind remote": "",
        "Labels": "",
        "Short Branch & Repo": "",
        "main": "",
        "Long Branch": "",
        "redesign-and-update-git-ui-list-entry-style": "",
        "Long Repo": "",
        "zed-industries-community-examples": "",
        "gpui": "",
        "Long Repo & Branch": "",
        "Uppercase Repo": "",
        "LICENSES": "",
        "Uppercase Branch": "",
        "update-README": "",
        "/root": "",
        "crates": "",
        "gpui.rs": "",
        "fn main() {}": "",
        "util": "",
        "util.rs": "",
        "fn do_it() {}": "",
        "crates/gpui/gpui.rs": "",
        "crates/util/util.rs": "",
        "/root/zed/crates/gpui": "",
        "project": "",
        "src": "",
        "main.rs": "",
        "lib.rs": "",
        "pub fn hello() {}": "",
        "utils.rs": "",
        "pub fn util() {}": "",
        "tests": "",
        "test.rs": "",
        "fn test() {}": "",
        "new_file.txt": "",
        "new content": "",
        "another_new.rs": "",
        "// new file": "",
        "conflict.txt": "",
        "conflicted content": "",
        "src/main.rs": "",
        "src/lib.rs": "",
        "tests/test.rs": "",
        "src/utils.rs": "",
        "/root/project": "",
        "Initial commit message": "",
        "Previous commit message": "",
        "/project": "",
        "tracked": "",
        "tracked\\n": "",
        "untracked": "",
        "old tracked\\n": "",
        "ProjectDiff should exist": "",
        "active_path should exist": ""
    },
    "zed/crates/git_ui/src/git_ui.rs": {
        "Operation was canceled": "",
        "Failed to rename branch": "",
        "RenameBranchModal": "",
        "Rename Branch ({})": "",
        "Fetch": "",
        "Fetch updates from remote": "",
        "git fetch": "",
        "Push": "",
        "Push committed changes to remote": "",
        "git push": "",
        "Pull": "",
        "git pull": "",
        "Publish": "",
        "Publish branch to remote": "",
        "git push --set-upstream": "",
        "Republish": "",
        "Re-publish branch to remote": "",
        "split-button-right": "",
        "Fetch From": "",
        "Pull (Rebase)": "",
        "Push To": "",
        "Force Push": "",
        "split-button-left-{}": "",
        "split-button-right-{}": "",
        "Modified": "",
        "Added": "",
        "Deleted": "",
        "Conflicted": "",
        "Enter repository URL…": "",
        "Clone a repository from GitHub or other sources.": "",
        "learn-more": "",
        "Learn More": ""
    },
    "zed/crates/git_ui/src/project_diff.rs": {
        "Git Branch Diff Opened": "",
        "Git Diff Opened": "",
        "Git Panel": "",
        "Action": "",
        "No active repository": "",
        "Could not determine default branch": "",
        "project diff editor should have a conflict addon": "",
        "Project Diff": "",
        "Uncommitted Changes": "",
        "Changes since {}": "",
        "Project Diff Opened": "",
        "EmptyPane": "",
        "GitDiff": "",
        "No uncommitted changes": "",
        "Remote up to date": "",
        "project-diff-close-button": "",
        "Close": "",
        "ProjectDiff": "",
        "workspace gone": "",
        "exec_bound failed to execute or parse for: {}": "",
        "Error in get_diff_base, select_row_bound failed to execute or parse for: {}": "",
        "deserializing diff base": "",
        "stage": "",
        "Toggle Staged": "",
        "Stage": "",
        "Stage and go to next hunk": "",
        "unstage": "",
        "Unstage": "",
        "Unstage and go to next hunk": "",
        "undo": "",
        "up": "",
        "Go to previous hunk": "",
        "down": "",
        "Go to next hunk": "",
        "unstage-all": "",
        "Unstage All": "",
        "Unstage all changes": "",
        "Unstaged": "",
        "stage-all": "",
        "Stage All": "",
        "Stage all changes": "",
        "commit": "",
        "Commit": "",
        "{} Commits Ahead": "",
        "Push your changes to {}": "",
        "push": "",
        "Publish Branch": "",
        "Create {} on remote": "",
        "publish": "",
        "Remote status unknown": "",
        "No Repository": "",
        "No Changes": "",
        "some-branch": "",
        "origin/some-branch": "",
        "abc123": "",
        "Modify stuff": "",
        "John Doe": "",
        "No Repo": "",
        "Unknown Upstream": "",
        "Ahead of Remote": "",
        "/project": "",
        ".git": "",
        "foo.txt": "",
        "FOO\\n": "",
        "foo\\n": "",
        "deadbeef": "",
        "\n                - foo\n                + ˇFOO\n            ": "",
        "ˇ": "",
        "bar": "",
        "BAR\\n": "",
        "bar\\n": "",
        "\n                - bar\n                + BAR\n\n                - ˇfoo\n                + FOO\n            ": "",
        "\n                - ˇbar\n                + BAR\n\n                - foo\n                + FOO\n            ": "",
        "modified\\n": "",
        "/project/foo": "",
        "original\\n": "",
        "\n                - original\n                + ˇmodified\n            ": "",
        "different\\n": "",
        "\n                - original\n                + different\n                  ˇ": "",
        "\n                - original\n                + ˇdifferent\n            ": "",
        "/a": "",
        "a.txt": "",
        "created\\n": "",
        "b.txt": "",
        "really changed\\n": "",
        "c.txt": "",
        "unchanged\\n": "",
        "before\\n": "",
        "d.txt": "",
        "deleted\\n": "",
        "\n            [EXCERPT]\n            before\n            really changed\n            [EXCERPT]\n            [FOLDED]\n            [EXCERPT]\n            ˇcreated\n        ": "",
        "\n            [EXCERPT]\n            before\n            really changed\n            [EXCERPT]\n            ˇ[FOLDED]\n            [EXCERPT]\n            created\n        ": "",
        "\n            [EXCERPT]\n            ˇbefore\n            really changed\n            [EXCERPT]\n            [FOLDED]\n            [EXCERPT]\n            created\n        ": "",
        "\n            #[rustfmt::skip]\n            fn main() {\n                let x = 0.0; // this line will be removed\n                // 1\n                // 2\n                // 3\n                let y = 0.0; // this line will be removed\n                // 1\n                // 2\n                // 3\n                let arr = [\n                    0.0, // this line will be removed\n                    0.0, // this line will be removed\n                    0.0, // this line will be removed\n                    0.0, // this line will be removed\n                ];\n            }\n        ": "",
        "\n            #[rustfmt::skip]\n            fn main() {\n                // 1\n                // 2\n                // 3\n                // 1\n                // 2\n                // 3\n                let arr = [\n                ];\n            }\n        ": "",
        "main.rs": "",
        "[EXCERPT]\\nˇ{git_contents}": "",
        "<<<<<<< x\\nours\\n=======\\ntheirs\\n>>>>>>> y\\n": "",
        "ours\\n": "",
        "\n                    one\n                    two\n                    three\n                    four\n                    five\n                    six\n                    seven\n                    eight\n                    nine\n                    ten\n                    ELEVEN\n                    twelve\n                ": "",
        "\n                    one\n                    two\n                    three\n                    four\n                    five\n                    six\n                    seven\n                    eight\n                    nine\n                    ten\n                    eleven\n                    twelve\n                ": "",
        "\n                  ˇnine\n                  ten\n                - eleven\n                + ELEVEN\n                  twelve\n            ": "",
        "\n                    one\n                    «TWO»\n                    three\n                    four\n                    five\n                    six\n                    seven\n                    eight\n                    nine\n                    ten\n                    ELEVEN\n                    twelve\n                ": "",
        "\n                  one\n                - two\n                + TWO\n                  three\n                  four\n                  five\n                  ˇnine\n                  ten\n                - eleven\n                + ELEVEN\n                  twelve\n            ": "",
        "C": "",
        "new": "",
        "in-merge-base-and-work-tree": "",
        "created-in-head": "",
        "B": "",
        "sha": "",
        "A": "",
        "\n                - A\n                + ˇC\n                + new\n                + created-in-head": "",
        "README.md": "",
        "# My cool project\\n": "",
        "# My cool project\\nDetails to come.\\n": "",
        "[EXCERPT]\\nˇ# My cool project\\nDetails to come.\\n": ""
    },
    "zed/crates/git_ui/src/remote_output.rs": {
        "fetch": "",
        "pull": "",
        "push": "",
        "Fetch: Already up to date": "",
        "Synchronized with {}": "",
        "Synchronized with remotes": "",
        "Failed to get last line of output": "",
        "Failed to get first word of last line": "",
        "Already up to date.\\n": "",
        "Pull: Already up to date": "",
        "Updating": "",
        "Received {} file change{} from {}": "",
        "s": "",
        "Fast forwarded from {}": "",
        "Merge": "",
        "Merged {} file change{} from {}": "",
        "Merged from {}": "",
        "Successfully rebased": "",
        "Successfully rebased from {}": "",
        "Successfully pulled from {}": "",
        "Everything up-to-date\\n": "",
        "Push: Everything is up-to-date": "",
        "Pushed {} to {}": "",
        "\\nremote: ": "",
        "Create a pull request": "",
        "Create Pull Request": "",
        "Create pull request": "",
        "create a merge request": "",
        "Create Merge Request": "",
        "View merge request": "",
        "View Merge Request": "",
        "test_branch": "",
        "test_remote": "",
        "\n                Total 0 (delta 0), reused 0 (delta 0), pack-reused 0 (from 0)\n                remote:\n                remote: Create a pull request for 'test' on GitHub by visiting:\n                remote:      https://example.com/test/test/pull/new/test\n                remote:\n                To example.com:test/test.git\n                 * [new branch]      test -> test\n                ": "",
        "Expected PushPrLink variant": "",
        "\n                Total 0 (delta 0), reused 0 (delta 0), pack-reused 0 (from 0)\n                remote:\n                remote: To create a merge request for test, visit:\n                remote:   https://example.com/test/test/-/merge_requests/new?merge_request%5Bsource_branch%5D=test\n                remote:\n                To example.com:test/test.git\n                 * [new branch]      test -> test\n                ": "",
        "\n                Total 0 (delta 0), reused 0 (delta 0), pack-reused 0 (from 0)\n                remote:\n                remote: View merge request for test:\n                remote:    https://example.com/test/test/-/merge_requests/99999\n                remote:\n                To example.com:test/test.git\n                    + 80bd3c83be...e03d499d2e test -> test\n                ": "",
        "\n                To http://example.com/test/test.git\n                 * [new branch]      test -> test\n                ": "",
        "To http://example.com/test/test.git\\n * [new branch]      test -> test\\n": "",
        "Expected ToastWithLog variant": ""
    },
    "zed/crates/go_to_line/src/cursor_position.rs": {
        "before the first character": "",
        "added 1": "",
        "line": "",
        "selection": "",
        "character": "",
        " (": "",
        ", ": "",
        "s": "",
        "{count} {name}{plural_suffix}": "",
        "{}{FILE_ROW_COLUMN_DELIMITER}{}": "",
        "go-to-line-column": "",
        "Go to Line/Column": ""
    },
    "zed/crates/go_to_line/src/go_to_line.rs": {
        "{line}{FILE_ROW_COLUMN_DELIMITER}{column}": "",
        "Current Line: {} of {} (column {})": "",
        "Go to line {line}, character {character}": "",
        "Go to line {line}": "",
        "GoToLine": "",
        "/dir": "",
        "a.rs": "",
        "\n                    struct SingleLine; // display line 0\n                                       // display line 1\n                    struct MultiLine { // display line 2\n                        field_1: i32,  // display line 3\n                        field_2: i32,  // display line 4\n                    }                  // display line 5\n                                       // display line 6\n                    struct Another {   // display line 7\n                        field_1: i32,  // display line 8\n                        field_2: i32,  // display line 9\n                        field_3: i32,  // display line 10\n                        field_4: i32,  // display line 11\n                    }                  // display line 12\n                ": "",
        "Initially opened go to line modal should not highlight any rows": "",
        "Go to line modal should highlight a row, corresponding to the query": "",
        "If the query is too large, the last row should be highlighted": "",
        "After cancelling and closing the modal, no rows should be highlighted": "",
        "Reopened modal should not highlight any rows": "",
        "After confirming and closing the modal, no rows should be highlighted": "",
        "ēlo": "",
        "missing cursor position item": "",
        "No selections should be initially": "",
        "After selecting a text with multibyte unicode characters, the character count should be correct": "",
        "ēlo你好": "",
        "Beginning of the line should be at first line, before any characters": "",
        "Wrong position for char '{c}' in string '{text}'": "",
        "After reaching the end of the text, position should not change when moving right": "",
        "When going to {point:?}, expecting the cursor to be at char '{c}' in string '{text}'": "",
        "When going into too large point, should go to the end of the text": "",
        "No position found": "",
        "No placeholder text": "",
        "Expected one caret selection but got: {selections:?}": "",
        "Expected a single caret selection, but got: {selection:?}": "",
        "struct Line{};": "",
        "Dismissing via outside click should maintain new scroll position": "",
        "Cancel should maintain new scroll position": "",
        "Confirm should maintain new scroll position": ""
    },
    "zed/crates/google_ai/src/google_ai.rs": {
        "{api_url}/v1beta/models/{model_id}:streamGenerateContent?alt=sse&key={api_key}": "",
        "Content-Type": "",
        "application/json": "",
        "data: ": "",
        "Error parsing JSON: {error:?}\\n{line:?}": "",
        "error during streamGenerateContent, status code: {:?}, body: {}": "",
        "{api_url}/v1beta/models/{model_id}:countTokens?key={api_key}": "",
        "error during countTokens, status code: {:?}, body: {}": "",
        "Model must be specified": "",
        "Request must contain at least one content item": "",
        "User content must contain at least one part": "",
        "generateContent": "",
        "streamGenerateContent": "",
        "countTokens": "",
        "embedContent": "",
        "batchEmbedContents": "",
        "camelCase": "",
        "ModelName::is_empty": "",
        "Option::is_none": "",
        "HARM_CATEGORY_UNSPECIFIED": "",
        "HARM_CATEGORY_DEROGATORY": "",
        "HARM_CATEGORY_TOXICITY": "",
        "HARM_CATEGORY_VIOLENCE": "",
        "HARM_CATEGORY_SEXUAL": "",
        "HARM_CATEGORY_MEDICAL": "",
        "HARM_CATEGORY_DANGEROUS": "",
        "HARM_CATEGORY_HARASSMENT": "",
        "HARM_CATEGORY_HATE_SPEECH": "",
        "HARM_CATEGORY_SEXUALLY_EXPLICIT": "",
        "HARM_CATEGORY_DANGEROUS_CONTENT": "",
        "SCREAMING_SNAKE_CASE": "",
        "HARM_BLOCK_THRESHOLD_UNSPECIFIED": "",
        "HARM_PROBABILITY_UNSPECIFIED": "",
        "lowercase": "",
        "models/": "",
        "{MODEL_NAME_PREFIX}{}": "",
        "Expected model name to begin with {}, got: {}": "",
        "schemars": "",
        "gemini-1.5-pro": "",
        "gemini-1.5-flash-8b": "",
        "gemini-1.5-flash": "",
        "gemini-2.0-flash-lite": "",
        "gemini-2.0-flash-lite-preview": "",
        "gemini-2.0-flash": "",
        "gemini-2.5-flash-lite-preview": "",
        "gemini-2.5-flash-lite-preview-06-17": "",
        "gemini-2.5-flash": "",
        "gemini-2.0-flash-thinking-exp": "",
        "gemini-2.5-flash-preview-04-17": "",
        "gemini-2.5-flash-preview-05-20": "",
        "gemini-2.5-flash-preview-latest": "",
        "gemini-2.5-pro": "",
        "gemini-2.0-pro-exp": "",
        "gemini-2.5-pro-preview-latest": "",
        "gemini-2.5-pro-exp-03-25": "",
        "gemini-2.5-pro-preview-03-25": "",
        "gemini-2.5-pro-preview-05-06": "",
        "gemini-2.5-pro-preview-06-05": "",
        "custom": "",
        "Gemini 1.5 Pro": "",
        "Gemini 1.5 Flash-8b": "",
        "Gemini 1.5 Flash": "",
        "Gemini 2.0 Flash-Lite": "",
        "Gemini 2.0 Flash": "",
        "Gemini 2.5 Flash-Lite Preview": "",
        "Gemini 2.5 Flash": "",
        "Gemini 2.5 Pro": "",
        "auto": ""
    },
    "zed/crates/gpui/examples/hello_world.rs": {
        "Hello, {}!": "",
        "World": ""
    },
    "zed/crates/gpui/examples/image/image.rs": {
        "main": "",
        "Image loaded from a local file": "",
        "Image loaded from a remote resource": "",
        "Image loaded from an asset": "",
        "Auto Width": "",
        "Auto Height": "",
        "image with max width 100%": "",
        "CARGO_MANIFEST_DIR": "",
        "examples": "",
        "gpui example": "",
        "cmd-q": "",
        "Image": "",
        "Quit": "",
        "Image Example": "",
        "examples/image/app-icon.png": "",
        "image/color.svg": ""
    },
    "zed/crates/gpui/examples/set_menus.rs": {
        "Set Menus Example": "",
        "List": "",
        "Grid": "",
        "set_menus": "",
        "Services": "",
        "Quit": "",
        "Gracefully quitting the application . . .": ""
    },
    "zed/crates/gpui/examples/uniform_list.rs": {
        "entries": "",
        "clicked Item {item:?}": "",
        "Item {item}": ""
    },
    "zed/crates/gpui/examples/window_positioning.rs": {
        "origin: {}, {} size: {}, {}": "",
        "cx.bounds() origin: {}, {} size {}, {}": "",
        "Top Left {:?}": "",
        "Top Right {:?}": "",
        "Bottom Left {:?}": "",
        "Bottom Right {:?}": "",
        "Top Center {:?}": "",
        "Left Center {:?}": "",
        "Center {:?}": "",
        "Right Center {:?}": "",
        "Bottom Center {:?}": ""
    },
    "zed/crates/gpui/src/elements/animation.rs": {
        "delta should always be between 0 and 1": "",
        "should only be called once": ""
    },
    "zed/crates/gpui/src/elements/div.rs": {
        "DragMoveEvent is only valid when the stored active drag is of the same type.": "",
        "inspector": "",
        "calling on_drag more than once on the same element is not supported": "",
        "calling on_hover more than once on the same element is not supported": "",
        "calling tooltip more than once on the same element is not supported": "",
        "tab group": "",
        "hover style already set": "",
        "This element was created at:\\n{}:{}:{}": "",
        "checked for type drag state type above": "",
        "enter": "",
        "space": ""
    },
    "zed/crates/gpui/src/action.rs": {
        "ActionName": "",
        "editor::SomeAction": "",
        "Message about why this action is deprecation": "",
        "Paste": "",
        "dyn Action": "",
        "name": "",
        "Didn't find an action named \\\"{name}\\\"": "",
        "Error while building action \\\"{name}\\\": {error}": "",
        "\n            );\n        }\n        self.by_name.insert(\n            name,\n            ActionData {\n                build: action.build,\n                json_schema: action.json_schema,\n            },\n        );\n        for &alias in action.deprecated_aliases {\n            if self.by_name.contains_key(alias) {\n                panic!(\n                    ": "",
        "\n                );\n            }\n            self.by_name.insert(\n                alias,\n                ActionData {\n                    build: action.build,\n                    json_schema: action.json_schema,\n                },\n            );\n            self.deprecated_aliases.insert(alias, name);\n            self.all_names.push(alias);\n        }\n        self.names_by_type_id.insert(action.type_id, name);\n        self.all_names.push(name);\n        if let Some(deprecation_msg) = action.deprecation_message {\n            self.deprecation_messages.insert(name, deprecation_msg);\n        }\n        if let Some(documentation) = action.documentation {\n            self.documentation.insert(name, documentation);\n        }\n    }\n\n    /// Construct an action based on its name and optional JSON parameters sourced from the keymap.\n    pub fn build_action_type(&self, type_id: &TypeId) -> Result<Box<dyn Action>> {\n        let name = self\n            .names_by_type_id\n            .get(type_id)\n            .with_context(|| format!(": "",
        "))?;\n\n        Ok(self.build_action(name, None)?)\n    }\n\n    /// Construct an action based on its name and optional JSON parameters sourced from the keymap.\n    pub fn build_action(\n        &self,\n        name: &str,\n        params: Option<serde_json::Value>,\n    ) -> std::result::Result<Box<dyn Action>, ActionBuildError> {\n        let build_action = self\n            .by_name\n            .get(name)\n            .ok_or_else(|| ActionBuildError::NotFound {\n                name: name.to_owned(),\n            })?\n            .build;\n        (build_action)(params.unwrap_or_else(|| json!({}))).map_err(|e| {\n            ActionBuildError::BuildError {\n                name: name.to_owned(),\n                error: e,\n            }\n        })\n    }\n\n    pub fn all_action_names(&self) -> &[&'static str] {\n        self.all_names.as_slice()\n    }\n\n    pub fn action_schemas(\n        &self,\n        generator: &mut schemars::SchemaGenerator,\n    ) -> Vec<(&'static str, Option<schemars::Schema>)> {\n        // Use the order from all_names so that the resulting schema has sensible order.\n        self.all_names\n            .iter()\n            .map(|name| {\n                let action_data = self\n                    .by_name\n                    .get(name)\n                    .expect(": ""
    },
    "zed/crates/gpui/src/app.rs": {
        "inspector": "",
        "TRACK_THREAD_BORROWS": "",
        "borrowed {thread_id:?}": "",
        "dropped borrow from {thread_id:?}": "",
        "dropped {thread_id:?}": "",
        "GPUI was compiled in test mode": "",
        "must construct App on main thread": "",
        "timed out waiting on app_will_quit": "",
        "invalid event type": "",
        "All windows should be off the stack when flushing effects": "",
        "window not found": "",
        "Can't spawn on main thread after on_app_quit": "",
        "no state of type {} exists": "",
        "no global added for {}": "",
        "no global registered of type {}": "",
        "invalid entity type": "",
        "attempted to read a window that is already on the stack": "",
        "root view's type has changed": "",
        "Notify({})": "",
        "Emit({:?})": "",
        "RefreshWindows": "",
        "NotifyGlobalObservers({:?})": "",
        "Defer(..)": "",
        "EntityCreated({:?})": "",
        "No HttpClient available": ""
    },
    "zed/crates/gpui/src/arena.rs": {
        "increased element arena capacity to {}kb": "",
        "Arena chunk_size of {} is too small to allocate {} bytes": "",
        "attempted to dereference an ArenaRef after its Arena was cleared": ""
    },
    "zed/crates/gpui/src/asset_cache.rs": {
        "Failed to load asset: {}": ""
    },
    "zed/crates/gpui/src/color.rs": {
        "rgba({:#010x})": "",
        "a string in the format #rrggbb or #rrggbbaa": "",
        "Rgba": "",
        "type": "",
        "string": "",
        "pattern": "",
        "^#([0-9a-fA-F]{3}|[0-9a-fA-F]{4}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})$": "",
        "#{r:02x}{g:02x}{b:02x}{a:02x}": "",
        "rgb": "",
        "rgba": "",
        "rrggbb": "",
        "rrggbbaa": "",
        "Expected #rgb, #rgba, #rrggbb, or #rrggbbaa": "",
        "invalid unicode characters in color": "",
        "invalid RGBA hex color: '{value}'. {EXPECTED_FORMATS}": "",
        "{INVALID_UNICODE}: r component of #rgb/#rgba for value: '{value}'": "",
        "{INVALID_UNICODE}: g component of #rgb/#rgba for value: '{value}'": "",
        "{INVALID_UNICODE}: b component of #rgb/#rgba for value: '{value}'": "",
        "{INVALID_UNICODE}: a component of #rgba for value: '{value}'": "",
        "{}: r component of #rrggbb/#rrggbbaa for value: '{}'": "",
        "{INVALID_UNICODE}: g component of #rrggbb/#rrggbbaa for value: '{value}'": "",
        "{INVALID_UNICODE}: b component of #rrggbb/#rrggbbaa for value: '{value}'": "",
        "{INVALID_UNICODE}: a component of #rrggbbaa for value: '{value}'": "",
        "hsla({:.2}, {:.2}%, {:.2}%, {:.2})": "",
        "sRGB": "",
        "Oklab": "",
        "Solid({:?})": "",
        "LinearGradient({}, {:?}, {:?})": "",
        "PatternSlash({:?}, {})": "",
        "#f09": "",
        "#f09f": "",
        "#ff0099": "",
        "#ff0099ff": "",
        " #f5f5f5ff   ": "",
        "#DeAdbEeF": ""
    },
    "zed/crates/gpui/src/element.rs": {
        "views": "",
        "inspector": "",
        "must call request_layout only once": "",
        "must call request_layout before prepaint": "",
        "must call prepaint before paint": "",
        "cannot measure after painting": ""
    },
    "zed/crates/gpui/src/executor.rs": {
        "\\nbacktrace of waiting future:\\n{:?}": "",
        "\\n  waiting on: {}\\n": "",
        "parked with nothing left to run{waiting_message}{backtrace_message}": "",
        "test timed out after {duration:?} with allow_parking": "",
        "parked with nothing let to run": "",
        "local task dropped by a thread that didn't spawn it. Task spawned at {}": "",
        "local task polled by a thread that didn't spawn it. Task spawned at {}": ""
    },
    "zed/crates/gpui/src/key_dispatch.rs": {
        "Editor": "",
        "cmd-z": "",
        "cmd-shift-z": "",
        "cmd-k left": "",
        "Pane": "",
        "node {} was not part of the reused subtree {:?}": "",
        "test::TestAction": "",
        "cmd-n": "",
        "ProjectPanel": "",
        "Workspace": "",
        "custom": "",
        "Terminal": "",
        "ctrl-b": "",
        "ctrl-b h": "",
        "ctrl-b [": ""
    },
    "zed/crates/gpui/src/platform/linux/platform.rs": {
        "wayland": "",
        "x11": "",
        "zed-github-account": "",
        "Couldn't open file picker due to missing xdg-desktop-portal implementation.": "",
        "screen-capture": "",
        "Failed to get app path: {:?}": "",
        "Restarting process, using app path: {:?}": "",
        "\n            while kill -0 {pid} 2>/dev/null; do\n                sleep 0.1\n            done\n\n            {app_path}\n            ": "",
        "We are restarting ourselves, using std command thus is fine": "",
        "/usr/bin/env": "",
        "bash": "",
        "-c": "",
        "failed to spawn restart script: {:?}": "",
        "activate is not implemented on Linux, ignoring the call": "",
        "hide is not implemented on Linux, ignoring the call": "",
        "hide_other_apps is not implemented on Linux, ignoring the call": "",
        "unhide_other_apps is not implemented on Linux, ignoring the call": "",
        "Open Folder": "",
        "Open File": "",
        "Save File": "",
        "pathbuf should not be nul terminated": "",
        "pick files": "",
        "pick directories": "",
        "xdg-open": "",
        "invoking xdg-open": "",
        "Platform<LinuxPlatform>::path_for_auxiliary_executable is not implemented yet": "",
        "url": "",
        "username": "",
        "Cannot find username in stored credentials": "",
        "register_url_scheme unimplemented": "",
        "Failed to open with dbus: {}": "",
        "XDG_ACTIVATION_TOKEN": "",
        "Failed to open with {}: {}": "",
        "LC_CTYPE": "",
        "C": "",
        "left_ptr": "",
        "text": "",
        "xterm": "",
        "crosshair": "",
        "cross": "",
        "closedhand": "",
        "grabbing": "",
        "hand2": "",
        "openhand": "",
        "grab": "",
        "hand1": "",
        "pointer": "",
        "hand": "",
        "w-resize": "",
        "left_side": "",
        "e-resize": "",
        "right_side": "",
        "ew-resize": "",
        "sb_h_double_arrow": "",
        "n-resize": "",
        "top_side": "",
        "s-resize": "",
        "bottom_side": "",
        "sb_v_double_arrow": "",
        "ns-resize": "",
        "size_fdiag": "",
        "bd_double_arrow": "",
        "nwse-resize": "",
        "size_bdiag": "",
        "nesw-resize": "",
        "fd_double_arrow": "",
        "col-resize": "",
        "row-resize": "",
        "vertical-text": "",
        "not-allowed": "",
        "crossed_circle": "",
        "alias": "",
        "copy": "",
        "context-menu": "",
        "CursorStyle::None should be handled separately in the client": "",
        "XCURSOR_PATH": "",
        ",\n            message,\n            xcursor_path\n        );\n    } else {\n        log::warn!(": "",
        ", message);\n    }\n}\n\n#[cfg(any(feature = ": "",
        ", feature = ": "",
        "))]\nfn guess_ascii(keycode: Keycode, shift: bool) -> Option<char> {\n    let c = match (keycode.raw(), shift) {\n        (24, _) => 'q',\n        (25, _) => 'w',\n        (26, _) => 'e',\n        (27, _) => 'r',\n        (28, _) => 't',\n        (29, _) => 'y',\n        (30, _) => 'u',\n        (31, _) => 'i',\n        (32, _) => 'o',\n        (33, _) => 'p',\n        (34, false) => '[',\n        (34, true) => '{',\n        (35, false) => ']',\n        (35, true) => '}',\n        (38, _) => 'a',\n        (39, _) => 's',\n        (40, _) => 'd',\n        (41, _) => 'f',\n        (42, _) => 'g',\n        (43, _) => 'h',\n        (44, _) => 'j',\n        (45, _) => 'k',\n        (46, _) => 'l',\n        (47, false) => ';',\n        (47, true) => ':',\n        (48, false) => '\\'',\n        (48, true) => '": "",
        "enter": "",
        "pageup": "",
        "pagedown": "",
        "tab": "",
        "back": "",
        "forward": "",
        "cut": "",
        "paste": "",
        "new": "",
        "open": "",
        "save": "",
        "_": "",
        "space": "",
        "backspace": "",
        "delete": "",
        "escape": "",
        "left": "",
        "right": "",
        "up": "",
        "down": "",
        "home": "",
        "end": "",
        "insert": "",
        "kp_": "",
        "ˇ": "",
        "ʽ": "",
        "ꞈ": "",
        "ə": "",
        "Ə": ""
    },
    "zed/crates/gpui/src/platform/windows/platform.rs": {
        "unable to initialize Windows OLE": "",
        "Creating DirectX devices": "",
        "Error creating DirectWriteTextSystem": "",
        "CreateWindowExW did not run correctly": "",
        "true": "",
        "Error creating drop target helper.": "",
        "Error retrieve windows version": "",
        "VSyncProvider": "",
        "Device lost: {err}": "",
        "\n            $pidToWaitFor = {}\n            $exePath = ": "",
        "\n\n            while ($true) {{\n                $process = Get-Process -Id $pidToWaitFor -ErrorAction SilentlyContinue\n                if (-not $process) {{\n                    Start-Process -FilePath $exePath\n                    break\n                }}\n                Start-Sleep -Seconds 0.1\n            }}\n            ": "",
        "We are restarting ourselves, using std command thus is fine": "",
        "powershell.exe": "",
        "-command": "",
        "failed to spawn restart script: {:?}": "",
        "screen-capture": "",
        "Opening url: {}": "",
        "only files": "",
        "only folders": "",
        "Revealing path {} in explorer": "",
        "Opening {} with system": "",
        "not yet implemented": "",
        "register_url_scheme unimplemented": "",
        "missing directx devices": "",
        "missing dispatcher": "",
        "missing main receiver": "",
        "Wrong validation number while processing message: {message}": "",
        "Failed to upgrade raw window handles": "",
        "Dock menu for index {action_idx} not found": "",
        "Destroying platform window": "",
        "open": "",
        "Unable to open target: {}": "",
        "No parent folder found": "",
        "file not\n            // found": "",
        "Opening target parent folder": "",
        "Can not open target path: {}": "",
        "failed to canonicalize directory": "",
        "failed to set dialog folder": "",
        "failed to set file name": "",
        "All files": "",
        "unable to get module handle": "",
        "unable to load icon file": "",
        "DirectX device lost detected: {:?}": "",
        "Failed to recreate new DirectX devices after device lost": "",
        "DirectX devices successfully recreated.": "",
        "Zed::PlatformWindow": "",
        "system": "",
        "missing main sender": "",
        "你好，我是张小白": "",
        "abcdef": ""
    },
    "zed/crates/html_to_markdown/src/html_to_markdown.rs": {
        "failed to parse HTML": "",
        "failed to convert HTML to Markdown": "",
        "failed to parse HTML document": ""
    },
    "zed/crates/html_to_markdown/src/markdown_writer.rs": {
        "^\\s*$": "",
        "Failed to create empty_line_regex": "",
        "\\n{3,}": "",
        "\\n\\n": "",
        " ": ""
    },
    "zed/crates/http_client/src/github.rs": {
        "prerelease": "",
        "error fetching latest release": "",
        "error reading latest release": "",
        "status error {}, response: {text:?}": "",
        "Error deserializing: {err:?}": "",
        "GitHub API response text: {:?}": "",
        "error deserializing latest release: {err:?}": "",
        "finding a prerelease": "",
        "sha256:": "",
        "error deserializing GitHub release: {err:?}": "",
        "{tag}.{extension}": "",
        "tar.gz": "",
        "gz": "",
        "zip": "",
        "cannot modify url path segments": "",
        "release/2.3.5": "",
        "microsoft/vscode-eslint": ""
    },
    "zed/crates/http_client/src/http_client.rs": {
        "Content-Type": "",
        "application/json": "",
        "called as_fake on {}": "",
        "not implemented": "",
        "ALL_PROXY": "",
        "all_proxy": "",
        "HTTPS_PROXY": "",
        "https_proxy": "",
        "HTTP_PROXY": "",
        "http_proxy": "",
        "NO_PROXY": "",
        "no_proxy": "",
        "BlockedHttpClient disallowed request": "",
        "FakeHttpClient": ""
    },
    "zed/crates/image_viewer/src/image_viewer.rs": {
        "ImageView": "",
        "No image path found": "",
        "Path not found": "",
        "image_viewers": "",
        "Saving image at path {image_path:?}": "",
        "img": ""
    },
    "zed/crates/install_cli/src/install_cli.rs": {},
    "zed/crates/language/src/buffer_tests.rs": {
        "[ \\t]+$": "",
        "Failed to create TRAILING_WHITESPACE_REGEX": "",
        "one\\r\\ntwo\\rthree": "",
        "one\\ntwo\\nthree": "",
        "\\r\\nfour": "",
        "zero\\r\\n": "",
        "zero\\none\\ntwo\\nthree\\nfour": "",
        "one\\ntwo\\nthree\\n": "",
        "Rust with longer extension": "",
        "longer.rs": "",
        "Make": "",
        "Makefile": "",
        "mk": "",
        "src/lib.rs": "",
        "src/lib.mk": "",
        "src/lib.longer.rs": "",
        "src/Makefile": "",
        "zed/cars": "",
        "zed/a.cars": "",
        "zed/sumk": "",
        "JavaScript": "",
        "js": "",
        "\\bnode\\b": "",
        "the/script": "",
        "nothing": "",
        "#!/bin/env node": "",
        "TypeScript": "",
        "*longer.ts": "",
        "ecmascript": "",
        "C++": "",
        "c": "",
        "*.dev": "",
        "Dockerfile": "",
        "Dockerfile.*": "",
        "ts": "",
        "ts.ecmascript": "",
        "cpp": "",
        "C": "",
        "foo.ts": "",
        "foo.ts.ecmascript": "",
        "foo.cpp": "",
        "foo.js": "",
        "foo.c": "",
        "foo.longer.ts": "",
        "foo.ecmascript": "",
        "c-plus-plus.dev": "",
        "Dockerfile.dev": "",
        "abcdef": "",
        "XYZ": "",
        "u": "",
        "w": "",
        "one two three\\nfour fiˇve six\\nseven eightˇ nine\\nten eleven twelve\\n": "",
        "one two three\\n{\\nfour FIVEˇ six\\n}\\nseven AND EIGHTˇ nine\\nten eleven twelve\\n": "",
        "one two three\\n{\\nˇ}\\nseven AND EIGHTEENˇ nine\\nten eleven twelve\\n": "",
        "zero": "",
        "one  ": "",
        "two": "",
        "three   ": "",
        "four": "",
        "five    ": "",
        "EE": "",
        "EEE": "",
        "zEEero": "",
        "one": "",
        "threeEEE   ": "",
        "five": "",
        "threeEEE": "",
        "fn a() {}": "",
        "(source_file (function_item name: (identifier) ": "",
        "parameters: (parameters) ": "",
        "body: (block)))": "",
        "b: C": "",
        " d; ": "",
        "fn a(b: C) { d; }": "",
        "parameters: (parameters (parameter pattern: (identifier) type: (type_identifier))) ": "",
        "body: (block (expression_statement (identifier)))))": "",
        ".e": "",
        "fn a(b: C) { d.e; }": "",
        "(f)": "",
        "fn a(b: C) { d.e(f); }": "",
        "::<G>": "",
        "fn a(b: C) { d.e::<G>(f); }": "",
        "body: (block (expression_statement (call_expression ": "",
        "function: (generic_function ": "",
        "function: (field_expression value: (identifier) field: (field_identifier)) ": "",
        "type_arguments: (type_arguments (type_identifier))) ": "",
        "arguments: (arguments (identifier)))))))": "",
        "(source_file (expression_statement (block)))": "",
        "(document (object))": "",
        "\n        struct Person {\n            name: String,\n            age: usize,\n        }\n\n        mod module {\n            enum LoginState {\n                LoggedOut,\n                LoggingOn,\n                LoggedIn {\n                    person: Person,\n                    time: Instant,\n                }\n            }\n        }\n\n        impl Eq for Person {}\n\n        impl Drop for Person {\n            fn drop(&mut self) {\n                println!(": "",
        ");\n            }\n        }\n    ": "",
        "struct Person": "",
        "name": "",
        "age": "",
        "mod module": "",
        "enum LoginState": "",
        "LoggedOut": "",
        "LoggingOn": "",
        "LoggedIn": "",
        "person": "",
        "time": "",
        "impl Eq for Person": "",
        "impl Drop for Person": "",
        "fn drop": "",
        "oon": "",
        "dp p": "",
        "dpn": "",
        "impl ": "",
        "\n        impl A for B<\n            C\n        > {\n        };\n    ": "",
        "impl A for B<": "",
        "\n            (function_declaration\n                ": "",
        " @context\n                name: (_) @name\n                parameters: (formal_parameters\n                    ": "",
        " @context.extra\n                    ": "",
        " @context.extra)) @item\n            ": "",
        "\n        function a() {}\n        function b(c) {}\n    ": "",
        "function a()": "",
        "function b( )": "",
        "function a": "",
        "\n        /// This is a doc comment\n        /// that spans multiple lines\n        fn annotated_function() {\n            // This is not an annotation\n        }\n\n        // This is a single-line annotation\n        fn another_function() {}\n\n        fn unannotated_function() {}\n\n        // This comment is not an annotation\n\n        fn function_after_blank_line() {}\n    ": "",
        "fn annotated_function": "",
        "/// This is a doc comment\\n/// that spans multiple lines": "",
        "fn another_function": "",
        "// This is a single-line annotation": "",
        "fn unannotated_function": "",
        "fn function_after_blank_line": "",
        "\n        impl Person {\n            fn one() {\n                1\n            }\n\n            fn two() {\n                2\n            }fn three() {\n                3\n            }\n        }\n    ": "",
        "impl Person": "",
        "fn one": "",
        "fn two": "",
        "\n        // ˇ😅 //\n        fn test() {\n        }\n    ": "",
        "\n            impl Hello {\n                fn say() -> u8 { return /* ˇhi */ 1 }\n            }": "",
        "/* hi */": "",
        "return /* hi */ 1": "",
        "fn say() -> u8 { return /* hi */ 1 }": "",
        "\n            mod x {\n                moˇd y {\n\n                }\n            }\n            let foo = 1;": "",
        "\n            mod x «{»\n                mod y {\n\n                }\n            «}»\n            let foo = 1;": "",
        "\n            mod x {\n                mod y ˇ{\n\n                }\n            }\n            let foo = 1;": "",
        "\n                mod x «{»\n                    mod y {\n\n                    }\n                «}»\n                let foo = 1;": "",
        "\n                mod x {\n                    mod y «{»\n\n                    «}»\n                }\n                let foo = 1;": "",
        "\n            mod x {\n                mod y {\n\n                }ˇ\n            }\n            let foo = 1;": "",
        "\n            mod x {\n                mod y {\n\n                }\n            ˇ}\n            let foo = 1;": "",
        "\n            mod x {\n                mod y {\n\n                }\n            }\n            let fˇoo = 1;": "",
        "\n            mod x {\n                mod y {\n\n                }\n            }\n            let foo = 1;ˇ": "",
        "\n        for (const a in b)ˇ {\n            // a comment that's longer than the for-loop header\n        }": "",
        "\n        for «(»const a in b«)» {\n            // a comment that's longer than the for-loop header\n        }": "",
        "\n        for (const a in b) {ˇ\n            // a comment that's longer than the for-loop header\n        }": "",
        "\n        for (const a in b) «{»\n            // a comment that's longer than the for-loop header\n        «}»": "",
        "fn a() { b(|c| {}) }": "",
        "|c|": "",
        "|c| {}": "",
        "(|c| {})": "",
        "\\n\\n": "",
        "fn a() {\\n    \\n}": "",
        "b()\\n": "",
        "fn a() {\\n    b()\\n    \\n}": "",
        ".c": "",
        "fn a() {\\n    b()\\n        .c\\n}": "",
        "fn a() {\\n    b()\\n    c\\n}": "",
        "fn a() {\\n\\t\\n}": "",
        "fn a() {\\n\\tb()\\n\\t\\n}": "",
        "fn a() {\\n\\tb()\\n\\t\\t.c\\n}": "",
        "fn a() {\\n\\tb()\\n\\tc\\n}": "",
        "\n            fn a() {\n            c;\n            d;\n            }\n            ": "",
        "\n            fn a() {\n            c«()»;\n            d«()»;\n            }\n            ": "",
        "\n            fn a() {\n            c();\n            d();\n            }\n            ": "",
        "\n            fn a() {\n            c«\n            .f\n            .g()»;\n            d«\n            .f\n            .g()»;\n            }\n            ": "",
        "\n            fn a() {\n            c\n                .f\n                .g();\n            d\n                .f\n                .g();\n            }\n            ": "",
        "\n            fn a() {«\n            »\n            c\n                .f\n                .g();\n            d\n                .f\n                .g();\n            }\n            ": "",
        "\n            fn a() {\n                ˇ\n            c\n                .f\n                .g();\n            d\n                .f\n                .g();\n            }\n            ": "",
        "ˇ": "",
        "\n            fn a() {\n            «»\n            c\n                .f\n                .g();\n            d\n                .f\n                .g();\n            }\n            ": "",
        "\n            fn a() {\n\n            c\n                .f\n                .g();\n            d\n                .f\n                .g();\n            }\n            ": "",
        "second buffer: {:?}": "",
        "\n            fn a() {\n                b();\n                |\n            ": "",
        "\n            fn a() {\n                b();\n                «}»\n            ": "",
        "\n            fn a() {\n                b();\n            }\n            ": "",
        "\n            fn a() {\n                b();\n            «    »}\n            ": "",
        "\n            fn a() {\n                b();\n                }\n            ": "",
        "DONE": "",
        "\n            fn a() {\n                i\n            }\n            ": "",
        "\n            fn a() {\n                i«f let Some(x) = y»\n            }\n            ": "",
        "\n            fn a() {\n                if let Some(x) = y\n            }\n            ": "",
        "\n            fn a() {\n                if let Some(x) = y« {»\n            }\n            ": "",
        "\n            fn a() {\n                if let Some(x) = y {\n            }\n            ": "",
        "\n            fn a() {}\n            ": "",
        "\n            fn a(«\n            b») {}\n            ": "",
        "\n            fn a(\n                b) {}\n            ": "",
        "\n            fn a(\n                ˇ) {}\n            ": "",
        "\n                fn a(\n                ) {}\n            ": "",
        "a\\nb": "",
        "\\n\\n\\n": "",
        "\n            const a: usize = 1;\n            fn b() {\n                if c {\n                    let d = 2;\n                }\n            }\n        ": "",
        "e(\\n    f()\\n);\\n": "",
        "\n                const a: usize = 1;\n                fn b() {\n                    if c {\n                        e(\n                            f()\n                        );\n                        let d = 2;\n                    }\n                }\n            ": "",
        "\n            fn a() {\n                b();\n            }\n        ": "",
        "\n            ": "",
        "\n        ": "",
        "\n            fn a() {\n                b();\n                ": "",
        "\n            }\n            ": "",
        "        ": "",
        "original_indent_columns": "",
        "\n\n                c();\n                    d();\n                        e();\n        ": "",
        "\n            fn a() {\n                b();\n\n                c();\n                    d();\n                        e();\n            }\n            ": "",
        "\n            fn a() {\n                if b() {\n\n                }\n            }\n        ": "",
        "    c\\n        .d()\\n        .e();": "",
        "\n            fn a() {\n                if b() {\n                    c\n                        .d()\n                        .e();\n                }\n            }\n            ": "",
        " ": "",
        "\n            mod numbers {\n                «fn one() {\n                    1\n                }\n            »\n                «fn two() {\n                    2\n                }\n            »\n                «fn three() {\n                    3\n                }\n            »}\n            ": "",
        "fn one() {\\n    101\\n}\\n": "",
        "fn two() {\\n    102\\n}\\n": "",
        "fn three() {\\n    103\\n}\\n": "",
        "\n            mod numbers {\n                fn one() {\n                    101\n                }\n\n                fn two() {\n                    102\n                }\n\n                fn three() {\n                    103\n                }\n            }\n            ": "",
        "\n            * one\n                - a\n                - b\n            * two\n        ": "",
        "\n            * one\n                - a\n                - b\n\n            * two\n            ": "",
        "HTML": "",
        "\n                <div>ˇ\n                </div>\n                <script>\n                    init({ˇ\n                    })\n                </script>\n                <span>ˇ\n                </span>\n            ": "",
        "\\na": "",
        "\n                <div>\n                  a\n                </div>\n                <script>\n                    init({\n                            a\n                    })\n                </script>\n                <span>\n                  a\n                </span>\n            ": "",
        "\n            class C\n            def a(b, c)\n            puts b\n            puts c\n            rescue\n            puts ": "",
        "\n            exit 1\n            end\n            end\n        ": "",
        "\n                class C\n                  def a(b, c)\n                    puts b\n                    puts c\n                  rescue\n                    puts ": "",
        "\n                    exit 1\n                  end\n                end\n            ": "",
        "fn a() {\\n\\n}": "",
        "fn a() {\\n    \\n\\n}": "",
        "x": "",
        "fn a() {\\n    x\\n    \\n}": "",
        "abc\\ndef\\nghi": "",
        "\\nabc\\ndef\\nghi": "",
        "\\n\\nabc\\ndef\\nghi": "",
        "abc\\ndef\\n\\n\\n\\nghi": "",
        "abc\\ndefghi\\njkl": "",
        "abc\\ndef\\n\\n\\n\\nghi\\njkl": "",
        "abc\\ndef\\n\\n\\nghi\\njkl": "",
        "abc\\ndef\\nghi\\n\\n\\n": "",
        "abc\\ndef\\nghi\\n\\n": "",
        "// ": "",
        "* ": "",
        "string": "",
        "comment": "",
        "element": "",
        "\n                (jsx_element) @element\n                (string) @string\n                (comment) @comment.inclusive\n                [\n                    (jsx_opening_element)\n                    (jsx_closing_element)\n                    (jsx_expression)\n                ] @default\n            ": "",
        "\n            a[": "",
        "] = <C d=": "",
        ">\n                <F></F>\n                { g() }\n            </C>; // a comment\n        ": "",
        "b\\\"": "",
        "<F>": "",
        " d=": "",
        "\n                (string_literal) @string\n            ": "",
        "\n            const S: &'static str = ": "",
        ";\n        ": "",
        "ello": "",
        "\n            <ol>\n            <% people.each do |person| %>\n                <li>\n                    <%= person.name %>\n                </li>\n            <% end %>\n            </ol>\n        ": "",
        "HTML+ERB": "",
        "# ": "",
        "\n            this is an *emphasized* word.\n        ": "",
        "\n            ```rs\n            let a = 2;\n            // let b = 3;\n            ```\n        ": "",
        "\n            ```html+erb\n            <div>Hello</div>\n            <%= link_to ": "",
        ", ": "",
        " %>\n            ```\n        ": "",
        "Ruby": "",
        "abc": "",
        "D": "",
        "E": "",
        "abcDE": "",
        "abcD": "",
        "F": "",
        "abcDF": "",
        "1.5\\n": "",
        "THREE": "",
        "one\\n1.5\\ntwo\\nTHREE\\n": "",
        "ZERO\\n": "",
        "ZERO\\none\\ntwo\\nthree\\n": "",
        "ZERO\\none\\n1.5\\ntwo\\nTHREE\\n": "",
        "2.5\\n": "",
        "ZERO\\none\\ntwo\\n2.5\\nthree\\n": "",
        "ZERO\\none\\n1.5\\ntwo\\n2.5\\nTHREE\\n": "",
        "abcdefghijk": "",
        "ABC": "",
        "HI": "",
        "LMN": "",
        "ABCdefgHIjkLMN": "",
        "abcdefgHIjk": "",
        "hi": "",
        "ABCdefghijkLMN": "",
        "abcdefghijkLMN": "",
        "ABCdefgHIjk": "",
        "\n        fn test_empty() -> bool {\n            false\n        }": "",
        "\n        fn calculate_area(: f64) -> f64 {\n            std::f64::consts::PI * .powi(2)\n        }": "",
        "radius": "",
        "\n                fn calculate_area(radius: f64) -> f64 {\n                    std::f64::consts::PI * radius.powi(2)": "",
        "\n        struct Person {\n            first_name: String,\n        }\n\n        impl Person {\n            fn first_name(&self) -> &String {\n                &self.first_name\n            }\n        }": "",
        "last": "",
        "\n                        firstlast_name: String,\n                    }\n\n                    impl Person {\n                        fn firstlast_name(&self) -> &String {\n                            &self.firstlast_name": "",
        "MIN_PEERS": "",
        "invalid `MIN_PEERS` variable": "",
        "MAX_PEERS": "",
        "invalid `MAX_PEERS` variable": "",
        "OPERATIONS": "",
        "invalid `OPERATIONS` variable": "",
        "Adding initial peer with replica id {:?}": "",
        "initial text: {:?}": "",
        "buffer {:?} text: {:?}": "",
        "peer {:?} clearing active selections": "",
        "peer {:?} setting active selections: {:?}": "",
        "peer {:?} setting diagnostics: {:?}": "",
        "Adding new replica {:?} (replicating from {:?})": "",
        "New replica {:?} text: {:?}": "",
        "peer {:?} (version: {:?}) applying {} ops from the network. {:?}": "",
        "Replica {:?} version != Replica 0 version": "",
        "Replica {:?} text != Replica 0 text": "",
        "Replica {:?} diagnostics != Replica 0 diagnostics": "",
        "Replica {:?} remote selections != expected selections": "",
        "wrong ranges for text lines:\\n{:?}": "",
        "\n0_isize 123 3.4 4  \nlet word=öäpple.bar你 Öäpple word2-öÄpPlE-Pizza-word ÖÄPPLE word\n    ": "",
        "Pizza": "",
        "piz": "",
        "öäpple": "",
        "Öäpple": "",
        "öÄpPlE": "",
        "ÖÄPPLE": "",
        "öp": "",
        "öÄ": "",
        "öÄ好": "",
        "bar你": "",
        "你": "",
        "let": "",
        "word": "",
        "word2": "",
        "0_isize": "",
        "rb": "",
        "\n            (class ": "",
        " @end) @indent\n            (method ": "",
        " @end) @indent\n            (rescue) @outdent\n            (then) @indent\n        ": "",
        "\n        (element\n          (start_tag) @start\n          (end_tag)? @end) @indent\n        ": "",
        "\n        (script_element\n            (raw_text) @injection.content\n            (#set! injection.language ": "",
        "))\n        ": "",
        "erb": "",
        "\n            (\n                (code) @content\n                (#set! ": "",
        ")\n                (#set! ": "",
        ")\n            )\n\n            (\n                (content) @content\n                (#set! ": "",
        ")\n            )\n        ": "",
        "\n        (call_expression) @indent\n        (field_expression) @indent\n        (_ ": "",
        " @end) @indent\n        (_ ": "",
        " @end) @indent\n        ": "",
        "\n        (": "",
        " @open ": "",
        " @close)\n        ": "",
        "\n        (function_item\n            body: (_\n                ": "",
        "\n                (_)* @function.inside\n                ": "",
        " )) @function.around\n\n        (line_comment)+ @comment.around\n\n        (block_comment) @comment.around\n        ": "",
        "\n        (line_comment) @annotation\n\n        (struct_item\n            ": "",
        " @context\n            name: (_) @name) @item\n        (enum_item\n            ": "",
        " @context\n            name: (_) @name) @item\n        (enum_variant\n            name: (_) @name) @item\n        (field_declaration\n            name: (_) @name) @item\n        (impl_item\n            ": "",
        " @context\n            trait: (_)? @name\n            ": "",
        "? @context\n            type: (_) @name\n            body: (_ ": "",
        " (_)* ": "",
        ")) @item\n        (function_item\n            ": "",
        " @context\n            name: (_) @name) @item\n        (mod_item\n            ": "",
        " @context\n            name: (_) @name) @item\n        ": "",
        "Json": "",
        " @close)\n        (": "",
        "\n        (object ": "",
        "md": "",
        "\n            (fenced_code_block\n                (info_string\n                    (language) @injection.language)\n                (code_fence_content) @injection.content)\n\n                ((inline) @injection.content\n                (#set! injection.language ": "",
        "Markdown-Inline": "",
        "(emphasis) @emphasis": "",
        "Empty chunk should have empty chars bitmap": "",
        "Empty chunk should have empty tabs bitmap": "",
        "Chunk text length {} exceeds 128 bytes": "",
        "Chunk text bytes: {:?}": "",
        "Char indices: {:?}": "",
        "Chars bitmap: {:#b}": "",
        "Chars bitmap mismatch at byte index {} in chunk {:?}. Expected bit: {}, Got bit: {}": "",
        "Tabs bitmap: {:#b}": "",
        "Tabs bitmap mismatch at byte index {} in chunk {:?}. Byte: {:?}, Expected bit: {}, Got bit: {}": ""
    },
    "zed/crates/language_selector/src/active_buffer_language.rs": {
        "Unknown": "",
        "change-language": "",
        "Select Language": ""
    },
    "zed/crates/language_selector/src/language_selector.rs": {
        "LanguageSelector": "",
        " (current)": "",
        "Select a language…": "",
        "project was dropped": "",
        "buffer was dropped": ""
    },
    "zed/crates/language_models/src/provider/anthropic.rs": {
        "ANTHROPIC_API_KEY": "",
        "user": "",
        "assistant": "",
        "system": "",
        "gpt-4": "",
        "App state dropped": "",
        "anthropic/{}": "",
        "base64": "",
        "image/png": "",
        "System role should never occur here": "",
        "\\n\\n": "",
        "end_turn": "",
        "max_tokens": "",
        "tool_use": "",
        "refusal": "",
        "Unexpected anthropic stop_reason: {stop_reason}": "",
        "sk-ant-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx": "",
        "not signed in": "",
        "API key set in {API_KEY_ENV_VAR_NAME} environment variable": "",
        "API key configured": "",
        "API key configured for {}": "",
        "Loading credentials...": "",
        "To use {}, you need to add an API key. Follow these steps:": "",
        "Zed's agent with Anthropic": "",
        "Create one by visiting": "",
        "Anthropic's settings": "",
        "Paste your API key below and hit enter to start using the agent": "",
        "You can also assign the {API_KEY_ENV_VAR_NAME} environment variable and restart Zed.": "",
        "To reset your API key, unset the {API_KEY_ENV_VAR_NAME} environment variable.": "",
        "Some prompt": "",
        "claude-3-5-sonnet": ""
    },
    "zed/crates/language_models/src/provider/bedrock.rs": {
        "amazon-bedrock": "",
        "Amazon Bedrock": "",
        "named_profile": "",
        "sso": "",
        "default": "",
        "type": "",
        "lowercase": "",
        "ZED_ACCESS_KEY_ID": "",
        "ZED_SECRET_ACCESS_KEY": "",
        "ZED_SESSION_TOKEN": "",
        "ZED_AWS_PROFILE": "",
        "ZED_AWS_REGION": "",
        "ZED_AWS_CREDENTIALS": "",
        "ZED_AWS_ENDPOINT": "",
        "Bearer": "",
        "invalid {PROVIDER_NAME} credentials": "",
        "failed to parse credentials": "",
        "us-east-1": "",
        "zed-bedrock-provider": "",
        "initializing Bedrock client": "",
        "Bedrock client not initialized": "",
        "App state dropped": "",
        "bedrock/{}": "",
        "App State Dropped": "",
        "\\n\\n[Error: Tool calls are disabled in this context. Attempted to call '{}']": "",
        "failed to build reasoning block": "",
        "failed to build Bedrock tool use block": "",
        "[Tool responded with an image, but Zed doesn't support these in Bedrock models yet]": "",
        "failed to build Bedrock tool result block": "",
        "failed to build cache point block": "",
        "System role should never occur here": "",
        "failed to build Bedrock message": "",
        "\\n\\n": "",
        "user": "",
        "assistant": "",
        "system": "",
        "gpt-4": "",
        "REDACTED": "",
        "XXXXXXXXXXXXXXXX": "",
        "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX": "",
        "not signed in": "",
        "Access Key ID": "",
        "Secret Access Key": "",
        "Session Token (Optional)": "",
        "Region": "",
        "Loading credentials...": "",
        "Access Key ID is set in {ZED_BEDROCK_ACCESS_KEY_ID_VAR}, Secret Key is set in {ZED_BEDROCK_SECRET_ACCESS_KEY_VAR}, Region is set in {ZED_BEDROCK_REGION_VAR} environment variables.": "",
        "You are using automatic credentials.": "",
        "You are using named profile.": "",
        "You are using a single sign on profile.": "",
        "You are using static credentials.": "",
        "To reset your credentials, unset the {ZED_BEDROCK_ACCESS_KEY_ID_VAR}, {ZED_BEDROCK_SECRET_ACCESS_KEY_VAR}, and {ZED_BEDROCK_REGION_VAR} environment variables.": "",
        "You cannot reset credentials as they're being derived, check Zed settings to understand how.": "",
        "To use Zed's agent with Bedrock, you can set a custom authentication strategy through the settings.json, or use static credentials.": "",
        "But, to access models on AWS, you need to:": "",
        "Grant permissions to the strategy you'll use according to the:": "",
        "Prerequisites": "",
        "Select the models you would like access to:": "",
        "Bedrock Model Catalog": "",
        "You can also assign the {ZED_BEDROCK_ACCESS_KEY_ID_VAR}, {ZED_BEDROCK_SECRET_ACCESS_KEY_VAR} AND {ZED_BEDROCK_REGION_VAR} environment variables and restart Zed.": "",
        "Optionally, if your environment uses AWS CLI profiles, you can set {ZED_AWS_PROFILE_VAR}; if it requires a custom endpoint, you can set {ZED_AWS_ENDPOINT_VAR}; and if it requires a Session Token, you can set {ZED_BEDROCK_SESSION_TOKEN_VAR}.": "",
        "Static Keys": "",
        "This method uses your AWS access key ID and secret access key directly.": "",
        "Create an IAM user in the AWS console with programmatic access": "",
        "IAM Console": "",
        "Attach the necessary Bedrock permissions to this ": "",
        "Copy the access key ID and secret access key when provided": "",
        "Enter these credentials below": ""
    },
    "zed/crates/language_models/src/provider/cloud.rs": {
        "type": "",
        "lowercase": "",
        "failed to fetch Zed models": "",
        "{}-thinking": "",
        "{} Thinking": "",
        "true": "",
        "/models": "",
        "Authorization": "",
        "Bearer {token}": "",
        "failed to send list models request": "",
        "error listing models.\\nStatus: {:?}\\nBody: {body}": "",
        "/completions": "",
        "Content-Type": "",
        "application/json": "",
        "cloud language model request failed with status {status}: {body}": "",
        "code": "",
        "upstream_http_error": "",
        "message": "",
        "Received an error from the Anthropic API: upstream connect error or disconnect/reset before headers, reset reason: connection timeout": "",
        "upstream_status": "",
        "deserialize_optional_status_code": "",
        "upstream_http_": "",
        "_error": "",
        "upstream_http_429": "",
        "zed.dev/{}": "",
        "/count_tokens": "",
        "-thinking": "",
        "You have access to Zed's hosted models through your Pro subscription.": "",
        "You have access to Zed's hosted models through your Pro trial.": "",
        "You have basic access to Zed's hosted models through the Free plan.": "",
        "Subscribe for access to Zed's hosted models. Start with a 14 day free trial.": "",
        "Subscribe for access to Zed's hosted models.": "",
        "manage_settings": "",
        "Manage Subscription": "",
        "start_trial": "",
        "Start 14-day Free Pro Trial": "",
        "upgrade": "",
        "Upgrade to Pro": "",
        "Sign in to have access to Zed's complete agentic experience with hosted models.": "",
        "sign_in": "",
        "Sign In to use Zed AI": "",
        "AI Configuration Content": "",
        "Not connected": "",
        "Accept Terms of Service": "",
        "No Plan - Not eligible for trial": "",
        "No Plan - Eligible for trial": "",
        "Free Plan": "",
        "Zed Pro Trial Plan": "",
        "Zed Pro Plan": "",
        ":503}": "",
        "Expected UpstreamProviderError for upstream 503, got: {:?}": "",
        ":500}": "",
        "Received an error from the OpenAI API: internal server error": "",
        "Expected UpstreamProviderError for upstream 500, got: {:?}": "",
        ":429}": "",
        "Received an error from the Google API: rate limit exceeded": "",
        "Expected UpstreamProviderError for upstream 429, got: {:?}": "",
        "Regular internal server error": "",
        "Expected ApiInternalServerError for regular 500, got: {:?}": "",
        ":30.5}": "",
        "Upstream Anthropic rate limit exceeded.": "",
        "Expected UpstreamProviderError for upstream_http_429, got: {:?}": "",
        "Not JSON at all": "",
        "Expected ApiInternalServerError for invalid JSON, got: {:?}": ""
    },
    "zed/crates/language_models/src/provider/copilot_chat.rs": {
        "copilot_chat": "",
        "GitHub Copilot Chat": "",
        "Copilot must be enabled for Copilot Chat to work. Please enable Copilot and try again.": "",
        "Received the following error while signing into Copilot: {err}": "",
        "Copilot is still starting, please wait for Copilot to start then try again": "",
        "Unable to authorize with Copilot. Please make sure that you have an active Copilot and Copilot Chat subscription.": "",
        "You have signed out of Copilot. Please sign in to Copilot and try again.": "",
        "Still signing into Copilot...": "",
        "Signing out of GitHub Copilot Chat is currently not supported.": "",
        "user": "",
        "assistant": "",
        "system": "",
        "copilot_chat/{}": "",
        "o200k_base": "",
        "gpt-4o": "",
        "cl100k_base": "",
        "gpt-4": "",
        "Response contained no choices": "",
        "Response contained no delta": "",
        "stop": "",
        "tool_calls": "",
        "Unexpected Copilot Chat stop_reason: {stop_reason:?}": "",
        "response.failed": "",
        "{error:?}": "",
        "This should be caught at {} level": "",
        "[Tool responded with an image, but this model does not support vision]": "",
        "[image omitted]": "",
        "completed": "",
        "msg_1": "",
        "Hello": "",
        "fn_1": "",
        "call_1": "",
        "do_it": "",
        "{\\\"x\\\":1}": "",
        "{not json}": "",
        "r1": "",
        "summary_text": "",
        "Chain": "",
        "ENC": "",
        "should emit exactly one Stop event": "",
        "Stop reason should be ToolUse": "",
        "too many requests": "",
        "expected HttpResponseError, got {:?}": "",
        "Authorized": "",
        "Sign Out": "",
        "Copilot Chat requires an active GitHub Copilot subscription. Please ensure Copilot is configured and try again, or use a different Assistant provider.": "",
        "Starting Copilot…": "",
        "Signing into Copilot…": "",
        "Copilot had issues starting. Please try restarting it. If the issue persists, try reinstalling Copilot.": "",
        "To use Zed's agent with GitHub Copilot, you need to be logged in to GitHub. Note that your GitHub account must have an active Copilot Chat subscription.": "",
        "sign_in": "",
        "Sign in to use GitHub Copilot": ""
    },
    "zed/crates/language_models/src/provider/deepseek.rs": {
        "deepseek": "",
        "DeepSeek": "",
        "DEEPSEEK_API_KEY": "",
        "deepseek-chat": "",
        "deepseek-reasoner": "",
        "App state dropped": "",
        "deepseek/{}": "",
        "user": "",
        "assistant": "",
        "system": "",
        "gpt-4": "",
        "Response contained no choices": "",
        "stop": "",
        "tool_calls": "",
        "Unexpected DeepSeek stop_reason: {stop_reason:?}": "",
        "sk-00000000000000000000000000000000": "",
        "API key set in {API_KEY_ENV_VAR_NAME} environment variable": "",
        "API key configured": "",
        "API key configured for {}": "",
        "Loading credentials...": "",
        "To use DeepSeek in Zed, you need an API key:": "",
        "Get your API key from the": "",
        "DeepSeek console": "",
        "Paste your API key below and hit enter to start using the assistant": "",
        "Or set the {API_KEY_ENV_VAR_NAME} environment variable.": ""
    },
    "zed/crates/language_models/src/provider/google.rs": {
        "type": "",
        "lowercase": "",
        "GEMINI_API_KEY": "",
        "GOOGLE_AI_API_KEY": "",
        "App state dropped": "",
        "Missing Google API key": "",
        "failed to stream completion": "",
        "google/{}": "",
        "image/png": "",
        "output": "",
        "Tool responded with an image": "",
        "SAFETY": "",
        "OTHER": "",
        "BLOCKLIST": "",
        "PROHIBITED_CONTENT": "",
        "IMAGE_SAFETY": "",
        "Unexpected Google block_reason: {block_reason}": "",
        "STOP": "",
        "MAX_TOKENS": "",
        "Unexpected google finish_reason: {finish_reason}": "",
        "(Encrypted thought)": "",
        "user": "",
        "assistant": "",
        "system": "",
        "gpt-4": "",
        "not signed in": "",
        "AIzaSy...": "",
        "API key set in {} environment variable": "",
        "API key configured": "",
        "API key configured for {}": "",
        "Loading credentials...": "",
        "To use {}, you need to add an API key. Follow these steps:": "",
        "Zed's agent with Google AI": "",
        "Create one by visiting": "",
        "Google AI's console": "",
        "Paste your API key below and hit enter to start using the assistant": "",
        "You can also assign the {GEMINI_API_KEY_VAR_NAME} environment variable and restart Zed.": "",
        "To reset your API key, make sure {GEMINI_API_KEY_VAR_NAME} and {GOOGLE_AI_API_KEY_VAR_NAME} environment variables are unset.": ""
    },
    "zed/crates/language_models/src/provider/lmstudio.rs": {
        "lmstudio": "",
        "LM Studio": "",
        "authenticated": "",
        "credentials not found": "",
        "App state dropped": "",
        "lmstudio/{}": "",
        "Response contained no choices": "",
        "stop": "",
        "tool_calls": "",
        "Unexpected LMStudio stop_reason: {stop_reason:?}": "",
        "Run local LLMs like Llama, Phi, and Qwen.": "",
        "Loading models...": "",
        "LM Studio needs to be running with at least one model downloaded.": "",
        "To get your first model, try running `lms get qwen2.5-coder-7b`": "",
        "lmstudio-site": "",
        "download_lmstudio_button": "",
        "Download LM Studio": "",
        "view-models": "",
        "Model Catalog": "",
        "connected": "",
        "Connected": "",
        "retry_lmstudio_models": "",
        "Connect": ""
    },
    "zed/crates/language_models/src/provider/mistral.rs": {
        "mistral": "",
        "Mistral": "",
        "MISTRAL_API_KEY": "",
        "CODESTRAL_API_KEY": "",
        "App state dropped": "",
        "mistral/{}": "",
        "user": "",
        "assistant": "",
        "system": "",
        "gpt-4": "",
        "[Tool responded with an image, but Zed doesn't support these in Mistral models yet]": "",
        "Response contained no choices": "",
        "stop": "",
        "tool_calls": "",
        "Unexpected Mistral stop_reason: {unexpected:?}": "",
        "Received incomplete tool call: missing id or name": "",
        "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx": "",
        "not signed in": "",
        "API key set in {CODESTRAL_API_KEY_ENV_VAR_NAME} environment variable": "",
        "Codestral API key configured": "",
        "codestral": "",
        ",\n                ))\n                .child(\n                    List::new()\n                        .child(InstructionListItem::new(\n                            ": "",
        ",\n                            Some(": "",
        "),\n                            Some(": "",
        "),\n                        ))\n                        .child(InstructionListItem::text_only(": "",
        ")),\n                )\n                .child(self.codestral_api_key_editor.clone())\n                .child(\n                    Label::new(\n                        format!(": "",
        "),\n                    )\n                    .size(LabelSize::Small).color(Color::Muted),\n                ).into_any()\n        } else {\n            ConfiguredApiCard::new(configured_card_label)\n                .disabled(env_var_set)\n                .on_click(cx.listener(|this, _, window, cx| this.reset_api_key(window, cx)))\n                .when(env_var_set, |this| {\n                    this.tooltip_label(format!(\n                        ": "",
        "\n                    ))\n                })\n                .on_click(\n                    cx.listener(|this, _, window, cx| this.reset_codestral_api_key(window, cx)),\n                )\n                .into_any_element()\n        }\n    }\n}\n\nimpl Render for ConfigurationView {\n    fn render(&mut self, _window: &mut Window, cx: &mut Context<Self>) -> impl IntoElement {\n        let env_var_set = self.state.read(cx).api_key_state.is_from_env_var();\n        let configured_card_label = if env_var_set {\n            format!(": "",
        ")\n        } else {\n            let api_url = MistralLanguageModelProvider::api_url(cx);\n            if api_url == MISTRAL_API_URL {\n                ": "",
        ".to_string()\n            } else {\n                format!(": "",
        ", api_url)\n            }\n        };\n\n        if self.load_credentials_task.is_some() {\n            div().child(Label::new(": "",
        ")).into_any()\n        } else if self.should_render_api_key_editor(cx) {\n            v_flex()\n                .size_full()\n                .on_action(cx.listener(Self::save_api_key))\n                .child(Label::new(": "",
        "))\n                .child(\n                    List::new()\n                        .child(InstructionListItem::new(\n                            ": "",
        "),\n                        ))\n                        .child(InstructionListItem::text_only(\n                            ": "",
        ",\n                        ))\n                        .child(InstructionListItem::text_only(\n                            ": "",
        ",\n                        )),\n                )\n                .child(self.api_key_editor.clone())\n                .child(\n                    Label::new(\n                        format!(": "",
        "),\n                    )\n                    .size(LabelSize::Small).color(Color::Muted),\n                )\n                .child(self.render_codestral_api_key_editor(cx))\n                .into_any()\n        } else {\n            v_flex()\n                .size_full()\n                .gap_1()\n                .child(\n                    ConfiguredApiCard::new(configured_card_label)\n                        .disabled(env_var_set)\n                        .on_click(cx.listener(|this, _, window, cx| this.reset_api_key(window, cx)))\n                        .when(env_var_set, |this| {\n                            this.tooltip_label(format!(\n                                ": "",
        "\n                            ))\n                        }),\n                )\n                .child(self.render_codestral_api_key_editor(cx))\n                .into_any()\n        }\n    }\n}\n\nfn set_edit_prediction_provider(provider: EditPredictionProvider, cx: &mut App) {\n    let fs = <dyn Fs>::global(cx);\n    update_settings_file(fs, cx, move |settings, _| {\n        settings\n            .project\n            .all_languages\n            .features\n            .get_or_insert_default()\n            .edit_prediction_provider = Some(provider);\n    });\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use language_model::{LanguageModelImage, LanguageModelRequestMessage, MessageContent};\n\n    #[test]\n    fn test_into_mistral_basic_conversion() {\n        let request = LanguageModelRequest {\n            messages: vec![\n                LanguageModelRequestMessage {\n                    role: Role::System,\n                    content: vec![MessageContent::Text(": "",
        ".into())],\n                    cache: false,\n                },\n                LanguageModelRequestMessage {\n                    role: Role::User,\n                    content: vec![MessageContent::Text(": "",
        ".into())],\n                    cache: false,\n                },\n            ],\n            temperature: Some(0.5),\n            tools: vec![],\n            tool_choice: None,\n            thread_id: None,\n            prompt_id: None,\n            intent: None,\n            mode: None,\n            stop: vec![],\n            thinking_allowed: true,\n        };\n\n        let mistral_request = into_mistral(request, mistral::Model::MistralSmallLatest, None);\n\n        assert_eq!(mistral_request.model, ": "",
        ");\n        assert_eq!(mistral_request.temperature, Some(0.5));\n        assert_eq!(mistral_request.messages.len(), 2);\n        assert!(mistral_request.stream);\n    }\n\n    #[test]\n    fn test_into_mistral_with_image() {\n        let request = LanguageModelRequest {\n            messages: vec![LanguageModelRequestMessage {\n                role: Role::User,\n                content: vec![\n                    MessageContent::Text(": "",
        ".into()),\n                    MessageContent::Image(LanguageModelImage {\n                        source: ": "",
        ".into(),\n                        size: Default::default(),\n                    }),\n                ],\n                cache: false,\n            }],\n            tools: vec![],\n            tool_choice: None,\n            temperature: None,\n            thread_id: None,\n            prompt_id: None,\n            intent: None,\n            mode: None,\n            stop: vec![],\n            thinking_allowed: true,\n        };\n\n        let mistral_request = into_mistral(request, mistral::Model::Pixtral12BLatest, None);\n\n        assert_eq!(mistral_request.messages.len(), 1);\n        assert!(matches!(\n            &mistral_request.messages[0],\n            mistral::RequestMessage::User {\n                content: mistral::MessageContent::Multipart { .. }\n            }\n        ));\n\n        if let mistral::RequestMessage::User {\n            content: mistral::MessageContent::Multipart { content },\n        } = &mistral_request.messages[0]\n        {\n            assert_eq!(content.len(), 2);\n            assert!(matches!(\n                &content[0],\n                mistral::MessagePart::Text { text } if text == ": "",
        "\n            ));\n            assert!(matches!(\n                &content[1],\n                mistral::MessagePart::ImageUrl { image_url } if image_url.starts_with(": ""
    },
    "zed/crates/language_models/src/provider/ollama.rs": {
        "ollama": "",
        "Ollama": "",
        "OLLAMA_API_KEY": "",
        "authenticated": "",
        "-embed": "",
        "Only tool result should be extracted": "",
        "ollama/{}": "",
        "App state dropped": "",
        "63e02e...": "",
        "API key": "",
        "API URL": "",
        ",\n            ))\n            .child(Label::new(": "",
        "))\n            .child(\n                List::new()\n                    .child(InstructionListItem::new(\n                        ": "",
        ",\n                        Some(": "",
        "),\n                        Some(": "",
        "),\n                    ))\n                    .child(InstructionListItem::text_only(\n                        ": "",
        ",\n                    ))\n                    .child(InstructionListItem::text_only(\n                        ": "",
        ",\n                    )),\n            )\n            .child(Label::new(\n                ": "",
        ",\n            ))\n    }\n\n    fn render_api_key_editor(&self, cx: &Context<Self>) -> impl IntoElement {\n        let state = self.state.read(cx);\n        let env_var_set = state.api_key_state.is_from_env_var();\n        let configured_card_label = if env_var_set {\n            format!(": "",
        ")\n        } else {\n            ": "",
        ".to_string()\n        };\n\n        if !state.api_key_state.has_key() {\n            v_flex()\n              .on_action(cx.listener(Self::save_api_key))\n              .child(self.api_key_editor.clone())\n              .child(\n                  Label::new(\n                      format!(": "",
        ")\n                  )\n                  .size(LabelSize::Small)\n                  .color(Color::Muted),\n              )\n              .into_any_element()\n        } else {\n            ConfiguredApiCard::new(configured_card_label)\n                .disabled(env_var_set)\n                .on_click(cx.listener(|this, _, window, cx| this.reset_api_key(window, cx)))\n                .when(env_var_set, |this| {\n                    this.tooltip_label(format!(": "",
        "))\n                })\n                .into_any_element()\n        }\n    }\n\n    fn render_api_url_editor(&self, cx: &Context<Self>) -> Div {\n        let api_url = OllamaLanguageModelProvider::api_url(cx);\n        let custom_api_url_set = api_url != OLLAMA_API_URL;\n\n        if custom_api_url_set {\n            h_flex()\n                .p_3()\n                .justify_between()\n                .rounded_md()\n                .border_1()\n                .border_color(cx.theme().colors().border)\n                .bg(cx.theme().colors().elevated_surface_background)\n                .child(\n                    h_flex()\n                        .gap_2()\n                        .child(Icon::new(IconName::Check).color(Color::Success))\n                        .child(v_flex().gap_1().child(Label::new(api_url))),\n                )\n                .child(\n                    Button::new(": "",
        ", ": "",
        ")\n                        .label_size(LabelSize::Small)\n                        .icon(IconName::Undo)\n                        .icon_size(IconSize::Small)\n                        .icon_position(IconPosition::Start)\n                        .layer(ElevationIndex::ModalSurface)\n                        .on_click(\n                            cx.listener(|this, _, window, cx| this.reset_api_url(window, cx)),\n                        ),\n                )\n        } else {\n            v_flex()\n                .on_action(cx.listener(|this, _: &menu::Confirm, _window, cx| {\n                    this.save_api_url(cx);\n                    cx.notify();\n                }))\n                .gap_2()\n                .child(self.api_url_editor.clone())\n        }\n    }\n}\n\nimpl Render for ConfigurationView {\n    fn render(&mut self, _: &mut Window, cx: &mut Context<Self>) -> impl IntoElement {\n        let is_authenticated = self.state.read(cx).is_authenticated();\n\n        v_flex()\n            .gap_2()\n            .child(Self::render_instructions())\n            .child(self.render_api_url_editor(cx))\n            .child(self.render_api_key_editor(cx))\n            .child(\n                h_flex()\n                    .w_full()\n                    .justify_between()\n                    .gap_2()\n                    .child(\n                        h_flex()\n                            .w_full()\n                            .gap_2()\n                            .map(|this| {\n                                if is_authenticated {\n                                    this.child(\n                                        Button::new(": "",
        ")\n                                            .style(ButtonStyle::Subtle)\n                                            .icon(IconName::ArrowUpRight)\n                                            .icon_size(IconSize::XSmall)\n                                            .icon_color(Color::Muted)\n                                            .on_click(move |_, _, cx| cx.open_url(OLLAMA_SITE))\n                                            .into_any_element(),\n                                    )\n                                } else {\n                                    this.child(\n                                        Button::new(": "",
        ")\n                                            .style(ButtonStyle::Subtle)\n                                            .icon(IconName::ArrowUpRight)\n                                            .icon_size(IconSize::XSmall)\n                                            .icon_color(Color::Muted)\n                                            .on_click(move |_, _, cx| {\n                                                cx.open_url(OLLAMA_DOWNLOAD_URL)\n                                            })\n                                            .into_any_element(),\n                                    )\n                                }\n                            })\n                            .child(\n                                Button::new(": "",
        ")\n                                    .style(ButtonStyle::Subtle)\n                                    .icon(IconName::ArrowUpRight)\n                                    .icon_size(IconSize::XSmall)\n                                    .icon_color(Color::Muted)\n                                    .on_click(move |_, _, cx| cx.open_url(OLLAMA_LIBRARY_URL)),\n                            ),\n                    )\n                    .map(|this| {\n                        if is_authenticated {\n                            this.child(\n                                ButtonLike::new(": "",
        ")\n                                    .disabled(true)\n                                    .cursor_style(CursorStyle::Arrow)\n                                    .child(\n                                        h_flex()\n                                            .gap_2()\n                                            .child(Icon::new(IconName::Check).color(Color::Success))\n                                            .child(Label::new(": "",
        "))\n                                            .into_any_element(),\n                                    )\n                                    .child(\n                                        IconButton::new(": "",
        ", IconName::RotateCcw)\n                                            .tooltip(Tooltip::text(": "",
        "))\n                                            .on_click(cx.listener(|this, _, _, cx| {\n                                                this.state.update(cx, |state, _| {\n                                                    state.fetched_models.clear();\n                                                });\n                                                this.retry_connection(cx);\n                                            })),\n                                    ),\n                            )\n                        } else {\n                            this.child(\n                                Button::new(": ""
    },
    "zed/crates/language_models/src/provider/open_ai.rs": {
        "OPENAI_API_KEY": "",
        "App state dropped": "",
        "openai/{}": "",
        "o1-": "",
        "stop": "",
        "tool_calls": "",
        "Unexpected OpenAI stop_reason: {stop_reason:?}": "",
        "user": "",
        "assistant": "",
        "system": "",
        "gpt-4o": "",
        "gpt-4": "",
        "sk-000000000000000000000000000000000000000000000000": "",
        "not signed in": "",
        "API key set in {API_KEY_ENV_VAR_NAME} environment variable": "",
        "API key configured": "",
        "API key configured for {}": "",
        "To use Zed's agent with OpenAI, you need to add an API key. Follow these steps:": "",
        "Create one by visiting": "",
        "OpenAI's console": "",
        "Ensure your OpenAI account has credits": "",
        "Paste your API key below and hit enter to start using the assistant": "",
        "You can also assign the {API_KEY_ENV_VAR_NAME} environment variable and restart Zed.": "",
        "Note that having a subscription for another service like GitHub Copilot won't work.": "",
        "To reset your API key, unset the {API_KEY_ENV_VAR_NAME} environment variable.": "",
        "Zed also supports OpenAI-compatible models.": "",
        "docs": "",
        "Learn More": "",
        "Loading credentials…": "",
        "message": ""
    },
    "zed/crates/markdown/examples/markdown.rs": {
        "\n# Markdown Example Document\n\n## Headings\nHeadings are created by adding one or more `#` symbols before your heading text. The number of `#` you use will determine the size of the heading.\n\n```\nfunction a(b: T) {\n\n}\n```\n\nRemember, markdown processors may have slight differences and extensions, so always refer to the specific documentation or guides relevant to your platform or editor for the best practices and additional features.\n\n## Images\n\n![Alt Text](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTgiIGhlaWdodD0iMTAiIHZpZXdCb3g9IjAgMCA1NDAgMzAwIiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgogIDxzdHlsZT4KICAgIC5ncmVlbi1zaGFwZSB7CiAgICAgIGZpbGw6ICNDNEVFRDA7IC8qIExpZ2h0IG1vZGUgKi8KICAgIH0KCiAgICBAbWVkaWEgKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKSB7CiAgICAgIC5ncmVlbi1zaGFwZSB7CiAgICAgICAgZmlsbDogIzEyNTIyNTsgLyogRGFyayBtb2RlICovCiAgICAgIH0KICAgIH0KICA8L3N0eWxlPgogIDxwYXRoIGQ9Ik00MjAgMzBMMzkwIDYwTDQ4MCAxNTBMMzkwIDI0MEwzMzAgMTgwTDMwMCAyMTBMMzkwIDMwMEw1NDAgMTUwTDQyMCAzMFoiIGNsYXNzPSJncmVlbi1zaGFwZSIvPgogIDxwYXRoIGQ9Ik0xNTAgMEwzMCAxMjBMNjAgMTUwTDE1MCA2MEwyMTAgMTIwTDI0MCA5MEwxNTAgMFoiIGNsYXNzPSJncmVlbi1zaGFwZSIvPgogIDxwYXRoIGQ9Ik0zOTAgMEw0MjAgMzBMMTUwIDMwMEwwIDE1MEwzMCAxMjBMMTUwIDI0MEwzOTAgMFoiIGZpbGw9IiMxRUE0NDYiLz4KPC9zdmc+) item one\n\n![other alt text](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTgiIGhlaWdodD0iMTAiIHZpZXdCb3g9IjAgMCA1NDAgMzAwIiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgogIDxzdHlsZT4KICAgIC5ncmF5LXNoYXBlIHsKICAgICAgZmlsbDogI0M2QzZDNjsgLyogTGlnaHQgbW9kZSAqLwogICAgfQoKICAgIEBtZWRpYSAocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspIHsKICAgICAgLmdyYXktc2hhcGUgewogICAgICAgIGZpbGw6ICM1NjU2NTY7IC8qIERhcmsgbW9kZSAqLwogICAgICB9CiAgICB9CiAgPC9zdHlsZT4KICA8cGF0aCBkPSJNMTUwIDBMMjQwIDkwTDIxMCAxMjBMMTIwIDMwTDE1MCAwWiIgZmlsbD0iI0YwOTQwOSIvPgogIDxwYXRoIGQ9Ik00MjAgMzBMNTQwIDE1MEw0MjAgMjcwTDM5MCAyNDBMNDgwIDE1MEwzOTAgNjBMNDIwIDMwWiIgY2xhc3M9ImdyYXktc2hhcGUiLz4KICA8cGF0aCBkPSJNMzMwIDE4MEwzMDAgMjEwTDM5MCAzMDBMNDIwIDI3MEwzMzAgMTgwWiIgZmlsbD0iI0YwOTQwOSIvPgogIDxwYXRoIGQ9Ik0xMjAgMzBMMTUwIDYwTDYwIDE1MEwxNTAgMjQwTDEyMCAyNzBMMCAxNTBMMTIwIDMwWiIgY2xhc3M9ImdyYXktc2hhcGUiLz4KICA8cGF0aCBkPSJNMzkwIDBMNDIwIDMwTDE1MCAzMDBMMTIwIDI3MEwzOTAgMFoiIGZpbGw9IiNGMDk0MDkiLz4KPC9zdmc+) item two\n\n![third alt text](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTgiIGhlaWdodD0iMTAiIHZpZXdCb3g9IjAgMCA1NDAgMzAwIiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgogIDxzdHlsZT4KICAgIC5ibHVlLXNoYXBlIHsKICAgICAgZmlsbDogI0E4QzdGQTsgLyogTGlnaHQgbW9kZSAqLwogICAgfQoKICAgIEBtZWRpYSAocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspIHsKICAgICAgLmJsdWUtc2hhcGUgewogICAgICAgIGZpbGw6ICMyRDUwOUU7IC8qIERhcmsgbW9kZSAqLwogICAgICB9CiAgICB9CgogICAgLmRhcmtlci1ibHVlLXNoYXBlIHsKICAgICAgICBmaWxsOiAjMUI2RUYzOwogICAgfQoKICAgIEBtZWRpYSAocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspIHsKICAgICAgICAuZGFya2VyLWJsdWUtc2hhcGUgewogICAgICAgICAgICBmaWxsOiAjNDE4NUZGOwogICAgICAgIH0KICAgIH0KCiAgPC9zdHlsZT4KICA8cGF0aCBkPSJNMTUwIDBMMTgwIDMwTDE1MCA2MEwxMjAgMzBMMTUwIDBaIiBjbGFzcz0iYmx1ZS1zaGFwZSIvPgogIDxwYXRoIGQ9Ik0yMTAgNjBMMjQwIDkwTDIxMCAxMjBMMTgwIDkwTDIxMCA2MFoiIGNsYXNzPSJibHVlLXNoYXBlIi8+CiAgPHBhdGggZD0iTTQ1MCA2MEw0ODAgOTBMNDUwIDEyMEw0MjAgOTBMNDUwIDYwWiIgY2xhc3M9ImJsdWUtc2hhcGUiLz4KICA8cGF0aCBkPSJNNTEwIDEyMEw1NDAgMTUwTDUxMCAxODBMNDgwIDE1MEw1MTAgMTIwWiIgY2xhc3M9ImJsdWUtc2hhcGUiLz4KICA8cGF0aCBkPSJNNDUwIDE4MEw0ODAgMjEwTDQ1MCAyNDBMNDIwIDIxMEw0NTAgMTgwWiIgY2xhc3M9ImJsdWUtc2hhcGUiLz4KICA8cGF0aCBkPSJNMzkwIDI0MEw0MjAgMjcwTDM5MCAzMDBMMzYwIDI3MEwzOTAgMjQwWiIgY2xhc3M9ImJsdWUtc2hhcGUiLz4KICA8cGF0aCBkPSJNMzMwIDE4MEwzNjAgMjEwTDMzMCAyNDBMMzAwIDIxMEwzMzAgMTgwWiIgY2xhc3M9ImJsdWUtc2hhcGUiLz4KICA8cGF0aCBkPSJNOTAgNjBMMTIwIDkwTDkwIDEyMEw2MCA5MEw5MCA2MFoiIGNsYXNzPSJibHVlLXNoYXBlIi8+CiAgPHBhdGggZD0iTTM5MCAwTDQyMCAzMEwxNTAgMzAwTDAgMTUwTDMwIDEyMEwxNTAgMjQwTDM5MCAwWiIgY2xhc3M9ImRhcmtlci1ibHVlLXNoYXBlIi8+Cjwvc3ZnPg==) item three\n\n": "",
        "cmd-c": "",
        "TypeScript": "",
        ".ZedSans": "",
        ".ZedMono": "",
        "markdown-example": ""
    },
    "zed/crates/media/src/media.rs": {
        "error getting sample timing info, code {result}": "",
        "CoreMedia": "",
        "framework": "",
        "C": "",
        "error getting parameter set, code: {result}": "",
        "could not get block buffer data": "",
        "could not create texture cache, code: {result}": "",
        "could not create texture, code: {result}": "",
        "CoreVideo": ""
    },
    "zed/crates/media/build.rs": {
        "build scripts are exempt": "",
        "xcrun": "",
        "--sdk": "",
        "macosx": "",
        "--show-sdk-path": "",
        "cargo:rerun-if-changed=src/bindings.h": "",
        "src/bindings.h": "",
        "-isysroot{}": "",
        "-xobjective-c": "",
        "CMItemIndex": "",
        "CMSampleTimingInfo": "",
        "CMVideoCodecType": "",
        "VTEncodeInfoFlags": "",
        "CMTimeMake": "",
        "kCVPixelFormatType_.*": "",
        "kCVReturn.*": "",
        "VTEncodeInfoFlags_.*": "",
        "kCMVideoCodecType_.*": "",
        "kCMTime.*": "",
        "kCMSampleAttachmentKey_.*": "",
        "unable to generate bindings": "",
        "OUT_DIR": "",
        "bindings.rs": "",
        "couldn't write dispatch bindings": ""
    },
    "zed/crates/node_runtime/src/node_runtime.rs": {
        "NODE_EXTRA_CA_CERTS": "",
        "using Node.js from `node.path` in settings: {:?}": "",
        "failure checking Node.js from `node.path` in settings ({}): {:?}": "",
        "using Node.js found on PATH: {:?}": "",
        "`node.ignore_system_version` is `true` in settings": "",
        "using Zed managed Node.js at {} since {}": "",
        ",\n                            err\n                        )\n                        .into(),\n                    }) as Box<dyn NodeRuntimeTrait>\n                }\n            }\n        } else if let Some(system_node_error) = system_node_error {\n            // failure case not cached, since it's cheap to check again\n            //\n            // TODO: When support is added for setting `options.allow_binary_download`, update this\n            // error message.\n            return Box::new(UnavailableNodeRuntime {\n                error_message: format!(\n                    ": "",
        ",\n                    system_node_error\n                )\n                .into(),\n            });\n        } else {\n            // failure case is cached because it will always happen with these options\n            //\n            // TODO: When support is added for setting `options.allow_binary_download`, update this\n            // error message.\n            Box::new(UnavailableNodeRuntime {\n                error_message: ": "",
        "\n                    .to_string()\n                    .into(),\n            })\n        };\n\n        state.instance = Some(instance.boxed_clone());\n        state.last_options = Some(options);\n        instance\n    }\n\n    pub async fn binary_path(&self) -> Result<PathBuf> {\n        self.instance().await.binary_path()\n    }\n\n    pub async fn run_npm_subcommand(\n        &self,\n        directory: &Path,\n        subcommand: &str,\n        args: &[&str],\n    ) -> Result<Output> {\n        let http = self.0.lock().await.http.clone();\n        self.instance()\n            .await\n            .run_npm_subcommand(Some(directory), http.proxy(), subcommand, args)\n            .await\n    }\n\n    pub async fn npm_package_installed_version(\n        &self,\n        local_package_directory: &Path,\n        name: &str,\n    ) -> Result<Option<String>> {\n        self.instance()\n            .await\n            .npm_package_installed_version(local_package_directory, name)\n            .await\n    }\n\n    pub async fn npm_package_latest_version(&self, name: &str) -> Result<String> {\n        let http = self.0.lock().await.http.clone();\n        let output = self\n            .instance()\n            .await\n            .run_npm_subcommand(\n                None,\n                http.proxy(),\n                ": "",
        ",\n                &[\n                    name,\n                    ": "",
        ",\n                    ": "",
        ",\n                ],\n            )\n            .await?;\n\n        let mut info: NpmInfo = serde_json::from_slice(&output.stdout)?;\n        info.dist_tags\n            .latest\n            .or_else(|| info.versions.pop())\n            .with_context(|| format!(": "",
        "))\n    }\n\n    pub async fn npm_install_packages(\n        &self,\n        directory: &Path,\n        packages: &[(&str, &str)],\n    ) -> Result<()> {\n        if packages.is_empty() {\n            return Ok(());\n        }\n\n        let packages: Vec<_> = packages\n            .iter()\n            .map(|(name, version)| format!(": "",
        "))\n            .collect();\n\n        let mut arguments: Vec<_> = packages.iter().map(|p| p.as_str()).collect();\n        arguments.extend_from_slice(&[\n            ": "",
        ",\n            ": "",
        ",\n        ]);\n\n        // This is also wrong because the directory is wrong.\n        self.run_npm_subcommand(directory, ": "",
        ", &arguments)\n            .await?;\n        Ok(())\n    }\n\n    pub async fn should_install_npm_package(\n        &self,\n        package_name: &str,\n        local_executable_path: &Path,\n        local_package_directory: &Path,\n        version_strategy: VersionStrategy<'_>,\n    ) -> bool {\n        // In the case of the local system not having the package installed,\n        // or in the instances where we fail to parse package.json data,\n        // we attempt to install the package.\n        if fs::metadata(local_executable_path).await.is_err() {\n            return true;\n        }\n\n        let Some(installed_version) = self\n            .npm_package_installed_version(local_package_directory, package_name)\n            .await\n            .log_err()\n            .flatten()\n        else {\n            return true;\n        };\n\n        let Some(installed_version) = Version::parse(&installed_version).log_err() else {\n            return true;\n        };\n\n        match version_strategy {\n            VersionStrategy::Pin(pinned_version) => {\n                let Some(pinned_version) = Version::parse(pinned_version).log_err() else {\n                    return true;\n                };\n                installed_version != pinned_version\n            }\n            VersionStrategy::Latest(latest_version) => {\n                let Some(latest_version) = Version::parse(latest_version).log_err() else {\n                    return true;\n                };\n                installed_version < latest_version\n            }\n        }\n    }\n}\n\nenum ArchiveType {\n    TarGz,\n    Zip,\n}\n\n#[derive(Debug, Deserialize)]\n#[serde(rename_all = ": "",
        ")]\npub struct NpmInfo {\n    #[serde(default)]\n    dist_tags: NpmInfoDistTags,\n    versions: Vec<String>,\n}\n\n#[derive(Debug, Deserialize, Default)]\npub struct NpmInfoDistTags {\n    latest: Option<String>,\n}\n\n#[async_trait::async_trait]\ntrait NodeRuntimeTrait: Send + Sync {\n    fn boxed_clone(&self) -> Box<dyn NodeRuntimeTrait>;\n    fn binary_path(&self) -> Result<PathBuf>;\n\n    async fn run_npm_subcommand(\n        &self,\n        directory: Option<&Path>,\n        proxy: Option<&Url>,\n        subcommand: &str,\n        args: &[&str],\n    ) -> Result<Output>;\n\n    async fn npm_package_installed_version(\n        &self,\n        local_package_directory: &Path,\n        name: &str,\n    ) -> Result<Option<String>>;\n}\n\n#[derive(Clone)]\nstruct ManagedNodeRuntime {\n    installation_path: PathBuf,\n}\n\nimpl ManagedNodeRuntime {\n    const VERSION: &str = ": "",
        ";\n\n    #[cfg(not(windows))]\n    const NODE_PATH: &str = ": "",
        ";\n    #[cfg(windows)]\n    const NODE_PATH: &str = ": "",
        ";\n\n    #[cfg(not(windows))]\n    const NPM_PATH: &str = ": "",
        ";\n    #[cfg(windows)]\n    const NPM_PATH: &str = ": "",
        ";\n\n    async fn install_if_needed(http: &Arc<dyn HttpClient>) -> Result<Self> {\n        log::info!(": "",
        ");\n\n        let os = match consts::OS {\n            ": "",
        " => ": "",
        ",\n            other => bail!(": "",
        "),\n        };\n\n        let arch = match consts::ARCH {\n            ": "",
        "),\n        };\n\n        let version = Self::VERSION;\n        let folder_name = format!(": "",
        ");\n        let node_containing_dir = paths::data_dir().join(": "",
        ");\n        let node_dir = node_containing_dir.join(folder_name);\n        let node_binary = node_dir.join(Self::NODE_PATH);\n        let npm_file = node_dir.join(Self::NPM_PATH);\n        let node_ca_certs = env::var(NODE_CA_CERTS_ENV_VAR).unwrap_or_else(|_| String::new());\n\n        let valid = if fs::metadata(&node_binary).await.is_ok() {\n            let result = util::command::new_smol_command(&node_binary)\n                .env_clear()\n                .env(NODE_CA_CERTS_ENV_VAR, node_ca_certs)\n                .arg(npm_file)\n                .arg(": "",
        ")\n                .args([": "",
        ".into(), node_dir.join(": "",
        ")])\n                .args([": "",
        ")])\n                .output()\n                .await;\n            match result {\n                Ok(output) => {\n                    if output.status.success() {\n                        true\n                    } else {\n                        log::warn!(\n                            ": "",
        ",\n                            node_binary.display(),\n                            output\n                        );\n                        false\n                    }\n                }\n                Err(err) => {\n                    log::warn!(\n                        ": "",
        ",\n                        node_binary.display(),\n                        err\n                    );\n                    false\n                }\n            }\n        } else {\n            false\n        };\n\n        if !valid {\n            _ = fs::remove_dir_all(&node_containing_dir).await;\n            fs::create_dir(&node_containing_dir)\n                .await\n                .context(": "",
        ")?;\n\n            let archive_type = match consts::OS {\n                ": "",
        " | ": "",
        " => ArchiveType::TarGz,\n                ": "",
        " => ArchiveType::Zip,\n                other => bail!(": "",
        "),\n            };\n\n            let version = Self::VERSION;\n            let file_name = format!(\n                ": "",
        ",\n                extension = match archive_type {\n                    ArchiveType::TarGz => ": "",
        ",\n                    ArchiveType::Zip => ": "",
        ",\n                }\n            );\n\n            let url = format!(": "",
        ");\n            log::info!(": "",
        ");\n            let mut response = http\n                .get(&url, Default::default(), true)\n                .await\n                .context(": "",
        ")?;\n            log::info!(": "",
        ");\n\n            let body = response.body_mut();\n            match archive_type {\n                ArchiveType::TarGz => {\n                    let decompressed_bytes = GzipDecoder::new(BufReader::new(response.body_mut()));\n                    let archive = Archive::new(decompressed_bytes);\n                    archive.unpack(&node_containing_dir).await?;\n                }\n                ArchiveType::Zip => extract_zip(&node_containing_dir, body).await?,\n            }\n            log::info!(": "",
        ", node_containing_dir.display())\n        }\n\n        // Note: Not in the `if !valid {}` so we can populate these for existing installations\n        _ = fs::create_dir(node_dir.join(": "",
        ")).await;\n        _ = fs::write(node_dir.join(": "",
        "), []).await;\n        _ = fs::write(node_dir.join(": "",
        "), []).await;\n\n        anyhow::Ok(ManagedNodeRuntime {\n            installation_path: node_dir,\n        })\n    }\n}\n\nfn path_with_node_binary_prepended(node_binary: &Path) -> Option<OsString> {\n    let existing_path = env::var_os(": "",
        ");\n    let node_bin_dir = node_binary.parent().map(|dir| dir.as_os_str());\n    match (existing_path, node_bin_dir) {\n        (Some(existing_path), Some(node_bin_dir)) => {\n            if let Ok(joined) = env::join_paths(\n                [PathBuf::from(node_bin_dir)]\n                    .into_iter()\n                    .chain(env::split_paths(&existing_path)),\n            ) {\n                Some(joined)\n            } else {\n                Some(existing_path)\n            }\n        }\n        (Some(existing_path), None) => Some(existing_path),\n        (None, Some(node_bin_dir)) => Some(node_bin_dir.to_owned()),\n        _ => None,\n    }\n}\n\n#[async_trait::async_trait]\nimpl NodeRuntimeTrait for ManagedNodeRuntime {\n    fn boxed_clone(&self) -> Box<dyn NodeRuntimeTrait> {\n        Box::new(self.clone())\n    }\n\n    fn binary_path(&self) -> Result<PathBuf> {\n        Ok(self.installation_path.join(Self::NODE_PATH))\n    }\n\n    async fn run_npm_subcommand(\n        &self,\n        directory: Option<&Path>,\n        proxy: Option<&Url>,\n        subcommand: &str,\n        args: &[&str],\n    ) -> Result<Output> {\n        let attempt = || async move {\n            let node_binary = self.installation_path.join(Self::NODE_PATH);\n            let npm_file = self.installation_path.join(Self::NPM_PATH);\n            let env_path = path_with_node_binary_prepended(&node_binary).unwrap_or_default();\n\n            anyhow::ensure!(\n                smol::fs::metadata(&node_binary).await.is_ok(),\n                ": "",
        "\n            );\n            anyhow::ensure!(\n                smol::fs::metadata(&npm_file).await.is_ok(),\n                ": "",
        "\n            );\n\n            let node_ca_certs = env::var(NODE_CA_CERTS_ENV_VAR).unwrap_or_else(|_| String::new());\n\n            let mut command = util::command::new_smol_command(node_binary);\n            command.env_clear();\n            command.env(": "",
        ", env_path);\n            command.env(NODE_CA_CERTS_ENV_VAR, node_ca_certs);\n            command.arg(npm_file).arg(subcommand);\n            command.args([": "",
        ".into(), self.installation_path.join(": "",
        ")]);\n            command.args([\n                ": "",
        ".into(),\n                self.installation_path.join(": "",
        "),\n            ]);\n            command.args([\n                ": "",
        "),\n            ]);\n            command.args(args);\n            configure_npm_command(&mut command, directory, proxy);\n            command.output().await.map_err(|e| anyhow!(": "",
        "))\n        };\n\n        let mut output = attempt().await;\n        if output.is_err() {\n            output = attempt().await;\n            anyhow::ensure!(\n                output.is_ok(),\n                ": "",
        ",\n                output.err()\n            );\n        }\n\n        if let Ok(output) = &output {\n            anyhow::ensure!(\n                output.status.success(),\n                ": "",
        ",\n                String::from_utf8_lossy(&output.stdout),\n                String::from_utf8_lossy(&output.stderr)\n            );\n        }\n\n        output.map_err(|e| anyhow!(": "",
        "))\n    }\n    async fn npm_package_installed_version(\n        &self,\n        local_package_directory: &Path,\n        name: &str,\n    ) -> Result<Option<String>> {\n        read_package_installed_version(local_package_directory.join(": "",
        "), name).await\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct SystemNodeRuntime {\n    node: PathBuf,\n    npm: PathBuf,\n    global_node_modules: PathBuf,\n    scratch_dir: PathBuf,\n}\n\nimpl SystemNodeRuntime {\n    const MIN_VERSION: semver::Version = Version::new(22, 0, 0);\n    async fn new(node: PathBuf, npm: PathBuf) -> Result<Self> {\n        let output = util::command::new_smol_command(&node)\n            .arg(": "",
        ")\n            .output()\n            .await\n            .with_context(|| format!(": "",
        ", node))?;\n        if !output.status.success() {\n            anyhow::bail!(\n                ": "",
        ",\n                String::from_utf8_lossy(&output.stdout),\n                String::from_utf8_lossy(&output.stderr),\n            );\n        }\n        let version_str = String::from_utf8_lossy(&output.stdout);\n        let version = semver::Version::parse(version_str.trim().trim_start_matches('v'))?;\n        if version < Self::MIN_VERSION {\n            anyhow::bail!(\n                ": "",
        ",\n                node.to_string_lossy(),\n                Self::MIN_VERSION,\n                version\n            )\n        }\n\n        let scratch_dir = paths::data_dir().join(": "",
        ");\n        fs::create_dir(&scratch_dir).await.ok();\n        fs::create_dir(scratch_dir.join(": "",
        ")).await.ok();\n\n        let mut this = Self {\n            node,\n            npm,\n            global_node_modules: PathBuf::default(),\n            scratch_dir,\n        };\n        let output = this.run_npm_subcommand(None, None, ": "",
        ", &[": "",
        "]).await?;\n        this.global_node_modules =\n            PathBuf::from(String::from_utf8_lossy(&output.stdout).to_string());\n\n        Ok(this)\n    }\n\n    async fn detect() -> std::result::Result<Self, DetectError> {\n        let node = which::which(": "",
        ").map_err(DetectError::NotInPath)?;\n        let npm = which::which(": "",
        ").map_err(DetectError::NotInPath)?;\n        Self::new(node, npm).await.map_err(DetectError::Other)\n    }\n}\n\nenum DetectError {\n    NotInPath(which::Error),\n    Other(anyhow::Error),\n}\n\nimpl Display for DetectError {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        match self {\n            DetectError::NotInPath(err) => {\n                write!(f, ": "",
        ", err)\n            }\n            DetectError::Other(err) => {\n                write!(f, ": "",
        ", err)\n            }\n        }\n    }\n}\n\n#[async_trait::async_trait]\nimpl NodeRuntimeTrait for SystemNodeRuntime {\n    fn boxed_clone(&self) -> Box<dyn NodeRuntimeTrait> {\n        Box::new(self.clone())\n    }\n\n    fn binary_path(&self) -> Result<PathBuf> {\n        Ok(self.node.clone())\n    }\n\n    async fn run_npm_subcommand(\n        &self,\n        directory: Option<&Path>,\n        proxy: Option<&Url>,\n        subcommand: &str,\n        args: &[&str],\n    ) -> anyhow::Result<Output> {\n        let node_ca_certs = env::var(NODE_CA_CERTS_ENV_VAR).unwrap_or_else(|_| String::new());\n        let mut command = util::command::new_smol_command(self.npm.clone());\n        let path = path_with_node_binary_prepended(&self.node).unwrap_or_default();\n        command\n            .env_clear()\n            .env(": "",
        ", path)\n            .env(NODE_CA_CERTS_ENV_VAR, node_ca_certs)\n            .arg(subcommand)\n            .args([": "",
        ".into(), self.scratch_dir.join(": "",
        ")])\n            .args(args);\n        configure_npm_command(&mut command, directory, proxy);\n        let output = command.output().await?;\n        anyhow::ensure!(\n            output.status.success(),\n            ": "",
        ",\n            String::from_utf8_lossy(&output.stdout),\n            String::from_utf8_lossy(&output.stderr)\n        );\n        Ok(output)\n    }\n\n    async fn npm_package_installed_version(\n        &self,\n        local_package_directory: &Path,\n        name: &str,\n    ) -> Result<Option<String>> {\n        read_package_installed_version(local_package_directory.join(": "",
        "), name).await\n        // todo: allow returning a globally installed version (requires callers not to hard-code the path)\n    }\n}\n\npub async fn read_package_installed_version(\n    node_module_directory: PathBuf,\n    name: &str,\n) -> Result<Option<String>> {\n    let package_json_path = node_module_directory.join(name).join(": "",
        ");\n\n    let mut file = match fs::File::open(package_json_path).await {\n        Ok(file) => file,\n        Err(err) => {\n            if err.kind() == io::ErrorKind::NotFound {\n                return Ok(None);\n            }\n\n            Err(err)?\n        }\n    };\n\n    #[derive(Deserialize)]\n    struct PackageJson {\n        version: String,\n    }\n\n    let mut contents = String::new();\n    file.read_to_string(&mut contents).await?;\n    let package_json: PackageJson = serde_json::from_str(&contents)?;\n    Ok(Some(package_json.version))\n}\n\n#[derive(Clone)]\npub struct UnavailableNodeRuntime {\n    error_message: Arc<String>,\n}\n\n#[async_trait::async_trait]\nimpl NodeRuntimeTrait for UnavailableNodeRuntime {\n    fn boxed_clone(&self) -> Box<dyn NodeRuntimeTrait> {\n        Box::new(self.clone())\n    }\n    fn binary_path(&self) -> Result<PathBuf> {\n        bail!(": "",
        ", self.error_message)\n    }\n\n    async fn run_npm_subcommand(\n        &self,\n        _: Option<&Path>,\n        _: Option<&Url>,\n        _: &str,\n        _: &[&str],\n    ) -> anyhow::Result<Output> {\n        bail!(": "",
        ", self.error_message)\n    }\n\n    async fn npm_package_installed_version(\n        &self,\n        _local_package_directory: &Path,\n        _: &str,\n    ) -> Result<Option<String>> {\n        bail!(": "",
        ", self.error_message)\n    }\n}\n\nfn configure_npm_command(\n    command: &mut smol::process::Command,\n    directory: Option<&Path>,\n    proxy: Option<&Url>,\n) {\n    if let Some(directory) = directory {\n        command.current_dir(directory);\n        command.args([": "",
        ".into(), directory.to_path_buf()]);\n    }\n\n    if let Some(mut proxy) = proxy.cloned() {\n        // Map proxy settings from `http://localhost:10809` to `http://127.0.0.1:10809`\n        // NodeRuntime without environment information can not parse `localhost`\n        // correctly.\n        // TODO: map to `[::1]` if we are using ipv6\n        if matches!(proxy.host(), Some(Host::Domain(domain)) if domain.eq_ignore_ascii_case(": "",
        "))\n        {\n            // When localhost is a valid Host, so is `127.0.0.1`\n            let _ = proxy.set_ip_host(IpAddr::V4(Ipv4Addr::LOCALHOST));\n        }\n\n        command.args([": "",
        ", proxy.as_str()]);\n    }\n\n    #[cfg(windows)]\n    {\n        // SYSTEMROOT is a critical environment variables for Windows.\n        if let Some(val) = env::var(": "",
        ")\n            .context(": "",
        ")\n            .log_err()\n        {\n            command.env(": "",
        ", val);\n        }\n        // Without ComSpec, the post-install will always fail.\n        if let Some(val) = env::var(": "",
        ", val);\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use http_client::Url;\n\n    use super::configure_npm_command;\n\n    // Map localhost to 127.0.0.1\n    // NodeRuntime without environment information can not parse `localhost` correctly.\n    #[test]\n    fn test_configure_npm_command_map_localhost_proxy() {\n        const CASES: [(&str, &str); 4] = [\n            // Map localhost to 127.0.0.1\n            (": "",
        ", ": "",
        "),\n            (": "",
        "),\n            (\n                ": "",
        ",\n                ": "",
        ",\n            ),\n            // Test when localhost is contained within a different part of the URL\n            (\n                ": "",
        ",\n            ),\n        ];\n\n        for (proxy, mapped_proxy) in CASES {\n            let mut dummy = smol::process::Command::new(": "",
        ");\n            let proxy = Url::parse(proxy).unwrap();\n            configure_npm_command(&mut dummy, None, Some(&proxy));\n            let proxy = dummy\n                .get_args()\n                .skip_while(|&arg| arg != ": "",
        ")\n                .skip(1)\n                .next();\n            let proxy = proxy.expect(": "",
        ");\n            assert_eq!(\n                proxy, mapped_proxy,\n                ": ""
    },
    "zed/crates/notifications/src/notification_store.rs": {
        "Notification store was dropped while loading notifications": ""
    },
    "zed/crates/ollama/src/ollama.rs": {
        "schemars": "",
        "granite-code": "",
        "phi": "",
        "tinyllama": "",
        "llama2": "",
        "stablelm2": "",
        "vicuna": "",
        "yi": "",
        "aya": "",
        "codegemma": "",
        "gemma": "",
        "gemma2": "",
        "llama3": "",
        "starcoder": "",
        "codellama": "",
        "starcoder2": "",
        "codestral": "",
        "dolphin-mixtral": "",
        "llava": "",
        "magistral": "",
        "mistral": "",
        "mixstral": "",
        "qwen2": "",
        "qwen2.5-coder": "",
        "cogito": "",
        "command-r": "",
        "deepseek-coder-v2": "",
        "deepseek-r1": "",
        "deepseek-v3": "",
        "devstral": "",
        "gemma3": "",
        "gpt-oss": "",
        "granite3.3": "",
        "llama3.1": "",
        "llama3.2": "",
        "llama3.3": "",
        "mistral-nemo": "",
        "phi3": "",
        "phi3.5": "",
        "phi4": "",
        "qwen3": "",
        "yi-coder": "",
        "qwen3-coder": "",
        ":latest": "",
        "role": "",
        "lowercase": "",
        "Option::is_none": "",
        "type": "",
        "a ModelShow object": "",
        "capabilities": "",
        "model_info": "",
        "general.architecture": "",
        "{}.context_length": "",
        "tools": "",
        "vision": "",
        "thinking": "",
        "{api_url}/api/chat": "",
        "Content-Type": "",
        "application/json": "",
        "Authorization": "",
        "Bearer {api_key}": "",
        "Unable to parse chat response": "",
        "Failed to connect to Ollama API: {} {}": "",
        "{api_url}/api/tags": "",
        "Accept": "",
        "Unable to parse Ollama tag listing": "",
        "{api_url}/api/show": "",
        "model": "",
        "created_at": "",
        "2023-12-12T14:13:43.416799Z": "",
        "message": "",
        "assistant": "",
        "content": "",
        "Hello! How are you today?": "",
        "done": "",
        "total_duration": "",
        "load_duration": "",
        "prompt_eval_count": "",
        "prompt_eval_duration": "",
        "eval_count": "",
        "eval_duration": "",
        "2023-08-04T08:52:19.385406455-07:00": "",
        "The": "",
        "images": "",
        "2023-08-04T19:22:45.499127Z": "",
        "llama3.2:3b": "",
        "2025-04-28T20:02:02.140489Z": "",
        "tool_calls": "",
        "function": "",
        "name": "",
        "weather": "",
        "arguments": "",
        "city": "",
        "london": "",
        "done_reason": "",
        "stop": "",
        "Deserialized wrong role": "",
        "license": "",
        "LLAMA 3.2 COMMUNITY LICENSE AGREEMENT...": "",
        "details": "",
        "parent_model": "",
        "format": "",
        "gguf": "",
        "family": "",
        "llama": "",
        "families": "",
        "parameter_size": "",
        "3.2B": "",
        "quantization_level": "",
        "Q4_K_M": "",
        "general.basename": "",
        "Llama-3.2": "",
        "general.file_type": "",
        "general.finetune": "",
        "Instruct": "",
        "general.languages": "",
        "en": "",
        "de": "",
        "fr": "",
        "it": "",
        "pt": "",
        "hi": "",
        "es": "",
        "th": "",
        "general.parameter_count": "",
        "general.quantization_version": "",
        "general.size_label": "",
        "3B": "",
        "general.tags": "",
        "facebook": "",
        "meta": "",
        "pytorch": "",
        "llama-3": "",
        "text-generation": "",
        "general.type": "",
        "llama.attention.head_count": "",
        "llama.attention.head_count_kv": "",
        "llama.attention.key_length": "",
        "llama.attention.layer_norm_rms_epsilon": "",
        "llama.attention.value_length": "",
        "llama.block_count": "",
        "llama.context_length": "",
        "llama.embedding_length": "",
        "llama.feed_forward_length": "",
        "llama.rope.dimension_count": "",
        "llama.rope.freq_base": "",
        "llama.vocab_size": "",
        "tokenizer.ggml.bos_token_id": "",
        "tokenizer.ggml.eos_token_id": "",
        "tokenizer.ggml.merges": "",
        "tokenizer.ggml.model": "",
        "gpt2": "",
        "tokenizer.ggml.pre": "",
        "llama-bpe": "",
        "tokenizer.ggml.token_type": "",
        "tokenizer.ggml.tokens": "",
        "tensors": "",
        "rope_freqs.weight": "",
        "F32": "",
        "shape": "",
        "token_embd.weight": "",
        "Q4_K_S": "",
        "completion": "",
        "modified_at": "",
        "2025-04-29T21:24:41.445877632+03:00": "",
        "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg==": "",
        "What do you see in this image?": "",
        "Hello, world!": "",
        "What do you see?": "",
        "messages": ""
    },
    "zed/crates/open_ai/src/open_ai.rs": {
        "lowercase": "",
        "user": "",
        "assistant": "",
        "system": "",
        "tool": "",
        "invalid role '{value}'": "",
        "schemars": "",
        "gpt-3.5-turbo": "",
        "gpt-4": "",
        "gpt-4-turbo": "",
        "gpt-4o": "",
        "gpt-4o-mini": "",
        "gpt-4.1": "",
        "gpt-4.1-mini": "",
        "gpt-4.1-nano": "",
        "o1": "",
        "o3-mini": "",
        "o3": "",
        "o4-mini": "",
        "gpt-5": "",
        "gpt-5-mini": "",
        "gpt-5-nano": "",
        "custom": "",
        "gpt-4-turbo-preview": "",
        "invalid model id '{invalid_id}'": "",
        "Option::is_none": "",
        "Vec::is_empty": "",
        "type": "",
        "role": "",
        "text": "",
        "image_url": "",
        "is_none_or_empty": "",
        "{api_url}/chat/completions": "",
        "Content-Type": "",
        "application/json": "",
        "Authorization": "",
        "data: ": "",
        "data:": "",
        "[DONE]": "",
        ",\n                                        error,\n                                        line,\n                                    );\n                                    Some(Err(anyhow!(error)))\n                                }\n                            }\n                        }\n                    }\n                    Err(error) => Some(Err(anyhow!(error))),\n                }\n            })\n            .boxed())\n    } else {\n        let mut body = String::new();\n        response.body_mut().read_to_string(&mut body).await?;\n\n        #[derive(Deserialize)]\n        struct OpenAiResponse {\n            error: OpenAiError,\n        }\n\n        match serde_json::from_str::<OpenAiResponse>(&body) {\n            Ok(response) if !response.error.message.is_empty() => Err(anyhow!(\n                ": "",
        ",\n                api_url,\n                response.error.message,\n            )),\n\n            _ => anyhow::bail!(\n                ": "",
        ",\n                api_url,\n                response.status(),\n                body,\n            ),\n        }\n    }\n}\n\n#[derive(Copy, Clone, Serialize, Deserialize)]\npub enum OpenAiEmbeddingModel {\n    #[serde(rename = ": "",
        ")]\n    TextEmbedding3Small,\n    #[serde(rename = ": "",
        ")]\n    TextEmbedding3Large,\n}\n\n#[derive(Serialize)]\nstruct OpenAiEmbeddingRequest<'a> {\n    model: OpenAiEmbeddingModel,\n    input: Vec<&'a str>,\n}\n\n#[derive(Deserialize)]\npub struct OpenAiEmbeddingResponse {\n    pub data: Vec<OpenAiEmbedding>,\n}\n\n#[derive(Deserialize)]\npub struct OpenAiEmbedding {\n    pub embedding: Vec<f32>,\n}\n\npub fn embed<'a>(\n    client: &dyn HttpClient,\n    api_url: &str,\n    api_key: &str,\n    model: OpenAiEmbeddingModel,\n    texts: impl IntoIterator<Item = &'a str>,\n) -> impl 'static + Future<Output = Result<OpenAiEmbeddingResponse>> {\n    let uri = format!(": "",
        ");\n\n    let request = OpenAiEmbeddingRequest {\n        model,\n        input: texts.into_iter().collect(),\n    };\n    let body = AsyncBody::from(serde_json::to_string(&request).unwrap());\n    let request = HttpRequest::builder()\n        .method(Method::POST)\n        .uri(uri)\n        .header(": "",
        ", ": "",
        ")\n        .header(": "",
        ", format!(": "",
        ", api_key.trim()))\n        .body(body)\n        .map(|request| client.send(request));\n\n    async move {\n        let mut response = request?.await?;\n        let mut body = String::new();\n        response.body_mut().read_to_string(&mut body).await?;\n\n        anyhow::ensure!(\n            response.status().is_success(),\n            ": "",
        ",\n            response.status(),\n            body\n        );\n        let response: OpenAiEmbeddingResponse =\n            serde_json::from_str(&body).context(": ""
    },
    "zed/crates/outline/src/outline.rs": {
        "Search buffer symbols...": "",
        "/dir": "",
        "a.rs": "",
        "\n                                       // display line 0\n                    struct SingleLine; // display line 1\n                                       // display line 2\n                    struct MultiLine { // display line 3\n                        field_1: i32,  // display line 4\n                        field_2: i32,  // display line 5\n                    }                  // display line 6\n                ": "",
        "struct SingleLine": "",
        "struct MultiLine": "",
        "field_1": "",
        "field_2": "",
        "Initially opened outline view should have no highlights": "",
        "Second struct's rows should be highlighted": "",
        "First struct's row should be highlighted": "",
        "No rows should be highlighted after outline view is cancelled and closed": "",
        "Reopened outline view should have no highlights": "",
        "No rows should be highlighted after outline view is confirmed and closed": "",
        "(struct_item\n            (visibility_modifier)? @context\n            ": "",
        " @context\n            name: (_) @name) @item\n\n        (enum_item\n            (visibility_modifier)? @context\n            ": "",
        " @context\n            name: (_) @name) @item\n\n        (enum_variant\n            (visibility_modifier)? @context\n            name: (_) @name) @item\n\n        (impl_item\n            ": "",
        " @context\n            trait: (_)? @name\n            ": "",
        "? @context\n            type: (_) @name) @item\n\n        (trait_item\n            (visibility_modifier)? @context\n            ": "",
        " @context\n            name: (_) @name) @item\n\n        (function_item\n            (visibility_modifier)? @context\n            (function_modifiers)? @context\n            ": "",
        " @context\n            name: (_) @name) @item\n\n        (function_signature_item\n            (visibility_modifier)? @context\n            (function_modifiers)? @context\n            ": "",
        " @context\n            name: (_) @name) @item\n\n        (macro_definition\n            . ": "",
        " @context\n            name: (_) @name) @item\n\n        (mod_item\n            (visibility_modifier)? @context\n            ": "",
        " @context\n            name: (_) @name) @item\n\n        (type_item\n            (visibility_modifier)? @context\n            ": "",
        " @context\n            name: (_) @name) @item\n\n        (associated_type\n            ": "",
        " @context\n            name: (_) @name) @item\n\n        (const_item\n            (visibility_modifier)? @context\n            ": "",
        " @context\n            name: (_) @name) @item\n\n        (field_declaration\n            (visibility_modifier)? @context\n            name: (_) @name) @item\n": "",
        "Expected one caret selection but got: {selections:?}": "",
        "Expected a single caret selection, but got: {selection:?}": ""
    },
    "zed/crates/outline_panel/src/outline_panel.rs": {
        "OutlinePanel": "",
        "Highlighted text that does not match the buffer text": "",
        "loading outline panel": "",
        "Filter...": "",
        "have a &mut Workspace": "",
        "menu": "",
        "editing": "",
        "not_editing": "",
        "Reveal in Finder": "",
        "Reveal in File Manager": "",
        "Open in Terminal": "",
        "Unfold Directory": "",
        "Fold Directory": "",
        "Copy Path": "",
        "Copy Relative Path": "",
        "Lines {}- {}": "",
        "Untitled": "",
        "Unknown buffer": "",
        "search-{match_range:?}": "",
        "Empty folded dirs receiver": "",
        "No matches for query": "",
        "No outlines available": "",
        "empty-outline-state": "",
        "Toggle this panel with {keystroke}": "",
        "entries": "",
        "outline-panel-menu": "",
        "Unpin Outline": "",
        "Pin Active Outline": "",
        "buffers_inside_directory called on a non-directory entry {dir_entry:?}": "",
        "Outline Panel": "",
        "outline-panel": "",
        "Searching:": "",
        "  <==== selected": "",
        "/rust-analyzer": "",
        "Project search view expected to appear after new search event trigger": "",
        "param_names_for_lifetime_elision_hints": "",
        "rust-analyzer/\n  crates/\n    ide/src/\n      inlay_hints/\n        fn_lifetime_fn.rs\n          search: match config.«param_names_for_lifetime_elision_hints» {\n          search: allocated_lifetimes.push(if config.«param_names_for_lifetime_elision_hints» {\n          search: Some(it) if config.«param_names_for_lifetime_elision_hints» => {\n          search: InlayHintsConfig { «param_names_for_lifetime_elision_hints»: true, ..TEST_CONFIG },\n      inlay_hints.rs\n        search: pub «param_names_for_lifetime_elision_hints»: bool,\n        search: «param_names_for_lifetime_elision_hints»: self\n      static_index.rs\n        search: «param_names_for_lifetime_elision_hints»: false,\n    rust-analyzer/src/\n      cli/\n        analysis_stats.rs\n          search: «param_names_for_lifetime_elision_hints»: true,\n      config.rs\n        search: «param_names_for_lifetime_elision_hints»: self": "",
        "`{line_to_select}` was not found in all matches `{all_matches}`": "",
        "{line_to_select}{SELECTED_MARKER}": "",
        "search: match config.«param_names_for_lifetime_elision_hints» {": "",
        "fn_lifetime_fn.rs": "",
        "rust-analyzer/\n  crates/\n    ide/src/\n      inlay_hints/\n        fn_lifetime_fn.rs{SELECTED_MARKER}\n      inlay_hints.rs\n        search: pub «param_names_for_lifetime_elision_hints»: bool,\n        search: «param_names_for_lifetime_elision_hints»: self\n      static_index.rs\n        search: «param_names_for_lifetime_elision_hints»: false,\n    rust-analyzer/src/\n      cli/\n        analysis_stats.rs\n          search: «param_names_for_lifetime_elision_hints»: true,\n      config.rs\n        search: «param_names_for_lifetime_elision_hints»: self": "",
        "inlay_hints/": "",
        "ide/src/": "",
        "rust-analyzer/\n  crates/\n    ide/src/{SELECTED_MARKER}\n    rust-analyzer/src/\n      cli/\n        analysis_stats.rs\n          search: «param_names_for_lifetime_elision_hints»: true,\n      config.rs\n        search: «param_names_for_lifetime_elision_hints»: self": "",
        "a": "",
        "search: ": "",
        "should have an active editor open": "",
        "Should place the initial editor selection on the corresponding search result": "",
        "search: Some(it) if config.«param_names_for_lifetime_elision_hints» => {": "",
        "Should still have the initial caret position after SelectNext calls": "",
        "After opening, should move the caret to the opened outline entry's position": "",
        "search: InlayHintsConfig { «param_names_for_lifetime_elision_hints»: true, ..TEST_CONFIG },": "",
        "Should again preserve the selection after another SelectNext call": "",
        "After opening an excerpt, new editor should be open": "",
        "fn_lifetime_fn.rs  <==== selected": "",
        "When opening the excerpt, should navigate to the place corresponding the outline entry": "",
        "/root": "",
        "one": "",
        "a.txt": "",
        "aaa aaa": "",
        "two": "",
        "b.txt": "",
        "a aaa": "",
        "/root/one": "",
        "/root/two": "",
        "Were opening another worktree directory": "",
        "Directory should be opened successfully": "",
        "aaa": "",
        "one/\n  a.txt\n    search: «aaa» aaa  <==== selected\n    search: aaa «aaa»\ntwo/\n  b.txt\n    search: a «aaa»": "",
        "one/\n  a.txt  <==== selected\ntwo/\n  b.txt\n    search: a «aaa»": "",
        "one/\n  a.txt\ntwo/  <==== selected": "",
        "one/\n  a.txt\ntwo/  <==== selected\n  b.txt\n    search: a «aaa»": "",
        "src": "",
        "lib.rs": "",
        "\n#[derive(Clone, Debug, PartialEq, Eq, Hash)]\nstruct OutlineEntryExcerpt {\n    id: ExcerptId,\n    buffer_id: BufferId,\n    range: ExcerptRange<language::Anchor>,\n}": "",
        "\n                (struct_item\n                    (visibility_modifier)? @context\n                    ": "",
        " @context\n                    name: (_) @name) @item\n\n                (field_declaration\n                    (visibility_modifier)? @context\n                    name: (_) @name) @item\n": "",
        "Failed to open Rust source file": "",
        "Should open an editor for Rust source file": "",
        "\noutline: struct OutlineEntryExcerpt\n  outline: id\n  outline: buffer_id\n  outline: range": "",
        "\noutline: struct OutlineEntryExcerpt  <==== selected\n  outline: id\n  outline: buffer_id\n  outline: range": "",
        "\noutline: struct OutlineEntryExcerpt\n  outline: id  <==== selected\n  outline: buffer_id\n  outline: range": "",
        "\noutline: struct OutlineEntryExcerpt\n  outline: id\n  outline: buffer_id  <==== selected\n  outline: range": "",
        "\noutline: struct OutlineEntryExcerpt\n  outline: id\n  outline: buffer_id\n  outline: range  <==== selected": "",
        "/frontend-project": "",
        "public": "",
        "lottie": "",
        "syntax-tree.json": "",
        "{ ": "",
        ": ": "",
        " }": "",
        "app": "",
        "(site)": "",
        "(about)": "",
        "jobs": "",
        "[slug]": "",
        "page.tsx": "",
        "static": "",
        "(blog)": "",
        "post": "",
        "components": "",
        "ErrorBoundary.tsx": "",
        "frontend-project/\n  public/lottie/\n    syntax-tree.json\n      search: {{ ": "",
        " }}  <==== selected\n  src/\n    app/(site)/\n      (about)/jobs/[slug]/\n        page.tsx\n          search: «static»\n      (blog)/post/[slug]/\n        page.tsx\n          search: «static»\n    components/\n      ErrorBoundary.tsx\n        search: «static»": "",
        " }}\n  src/\n    app/(site)/  <==== selected\n    components/\n      ErrorBoundary.tsx\n        search: «static»": "",
        " }}\n  src/\n    app/(site)/\n    components/\n      ErrorBoundary.tsx\n        search: «static»  <==== selected": "",
        "Should have an active editor": "",
        " }}\n  src/\n    app/(site)/\n    components/\n      ErrorBoundary.tsx  <==== selected": "",
        "frontend-project/\n  public/lottie/\n    syntax-tree.json  <==== selected\n  src/\n    app/(site)/\n    components/\n      ErrorBoundary.tsx": "",
        "frontend-project/": "",
        "frontend-project/\n  public/lottie/\n    syntax-tree.json  <==== selected\n      search: {{ ": "",
        " }}\n  src/\n    app/(site)/\n      (about)/jobs/[slug]/\n        page.tsx\n          search: «static»\n      (blog)/post/[slug]/\n        page.tsx\n          search: «static»\n    components/\n      ErrorBoundary.tsx\n        search: «static»": "",
        "Failed to load outline panel": "",
        "no outline panel": "",
        "  ": "",
        "Did not cover external files with tests": "",
        "{path}/": "",
        "outline: {}": "",
        "search: {search_result}": "",
        "crates": "",
        "ide": "",
        "inlay_hints": "",
        "\n        pub(super) fn hints(\n            acc: &mut Vec<InlayHint>,\n            config: &InlayHintsConfig,\n            func: ast::Fn,\n        ) -> Option<()> {\n            // ... snip\n\n            let mut used_names: FxHashMap<SmolStr, usize> =\n                match config.param_names_for_lifetime_elision_hints {\n                    true => generic_param_list\n                        .iter()\n                        .flat_map(|gpl| gpl.lifetime_params())\n                        .filter_map(|param| param.lifetime())\n                        .filter_map(|lt| Some((SmolStr::from(lt.text().as_str().get(1..)?), 0)))\n                        .collect(),\n                    false => Default::default(),\n                };\n            {\n                let mut potential_lt_refs = potential_lt_refs.iter().filter(|&&(.., is_elided)| is_elided);\n                if self_param.is_some() && potential_lt_refs.next().is_some() {\n                    allocated_lifetimes.push(if config.param_names_for_lifetime_elision_hints {\n                        // self can't be used as a lifetime, so no need to check for collisions\n                        ": "",
        ".into()\n                    } else {\n                        gen_idx_name()\n                    });\n                }\n                potential_lt_refs.for_each(|(name, ..)| {\n                    let name = match name {\n                        Some(it) if config.param_names_for_lifetime_elision_hints => {\n                            if let Some(c) = used_names.get_mut(it.text().as_str()) {\n                                *c += 1;\n                                SmolStr::from(format!(": "",
        ", text = it.text().as_str()))\n                            } else {\n                                used_names.insert(it.text().as_str().into(), 0);\n                                SmolStr::from_iter([": "",
        ", it.text().as_str()])\n                            }\n                        }\n                        _ => gen_idx_name(),\n                    };\n                    allocated_lifetimes.push(name);\n                });\n            }\n\n            // ... snip\n        }\n\n        // ... snip\n\n            #[test]\n            fn hints_lifetimes_named() {\n                check_with_config(\n                    InlayHintsConfig { param_names_for_lifetime_elision_hints: true, ..TEST_CONFIG },\n                    r#": "",
        "#,\n                );\n            }\n\n        // ... snip\n        ": "",
        "inlay_hints.rs": "",
        "\n    #[derive(Clone, Debug, PartialEq, Eq)]\n    pub struct InlayHintsConfig {\n        // ... snip\n        pub param_names_for_lifetime_elision_hints: bool,\n        pub max_length: Option<usize>,\n        // ... snip\n    }\n\n    impl Config {\n        pub fn inlay_hints(&self) -> InlayHintsConfig {\n            InlayHintsConfig {\n                // ... snip\n                param_names_for_lifetime_elision_hints: self\n                    .inlayHints_lifetimeElisionHints_useParameterNames()\n                    .to_owned(),\n                max_length: self.inlayHints_maxLength().to_owned(),\n                // ... snip\n            }\n        }\n    }\n    ": "",
        "static_index.rs": "",
        "\n// ... snip\n        fn add_file(&mut self, file_id: FileId) {\n            let current_crate = crates_for(self.db, file_id).pop().map(Into::into);\n            let folds = self.analysis.folding_ranges(file_id).unwrap();\n            let inlay_hints = self\n                .analysis\n                .inlay_hints(\n                    &InlayHintsConfig {\n                        // ... snip\n                        closure_style: hir::ClosureStyle::ImplFn,\n                        param_names_for_lifetime_elision_hints: false,\n                        binding_mode_hints: false,\n                        max_length: Some(25),\n                        closure_capture_hints: false,\n                        // ... snip\n                    },\n                    file_id,\n                    None,\n                )\n                .unwrap();\n            // ... snip\n    }\n// ... snip\n    ": "",
        "rust-analyzer": "",
        "cli": "",
        "analysis_stats.rs": "",
        "\n        // ... snip\n                for &file_id in &file_ids {\n                    _ = analysis.inlay_hints(\n                        &InlayHintsConfig {\n                            // ... snip\n                            implicit_drop_hints: true,\n                            lifetime_elision_hints: ide::LifetimeElisionHints::Always,\n                            param_names_for_lifetime_elision_hints: true,\n                            hide_named_constructor_hints: false,\n                            hide_closure_initialization_hints: false,\n                            closure_style: hir::ClosureStyle::ImplFn,\n                            max_length: Some(25),\n                            closing_brace_hints_min_lines: Some(20),\n                            fields_to_resolve: InlayFieldsToResolve::empty(),\n                            range_exclusive_hints: true,\n                        },\n                        file_id.into(),\n                        None,\n                    );\n                }\n        // ... snip\n                                    ": "",
        "config.rs": "",
        "\n                config_data! {\n                    /// Configs that only make sense when they are set by a client. As such they can only be defined\n                    /// by setting them using client's settings (e.g `settings.json` on VS Code).\n                    client: struct ClientDefaultConfigData <- ClientConfigInput -> {\n                        // ... snip\n                        /// Maximum length for inlay hints. Set to null to have an unlimited length.\n                        inlayHints_maxLength: Option<usize>                        = Some(25),\n                        // ... snip\n                        /// Whether to prefer using parameter names as the name for elided lifetime hints if possible.\n                        inlayHints_lifetimeElisionHints_useParameterNames: bool    = false,\n                        // ... snip\n                    }\n                }\n\n                impl Config {\n                    // ... snip\n                    pub fn inlay_hints(&self) -> InlayHintsConfig {\n                        InlayHintsConfig {\n                            // ... snip\n                            param_names_for_lifetime_elision_hints: self\n                                .inlayHints_lifetimeElisionHints_useParameterNames()\n                                .to_owned(),\n                            max_length: self.inlayHints_maxLength().to_owned(),\n                            // ... snip\n                        }\n                    }\n                    // ... snip\n                }\n                ": "",
        "\n                (field_identifier) @field\n                (struct_expression) @struct\n            ": "",
        "\n                (macro_invocation\n                    (token_tree) @injection.content\n                    (#set! injection.language ": "",
        "))\n            ": "",
        "Active editor should have exactly one selection after any outline panel interactions": "",
        "/test": "",
        "\n                            mod outer {\n                                pub struct OuterStruct {\n                                    field: String,\n                                }\n                                impl OuterStruct {\n                                    pub fn new() -> Self {\n                                        Self { field: String::new() }\n                                    }\n                                    pub fn method(&self) {\n                                        println!(\\\"{}\\\", self.field);\n                                    }\n                                }\n                                mod inner {\n                                    pub fn inner_function() {\n                                        let x = 42;\n                                        println!(\\\"{}\\\", x);\n                                    }\n                                    pub struct InnerStruct {\n                                        value: i32,\n                                    }\n                                }\n                            }\n                            fn main() {\n                                let s = outer::OuterStruct::new();\n                                s.method();\n                            }\n                        ": "",
        "\n                            (struct_item\n                                (visibility_modifier)? @context\n                                ": "",
        " @context\n                                name: (_) @name) @item\n                            (impl_item\n                                ": "",
        " @context\n                                trait: (_)? @context\n                                ": "",
        "? @context\n                                type: (_) @context\n                                body: (_)) @item\n                            (function_item\n                                (visibility_modifier)? @context\n                                ": "",
        " @context\n                                name: (_) @name\n                                parameters: (_) @context) @item\n                            (mod_item\n                                (visibility_modifier)? @context\n                                ": "",
        " @context\n                                name: (_) @name) @item\n                            (enum_item\n                                (visibility_modifier)? @context\n                                ": "",
        " @context\n                                name: (_) @name) @item\n                            (field_declaration\n                                (visibility_modifier)? @context\n                                name: (_) @name\n                                ": "",
        " @context\n                                type: (_) @context) @item\n                            ": "",
        "\noutline: mod outer  <==== selected\n  outline: pub struct OuterStruct\n    outline: field: String\n  outline: impl OuterStruct\n    outline: pub fn new()\n    outline: pub fn method(&self)\n  outline: mod inner\n    outline: pub fn inner_function()\n    outline: pub struct InnerStruct\n      outline: value: i32\noutline: fn main()": "",
        "Should find an outline with children": "",
        "\noutline: mod outer  <==== selected\noutline: fn main()": "",
        "\noutline: mod outer\noutline: fn main()": "",
        "Should have collapsed entries tracked": "",
        "main.rs": "",
        "\n                            struct Config {\n                                name: String,\n                                value: i32,\n                            }\n                            impl Config {\n                                fn new(name: String) -> Self {\n                                    Self { name, value: 0 }\n                                }\n                                fn get_value(&self) -> i32 {\n                                    self.value\n                                }\n                            }\n                            enum Status {\n                                Active,\n                                Inactive,\n                            }\n                            fn process_config(config: Config) -> Status {\n                                if config.get_value() > 0 {\n                                    Status::Active\n                                } else {\n                                    Status::Inactive\n                                }\n                            }\n                            fn main() {\n                                let config = Config::new(\\\"test\\\".to_string());\n                                let status = process_config(config);\n                            }\n                        ": "",
        "\noutline: struct Config\n  outline: name: String\n  outline: value: i32\noutline: impl Config\n  outline: fn new(name: String)\n  outline: fn get_value(&self)\noutline: enum Status\noutline: fn process_config(config: Config)\noutline: fn main()": "",
        "\noutline: struct Config  <==== selected\n  outline: name: String\n  outline: value: i32\noutline: impl Config\n  outline: fn new(name: String)\n  outline: fn get_value(&self)\noutline: enum Status\noutline: fn process_config(config: Config)\noutline: fn main()": "",
        "\noutline: struct Config  <==== selected\noutline: impl Config\n  outline: fn new(name: String)\n  outline: fn get_value(&self)\noutline: enum Status\noutline: fn process_config(config: Config)\noutline: fn main()": "",
        "\n        outline: mod outer  <==== selected\n        outline: fn main()": "",
        "\n        outline: mod outer  <==== selected\n          outline: pub struct OuterStruct\n            outline: field: String\n          outline: impl OuterStruct\n            outline: pub fn new()\n            outline: pub fn method(&self)\n          outline: mod inner\n            outline: pub fn inner_function()\n            outline: pub struct InnerStruct\n              outline: value: i32\n        outline: fn main()": "",
        "foo.txt": "",
        "<_constitution>\n\n</_constitution>\n\n\n\n## 📊 Output\n\n| Field          | Meaning                |\n": "",
        "search: | Field«  »        | Meaning                |  <==== selected\nsearch: | Field  «  »      | Meaning                |\nsearch: | Field    «  »    | Meaning                |\nsearch: | Field      «  »  | Meaning                |\nsearch: | Field        «  »| Meaning                |\nsearch: | Field          | Meaning«  »              |\nsearch: | Field          | Meaning  «  »            |\nsearch: | Field          | Meaning    «  »          |\nsearch: | Field          | Meaning      «  »        |\nsearch: | Field          | Meaning        «  »      |\nsearch: | Field          | Meaning          «  »    |\nsearch: | Field          | Meaning            «  »  |\nsearch: | Field          | Meaning              «  »|": ""
    },
    "zed/crates/paths/src/paths.rs": {
        ".editorconfig": "",
        ".zed_server": "",
        ".zed_wsl_server": "",
        "set_custom_data_dir called after data_dir or config_dir was initialized": "",
        "failed to canonicalize custom data directory's path to an absolute path": "",
        "failed to create custom data directory": "",
        "config": "",
        "failed to determine RoamingAppData directory": "",
        "FLATPAK_XDG_CONFIG_HOME": "",
        "failed to determine XDG_CONFIG_HOME directory": "",
        ".config": "",
        "Library/Application Support/Zed": "",
        "FLATPAK_XDG_DATA_HOME": "",
        "failed to determine XDG_DATA_HOME directory": "",
        "failed to determine LocalAppData directory": "",
        "failed to determine cachesDirectory directory": "",
        "FLATPAK_XDG_CACHE_HOME": "",
        "failed to determine XDG_CACHE_HOME directory": "",
        ".cache": "",
        "Library/Logs/Zed": "",
        "logs": "",
        "server_state": "",
        "Zed.log": "",
        "Zed.log.old": "",
        "db": "",
        "Library/Logs/DiagnosticReports": "",
        "Retired": "",
        "settings.json": "",
        "global_settings.json": "",
        "settings_backup.json": "",
        "keymap.json": "",
        "keymap_backup.json": "",
        "tasks.json": "",
        "debug.json": "",
        "extensions": "",
        "remote_extensions": "",
        "uploads": "",
        "themes": "",
        "snippets": "",
        "conversations": "",
        "prompts": "",
        "assets": "",
        "prompt_overrides": "",
        "embeddings": "",
        "languages": "",
        "debug_adapters": "",
        "external_agents": "",
        "copilot": "",
        "supermaven": "",
        "prettier": "",
        "remote_servers": "",
        ".zed": "",
        ".vscode": "",
        ".zed/settings.json": "",
        ".zed/tasks.json": "",
        ".vscode/tasks.json": "",
        ".zed/debug.json": "",
        ".vscode/launch.json": "",
        ".ssh/config": "",
        "/etc/ssh/ssh_config": "",
        "User/settings.json": "",
        "Code": "",
        "Code - OSS": "",
        "VSCodium": "",
        "Code Dev": "",
        "Code - OSS Dev": "",
        "code-oss-dev": "",
        "VSCODE_PORTABLE": "",
        "user-data": "",
        "VSCODE_APPDATA": "",
        "Cursor": "",
        "Library/Application Support": "",
        "git": "",
        "ignore": ""
    },
    "zed/crates/prettier/src/prettier.rs": {
        "prettier_server.js": "",
        "prettier": "",
        "prettier-plugin-tailwindcss": "",
        "\\nformatted by test prettier": "",
        ".prettierrc": "",
        ".prettierrc.json": "",
        ".prettierrc.json5": "",
        ".prettierrc.yaml": "",
        ".prettierrc.yml": "",
        ".prettierrc.toml": "",
        ".prettierrc.js": "",
        ".prettierrc.cjs": "",
        ".prettierrc.mjs": "",
        ".prettierrc.ts": "",
        ".prettierrc.cts": "",
        ".prettierrc.mts": "",
        "package.json": "",
        "prettier.config.js": "",
        "prettier.config.cjs": "",
        "prettier.config.mjs": "",
        "prettier.config.ts": "",
        "prettier.config.cts": "",
        "prettier.config.mts": "",
        ".editorconfig": "",
        ".prettierignore": "",
        "node_modules": "",
        "Skipping prettier location for path {path_to_check:?} that is inside node_modules": "",
        "failed to get metadata for initial path {path_to_check:?}": "",
        "empty metadata for initial path {path_to_check:?}": "",
        "Found prettier path {path_to_check:?} in installed prettiers": "",
        "Found prettier path {path_to_check:?} in the node_modules": "",
        "workspaces": "",
        "traversing path parents, should be able to strip prefix": "",
        "Skipping non-string 'workspaces' value: {value:?}": "",
        "Path {path_to_check:?} is the workspace root for project in {closest_package_json_path:?}, but it has no prettier installed": "",
        "Found prettier path {path_to_check:?} in the workspace root for project in {closest_package_json_path:?}": "",
        "Skipping path {path_to_check:?} workspace root with workspaces {workspaces:?} that have no prettier installed": "",
        "Failed to parse workspaces for {path_to_check:?} from package.json, got {unknown:?}. Skipping.": "",
        "Skipping path {path_to_check:?} that has no prettier dependency and no workspaces section in its package.json": "",
        "Found no prettier in ancestors of {locate_from:?}": "",
        "Skipping prettier ignore location for path {path_to_check:?} that is inside node_modules": "",
        "Found prettier ignore at {path_to_check:?}": "",
        "fetching metadata for {ignore_path:?}": "",
        "Found prettier ignore at {ignore_path:?}": "",
        "Found prettier ignore at workspace root {workspace_ignore:?}": "",
        "Found no prettier ignore in ancestors of {locate_from:?}": "",
        "Prettier dir {prettier_dir:?} is not a directory": "",
        "no prettier server package found at {prettier_server:?}": "",
        "prettier server creation": "",
        "prettier server initialization": "",
        "Cannot format: prettier is not allowed for language {buffer_language:?}": "",
        "Prettier node_modules dir does not exist: {prettier_node_modules:?}": "",
        "dist": "",
        "index.mjs": "",
        "index.js": "",
        "plugin.js": "",
        "src": "",
        "lib": "",
        "standalone.js": "",
        "prettier-plugin-latex.js": "",
        "tabWidth": "",
        "printWidth": "",
        "useTabs": "",
        "Have not found plugin path for {plugin_name:?} inside {prettier_node_modules:?}": "",
        "Formatting unsaved file with prettier failed. No prettier parser configured for language {buffer_language:?}": "",
        "Cannot determine prettier parser for unsaved file": "",
        "Formatting file {:?} with prettier, plugins :{:?}, options: {:?}, ignore_path: {:?}": "",
        "building prettier request": "",
        "rust": "",
        "prettier does not support Rust": "",
        "Should not format buffer without a language with prettier": "",
        "prettier clear cache": "",
        "fetching metadata for {possible_node_modules_location:?}": "",
        "fetching metadata for package json {possible_package_json:?}": "",
        "reading {possible_package_json:?} file contents": "",
        "parsing {possible_package_json:?} file contents": "",
        "camelCase": "",
        "filepath": "",
        "prettier/format": "",
        "prettier/clear_cache": "",
        "/root": "",
        ".config": "",
        "settings.json": "",
        "{ ": "",
        ": ": "",
        " }": "",
        "work": "",
        "project": "",
        "// index.js file contents": "",
        "expect": "",
        "build": "",
        "print.js": "",
        "// print.js file contents": "",
        "{\n                                    ": "",
        ": {\n                                        ": "",
        "\n                                    }\n                                }": "",
        "// Dummy prettier package file": "",
        "Should find no prettier for path hierarchy without it": "",
        "/root/work/project": "",
        "Should successfully find a prettier for path hierarchy that has node_modules with prettier, but no package.json mentions of it": "",
        "Should not format files inside node_modules/": "",
        "web_blog": "",
        "{\n                                ": "",
        ": {\n                                    ": "",
        "\n                                }\n                            }": "",
        "pages": "",
        "[slug].tsx": "",
        "// [slug].tsx file contents": "",
        "{\n                        ": "",
        ": {\n                            ": "",
        "\n                        },\n                        ": "",
        ": false,\n                            ": "",
        ": 80,\n                            ": "",
        ",\n                            ": "",
        ": 4\n                        }\n                    }": "",
        "/root/web_blog": "",
        "Should find a preinstalled prettier in the project root": "",
        "Should not allow formatting node_modules/ contents": "",
        "{\n                            ": "",
        ": {\n                                ": "",
        "\n                            },\n                            ": "",
        ": false,\n                                ": "",
        ": 80,\n                                ": "",
        ",\n                                ": "",
        ": 4\n                            }\n                        }": "",
        "Should find no prettier when node_modules don't have it": "",
        "/root/work": "",
        "Should return closest cached value found without path checks": "",
        "Should not allow formatting files inside node_modules/": "",
        "Should ignore cache lookup for files inside node_modules/": "",
        "full-stack-foundations": "",
        "exercises": "",
        "03.loading": "",
        "01.problem.loader": "",
        "app": "",
        "routes": "",
        "users+": "",
        "$username_+": "",
        "notes.tsx": "",
        "// notes.tsx file contents": "",
        "test.js": "",
        "// test.js contents": "",
        "{\n                                        ": "",
        ": {\n                                            ": "",
        "\n                                        }\n                                    }": "",
        ": [": "",
        ", ": "",
        "]\n                        }": "",
        "/root/work/full-stack-foundations": "",
        "Should ascend to the multi-workspace root and find the prettier there": "",
        "Should not allow formatting files inside root node_modules/": "",
        "Should not allow formatting files inside submodule's node_modules/": "",
        "Expected to fail for prettier in package.json but not in node_modules found, but got path {path:?}": "",
        "/root/work/full-stack-foundations/exercises/03.loading/01.problem.loader": "",
        "Error message should mention which project had prettier defined": "",
        "Error message should mention potential candidates without prettier node_modules contents": "",
        "ignored.js": "",
        "// this file should be ignored": "",
        "\n                    }": "",
        "/root/project": "",
        "Should find prettierignore in project root": "",
        "monorepo": "",
        "packages": "",
        "web": "",
        "// index.js contents": "",
        "// this should be ignored": "",
        "\n                            }": "",
        "],\n                        ": "",
        "\n                        }\n                    }": "",
        "/root/monorepo/packages/web": "",
        "Should find prettierignore in child package": "",
        "main.js": "",
        "// this should not be ignored": "",
        "Should find child package prettierignore first": ""
    },
    "zed/crates/project/src/buffer_store.rs": {
        "missing variant": "",
        "no worktree found for id {}": "",
        "received chunk for buffer {} without initial state": "",
        "missing transaction": "",
        "buffer doesn't have a file": "",
        "no such worktree": "",
        "Could not open path: {}": "",
        "{e}": "",
        "buffer {remote_id} was already registered": "",
        "unknown buffer id {buffer_id}": "",
        "tried to register shared lsp handle, but buffer was not shared": "",
        "missing original_sender_id on SynchronizeBuffers request": "",
        "buffer store is not a remote": "",
        "invalid file": "",
        "project is not shared": "",
        "peer_id {} closed buffer_id {} which was either not open or already closed": "",
        "missing line ending": "",
        "local-only method called in a non-local context": "",
        "not a remote buffer store": ""
    },
    "zed/crates/project/src/color_extractor.rs": {
        "(#(?:[\\da-fA-F]{3}){1,2})": "",
        "(rgba?|hsla?)\\(\\s*(\\d{1,3}%?)\\s*,\\s*(\\d{1,3}%?)\\s*,\\s*(\\d{1,3}%?)\\s*(?:,\\s*(1|0?\\.\\d+))?\\s*\\)": "",
        "Failed to create RELAXED_HEX_REGEX": "",
        "^{HEX}$": "",
        "Failed to create STRICT_HEX_REGEX": "",
        "Failed to create RELAXED_RGB_OR_HSL_REGEX": "",
        "^{RGB_OR_HSL}$": "",
        "Failed to create STRICT_RGB_OR_HSL_REGEX": "",
        "rgb": "",
        "rgba": "",
        "hsl": "",
        "hsla": "",
        "f0f": "",
        "#fof": "",
        "rgb(255, 0, 0, 0.0)": "",
        "hsl(120, 0, 0, 0.0)": "",
        "rgba(255, 0, 0)": "",
        "hsla(120, 0, 0)": "",
        "rgba(255, 0, 0, 0)": "",
        "hsla(120, 0, 0, 0)": "",
        "rgba(255, 0, 0, 1.0)": "",
        "hsla(120, 0, 0, 1.0)": "",
        "#f0f": "",
        "#ff0000": "",
        "rgb(255, 0, 0)": "",
        "rgba(255, 0, 0, 0.4)": "",
        "rgba(255, 0, 0, 1)": "",
        "rgb(20%, 0%, 0%)": "",
        "rgba(20%, 0%, 0%, 1)": "",
        "rgb(0%, 20%, 0%)": "",
        "rgba(0%, 20%, 0%, 1)": "",
        "rgb(0%, 0%, 20%)": "",
        "rgba(0%, 0%, 20%, 1)": "",
        "hsl(0, 100%, 50%)": "",
        "hsl(120, 100%, 50%)": "",
        "hsla(0, 100%, 50%, 0.0)": "",
        "hsla(0, 100%, 50%, 0.4)": "",
        "hsla(0, 100%, 50%, 1)": "",
        "hsla(120, 100%, 50%, 0.0)": "",
        "hsla(120, 100%, 50%, 0.4)": "",
        "hsla(120, 100%, 50%, 1)": "",
        "{} foo": "",
        "foo {}": "",
        "foo {} foo": ""
    },
    "zed/crates/project/src/environment.rs": {
        "using project environment variables from CLI": "",
        "PATH": "",
        "using project environment variables shell launched in {:?}. PATH={:?}": "",
        "ZED_ENVIRONMENT": "",
        "cli": "",
        "worktree-shell": "",
        "Failed to open {}": "",
        "stat {abs_path:?}": "",
        "getting parent of {abs_path:?}": "",
        "Failed to load environment variables": "",
        "capturing shell environment with {shell:?}": "",
        "Path": "",
        "Failed to load direnv environment": "",
        "load direnv environment": "",
        "direnv": "",
        "export": "",
        "json": "",
        "TERM": "",
        "dumb": "",
        "running direnv": "",
        "Loading direnv environment failed ({}), stderr: {}": "",
        "parsing direnv json": ""
    },
    "zed/crates/project/src/image_store.rs": {
        "absolutizing image file path": "",
        "Failed to load image content": "",
        "svg": "",
        "no such worktree": "",
        "invalid image id": "",
        "received chunk for unknown image": "",
        "missing file in image state": "",
        "worktree not found": "",
        "invalid file in image state": "",
        "Received CreateImageForPeer with no variant": "",
        "invalid image_id in response": "",
        "Reloading images from remote is not supported": "",
        "Image format {format:?} not supported": "",
        "/root": "",
        "image_1.png": ""
    },
    "zed/crates/project/src/lsp_command.rs": {
        "Invalid file path provided to LSP request: {path:?}": "",
        "Prepare rename": "",
        "Rename not supported": "",
        "invalid position": "",
        "Missing start or end position in remote project PrepareRenameResponse": "",
        "Rename": "",
        "missing transaction": "",
        "Get definition": "",
        "Get declaration": "",
        "Get implementation": "",
        "Get type definition": "",
        "no language server found for buffer": "",
        "missing origin start": "",
        "missing origin end": "",
        "missing target": "",
        "missing target start": "",
        "missing target end": "",
        "Find all references": "",
        "Finding references...": "",
        "Get document highlights": "",
        "Get document symbols": "",
        "invalid start": "",
        "invalid end": "",
        "invalid selection start": "",
        "invalid selection end": "",
        "Get signature help": "",
        "waiting for version for buffer {}": "",
        "Get hover": "",
        "Get completion": "",
        "no language server with id {server_id}": "",
        "completion out of expected range ": "",
        "completion out of expected range": "",
        "completion out of expected range, start: {start:?}, end: {end:?}, range: {range:?}": "",
        "completion (insert) out of expected range": "",
        "Get code actions": "",
        "Missing the language server that just returned a response {server_id}": "",
        "Formatting on typing": "",
        "lsp to project inlay hint conversion": "",
        "failed to serialize resolve json data": "",
        "incorrect proto inlay hint message: no resolve state in hint {message_hint:?}": "",
        "incorrect proto inlay hint message: non-json resolve state {lsp_resolve_state:?}": "",
        "No lsp resolve data for the hint that can be resolved: {message_hint:?}": "",
        "Unexpected resolve state {invalid} for hint {message_hint:?}": "",
        "missing label": "",
        "invalid uri in hint part {part:?}": "",
        "Inlay hints": "",
        "typescript-language-server": "",
        "lsp to project inlay hints conversion": "",
        "Code Lens": "",
        "deserializing proto code lens response": "",
        "Linked editing range": "",
        "deserializing diagnostics": "",
        "invalid start range": "",
        "invalid end range": "",
        "Get diagnostics": "",
        "missing url on buffer {}": "",
        "proto::GetDocumentDiagnostics is not expected to be converted from proto directly, as it needs `previous_result_id` fetched first": "",
        "serializing diagnostics": "",
        "Document color": "",
        "Unexpected state: file {uri} has two different sets of diagnostics reported": "",
        "E001": "",
        "test-source": "",
        "Test error message": "",
        "detail": "",
        "test detail": "",
        "Failed to serialize diagnostic": "",
        "ERR": "",
        "Prism": "",
        "assigned but unused variable - a": "",
        "Failed to deserialize diagnostic": "",
        "file:///test.rs": "",
        "Related info message": "",
        "Test message": ""
    },
    "zed/crates/project/src/lsp_store.rs": {
        "id:": "",
        "{number}": "",
        "{string}": "",
        "To find LSP adapter": "",
        "Expected `start_language_server` to ensure that `key` exists in a map": "",
        "attempting to start language server {:?}, path: {root_path:?}, id: {server_id}": "",
        "{err:#}": "",
        "{err:#}\\n-- stderr --\\n{log}": "",
        "Failed to start language server {server_name:?}: {err:?}": "",
        "server stderr: {log}": "",
        "Expected the LSP store to be in a local mode": "",
        "Failed to register server capabilities: {e:#}": "",
        "Failed to unregister server capabilities: {e:#}": "",
        "formatting buffer '{:?}'": "",
        "unknown": "",
        "transaction already open": "",
        "no formatting transaction": "",
        "no changes made while formatting": "",
        "forgetting format transaction": "",
        "Buffer edited while formatting. Aborting": "",
        "removing trailing whitespace": "",
        "ensuring final newline": "",
        "going to run code actions on format": "",
        "Formatter set to auto: defaulting to prettier": "",
        "Formatter set to auto: defaulting to primary language server": "",
        "Auto resolved above": "",
        "prettier": "",
        "formatting": "",
        "Formatting buffer via prettier": "",
        "No changes": "",
        "command": "",
        "Formatting buffer via external command": "",
        "Failed to format buffer via external command: {}": "",
        "language-server": "",
        "Formatting buffer using language server": "",
        "Cannot format buffer that is not backed by a file on disk using language servers. Skipping": "",
        "No language server found to format buffer '{:?}'. Skipping": "",
        "Formatting buffer '{:?}' using language server '{:?}'": "",
        "formatting ranges": "",
        "Failed to format ranges via language server": "",
        "formatting full": "",
        "failed to format via language server": "",
        "code-actions": "",
        "Formatting buffer using code actions": "",
        "Cannot format buffer that is not backed by a file on disk using code actions. Skipping": "",
        "Attempting to resolve code actions {:?}": "",
        "Failed to resolve code action {:?} with language server {}": "",
        "No code actions were resolved, continuing": "",
        "code action '{}' with title \\\"{}\\\" on server {}": "",
        "Executing {}": "",
        "Failed to resolve {}. Error: {}": "",
        "No changes for code action. Skipping {}": "",
        "Code actions which create, delete, or rename files are not supported on format. Skipping {}": "",
        "Failed to convert URI '{:?}' to file path. Skipping {}": "",
        "File path '{:?}' does not match buffer path '{:?}'. Skipping {}": "",
        "Code actions which produce snippet edits are not supported during formatting. Skipping {}": "",
        "Failed to resolve edits from LSP for buffer {:?} while handling {}": "",
        "No edits resolved from LSP": "",
        "Applying edits {edits:?}. Content: {:?}": "",
        "Applied edits. New Content: {:?}": "",
        "Executing code action command '{}'. This may cause formatting to abort unnecessarily as well as splitting formatting into two entries in the undo history": "",
        "Cannot execute a command {} not listed in the language server capabilities of server {}": "",
        "Executing command {}": "",
        "Failed to execute command '{}' as part of {}": "",
        "Successfully captured {} edits that resulted from command {}": "",
        ", ": "",
        "Unexpected edits to buffers other than the buffer actively being formatted due to command {}. Impacted buffers: [{}].": "",
        "{} language server does not support range formatting": "",
        "lsp_format": "",
        "Formatting via LSP": "",
        "format-full": "",
        "format-range": "",
        "{buffer_path}": "",
        "Untitled": "",
        "failed to acquire stdin": "",
        "command failed with exit code {:?}:\\nstdout: {}\\nstderr: {}": "",
        "{old_path:?} is not parseable as an URI": "",
        "no snapshots found for buffer {buffer_id} and server {server_id}": "",
        "snapshot not found for buffer {buffer_id} server {server_id} at version {version}": "",
        "resolving a formatting code action": "",
        "project dropped": "",
        "execute command": "",
        "Cannot execute a command {} not listed in the language server capabilities": "",
        "can't convert URI to path": "",
        "project project closed": "",
        "language server not found": "",
        "Processing new watcher paths for language server with id {}": "",
        "Failed to strip prefix for string pattern: {}, with prefix: {}, with error: {}": "",
        "Failed to strip prefix for relative pattern: {}, with prefix: {}, with error: {}": "",
        "language server {}: unregistered workspace/DidChangeWatchedFiles capability with id {}": "",
        "language server {}: failed to unregister workspace/DidChangeWatchedFiles capability with id {}. not registered.": "",
        "language-less": "",
        "bad refcounting": "",
        "{} via {} failed: {}": "",
        "content modified": "",
        "{message}": "",
        "no app context": "",
        "missing transaction": "",
        "resolving a code action": "",
        "no app present": "",
        "no upstream client and not local": "",
        "Inlay hint resolve failed: {e:#}": "",
        "Did not change hint's resolve state after spawning its resolve": "",
        "inlay hints proto request": "",
        "inlay hints proto resolve response conversion": "",
        "inlay hint resolve LSP request": "",
        "color presentation proto request": "",
        "buffer with the missing path": "",
        "color presentation resolve LSP request": "",
        "No upstream client or local language server": "",
        "fetching code lens": "",
        "{e:#}": "",
        "Failed to fetch code lens": "",
        "Fetching completions from server {server_id} timed out, timeout ms: {}": "",
        "server_id mismatch, querying completion resolve for {server_id} but completion server id is {completion_server_id}": "",
        "resolve completion": "",
        "server_id mismatch, applying completion resolve for {server_id} but completion server id is {completion_server_id}": "",
        ",\n                completion.label.text(),\n                new_label.text(),\n                completion.label.filter_text(),\n                new_label.filter_text()\n            );\n        }\n\n        Ok(())\n    }\n\n    async fn resolve_completion_remote(\n        project_id: u64,\n        server_id: LanguageServerId,\n        buffer_id: BufferId,\n        completions: Rc<RefCell<Box<[Completion]>>>,\n        completion_index: usize,\n        client: AnyProtoClient,\n    ) -> Result<()> {\n        let lsp_completion = {\n            let completion = &completions.borrow()[completion_index];\n            match &completion.source {\n                CompletionSource::Lsp {\n                    lsp_completion,\n                    resolved,\n                    server_id: completion_server_id,\n                    ..\n                } => {\n                    anyhow::ensure!(\n                        server_id == *completion_server_id,\n                        ": "",
        "\n                    );\n                    if *resolved {\n                        return Ok(());\n                    }\n                    serde_json::to_string(lsp_completion).unwrap().into_bytes()\n                }\n                CompletionSource::Custom\n                | CompletionSource::Dap { .. }\n                | CompletionSource::BufferWord { .. } => {\n                    return Ok(());\n                }\n            }\n        };\n        let request = proto::ResolveCompletionDocumentation {\n            project_id,\n            language_server_id: server_id.0 as u64,\n            lsp_completion,\n            buffer_id: buffer_id.into(),\n        };\n\n        let response = client\n            .request(request)\n            .await\n            .context(": "",
        ")?;\n        let resolved_lsp_completion = serde_json::from_slice(&response.lsp_completion)?;\n\n        let documentation = if response.documentation.is_empty() {\n            CompletionDocumentation::Undocumented\n        } else if response.documentation_is_markdown {\n            CompletionDocumentation::MultiLineMarkdown(response.documentation.into())\n        } else if response.documentation.lines().count() <= 1 {\n            CompletionDocumentation::SingleLine(response.documentation.into())\n        } else {\n            CompletionDocumentation::MultiLinePlainText(response.documentation.into())\n        };\n\n        let mut completions = completions.borrow_mut();\n        let completion = &mut completions[completion_index];\n        completion.documentation = Some(documentation);\n        if let CompletionSource::Lsp {\n            insert_range,\n            lsp_completion,\n            resolved,\n            server_id: completion_server_id,\n            lsp_defaults: _,\n        } = &mut completion.source\n        {\n            let completion_insert_range = response\n                .old_insert_start\n                .and_then(deserialize_anchor)\n                .zip(response.old_insert_end.and_then(deserialize_anchor));\n            *insert_range = completion_insert_range.map(|(start, end)| start..end);\n\n            if *resolved {\n                return Ok(());\n            }\n            anyhow::ensure!(\n                server_id == *completion_server_id,\n                ": "",
        "\n            );\n            *lsp_completion = Box::new(resolved_lsp_completion);\n            *resolved = true;\n        }\n\n        let replace_range = response\n            .old_replace_start\n            .and_then(deserialize_anchor)\n            .zip(response.old_replace_end.and_then(deserialize_anchor));\n        if let Some((old_replace_start, old_replace_end)) = replace_range\n            && !response.new_text.is_empty()\n        {\n            completion.new_text = response.new_text;\n            completion.replace_range = old_replace_start..old_replace_end;\n        }\n\n        Ok(())\n    }\n\n    pub fn apply_additional_edits_for_completion(\n        &self,\n        buffer_handle: Entity<Buffer>,\n        completions: Rc<RefCell<Box<[Completion]>>>,\n        completion_index: usize,\n        push_to_history: bool,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Option<Transaction>>> {\n        if let Some((client, project_id)) = self.upstream_client() {\n            let buffer = buffer_handle.read(cx);\n            let buffer_id = buffer.remote_id();\n            cx.spawn(async move |_, cx| {\n                let request = {\n                    let completion = completions.borrow()[completion_index].clone();\n                    proto::ApplyCompletionAdditionalEdits {\n                        project_id,\n                        buffer_id: buffer_id.into(),\n                        completion: Some(Self::serialize_completion(&CoreCompletion {\n                            replace_range: completion.replace_range,\n                            new_text: completion.new_text,\n                            source: completion.source,\n                        })),\n                    }\n                };\n\n                if let Some(transaction) = client.request(request).await?.transaction {\n                    let transaction = language::proto::deserialize_transaction(transaction)?;\n                    buffer_handle\n                        .update(cx, |buffer, _| {\n                            buffer.wait_for_edits(transaction.edit_ids.iter().copied())\n                        })?\n                        .await?;\n                    if push_to_history {\n                        buffer_handle.update(cx, |buffer, _| {\n                            buffer.push_transaction(transaction.clone(), Instant::now());\n                            buffer.finalize_last_transaction();\n                        })?;\n                    }\n                    Ok(Some(transaction))\n                } else {\n                    Ok(None)\n                }\n            })\n        } else {\n            let Some(server) = buffer_handle.update(cx, |buffer, cx| {\n                let completion = &completions.borrow()[completion_index];\n                let server_id = completion.source.server_id()?;\n                Some(\n                    self.language_server_for_local_buffer(buffer, server_id, cx)?\n                        .1\n                        .clone(),\n                )\n            }) else {\n                return Task::ready(Ok(None));\n            };\n\n            cx.spawn(async move |this, cx| {\n                Self::resolve_completion_local(\n                    server.clone(),\n                    completions.clone(),\n                    completion_index,\n                )\n                .await\n                .context(": "",
        ")?;\n                let completion = completions.borrow()[completion_index].clone();\n                let additional_text_edits = completion\n                    .source\n                    .lsp_completion(true)\n                    .as_ref()\n                    .and_then(|lsp_completion| lsp_completion.additional_text_edits.clone());\n                if let Some(edits) = additional_text_edits {\n                    let edits = this\n                        .update(cx, |this, cx| {\n                            this.as_local_mut().unwrap().edits_from_lsp(\n                                &buffer_handle,\n                                edits,\n                                server.server_id(),\n                                None,\n                                cx,\n                            )\n                        })?\n                        .await?;\n\n                    buffer_handle.update(cx, |buffer, cx| {\n                        buffer.finalize_last_transaction();\n                        buffer.start_transaction();\n\n                        for (range, text) in edits {\n                            let primary = &completion.replace_range;\n\n                            // Special case: if both ranges start at the very beginning of the file (line 0, column 0),\n                            // and the primary completion is just an insertion (empty range), then this is likely\n                            // an auto-import scenario and should not be considered overlapping\n                            // https://github.com/zed-industries/zed/issues/26136\n                            let is_file_start_auto_import = {\n                                let snapshot = buffer.snapshot();\n                                let primary_start_point = primary.start.to_point(&snapshot);\n                                let range_start_point = range.start.to_point(&snapshot);\n\n                                let result = primary_start_point.row == 0\n                                    && primary_start_point.column == 0\n                                    && range_start_point.row == 0\n                                    && range_start_point.column == 0;\n\n                                result\n                            };\n\n                            let has_overlap = if is_file_start_auto_import {\n                                false\n                            } else {\n                                let start_within = primary.start.cmp(&range.start, buffer).is_le()\n                                    && primary.end.cmp(&range.start, buffer).is_ge();\n                                let end_within = range.start.cmp(&primary.end, buffer).is_le()\n                                    && range.end.cmp(&primary.end, buffer).is_ge();\n                                let result = start_within || end_within;\n                                result\n                            };\n\n                            //Skip additional edits which overlap with the primary completion edit\n                            //https://github.com/zed-industries/zed/pull/1871\n                            if !has_overlap {\n                                buffer.edit([(range, text)], None, cx);\n                            }\n                        }\n\n                        let transaction = if buffer.end_transaction(cx).is_some() {\n                            let transaction = buffer.finalize_last_transaction().unwrap().clone();\n                            if !push_to_history {\n                                buffer.forget_transaction(transaction.id);\n                            }\n                            Some(transaction)\n                        } else {\n                            None\n                        };\n                        Ok(transaction)\n                    })?\n                } else {\n                    Ok(None)\n                }\n            })\n        }\n    }\n\n    pub fn pull_diagnostics(\n        &mut self,\n        buffer: Entity<Buffer>,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Option<Vec<LspPullDiagnostics>>>> {\n        let buffer_id = buffer.read(cx).remote_id();\n\n        if let Some((client, upstream_project_id)) = self.upstream_client() {\n            let mut suitable_capabilities = None;\n            // Are we capable for proto request?\n            let any_server_has_diagnostics_provider = self.check_if_capable_for_proto_request(\n                &buffer,\n                |capabilities| {\n                    if let Some(caps) = &capabilities.diagnostic_provider {\n                        suitable_capabilities = Some(caps.clone());\n                        true\n                    } else {\n                        false\n                    }\n                },\n                cx,\n            );\n            // We don't really care which caps are passed into the request, as they're ignored by RPC anyways.\n            let Some(dynamic_caps) = suitable_capabilities else {\n                return Task::ready(Ok(None));\n            };\n            assert!(any_server_has_diagnostics_provider);\n\n            let request = GetDocumentDiagnostics {\n                previous_result_id: None,\n                dynamic_caps,\n            };\n            let request_task = client.request_lsp(\n                upstream_project_id,\n                None,\n                LSP_REQUEST_TIMEOUT,\n                cx.background_executor().clone(),\n                request.to_proto(upstream_project_id, buffer.read(cx)),\n            );\n            cx.background_spawn(async move {\n                // Proto requests cause the diagnostics to be pulled from language server(s) on the local side\n                // and then, buffer state updated with the diagnostics received, which will be later propagated to the client.\n                // Do not attempt to further process the dummy responses here.\n                let _response = request_task.await?;\n                Ok(None)\n            })\n        } else {\n            let servers = buffer.update(cx, |buffer, cx| {\n                self.language_servers_for_local_buffer(buffer, cx)\n                    .map(|(_, server)| server.clone())\n                    .collect::<Vec<_>>()\n            });\n\n            let pull_diagnostics = servers\n                .into_iter()\n                .flat_map(|server| {\n                    let result = maybe!({\n                        let local = self.as_local()?;\n                        let server_id = server.server_id();\n                        let providers_with_identifiers = local\n                            .language_server_dynamic_registrations\n                            .get(&server_id)\n                            .into_iter()\n                            .flat_map(|registrations| registrations.diagnostics.values().cloned())\n                            .collect::<Vec<_>>();\n                        Some(\n                            providers_with_identifiers\n                                .into_iter()\n                                .map(|dynamic_caps| {\n                                    let result_id = self.result_id(server_id, buffer_id, cx);\n                                    self.request_lsp(\n                                        buffer.clone(),\n                                        LanguageServerToQuery::Other(server_id),\n                                        GetDocumentDiagnostics {\n                                            previous_result_id: result_id,\n                                            dynamic_caps,\n                                        },\n                                        cx,\n                                    )\n                                })\n                                .collect::<Vec<_>>(),\n                        )\n                    });\n\n                    result.unwrap_or_default()\n                })\n                .collect::<Vec<_>>();\n\n            cx.background_spawn(async move {\n                let mut responses = Vec::new();\n                for diagnostics in join_all(pull_diagnostics).await {\n                    responses.extend(diagnostics?);\n                }\n                Ok(Some(responses))\n            })\n        }\n    }\n\n    pub fn applicable_inlay_chunks(\n        &mut self,\n        buffer: &Entity<Buffer>,\n        ranges: &[Range<text::Anchor>],\n        cx: &mut Context<Self>,\n    ) -> Vec<Range<BufferRow>> {\n        self.latest_lsp_data(buffer, cx)\n            .inlay_hints\n            .applicable_chunks(ranges)\n            .map(|chunk| chunk.start..chunk.end)\n            .collect()\n    }\n\n    pub fn invalidate_inlay_hints<'a>(\n        &'a mut self,\n        for_buffers: impl IntoIterator<Item = &'a BufferId> + 'a,\n    ) {\n        for buffer_id in for_buffers {\n            if let Some(lsp_data) = self.lsp_data.get_mut(buffer_id) {\n                lsp_data.inlay_hints.clear();\n            }\n        }\n    }\n\n    pub fn inlay_hints(\n        &mut self,\n        invalidate: InvalidationStrategy,\n        buffer: Entity<Buffer>,\n        ranges: Vec<Range<text::Anchor>>,\n        known_chunks: Option<(clock::Global, HashSet<Range<BufferRow>>)>,\n        cx: &mut Context<Self>,\n    ) -> HashMap<Range<BufferRow>, Task<Result<CacheInlayHints>>> {\n        let buffer_snapshot = buffer.read(cx).snapshot();\n        let next_hint_id = self.next_hint_id.clone();\n        let lsp_data = self.latest_lsp_data(&buffer, cx);\n        let mut lsp_refresh_requested = false;\n        let for_server = if let InvalidationStrategy::RefreshRequested {\n            server_id,\n            request_id,\n        } = invalidate\n        {\n            let invalidated = lsp_data\n                .inlay_hints\n                .invalidate_for_server_refresh(server_id, request_id);\n            lsp_refresh_requested = invalidated;\n            Some(server_id)\n        } else {\n            None\n        };\n        let existing_inlay_hints = &mut lsp_data.inlay_hints;\n        let known_chunks = known_chunks\n            .filter(|(known_version, _)| !lsp_data.buffer_version.changed_since(known_version))\n            .map(|(_, known_chunks)| known_chunks)\n            .unwrap_or_default();\n\n        let mut hint_fetch_tasks = Vec::new();\n        let mut cached_inlay_hints = None;\n        let mut ranges_to_query = None;\n        let applicable_chunks = existing_inlay_hints\n            .applicable_chunks(ranges.as_slice())\n            .filter(|chunk| !known_chunks.contains(&(chunk.start..chunk.end)))\n            .collect::<Vec<_>>();\n        if applicable_chunks.is_empty() {\n            return HashMap::default();\n        }\n\n        let last_chunk_number = existing_inlay_hints.buffer_chunks_len() - 1;\n\n        for row_chunk in applicable_chunks {\n            match (\n                existing_inlay_hints\n                    .cached_hints(&row_chunk)\n                    .filter(|_| !lsp_refresh_requested)\n                    .cloned(),\n                existing_inlay_hints\n                    .fetched_hints(&row_chunk)\n                    .as_ref()\n                    .filter(|_| !lsp_refresh_requested)\n                    .cloned(),\n            ) {\n                (None, None) => {\n                    let end = if last_chunk_number == row_chunk.id {\n                        Point::new(row_chunk.end, buffer_snapshot.line_len(row_chunk.end))\n                    } else {\n                        Point::new(row_chunk.end, 0)\n                    };\n                    ranges_to_query.get_or_insert_with(Vec::new).push((\n                        row_chunk,\n                        buffer_snapshot.anchor_before(Point::new(row_chunk.start, 0))\n                            ..buffer_snapshot.anchor_after(end),\n                    ));\n                }\n                (None, Some(fetched_hints)) => hint_fetch_tasks.push((row_chunk, fetched_hints)),\n                (Some(cached_hints), None) => {\n                    for (server_id, cached_hints) in cached_hints {\n                        if for_server.is_none_or(|for_server| for_server == server_id) {\n                            cached_inlay_hints\n                                .get_or_insert_with(HashMap::default)\n                                .entry(row_chunk.start..row_chunk.end)\n                                .or_insert_with(HashMap::default)\n                                .entry(server_id)\n                                .or_insert_with(Vec::new)\n                                .extend(cached_hints);\n                        }\n                    }\n                }\n                (Some(cached_hints), Some(fetched_hints)) => {\n                    hint_fetch_tasks.push((row_chunk, fetched_hints));\n                    for (server_id, cached_hints) in cached_hints {\n                        if for_server.is_none_or(|for_server| for_server == server_id) {\n                            cached_inlay_hints\n                                .get_or_insert_with(HashMap::default)\n                                .entry(row_chunk.start..row_chunk.end)\n                                .or_insert_with(HashMap::default)\n                                .entry(server_id)\n                                .or_insert_with(Vec::new)\n                                .extend(cached_hints);\n                        }\n                    }\n                }\n            }\n        }\n\n        if hint_fetch_tasks.is_empty()\n            && ranges_to_query\n                .as_ref()\n                .is_none_or(|ranges| ranges.is_empty())\n            && let Some(cached_inlay_hints) = cached_inlay_hints\n        {\n            cached_inlay_hints\n                .into_iter()\n                .map(|(row_chunk, hints)| (row_chunk, Task::ready(Ok(hints))))\n                .collect()\n        } else {\n            for (chunk, range_to_query) in ranges_to_query.into_iter().flatten() {\n                let next_hint_id = next_hint_id.clone();\n                let buffer = buffer.clone();\n                let new_inlay_hints = cx\n                    .spawn(async move |lsp_store, cx| {\n                        let new_fetch_task = lsp_store.update(cx, |lsp_store, cx| {\n                            lsp_store.fetch_inlay_hints(for_server, &buffer, range_to_query, cx)\n                        })?;\n                        new_fetch_task\n                            .await\n                            .and_then(|new_hints_by_server| {\n                                lsp_store.update(cx, |lsp_store, cx| {\n                                    let lsp_data = lsp_store.latest_lsp_data(&buffer, cx);\n                                    let update_cache = !lsp_data\n                                        .buffer_version\n                                        .changed_since(&buffer.read(cx).version());\n                                    if new_hints_by_server.is_empty() {\n                                        if update_cache {\n                                            lsp_data.inlay_hints.invalidate_for_chunk(chunk);\n                                        }\n                                        HashMap::default()\n                                    } else {\n                                        new_hints_by_server\n                                            .into_iter()\n                                            .map(|(server_id, new_hints)| {\n                                                let new_hints = new_hints\n                                                    .into_iter()\n                                                    .map(|new_hint| {\n                                                        (\n                                                            InlayId::Hint(next_hint_id.fetch_add(\n                                                                1,\n                                                                atomic::Ordering::AcqRel,\n                                                            )),\n                                                            new_hint,\n                                                        )\n                                                    })\n                                                    .collect::<Vec<_>>();\n                                                if update_cache {\n                                                    lsp_data.inlay_hints.insert_new_hints(\n                                                        chunk,\n                                                        server_id,\n                                                        new_hints.clone(),\n                                                    );\n                                                }\n                                                (server_id, new_hints)\n                                            })\n                                            .collect()\n                                    }\n                                })\n                            })\n                            .map_err(Arc::new)\n                    })\n                    .shared();\n\n                let fetch_task = lsp_data.inlay_hints.fetched_hints(&chunk);\n                *fetch_task = Some(new_inlay_hints.clone());\n                hint_fetch_tasks.push((chunk, new_inlay_hints));\n            }\n\n            cached_inlay_hints\n                .unwrap_or_default()\n                .into_iter()\n                .map(|(row_chunk, hints)| (row_chunk, Task::ready(Ok(hints))))\n                .chain(hint_fetch_tasks.into_iter().map(|(chunk, hints_fetch)| {\n                    (\n                        chunk.start..chunk.end,\n                        cx.spawn(async move |_, _| {\n                            hints_fetch.await.map_err(|e| {\n                                if e.error_code() != ErrorCode::Internal {\n                                    anyhow!(e.error_code())\n                                } else {\n                                    anyhow!(": "",
        ")\n                                }\n                            })\n                        }),\n                    )\n                }))\n                .collect()\n        }\n    }\n\n    fn fetch_inlay_hints(\n        &mut self,\n        for_server: Option<LanguageServerId>,\n        buffer: &Entity<Buffer>,\n        range: Range<Anchor>,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<HashMap<LanguageServerId, Vec<InlayHint>>>> {\n        let request = InlayHints {\n            range: range.clone(),\n        };\n        if let Some((upstream_client, project_id)) = self.upstream_client() {\n            if !self.is_capable_for_proto_request(buffer, &request, cx) {\n                return Task::ready(Ok(HashMap::default()));\n            }\n            let request_task = upstream_client.request_lsp(\n                project_id,\n                for_server.map(|id| id.to_proto()),\n                LSP_REQUEST_TIMEOUT,\n                cx.background_executor().clone(),\n                request.to_proto(project_id, buffer.read(cx)),\n            );\n            let buffer = buffer.clone();\n            cx.spawn(async move |weak_lsp_store, cx| {\n                let Some(lsp_store) = weak_lsp_store.upgrade() else {\n                    return Ok(HashMap::default());\n                };\n                let Some(responses) = request_task.await? else {\n                    return Ok(HashMap::default());\n                };\n\n                let inlay_hints = join_all(responses.payload.into_iter().map(|response| {\n                    let lsp_store = lsp_store.clone();\n                    let buffer = buffer.clone();\n                    let cx = cx.clone();\n                    let request = request.clone();\n                    async move {\n                        (\n                            LanguageServerId::from_proto(response.server_id),\n                            request\n                                .response_from_proto(response.response, lsp_store, buffer, cx)\n                                .await,\n                        )\n                    }\n                }))\n                .await;\n\n                let mut has_errors = false;\n                let inlay_hints = inlay_hints\n                    .into_iter()\n                    .filter_map(|(server_id, inlay_hints)| match inlay_hints {\n                        Ok(inlay_hints) => Some((server_id, inlay_hints)),\n                        Err(e) => {\n                            has_errors = true;\n                            log::error!(": "",
        ");\n                            None\n                        }\n                    })\n                    .collect::<HashMap<_, _>>();\n                anyhow::ensure!(\n                    !has_errors || !inlay_hints.is_empty(),\n                    ": "",
        "\n                );\n                Ok(inlay_hints)\n            })\n        } else {\n            let inlay_hints_task = match for_server {\n                Some(server_id) => {\n                    let server_task = self.request_lsp(\n                        buffer.clone(),\n                        LanguageServerToQuery::Other(server_id),\n                        request,\n                        cx,\n                    );\n                    cx.background_spawn(async move {\n                        let mut responses = Vec::new();\n                        match server_task.await {\n                            Ok(response) => responses.push((server_id, response)),\n                            // rust-analyzer likes to error with this when its still loading up\n                            Err(e) if format!(": "",
        ").ends_with(": "",
        ") => (),\n                            Err(e) => log::error!(\n                                ": "",
        "\n                            ),\n                        }\n                        responses\n                    })\n                }\n                None => self.request_multiple_lsp_locally(buffer, None::<usize>, request, cx),\n            };\n            let buffer_snapshot = buffer.read_with(cx, |buffer, _| buffer.snapshot());\n            cx.background_spawn(async move {\n                Ok(inlay_hints_task\n                    .await\n                    .into_iter()\n                    .map(|(server_id, mut new_hints)| {\n                        new_hints.retain(|hint| {\n                            hint.position.is_valid(&buffer_snapshot)\n                                && range.start.is_valid(&buffer_snapshot)\n                                && range.end.is_valid(&buffer_snapshot)\n                                && hint.position.cmp(&range.start, &buffer_snapshot).is_ge()\n                                && hint.position.cmp(&range.end, &buffer_snapshot).is_lt()\n                        });\n                        (server_id, new_hints)\n                    })\n                    .collect())\n            })\n        }\n    }\n\n    pub fn pull_diagnostics_for_buffer(\n        &mut self,\n        buffer: Entity<Buffer>,\n        cx: &mut Context<Self>,\n    ) -> Task<anyhow::Result<()>> {\n        let diagnostics = self.pull_diagnostics(buffer, cx);\n        cx.spawn(async move |lsp_store, cx| {\n            let Some(diagnostics) = diagnostics.await.context(": "",
        ")? else {\n                return Ok(());\n            };\n            lsp_store.update(cx, |lsp_store, cx| {\n                if lsp_store.as_local().is_none() {\n                    return;\n                }\n\n                let mut unchanged_buffers = HashSet::default();\n                let mut changed_buffers = HashSet::default();\n                let server_diagnostics_updates = diagnostics\n                    .into_iter()\n                    .filter_map(|diagnostics_set| match diagnostics_set {\n                        LspPullDiagnostics::Response {\n                            server_id,\n                            uri,\n                            diagnostics,\n                        } => Some((server_id, uri, diagnostics)),\n                        LspPullDiagnostics::Default => None,\n                    })\n                    .fold(\n                        HashMap::default(),\n                        |mut acc, (server_id, uri, diagnostics)| {\n                            let (result_id, diagnostics) = match diagnostics {\n                                PulledDiagnostics::Unchanged { result_id } => {\n                                    unchanged_buffers.insert(uri.clone());\n                                    (Some(result_id), Vec::new())\n                                }\n                                PulledDiagnostics::Changed {\n                                    result_id,\n                                    diagnostics,\n                                } => {\n                                    changed_buffers.insert(uri.clone());\n                                    (result_id, diagnostics)\n                                }\n                            };\n                            let disk_based_sources = Cow::Owned(\n                                lsp_store\n                                    .language_server_adapter_for_id(server_id)\n                                    .as_ref()\n                                    .map(|adapter| adapter.disk_based_diagnostic_sources.as_slice())\n                                    .unwrap_or(&[])\n                                    .to_vec(),\n                            );\n                            acc.entry(server_id).or_insert_with(Vec::new).push(\n                                DocumentDiagnosticsUpdate {\n                                    server_id,\n                                    diagnostics: lsp::PublishDiagnosticsParams {\n                                        uri,\n                                        diagnostics,\n                                        version: None,\n                                    },\n                                    result_id,\n                                    disk_based_sources,\n                                },\n                            );\n                            acc\n                        },\n                    );\n\n                for diagnostic_updates in server_diagnostics_updates.into_values() {\n                    lsp_store\n                        .merge_lsp_diagnostics(\n                            DiagnosticSourceKind::Pulled,\n                            diagnostic_updates,\n                            |buffer, old_diagnostic, cx| {\n                                File::from_dyn(buffer.file())\n                                    .and_then(|file| {\n                                        let abs_path = file.as_local()?.abs_path(cx);\n                                        lsp::Uri::from_file_path(abs_path).ok()\n                                    })\n                                    .is_none_or(|buffer_uri| {\n                                        unchanged_buffers.contains(&buffer_uri)\n                                            || match old_diagnostic.source_kind {\n                                                DiagnosticSourceKind::Pulled => {\n                                                    !changed_buffers.contains(&buffer_uri)\n                                                }\n                                                DiagnosticSourceKind::Other\n                                                | DiagnosticSourceKind::Pushed => true,\n                                            }\n                                    })\n                            },\n                            cx,\n                        )\n                        .log_err();\n                }\n            })\n        })\n    }\n\n    pub fn document_colors(\n        &mut self,\n        known_cache_version: Option<usize>,\n        buffer: Entity<Buffer>,\n        cx: &mut Context<Self>,\n    ) -> Option<DocumentColorTask> {\n        let version_queried_for = buffer.read(cx).version();\n        let buffer_id = buffer.read(cx).remote_id();\n\n        let current_language_servers = self.as_local().map(|local| {\n            local\n                .buffers_opened_in_servers\n                .get(&buffer_id)\n                .cloned()\n                .unwrap_or_default()\n        });\n\n        if let Some(lsp_data) = self.current_lsp_data(buffer_id) {\n            if let Some(cached_colors) = &lsp_data.document_colors {\n                if !version_queried_for.changed_since(&lsp_data.buffer_version) {\n                    let has_different_servers =\n                        current_language_servers.is_some_and(|current_language_servers| {\n                            current_language_servers\n                                != cached_colors.colors.keys().copied().collect()\n                        });\n                    if !has_different_servers {\n                        let cache_version = cached_colors.cache_version;\n                        if Some(cache_version) == known_cache_version {\n                            return None;\n                        } else {\n                            return Some(\n                                Task::ready(Ok(DocumentColors {\n                                    colors: cached_colors\n                                        .colors\n                                        .values()\n                                        .flatten()\n                                        .cloned()\n                                        .collect(),\n                                    cache_version: Some(cache_version),\n                                }))\n                                .shared(),\n                            );\n                        }\n                    }\n                }\n            }\n        }\n\n        let color_lsp_data = self\n            .latest_lsp_data(&buffer, cx)\n            .document_colors\n            .get_or_insert_default();\n        if let Some((updating_for, running_update)) = &color_lsp_data.colors_update\n            && !version_queried_for.changed_since(updating_for)\n        {\n            return Some(running_update.clone());\n        }\n        let buffer_version_queried_for = version_queried_for.clone();\n        let new_task = cx\n            .spawn(async move |lsp_store, cx| {\n                cx.background_executor()\n                    .timer(Duration::from_millis(30))\n                    .await;\n                let fetched_colors = lsp_store\n                    .update(cx, |lsp_store, cx| {\n                        lsp_store.fetch_document_colors_for_buffer(&buffer, cx)\n                    })?\n                    .await\n                    .context(": "",
        ")\n                    .map_err(Arc::new);\n                let fetched_colors = match fetched_colors {\n                    Ok(fetched_colors) => {\n                        if Some(true)\n                            == buffer\n                                .update(cx, |buffer, _| {\n                                    buffer.version() != buffer_version_queried_for\n                                })\n                                .ok()\n                        {\n                            return Ok(DocumentColors::default());\n                        }\n                        fetched_colors\n                    }\n                    Err(e) => {\n                        lsp_store\n                            .update(cx, |lsp_store, _| {\n                                if let Some(lsp_data) = lsp_store.lsp_data.get_mut(&buffer_id) {\n                                    if let Some(document_colors) = &mut lsp_data.document_colors {\n                                        document_colors.colors_update = None;\n                                    }\n                                }\n                            })\n                            .ok();\n                        return Err(e);\n                    }\n                };\n\n                lsp_store\n                    .update(cx, |lsp_store, cx| {\n                        let lsp_data = lsp_store.latest_lsp_data(&buffer, cx);\n                        let lsp_colors = lsp_data.document_colors.get_or_insert_default();\n\n                        if let Some(fetched_colors) = fetched_colors {\n                            if lsp_data.buffer_version == buffer_version_queried_for {\n                                lsp_colors.colors.extend(fetched_colors);\n                                lsp_colors.cache_version += 1;\n                            } else if !lsp_data\n                                .buffer_version\n                                .changed_since(&buffer_version_queried_for)\n                            {\n                                lsp_data.buffer_version = buffer_version_queried_for;\n                                lsp_colors.colors = fetched_colors;\n                                lsp_colors.cache_version += 1;\n                            }\n                        }\n                        lsp_colors.colors_update = None;\n                        let colors = lsp_colors\n                            .colors\n                            .values()\n                            .flatten()\n                            .cloned()\n                            .collect::<HashSet<_>>();\n                        DocumentColors {\n                            colors,\n                            cache_version: Some(lsp_colors.cache_version),\n                        }\n                    })\n                    .map_err(Arc::new)\n            })\n            .shared();\n        color_lsp_data.colors_update = Some((version_queried_for, new_task.clone()));\n        Some(new_task)\n    }\n\n    fn fetch_document_colors_for_buffer(\n        &mut self,\n        buffer: &Entity<Buffer>,\n        cx: &mut Context<Self>,\n    ) -> Task<anyhow::Result<Option<HashMap<LanguageServerId, HashSet<DocumentColor>>>>> {\n        if let Some((client, project_id)) = self.upstream_client() {\n            let request = GetDocumentColor {};\n            if !self.is_capable_for_proto_request(buffer, &request, cx) {\n                return Task::ready(Ok(None));\n            }\n\n            let request_task = client.request_lsp(\n                project_id,\n                None,\n                LSP_REQUEST_TIMEOUT,\n                cx.background_executor().clone(),\n                request.to_proto(project_id, buffer.read(cx)),\n            );\n            let buffer = buffer.clone();\n            cx.spawn(async move |lsp_store, cx| {\n                let Some(lsp_store) = lsp_store.upgrade() else {\n                    return Ok(None);\n                };\n                let colors = join_all(\n                    request_task\n                        .await\n                        .log_err()\n                        .flatten()\n                        .map(|response| response.payload)\n                        .unwrap_or_default()\n                        .into_iter()\n                        .map(|color_response| {\n                            let response = request.response_from_proto(\n                                color_response.response,\n                                lsp_store.clone(),\n                                buffer.clone(),\n                                cx.clone(),\n                            );\n                            async move {\n                                (\n                                    LanguageServerId::from_proto(color_response.server_id),\n                                    response.await.log_err().unwrap_or_default(),\n                                )\n                            }\n                        }),\n                )\n                .await\n                .into_iter()\n                .fold(HashMap::default(), |mut acc, (server_id, colors)| {\n                    acc.entry(server_id)\n                        .or_insert_with(HashSet::default)\n                        .extend(colors);\n                    acc\n                });\n                Ok(Some(colors))\n            })\n        } else {\n            let document_colors_task =\n                self.request_multiple_lsp_locally(buffer, None::<usize>, GetDocumentColor, cx);\n            cx.background_spawn(async move {\n                Ok(Some(\n                    document_colors_task\n                        .await\n                        .into_iter()\n                        .fold(HashMap::default(), |mut acc, (server_id, colors)| {\n                            acc.entry(server_id)\n                                .or_insert_with(HashSet::default)\n                                .extend(colors);\n                            acc\n                        })\n                        .into_iter()\n                        .collect(),\n                ))\n            })\n        }\n    }\n\n    pub fn signature_help<T: ToPointUtf16>(\n        &mut self,\n        buffer: &Entity<Buffer>,\n        position: T,\n        cx: &mut Context<Self>,\n    ) -> Task<Option<Vec<SignatureHelp>>> {\n        let position = position.to_point_utf16(buffer.read(cx));\n\n        if let Some((client, upstream_project_id)) = self.upstream_client() {\n            let request = GetSignatureHelp { position };\n            if !self.is_capable_for_proto_request(buffer, &request, cx) {\n                return Task::ready(None);\n            }\n            let request_task = client.request_lsp(\n                upstream_project_id,\n                None,\n                LSP_REQUEST_TIMEOUT,\n                cx.background_executor().clone(),\n                request.to_proto(upstream_project_id, buffer.read(cx)),\n            );\n            let buffer = buffer.clone();\n            cx.spawn(async move |weak_lsp_store, cx| {\n                let lsp_store = weak_lsp_store.upgrade()?;\n                let signatures = join_all(\n                    request_task\n                        .await\n                        .log_err()\n                        .flatten()\n                        .map(|response| response.payload)\n                        .unwrap_or_default()\n                        .into_iter()\n                        .map(|response| {\n                            let response = GetSignatureHelp { position }.response_from_proto(\n                                response.response,\n                                lsp_store.clone(),\n                                buffer.clone(),\n                                cx.clone(),\n                            );\n                            async move { response.await.log_err().flatten() }\n                        }),\n                )\n                .await\n                .into_iter()\n                .flatten()\n                .collect();\n                Some(signatures)\n            })\n        } else {\n            let all_actions_task = self.request_multiple_lsp_locally(\n                buffer,\n                Some(position),\n                GetSignatureHelp { position },\n                cx,\n            );\n            cx.background_spawn(async move {\n                Some(\n                    all_actions_task\n                        .await\n                        .into_iter()\n                        .flat_map(|(_, actions)| actions)\n                        .collect::<Vec<_>>(),\n                )\n            })\n        }\n    }\n\n    pub fn hover(\n        &mut self,\n        buffer: &Entity<Buffer>,\n        position: PointUtf16,\n        cx: &mut Context<Self>,\n    ) -> Task<Option<Vec<Hover>>> {\n        if let Some((client, upstream_project_id)) = self.upstream_client() {\n            let request = GetHover { position };\n            if !self.is_capable_for_proto_request(buffer, &request, cx) {\n                return Task::ready(None);\n            }\n            let request_task = client.request_lsp(\n                upstream_project_id,\n                None,\n                LSP_REQUEST_TIMEOUT,\n                cx.background_executor().clone(),\n                request.to_proto(upstream_project_id, buffer.read(cx)),\n            );\n            let buffer = buffer.clone();\n            cx.spawn(async move |weak_lsp_store, cx| {\n                let lsp_store = weak_lsp_store.upgrade()?;\n                let hovers = join_all(\n                    request_task\n                        .await\n                        .log_err()\n                        .flatten()\n                        .map(|response| response.payload)\n                        .unwrap_or_default()\n                        .into_iter()\n                        .map(|response| {\n                            let response = GetHover { position }.response_from_proto(\n                                response.response,\n                                lsp_store.clone(),\n                                buffer.clone(),\n                                cx.clone(),\n                            );\n                            async move {\n                                response\n                                    .await\n                                    .log_err()\n                                    .flatten()\n                                    .and_then(remove_empty_hover_blocks)\n                            }\n                        }),\n                )\n                .await\n                .into_iter()\n                .flatten()\n                .collect();\n                Some(hovers)\n            })\n        } else {\n            let all_actions_task = self.request_multiple_lsp_locally(\n                buffer,\n                Some(position),\n                GetHover { position },\n                cx,\n            );\n            cx.background_spawn(async move {\n                Some(\n                    all_actions_task\n                        .await\n                        .into_iter()\n                        .filter_map(|(_, hover)| remove_empty_hover_blocks(hover?))\n                        .collect::<Vec<Hover>>(),\n                )\n            })\n        }\n    }\n\n    pub fn symbols(&self, query: &str, cx: &mut Context<Self>) -> Task<Result<Vec<Symbol>>> {\n        let language_registry = self.languages.clone();\n\n        if let Some((upstream_client, project_id)) = self.upstream_client().as_ref() {\n            let request = upstream_client.request(proto::GetProjectSymbols {\n                project_id: *project_id,\n                query: query.to_string(),\n            });\n            cx.foreground_executor().spawn(async move {\n                let response = request.await?;\n                let mut symbols = Vec::new();\n                let core_symbols = response\n                    .symbols\n                    .into_iter()\n                    .filter_map(|symbol| Self::deserialize_symbol(symbol).log_err())\n                    .collect::<Vec<_>>();\n                populate_labels_for_symbols(core_symbols, &language_registry, None, &mut symbols)\n                    .await;\n                Ok(symbols)\n            })\n        } else if let Some(local) = self.as_local() {\n            struct WorkspaceSymbolsResult {\n                server_id: LanguageServerId,\n                lsp_adapter: Arc<CachedLspAdapter>,\n                worktree: WeakEntity<Worktree>,\n                lsp_symbols: Vec<(String, SymbolKind, lsp::Location)>,\n            }\n\n            let mut requests = Vec::new();\n            let mut requested_servers = BTreeSet::new();\n            for (seed, state) in local.language_server_ids.iter() {\n                let Some(worktree_handle) = self\n                    .worktree_store\n                    .read(cx)\n                    .worktree_for_id(seed.worktree_id, cx)\n                else {\n                    continue;\n                };\n                let worktree = worktree_handle.read(cx);\n                if !worktree.is_visible() {\n                    continue;\n                }\n\n                if !requested_servers.insert(state.id) {\n                    continue;\n                }\n\n                let (lsp_adapter, server) = match local.language_servers.get(&state.id) {\n                    Some(LanguageServerState::Running {\n                        adapter, server, ..\n                    }) => (adapter.clone(), server),\n\n                    _ => continue,\n                };\n                let supports_workspace_symbol_request =\n                    match server.capabilities().workspace_symbol_provider {\n                        Some(OneOf::Left(supported)) => supported,\n                        Some(OneOf::Right(_)) => true,\n                        None => false,\n                    };\n                if !supports_workspace_symbol_request {\n                    continue;\n                }\n                let worktree_handle = worktree_handle.clone();\n                let server_id = server.server_id();\n                requests.push(\n                        server\n                            .request::<lsp::request::WorkspaceSymbolRequest>(\n                                lsp::WorkspaceSymbolParams {\n                                    query: query.to_string(),\n                                    ..Default::default()\n                                },\n                            )\n                            .map(move |response| {\n                                let lsp_symbols = response.into_response()\n                                    .context(": "",
        ")\n                                    .log_err()\n                                    .flatten()\n                                    .map(|symbol_response| match symbol_response {\n                                        lsp::WorkspaceSymbolResponse::Flat(flat_responses) => {\n                                            flat_responses.into_iter().map(|lsp_symbol| {\n                                            (lsp_symbol.name, lsp_symbol.kind, lsp_symbol.location)\n                                            }).collect::<Vec<_>>()\n                                        }\n                                        lsp::WorkspaceSymbolResponse::Nested(nested_responses) => {\n                                            nested_responses.into_iter().filter_map(|lsp_symbol| {\n                                                let location = match lsp_symbol.location {\n                                                    OneOf::Left(location) => location,\n                                                    OneOf::Right(_) => {\n                                                        log::error!(": "",
        ");\n                                                        return None\n                                                    }\n                                                };\n                                                Some((lsp_symbol.name, lsp_symbol.kind, location))\n                                            }).collect::<Vec<_>>()\n                                        }\n                                    }).unwrap_or_default();\n\n                                WorkspaceSymbolsResult {\n                                    server_id,\n                                    lsp_adapter,\n                                    worktree: worktree_handle.downgrade(),\n                                    lsp_symbols,\n                                }\n                            }),\n                    );\n            }\n\n            cx.spawn(async move |this, cx| {\n                let responses = futures::future::join_all(requests).await;\n                let this = match this.upgrade() {\n                    Some(this) => this,\n                    None => return Ok(Vec::new()),\n                };\n\n                let mut symbols = Vec::new();\n                for result in responses {\n                    let core_symbols = this.update(cx, |this, cx| {\n                        result\n                            .lsp_symbols\n                            .into_iter()\n                            .filter_map(|(symbol_name, symbol_kind, symbol_location)| {\n                                let abs_path = symbol_location.uri.to_file_path().ok()?;\n                                let source_worktree = result.worktree.upgrade()?;\n                                let source_worktree_id = source_worktree.read(cx).id();\n\n                                let path = if let Some((tree, rel_path)) =\n                                    this.worktree_store.read(cx).find_worktree(&abs_path, cx)\n                                {\n                                    let worktree_id = tree.read(cx).id();\n                                    SymbolLocation::InProject(ProjectPath {\n                                        worktree_id,\n                                        path: rel_path,\n                                    })\n                                } else {\n                                    SymbolLocation::OutsideProject {\n                                        signature: this.symbol_signature(&abs_path),\n                                        abs_path: abs_path.into(),\n                                    }\n                                };\n\n                                Some(CoreSymbol {\n                                    source_language_server_id: result.server_id,\n                                    language_server_name: result.lsp_adapter.name.clone(),\n                                    source_worktree_id,\n                                    path,\n                                    kind: symbol_kind,\n                                    name: symbol_name,\n                                    range: range_from_lsp(symbol_location.range),\n                                })\n                            })\n                            .collect()\n                    })?;\n\n                    populate_labels_for_symbols(\n                        core_symbols,\n                        &language_registry,\n                        Some(result.lsp_adapter),\n                        &mut symbols,\n                    )\n                    .await;\n                }\n\n                Ok(symbols)\n            })\n        } else {\n            Task::ready(Err(anyhow!(": "",
        ")))\n        }\n    }\n\n    pub fn diagnostic_summary(&self, include_ignored: bool, cx: &App) -> DiagnosticSummary {\n        let mut summary = DiagnosticSummary::default();\n        for (_, _, path_summary) in self.diagnostic_summaries(include_ignored, cx) {\n            summary.error_count += path_summary.error_count;\n            summary.warning_count += path_summary.warning_count;\n        }\n        summary\n    }\n\n    /// Returns the diagnostic summary for a specific project path.\n    pub fn diagnostic_summary_for_path(\n        &self,\n        project_path: &ProjectPath,\n        _: &App,\n    ) -> DiagnosticSummary {\n        if let Some(summaries) = self\n            .diagnostic_summaries\n            .get(&project_path.worktree_id)\n            .and_then(|map| map.get(&project_path.path))\n        {\n            let (error_count, warning_count) = summaries.iter().fold(\n                (0, 0),\n                |(error_count, warning_count), (_language_server_id, summary)| {\n                    (\n                        error_count + summary.error_count,\n                        warning_count + summary.warning_count,\n                    )\n                },\n            );\n\n            DiagnosticSummary {\n                error_count,\n                warning_count,\n            }\n        } else {\n            DiagnosticSummary::default()\n        }\n    }\n\n    pub fn diagnostic_summaries<'a>(\n        &'a self,\n        include_ignored: bool,\n        cx: &'a App,\n    ) -> impl Iterator<Item = (ProjectPath, LanguageServerId, DiagnosticSummary)> + 'a {\n        self.worktree_store\n            .read(cx)\n            .visible_worktrees(cx)\n            .filter_map(|worktree| {\n                let worktree = worktree.read(cx);\n                Some((worktree, self.diagnostic_summaries.get(&worktree.id())?))\n            })\n            .flat_map(move |(worktree, summaries)| {\n                let worktree_id = worktree.id();\n                summaries\n                    .iter()\n                    .filter(move |(path, _)| {\n                        include_ignored\n                            || worktree\n                                .entry_for_path(path.as_ref())\n                                .is_some_and(|entry| !entry.is_ignored)\n                    })\n                    .flat_map(move |(path, summaries)| {\n                        summaries.iter().map(move |(server_id, summary)| {\n                            (\n                                ProjectPath {\n                                    worktree_id,\n                                    path: path.clone(),\n                                },\n                                *server_id,\n                                *summary,\n                            )\n                        })\n                    })\n            })\n    }\n\n    pub fn on_buffer_edited(\n        &mut self,\n        buffer: Entity<Buffer>,\n        cx: &mut Context<Self>,\n    ) -> Option<()> {\n        let language_servers: Vec<_> = buffer.update(cx, |buffer, cx| {\n            Some(\n                self.as_local()?\n                    .language_servers_for_buffer(buffer, cx)\n                    .map(|i| i.1.clone())\n                    .collect(),\n            )\n        })?;\n\n        let buffer = buffer.read(cx);\n        let file = File::from_dyn(buffer.file())?;\n        let abs_path = file.as_local()?.abs_path(cx);\n        let uri = lsp::Uri::from_file_path(&abs_path)\n            .ok()\n            .with_context(|| format!(": "",
        ", abs_path.display()))\n            .unwrap();\n        let next_snapshot = buffer.text_snapshot();\n        for language_server in language_servers {\n            let language_server = language_server.clone();\n\n            let buffer_snapshots = self\n                .as_local_mut()\n                .unwrap()\n                .buffer_snapshots\n                .get_mut(&buffer.remote_id())\n                .and_then(|m| m.get_mut(&language_server.server_id()))?;\n            let previous_snapshot = buffer_snapshots.last()?;\n\n            let build_incremental_change = || {\n                buffer\n                    .edits_since::<Dimensions<PointUtf16, usize>>(\n                        previous_snapshot.snapshot.version(),\n                    )\n                    .map(|edit| {\n                        let edit_start = edit.new.start.0;\n                        let edit_end = edit_start + (edit.old.end.0 - edit.old.start.0);\n                        let new_text = next_snapshot\n                            .text_for_range(edit.new.start.1..edit.new.end.1)\n                            .collect();\n                        lsp::TextDocumentContentChangeEvent {\n                            range: Some(lsp::Range::new(\n                                point_to_lsp(edit_start),\n                                point_to_lsp(edit_end),\n                            )),\n                            range_length: None,\n                            text: new_text,\n                        }\n                    })\n                    .collect()\n            };\n\n            let document_sync_kind = language_server\n                .capabilities()\n                .text_document_sync\n                .as_ref()\n                .and_then(|sync| match sync {\n                    lsp::TextDocumentSyncCapability::Kind(kind) => Some(*kind),\n                    lsp::TextDocumentSyncCapability::Options(options) => options.change,\n                });\n\n            let content_changes: Vec<_> = match document_sync_kind {\n                Some(lsp::TextDocumentSyncKind::FULL) => {\n                    vec![lsp::TextDocumentContentChangeEvent {\n                        range: None,\n                        range_length: None,\n                        text: next_snapshot.text(),\n                    }]\n                }\n                Some(lsp::TextDocumentSyncKind::INCREMENTAL) => build_incremental_change(),\n                _ => {\n                    #[cfg(any(test, feature = ": "",
        "))]\n                    {\n                        build_incremental_change()\n                    }\n\n                    #[cfg(not(any(test, feature = ": "",
        ")))]\n                    {\n                        continue;\n                    }\n                }\n            };\n\n            let next_version = previous_snapshot.version + 1;\n            buffer_snapshots.push(LspBufferSnapshot {\n                version: next_version,\n                snapshot: next_snapshot.clone(),\n            });\n\n            language_server\n                .notify::<lsp::notification::DidChangeTextDocument>(\n                    lsp::DidChangeTextDocumentParams {\n                        text_document: lsp::VersionedTextDocumentIdentifier::new(\n                            uri.clone(),\n                            next_version,\n                        ),\n                        content_changes,\n                    },\n                )\n                .ok();\n            self.pull_workspace_diagnostics(language_server.server_id());\n        }\n\n        None\n    }\n\n    pub fn on_buffer_saved(\n        &mut self,\n        buffer: Entity<Buffer>,\n        cx: &mut Context<Self>,\n    ) -> Option<()> {\n        let file = File::from_dyn(buffer.read(cx).file())?;\n        let worktree_id = file.worktree_id(cx);\n        let abs_path = file.as_local()?.abs_path(cx);\n        let text_document = lsp::TextDocumentIdentifier {\n            uri: file_path_to_lsp_url(&abs_path).log_err()?,\n        };\n        let local = self.as_local()?;\n\n        for server in local.language_servers_for_worktree(worktree_id) {\n            if let Some(include_text) = include_text(server.as_ref()) {\n                let text = if include_text {\n                    Some(buffer.read(cx).text())\n                } else {\n                    None\n                };\n                server\n                    .notify::<lsp::notification::DidSaveTextDocument>(\n                        lsp::DidSaveTextDocumentParams {\n                            text_document: text_document.clone(),\n                            text,\n                        },\n                    )\n                    .ok();\n            }\n        }\n\n        let language_servers = buffer.update(cx, |buffer, cx| {\n            local.language_server_ids_for_buffer(buffer, cx)\n        });\n        for language_server_id in language_servers {\n            self.simulate_disk_based_diagnostics_events_if_needed(language_server_id, cx);\n        }\n\n        None\n    }\n\n    async fn refresh_workspace_configurations(lsp_store: &WeakEntity<Self>, cx: &mut AsyncApp) {\n        maybe!(async move {\n            let mut refreshed_servers = HashSet::default();\n            let servers = lsp_store\n                .update(cx, |lsp_store, cx| {\n                    let local = lsp_store.as_local()?;\n\n                    let servers = local\n                        .language_server_ids\n                        .iter()\n                        .filter_map(|(seed, state)| {\n                            let worktree = lsp_store\n                                .worktree_store\n                                .read(cx)\n                                .worktree_for_id(seed.worktree_id, cx);\n                            let delegate: Arc<dyn LspAdapterDelegate> =\n                                worktree.map(|worktree| {\n                                    LocalLspAdapterDelegate::new(\n                                        local.languages.clone(),\n                                        &local.environment,\n                                        cx.weak_entity(),\n                                        &worktree,\n                                        local.http_client.clone(),\n                                        local.fs.clone(),\n                                        cx,\n                                    )\n                                })?;\n                            let server_id = state.id;\n\n                            let states = local.language_servers.get(&server_id)?;\n\n                            match states {\n                                LanguageServerState::Starting { .. } => None,\n                                LanguageServerState::Running {\n                                    adapter, server, ..\n                                } => {\n                                    let adapter = adapter.clone();\n                                    let server = server.clone();\n                                    refreshed_servers.insert(server.name());\n                                    let toolchain = seed.toolchain.clone();\n                                    Some(cx.spawn(async move |_, cx| {\n                                        let settings =\n                                            LocalLspStore::workspace_configuration_for_adapter(\n                                                adapter.adapter.clone(),\n                                                &delegate,\n                                                toolchain,\n                                                cx,\n                                            )\n                                            .await\n                                            .ok()?;\n                                        server\n                                            .notify::<lsp::notification::DidChangeConfiguration>(\n                                                lsp::DidChangeConfigurationParams { settings },\n                                            )\n                                            .ok()?;\n                                        Some(())\n                                    }))\n                                }\n                            }\n                        })\n                        .collect::<Vec<_>>();\n\n                    Some(servers)\n                })\n                .ok()\n                .flatten()?;\n\n            log::debug!(": "",
        ");\n            // TODO this asynchronous job runs concurrently with extension (de)registration and may take enough time for a certain extension\n            // to stop and unregister its language server wrapper.\n            // This is racy : an extension might have already removed all `local.language_servers` state, but here we `.clone()` and hold onto it anyway.\n            // This now causes errors in the logs, we should find a way to remove such servers from the processing everywhere.\n            let _: Vec<Option<()>> = join_all(servers).await;\n\n            Some(())\n        })\n        .await;\n    }\n\n    fn maintain_workspace_config(\n        external_refresh_requests: watch::Receiver<()>,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<()>> {\n        let (mut settings_changed_tx, mut settings_changed_rx) = watch::channel();\n        let _ = postage::stream::Stream::try_recv(&mut settings_changed_rx);\n\n        let settings_observation = cx.observe_global::<SettingsStore>(move |_, _| {\n            *settings_changed_tx.borrow_mut() = ();\n        });\n\n        let mut joint_future =\n            futures::stream::select(settings_changed_rx, external_refresh_requests);\n        // Multiple things can happen when a workspace environment (selected toolchain + settings) change:\n        // - We might shut down a language server if it's no longer enabled for a given language (and there are no buffers using it otherwise).\n        // - We might also shut it down when the workspace configuration of all of the users of a given language server converges onto that of the other.\n        // - In the same vein, we might also decide to start a new language server if the workspace configuration *diverges* from the other.\n        // - In the easiest case (where we're not wrangling the lifetime of a language server anyhow), if none of the roots of a single language server diverge in their configuration,\n        // but it is still different to what we had before, we're gonna send out a workspace configuration update.\n        cx.spawn(async move |this, cx| {\n            while let Some(()) = joint_future.next().await {\n                this.update(cx, |this, cx| {\n                    this.refresh_server_tree(cx);\n                })\n                .ok();\n\n                Self::refresh_workspace_configurations(&this, cx).await;\n            }\n\n            drop(settings_observation);\n            anyhow::Ok(())\n        })\n    }\n\n    pub fn language_servers_for_local_buffer<'a>(\n        &'a self,\n        buffer: &Buffer,\n        cx: &mut App,\n    ) -> impl Iterator<Item = (&'a Arc<CachedLspAdapter>, &'a Arc<LanguageServer>)> {\n        let local = self.as_local();\n        let language_server_ids = local\n            .map(|local| local.language_server_ids_for_buffer(buffer, cx))\n            .unwrap_or_default();\n\n        language_server_ids\n            .into_iter()\n            .filter_map(\n                move |server_id| match local?.language_servers.get(&server_id)? {\n                    LanguageServerState::Running {\n                        adapter, server, ..\n                    } => Some((adapter, server)),\n                    _ => None,\n                },\n            )\n    }\n\n    pub fn language_server_for_local_buffer<'a>(\n        &'a self,\n        buffer: &'a Buffer,\n        server_id: LanguageServerId,\n        cx: &'a mut App,\n    ) -> Option<(&'a Arc<CachedLspAdapter>, &'a Arc<LanguageServer>)> {\n        self.as_local()?\n            .language_servers_for_buffer(buffer, cx)\n            .find(|(_, s)| s.server_id() == server_id)\n    }\n\n    fn remove_worktree(&mut self, id_to_remove: WorktreeId, cx: &mut Context<Self>) {\n        self.diagnostic_summaries.remove(&id_to_remove);\n        if let Some(local) = self.as_local_mut() {\n            let to_remove = local.remove_worktree(id_to_remove, cx);\n            for server in to_remove {\n                self.language_server_statuses.remove(&server);\n            }\n        }\n    }\n\n    pub fn shared(\n        &mut self,\n        project_id: u64,\n        downstream_client: AnyProtoClient,\n        _: &mut Context<Self>,\n    ) {\n        self.downstream_client = Some((downstream_client.clone(), project_id));\n\n        for (server_id, status) in &self.language_server_statuses {\n            if let Some(server) = self.language_server_for_id(*server_id) {\n                downstream_client\n                    .send(proto::StartLanguageServer {\n                        project_id,\n                        server: Some(proto::LanguageServer {\n                            id: server_id.to_proto(),\n                            name: status.name.to_string(),\n                            worktree_id: status.worktree.map(|id| id.to_proto()),\n                        }),\n                        capabilities: serde_json::to_string(&server.capabilities())\n                            .expect(": "",
        "),\n                    })\n                    .log_err();\n            }\n        }\n    }\n\n    pub fn disconnected_from_host(&mut self) {\n        self.downstream_client.take();\n    }\n\n    pub fn disconnected_from_ssh_remote(&mut self) {\n        if let LspStoreMode::Remote(RemoteLspStore {\n            upstream_client, ..\n        }) = &mut self.mode\n        {\n            upstream_client.take();\n        }\n    }\n\n    pub(crate) fn set_language_server_statuses_from_proto(\n        &mut self,\n        project: WeakEntity<Project>,\n        language_servers: Vec<proto::LanguageServer>,\n        server_capabilities: Vec<String>,\n        cx: &mut Context<Self>,\n    ) {\n        let lsp_logs = cx\n            .try_global::<GlobalLogStore>()\n            .map(|lsp_store| lsp_store.0.clone());\n\n        self.language_server_statuses = language_servers\n            .into_iter()\n            .zip(server_capabilities)\n            .map(|(server, server_capabilities)| {\n                let server_id = LanguageServerId(server.id as usize);\n                if let Ok(server_capabilities) = serde_json::from_str(&server_capabilities) {\n                    self.lsp_server_capabilities\n                        .insert(server_id, server_capabilities);\n                }\n\n                let name = LanguageServerName::from_proto(server.name);\n                let worktree = server.worktree_id.map(WorktreeId::from_proto);\n\n                if let Some(lsp_logs) = &lsp_logs {\n                    lsp_logs.update(cx, |lsp_logs, cx| {\n                        lsp_logs.add_language_server(\n                            // Only remote clients get their language servers set from proto\n                            LanguageServerKind::Remote {\n                                project: project.clone(),\n                            },\n                            server_id,\n                            Some(name.clone()),\n                            worktree,\n                            None,\n                            cx,\n                        );\n                    });\n                }\n\n                (\n                    server_id,\n                    LanguageServerStatus {\n                        name,\n                        pending_work: Default::default(),\n                        has_pending_diagnostic_updates: false,\n                        progress_tokens: Default::default(),\n                        worktree,\n                    },\n                )\n            })\n            .collect();\n    }\n\n    #[cfg(test)]\n    pub fn update_diagnostic_entries(\n        &mut self,\n        server_id: LanguageServerId,\n        abs_path: PathBuf,\n        result_id: Option<String>,\n        version: Option<i32>,\n        diagnostics: Vec<DiagnosticEntry<Unclipped<PointUtf16>>>,\n        cx: &mut Context<Self>,\n    ) -> anyhow::Result<()> {\n        self.merge_diagnostic_entries(\n            vec![DocumentDiagnosticsUpdate {\n                diagnostics: DocumentDiagnostics {\n                    diagnostics,\n                    document_abs_path: abs_path,\n                    version,\n                },\n                result_id,\n                server_id,\n                disk_based_sources: Cow::Borrowed(&[]),\n            }],\n            |_, _, _| false,\n            cx,\n        )?;\n        Ok(())\n    }\n\n    pub fn merge_diagnostic_entries<'a>(\n        &mut self,\n        diagnostic_updates: Vec<DocumentDiagnosticsUpdate<'a, DocumentDiagnostics>>,\n        merge: impl Fn(&Buffer, &Diagnostic, &App) -> bool + Clone,\n        cx: &mut Context<Self>,\n    ) -> anyhow::Result<()> {\n        let mut diagnostics_summary = None::<proto::UpdateDiagnosticSummary>;\n        let mut updated_diagnostics_paths = HashMap::default();\n        for mut update in diagnostic_updates {\n            let abs_path = &update.diagnostics.document_abs_path;\n            let server_id = update.server_id;\n            let Some((worktree, relative_path)) =\n                self.worktree_store.read(cx).find_worktree(abs_path, cx)\n            else {\n                log::warn!(": "",
        ");\n                return Ok(());\n            };\n\n            let worktree_id = worktree.read(cx).id();\n            let project_path = ProjectPath {\n                worktree_id,\n                path: relative_path,\n            };\n\n            if let Some(buffer_handle) = self.buffer_store.read(cx).get_by_path(&project_path) {\n                let snapshot = buffer_handle.read(cx).snapshot();\n                let buffer = buffer_handle.read(cx);\n                let reused_diagnostics = buffer\n                    .buffer_diagnostics(Some(server_id))\n                    .iter()\n                    .filter(|v| merge(buffer, &v.diagnostic, cx))\n                    .map(|v| {\n                        let start = Unclipped(v.range.start.to_point_utf16(&snapshot));\n                        let end = Unclipped(v.range.end.to_point_utf16(&snapshot));\n                        DiagnosticEntry {\n                            range: start..end,\n                            diagnostic: v.diagnostic.clone(),\n                        }\n                    })\n                    .collect::<Vec<_>>();\n\n                self.as_local_mut()\n                    .context(": "",
        ")?\n                    .update_buffer_diagnostics(\n                        &buffer_handle,\n                        server_id,\n                        update.result_id,\n                        update.diagnostics.version,\n                        update.diagnostics.diagnostics.clone(),\n                        reused_diagnostics.clone(),\n                        cx,\n                    )?;\n\n                update.diagnostics.diagnostics.extend(reused_diagnostics);\n            }\n\n            let updated = worktree.update(cx, |worktree, cx| {\n                self.update_worktree_diagnostics(\n                    worktree.id(),\n                    server_id,\n                    project_path.path.clone(),\n                    update.diagnostics.diagnostics,\n                    cx,\n                )\n            })?;\n            match updated {\n                ControlFlow::Continue(new_summary) => {\n                    if let Some((project_id, new_summary)) = new_summary {\n                        match &mut diagnostics_summary {\n                            Some(diagnostics_summary) => {\n                                diagnostics_summary\n                                    .more_summaries\n                                    .push(proto::DiagnosticSummary {\n                                        path: project_path.path.as_ref().to_proto(),\n                                        language_server_id: server_id.0 as u64,\n                                        error_count: new_summary.error_count,\n                                        warning_count: new_summary.warning_count,\n                                    })\n                            }\n                            None => {\n                                diagnostics_summary = Some(proto::UpdateDiagnosticSummary {\n                                    project_id,\n                                    worktree_id: worktree_id.to_proto(),\n                                    summary: Some(proto::DiagnosticSummary {\n                                        path: project_path.path.as_ref().to_proto(),\n                                        language_server_id: server_id.0 as u64,\n                                        error_count: new_summary.error_count,\n                                        warning_count: new_summary.warning_count,\n                                    }),\n                                    more_summaries: Vec::new(),\n                                })\n                            }\n                        }\n                    }\n                    updated_diagnostics_paths\n                        .entry(server_id)\n                        .or_insert_with(Vec::new)\n                        .push(project_path);\n                }\n                ControlFlow::Break(()) => {}\n            }\n        }\n\n        if let Some((diagnostics_summary, (downstream_client, _))) =\n            diagnostics_summary.zip(self.downstream_client.as_ref())\n        {\n            downstream_client.send(diagnostics_summary).log_err();\n        }\n        for (server_id, paths) in updated_diagnostics_paths {\n            cx.emit(LspStoreEvent::DiagnosticsUpdated { server_id, paths });\n        }\n        Ok(())\n    }\n\n    fn update_worktree_diagnostics(\n        &mut self,\n        worktree_id: WorktreeId,\n        server_id: LanguageServerId,\n        path_in_worktree: Arc<RelPath>,\n        diagnostics: Vec<DiagnosticEntry<Unclipped<PointUtf16>>>,\n        _: &mut Context<Worktree>,\n    ) -> Result<ControlFlow<(), Option<(u64, proto::DiagnosticSummary)>>> {\n        let local = match &mut self.mode {\n            LspStoreMode::Local(local_lsp_store) => local_lsp_store,\n            _ => anyhow::bail!(": "",
        "),\n        };\n\n        let summaries_for_tree = self.diagnostic_summaries.entry(worktree_id).or_default();\n        let diagnostics_for_tree = local.diagnostics.entry(worktree_id).or_default();\n        let summaries_by_server_id = summaries_for_tree\n            .entry(path_in_worktree.clone())\n            .or_default();\n\n        let old_summary = summaries_by_server_id\n            .remove(&server_id)\n            .unwrap_or_default();\n\n        let new_summary = DiagnosticSummary::new(&diagnostics);\n        if new_summary.is_empty() {\n            if let Some(diagnostics_by_server_id) = diagnostics_for_tree.get_mut(&path_in_worktree)\n            {\n                if let Ok(ix) = diagnostics_by_server_id.binary_search_by_key(&server_id, |e| e.0) {\n                    diagnostics_by_server_id.remove(ix);\n                }\n                if diagnostics_by_server_id.is_empty() {\n                    diagnostics_for_tree.remove(&path_in_worktree);\n                }\n            }\n        } else {\n            summaries_by_server_id.insert(server_id, new_summary);\n            let diagnostics_by_server_id = diagnostics_for_tree\n                .entry(path_in_worktree.clone())\n                .or_default();\n            match diagnostics_by_server_id.binary_search_by_key(&server_id, |e| e.0) {\n                Ok(ix) => {\n                    diagnostics_by_server_id[ix] = (server_id, diagnostics);\n                }\n                Err(ix) => {\n                    diagnostics_by_server_id.insert(ix, (server_id, diagnostics));\n                }\n            }\n        }\n\n        if !old_summary.is_empty() || !new_summary.is_empty() {\n            if let Some((_, project_id)) = &self.downstream_client {\n                Ok(ControlFlow::Continue(Some((\n                    *project_id,\n                    proto::DiagnosticSummary {\n                        path: path_in_worktree.to_proto(),\n                        language_server_id: server_id.0 as u64,\n                        error_count: new_summary.error_count as u32,\n                        warning_count: new_summary.warning_count as u32,\n                    },\n                ))))\n            } else {\n                Ok(ControlFlow::Continue(None))\n            }\n        } else {\n            Ok(ControlFlow::Break(()))\n        }\n    }\n\n    pub fn open_buffer_for_symbol(\n        &mut self,\n        symbol: &Symbol,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Entity<Buffer>>> {\n        if let Some((client, project_id)) = self.upstream_client() {\n            let request = client.request(proto::OpenBufferForSymbol {\n                project_id,\n                symbol: Some(Self::serialize_symbol(symbol)),\n            });\n            cx.spawn(async move |this, cx| {\n                let response = request.await?;\n                let buffer_id = BufferId::new(response.buffer_id)?;\n                this.update(cx, |this, cx| this.wait_for_remote_buffer(buffer_id, cx))?\n                    .await\n            })\n        } else if let Some(local) = self.as_local() {\n            let is_valid = local.language_server_ids.iter().any(|(seed, state)| {\n                seed.worktree_id == symbol.source_worktree_id\n                    && state.id == symbol.source_language_server_id\n                    && symbol.language_server_name == seed.name\n            });\n            if !is_valid {\n                return Task::ready(Err(anyhow!(\n                    ": "",
        "\n                )));\n            };\n\n            let symbol_abs_path = match &symbol.path {\n                SymbolLocation::InProject(project_path) => self\n                    .worktree_store\n                    .read(cx)\n                    .absolutize(&project_path, cx)\n                    .context(": "",
        "),\n                SymbolLocation::OutsideProject {\n                    abs_path,\n                    signature: _,\n                } => Ok(abs_path.to_path_buf()),\n            };\n            let symbol_abs_path = match symbol_abs_path {\n                Ok(abs_path) => abs_path,\n                Err(err) => return Task::ready(Err(err)),\n            };\n            let symbol_uri = if let Ok(uri) = lsp::Uri::from_file_path(symbol_abs_path) {\n                uri\n            } else {\n                return Task::ready(Err(anyhow!(": "",
        ")));\n            };\n\n            self.open_local_buffer_via_lsp(symbol_uri, symbol.source_language_server_id, cx)\n        } else {\n            Task::ready(Err(anyhow!(": "",
        ")))\n        }\n    }\n\n    pub(crate) fn open_local_buffer_via_lsp(\n        &mut self,\n        abs_path: lsp::Uri,\n        language_server_id: LanguageServerId,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Entity<Buffer>>> {\n        cx.spawn(async move |lsp_store, cx| {\n            // Escape percent-encoded string.\n            let current_scheme = abs_path.scheme().to_owned();\n            // Uri is immutable, so we can't modify the scheme\n\n            let abs_path = abs_path\n                .to_file_path()\n                .map_err(|()| anyhow!(": "",
        "))?;\n            let p = abs_path.clone();\n            let yarn_worktree = lsp_store\n                .update(cx, move |lsp_store, cx| match lsp_store.as_local() {\n                    Some(local_lsp_store) => local_lsp_store.yarn.update(cx, |_, cx| {\n                        cx.spawn(async move |this, cx| {\n                            let t = this\n                                .update(cx, |this, cx| this.process_path(&p, &current_scheme, cx))\n                                .ok()?;\n                            t.await\n                        })\n                    }),\n                    None => Task::ready(None),\n                })?\n                .await;\n            let (worktree_root_target, known_relative_path) =\n                if let Some((zip_root, relative_path)) = yarn_worktree {\n                    (zip_root, Some(relative_path))\n                } else {\n                    (Arc::<Path>::from(abs_path.as_path()), None)\n                };\n            let (worktree, relative_path) = if let Some(result) =\n                lsp_store.update(cx, |lsp_store, cx| {\n                    lsp_store.worktree_store.update(cx, |worktree_store, cx| {\n                        worktree_store.find_worktree(&worktree_root_target, cx)\n                    })\n                })? {\n                let relative_path = known_relative_path.unwrap_or_else(|| result.1.clone());\n                (result.0, relative_path)\n            } else {\n                let worktree = lsp_store\n                    .update(cx, |lsp_store, cx| {\n                        lsp_store.worktree_store.update(cx, |worktree_store, cx| {\n                            worktree_store.create_worktree(&worktree_root_target, false, cx)\n                        })\n                    })?\n                    .await?;\n                if worktree.read_with(cx, |worktree, _| worktree.is_local())? {\n                    lsp_store\n                        .update(cx, |lsp_store, cx| {\n                            if let Some(local) = lsp_store.as_local_mut() {\n                                local.register_language_server_for_invisible_worktree(\n                                    &worktree,\n                                    language_server_id,\n                                    cx,\n                                )\n                            }\n                        })\n                        .ok();\n                }\n                let worktree_root = worktree.read_with(cx, |worktree, _| worktree.abs_path())?;\n                let relative_path = if let Some(known_path) = known_relative_path {\n                    known_path\n                } else {\n                    RelPath::new(abs_path.strip_prefix(worktree_root)?, PathStyle::local())?\n                        .into_arc()\n                };\n                (worktree, relative_path)\n            };\n            let project_path = ProjectPath {\n                worktree_id: worktree.read_with(cx, |worktree, _| worktree.id())?,\n                path: relative_path,\n            };\n            lsp_store\n                .update(cx, |lsp_store, cx| {\n                    lsp_store.buffer_store().update(cx, |buffer_store, cx| {\n                        buffer_store.open_buffer(project_path, cx)\n                    })\n                })?\n                .await\n        })\n    }\n\n    fn request_multiple_lsp_locally<P, R>(\n        &mut self,\n        buffer: &Entity<Buffer>,\n        position: Option<P>,\n        request: R,\n        cx: &mut Context<Self>,\n    ) -> Task<Vec<(LanguageServerId, R::Response)>>\n    where\n        P: ToOffset,\n        R: LspCommand + Clone,\n        <R::LspRequest as lsp::request::Request>::Result: Send,\n        <R::LspRequest as lsp::request::Request>::Params: Send,\n    {\n        let Some(local) = self.as_local() else {\n            return Task::ready(Vec::new());\n        };\n\n        let snapshot = buffer.read(cx).snapshot();\n        let scope = position.and_then(|position| snapshot.language_scope_at(position));\n\n        let server_ids = buffer.update(cx, |buffer, cx| {\n            local\n                .language_servers_for_buffer(buffer, cx)\n                .filter(|(adapter, _)| {\n                    scope\n                        .as_ref()\n                        .map(|scope| scope.language_allowed(&adapter.name))\n                        .unwrap_or(true)\n                })\n                .map(|(_, server)| server.server_id())\n                .filter(|server_id| {\n                    self.as_local().is_none_or(|local| {\n                        local\n                            .buffers_opened_in_servers\n                            .get(&snapshot.remote_id())\n                            .is_some_and(|servers| servers.contains(server_id))\n                    })\n                })\n                .collect::<Vec<_>>()\n        });\n\n        let mut response_results = server_ids\n            .into_iter()\n            .map(|server_id| {\n                let task = self.request_lsp(\n                    buffer.clone(),\n                    LanguageServerToQuery::Other(server_id),\n                    request.clone(),\n                    cx,\n                );\n                async move { (server_id, task.await) }\n            })\n            .collect::<FuturesUnordered<_>>();\n\n        cx.background_spawn(async move {\n            let mut responses = Vec::with_capacity(response_results.len());\n            while let Some((server_id, response_result)) = response_results.next().await {\n                match response_result {\n                    Ok(response) => responses.push((server_id, response)),\n                    // rust-analyzer likes to error with this when its still loading up\n                    Err(e) if format!(": "",
        ") => (),\n                    Err(e) => log::error!(": "",
        "),\n                }\n            }\n            responses\n        })\n    }\n\n    async fn handle_lsp_command<T: LspCommand>(\n        this: Entity<Self>,\n        envelope: TypedEnvelope<T::ProtoRequest>,\n        mut cx: AsyncApp,\n    ) -> Result<<T::ProtoRequest as proto::RequestMessage>::Response>\n    where\n        <T::LspRequest as lsp::request::Request>::Params: Send,\n        <T::LspRequest as lsp::request::Request>::Result: Send,\n    {\n        let sender_id = envelope.original_sender_id().unwrap_or_default();\n        let buffer_id = T::buffer_id_from_proto(&envelope.payload)?;\n        let buffer_handle = this.update(&mut cx, |this, cx| {\n            this.buffer_store.read(cx).get_existing(buffer_id)\n        })??;\n        let request = T::from_proto(\n            envelope.payload,\n            this.clone(),\n            buffer_handle.clone(),\n            cx.clone(),\n        )\n        .await?;\n        let response = this\n            .update(&mut cx, |this, cx| {\n                this.request_lsp(\n                    buffer_handle.clone(),\n                    LanguageServerToQuery::FirstCapable,\n                    request,\n                    cx,\n                )\n            })?\n            .await?;\n        this.update(&mut cx, |this, cx| {\n            Ok(T::response_to_proto(\n                response,\n                this,\n                sender_id,\n                &buffer_handle.read(cx).version(),\n                cx,\n            ))\n        })?\n    }\n\n    async fn handle_lsp_query(\n        lsp_store: Entity<Self>,\n        envelope: TypedEnvelope<proto::LspQuery>,\n        mut cx: AsyncApp,\n    ) -> Result<proto::Ack> {\n        use proto::lsp_query::Request;\n        let sender_id = envelope.original_sender_id().unwrap_or_default();\n        let lsp_query = envelope.payload;\n        let lsp_request_id = LspRequestId(lsp_query.lsp_request_id);\n        let server_id = lsp_query.server_id.map(LanguageServerId::from_proto);\n        match lsp_query.request.context(": "",
        ")? {\n            Request::GetReferences(get_references) => {\n                let position = get_references.position.clone().and_then(deserialize_anchor);\n                Self::query_lsp_locally::<GetReferences>(\n                    lsp_store,\n                    server_id,\n                    sender_id,\n                    lsp_request_id,\n                    get_references,\n                    position,\n                    &mut cx,\n                )\n                .await?;\n            }\n            Request::GetDocumentColor(get_document_color) => {\n                Self::query_lsp_locally::<GetDocumentColor>(\n                    lsp_store,\n                    server_id,\n                    sender_id,\n                    lsp_request_id,\n                    get_document_color,\n                    None,\n                    &mut cx,\n                )\n                .await?;\n            }\n            Request::GetHover(get_hover) => {\n                let position = get_hover.position.clone().and_then(deserialize_anchor);\n                Self::query_lsp_locally::<GetHover>(\n                    lsp_store,\n                    server_id,\n                    sender_id,\n                    lsp_request_id,\n                    get_hover,\n                    position,\n                    &mut cx,\n                )\n                .await?;\n            }\n            Request::GetCodeActions(get_code_actions) => {\n                Self::query_lsp_locally::<GetCodeActions>(\n                    lsp_store,\n                    server_id,\n                    sender_id,\n                    lsp_request_id,\n                    get_code_actions,\n                    None,\n                    &mut cx,\n                )\n                .await?;\n            }\n            Request::GetSignatureHelp(get_signature_help) => {\n                let position = get_signature_help\n                    .position\n                    .clone()\n                    .and_then(deserialize_anchor);\n                Self::query_lsp_locally::<GetSignatureHelp>(\n                    lsp_store,\n                    server_id,\n                    sender_id,\n                    lsp_request_id,\n                    get_signature_help,\n                    position,\n                    &mut cx,\n                )\n                .await?;\n            }\n            Request::GetCodeLens(get_code_lens) => {\n                Self::query_lsp_locally::<GetCodeLens>(\n                    lsp_store,\n                    server_id,\n                    sender_id,\n                    lsp_request_id,\n                    get_code_lens,\n                    None,\n                    &mut cx,\n                )\n                .await?;\n            }\n            Request::GetDefinition(get_definition) => {\n                let position = get_definition.position.clone().and_then(deserialize_anchor);\n                Self::query_lsp_locally::<GetDefinitions>(\n                    lsp_store,\n                    server_id,\n                    sender_id,\n                    lsp_request_id,\n                    get_definition,\n                    position,\n                    &mut cx,\n                )\n                .await?;\n            }\n            Request::GetDeclaration(get_declaration) => {\n                let position = get_declaration\n                    .position\n                    .clone()\n                    .and_then(deserialize_anchor);\n                Self::query_lsp_locally::<GetDeclarations>(\n                    lsp_store,\n                    server_id,\n                    sender_id,\n                    lsp_request_id,\n                    get_declaration,\n                    position,\n                    &mut cx,\n                )\n                .await?;\n            }\n            Request::GetTypeDefinition(get_type_definition) => {\n                let position = get_type_definition\n                    .position\n                    .clone()\n                    .and_then(deserialize_anchor);\n                Self::query_lsp_locally::<GetTypeDefinitions>(\n                    lsp_store,\n                    server_id,\n                    sender_id,\n                    lsp_request_id,\n                    get_type_definition,\n                    position,\n                    &mut cx,\n                )\n                .await?;\n            }\n            Request::GetImplementation(get_implementation) => {\n                let position = get_implementation\n                    .position\n                    .clone()\n                    .and_then(deserialize_anchor);\n                Self::query_lsp_locally::<GetImplementations>(\n                    lsp_store,\n                    server_id,\n                    sender_id,\n                    lsp_request_id,\n                    get_implementation,\n                    position,\n                    &mut cx,\n                )\n                .await?;\n            }\n            Request::GetDocumentDiagnostics(get_document_diagnostics) => {\n                let buffer_id = BufferId::new(get_document_diagnostics.buffer_id())?;\n                let version = deserialize_version(get_document_diagnostics.buffer_version());\n                let buffer = lsp_store.update(&mut cx, |this, cx| {\n                    this.buffer_store.read(cx).get_existing(buffer_id)\n                })??;\n                buffer\n                    .update(&mut cx, |buffer, _| {\n                        buffer.wait_for_version(version.clone())\n                    })?\n                    .await?;\n                lsp_store.update(&mut cx, |lsp_store, cx| {\n                    let lsp_data = lsp_store.latest_lsp_data(&buffer, cx);\n                    let key = LspKey {\n                        request_type: TypeId::of::<GetDocumentDiagnostics>(),\n                        server_queried: server_id,\n                    };\n                    if <GetDocumentDiagnostics as LspCommand>::ProtoRequest::stop_previous_requests(\n                    ) {\n                        if let Some(lsp_requests) = lsp_data.lsp_requests.get_mut(&key) {\n                            lsp_requests.clear();\n                        };\n                    }\n\n                    let existing_queries = lsp_data.lsp_requests.entry(key).or_default();\n                    existing_queries.insert(\n                        lsp_request_id,\n                        cx.spawn(async move |lsp_store, cx| {\n                            let diagnostics_pull = lsp_store\n                                .update(cx, |lsp_store, cx| {\n                                    lsp_store.pull_diagnostics_for_buffer(buffer, cx)\n                                })\n                                .ok();\n                            if let Some(diagnostics_pull) = diagnostics_pull {\n                                match diagnostics_pull.await {\n                                    Ok(()) => {}\n                                    Err(e) => log::error!(": "",
        "),\n                                };\n                            }\n                        }),\n                    );\n                })?;\n            }\n            Request::InlayHints(inlay_hints) => {\n                let query_start = inlay_hints\n                    .start\n                    .clone()\n                    .and_then(deserialize_anchor)\n                    .context(": "",
        ")?;\n                let query_end = inlay_hints\n                    .end\n                    .clone()\n                    .and_then(deserialize_anchor)\n                    .context(": "",
        ")?;\n                Self::deduplicate_range_based_lsp_requests::<InlayHints>(\n                    &lsp_store,\n                    server_id,\n                    lsp_request_id,\n                    &inlay_hints,\n                    query_start..query_end,\n                    &mut cx,\n                )\n                .await\n                .context(": "",
        ")?;\n                Self::query_lsp_locally::<InlayHints>(\n                    lsp_store,\n                    server_id,\n                    sender_id,\n                    lsp_request_id,\n                    inlay_hints,\n                    None,\n                    &mut cx,\n                )\n                .await\n                .context(": "",
        ")?\n            }\n        }\n        Ok(proto::Ack {})\n    }\n\n    async fn handle_lsp_query_response(\n        lsp_store: Entity<Self>,\n        envelope: TypedEnvelope<proto::LspQueryResponse>,\n        cx: AsyncApp,\n    ) -> Result<()> {\n        lsp_store.read_with(&cx, |lsp_store, _| {\n            if let Some((upstream_client, _)) = lsp_store.upstream_client() {\n                upstream_client.handle_lsp_response(envelope.clone());\n            }\n        })?;\n        Ok(())\n    }\n\n    async fn handle_apply_code_action(\n        this: Entity<Self>,\n        envelope: TypedEnvelope<proto::ApplyCodeAction>,\n        mut cx: AsyncApp,\n    ) -> Result<proto::ApplyCodeActionResponse> {\n        let sender_id = envelope.original_sender_id().unwrap_or_default();\n        let action =\n            Self::deserialize_code_action(envelope.payload.action.context(": "",
        ")?)?;\n        let apply_code_action = this.update(&mut cx, |this, cx| {\n            let buffer_id = BufferId::new(envelope.payload.buffer_id)?;\n            let buffer = this.buffer_store.read(cx).get_existing(buffer_id)?;\n            anyhow::Ok(this.apply_code_action(buffer, action, false, cx))\n        })??;\n\n        let project_transaction = apply_code_action.await?;\n        let project_transaction = this.update(&mut cx, |this, cx| {\n            this.buffer_store.update(cx, |buffer_store, cx| {\n                buffer_store.serialize_project_transaction_for_peer(\n                    project_transaction,\n                    sender_id,\n                    cx,\n                )\n            })\n        })?;\n        Ok(proto::ApplyCodeActionResponse {\n            transaction: Some(project_transaction),\n        })\n    }\n\n    async fn handle_register_buffer_with_language_servers(\n        this: Entity<Self>,\n        envelope: TypedEnvelope<proto::RegisterBufferWithLanguageServers>,\n        mut cx: AsyncApp,\n    ) -> Result<proto::Ack> {\n        let buffer_id = BufferId::new(envelope.payload.buffer_id)?;\n        let peer_id = envelope.original_sender_id.unwrap_or(envelope.sender_id);\n        this.update(&mut cx, |this, cx| {\n            if let Some((upstream_client, upstream_project_id)) = this.upstream_client() {\n                return upstream_client.send(proto::RegisterBufferWithLanguageServers {\n                    project_id: upstream_project_id,\n                    buffer_id: buffer_id.to_proto(),\n                    only_servers: envelope.payload.only_servers,\n                });\n            }\n\n            let Some(buffer) = this.buffer_store().read(cx).get(buffer_id) else {\n                anyhow::bail!(": "",
        ");\n            };\n\n            let handle = this.register_buffer_with_language_servers(\n                &buffer,\n                envelope\n                    .payload\n                    .only_servers\n                    .into_iter()\n                    .filter_map(|selector| {\n                        Some(match selector.selector? {\n                            proto::language_server_selector::Selector::ServerId(server_id) => {\n                                LanguageServerSelector::Id(LanguageServerId::from_proto(server_id))\n                            }\n                            proto::language_server_selector::Selector::Name(name) => {\n                                LanguageServerSelector::Name(LanguageServerName(\n                                    SharedString::from(name),\n                                ))\n                            }\n                        })\n                    })\n                    .collect(),\n                false,\n                cx,\n            );\n            this.buffer_store().update(cx, |buffer_store, _| {\n                buffer_store.register_shared_lsp_handle(peer_id, buffer_id, handle);\n            });\n\n            Ok(())\n        })??;\n        Ok(proto::Ack {})\n    }\n\n    async fn handle_rename_project_entry(\n        this: Entity<Self>,\n        envelope: TypedEnvelope<proto::RenameProjectEntry>,\n        mut cx: AsyncApp,\n    ) -> Result<proto::ProjectEntryResponse> {\n        let entry_id = ProjectEntryId::from_proto(envelope.payload.entry_id);\n        let new_worktree_id = WorktreeId::from_proto(envelope.payload.new_worktree_id);\n        let new_path =\n            RelPath::from_proto(&envelope.payload.new_path).context(": "",
        ")?;\n\n        let (worktree_store, old_worktree, new_worktree, old_entry) = this\n            .update(&mut cx, |this, cx| {\n                let (worktree, entry) = this\n                    .worktree_store\n                    .read(cx)\n                    .worktree_and_entry_for_id(entry_id, cx)?;\n                let new_worktree = this\n                    .worktree_store\n                    .read(cx)\n                    .worktree_for_id(new_worktree_id, cx)?;\n                Some((\n                    this.worktree_store.clone(),\n                    worktree,\n                    new_worktree,\n                    entry.clone(),\n                ))\n            })?\n            .context(": "",
        ")?;\n        let (old_abs_path, old_worktree_id) = old_worktree.read_with(&cx, |worktree, _| {\n            (worktree.absolutize(&old_entry.path), worktree.id())\n        })?;\n        let new_abs_path =\n            new_worktree.read_with(&cx, |worktree, _| worktree.absolutize(&new_path))?;\n\n        let _transaction = Self::will_rename_entry(\n            this.downgrade(),\n            old_worktree_id,\n            &old_abs_path,\n            &new_abs_path,\n            old_entry.is_dir(),\n            cx.clone(),\n        )\n        .await;\n        let response = WorktreeStore::handle_rename_project_entry(\n            worktree_store,\n            envelope.payload,\n            cx.clone(),\n        )\n        .await;\n        this.read_with(&cx, |this, _| {\n            this.did_rename_entry(\n                old_worktree_id,\n                &old_abs_path,\n                &new_abs_path,\n                old_entry.is_dir(),\n            );\n        })\n        .ok();\n        response\n    }\n\n    async fn handle_update_diagnostic_summary(\n        this: Entity<Self>,\n        envelope: TypedEnvelope<proto::UpdateDiagnosticSummary>,\n        mut cx: AsyncApp,\n    ) -> Result<()> {\n        this.update(&mut cx, |lsp_store, cx| {\n            let worktree_id = WorktreeId::from_proto(envelope.payload.worktree_id);\n            let mut updated_diagnostics_paths = HashMap::default();\n            let mut diagnostics_summary = None::<proto::UpdateDiagnosticSummary>;\n            for message_summary in envelope\n                .payload\n                .summary\n                .into_iter()\n                .chain(envelope.payload.more_summaries)\n            {\n                let project_path = ProjectPath {\n                    worktree_id,\n                    path: RelPath::from_proto(&message_summary.path).context(": "",
        ")?,\n                };\n                let path = project_path.path.clone();\n                let server_id = LanguageServerId(message_summary.language_server_id as usize);\n                let summary = DiagnosticSummary {\n                    error_count: message_summary.error_count as usize,\n                    warning_count: message_summary.warning_count as usize,\n                };\n\n                if summary.is_empty() {\n                    if let Some(worktree_summaries) =\n                        lsp_store.diagnostic_summaries.get_mut(&worktree_id)\n                        && let Some(summaries) = worktree_summaries.get_mut(&path)\n                    {\n                        summaries.remove(&server_id);\n                        if summaries.is_empty() {\n                            worktree_summaries.remove(&path);\n                        }\n                    }\n                } else {\n                    lsp_store\n                        .diagnostic_summaries\n                        .entry(worktree_id)\n                        .or_default()\n                        .entry(path)\n                        .or_default()\n                        .insert(server_id, summary);\n                }\n\n                if let Some((_, project_id)) = &lsp_store.downstream_client {\n                    match &mut diagnostics_summary {\n                        Some(diagnostics_summary) => {\n                            diagnostics_summary\n                                .more_summaries\n                                .push(proto::DiagnosticSummary {\n                                    path: project_path.path.as_ref().to_proto(),\n                                    language_server_id: server_id.0 as u64,\n                                    error_count: summary.error_count as u32,\n                                    warning_count: summary.warning_count as u32,\n                                })\n                        }\n                        None => {\n                            diagnostics_summary = Some(proto::UpdateDiagnosticSummary {\n                                project_id: *project_id,\n                                worktree_id: worktree_id.to_proto(),\n                                summary: Some(proto::DiagnosticSummary {\n                                    path: project_path.path.as_ref().to_proto(),\n                                    language_server_id: server_id.0 as u64,\n                                    error_count: summary.error_count as u32,\n                                    warning_count: summary.warning_count as u32,\n                                }),\n                                more_summaries: Vec::new(),\n                            })\n                        }\n                    }\n                }\n                updated_diagnostics_paths\n                    .entry(server_id)\n                    .or_insert_with(Vec::new)\n                    .push(project_path);\n            }\n\n            if let Some((diagnostics_summary, (downstream_client, _))) =\n                diagnostics_summary.zip(lsp_store.downstream_client.as_ref())\n            {\n                downstream_client.send(diagnostics_summary).log_err();\n            }\n            for (server_id, paths) in updated_diagnostics_paths {\n                cx.emit(LspStoreEvent::DiagnosticsUpdated { server_id, paths });\n            }\n            Ok(())\n        })?\n    }\n\n    async fn handle_start_language_server(\n        lsp_store: Entity<Self>,\n        envelope: TypedEnvelope<proto::StartLanguageServer>,\n        mut cx: AsyncApp,\n    ) -> Result<()> {\n        let server = envelope.payload.server.context(": "",
        ")?;\n        let server_capabilities =\n            serde_json::from_str::<lsp::ServerCapabilities>(&envelope.payload.capabilities)\n                .with_context(|| {\n                    format!(\n                        ": "",
        ",\n                        envelope.payload.capabilities\n                    )\n                })?;\n        lsp_store.update(&mut cx, |lsp_store, cx| {\n            let server_id = LanguageServerId(server.id as usize);\n            let server_name = LanguageServerName::from_proto(server.name.clone());\n            lsp_store\n                .lsp_server_capabilities\n                .insert(server_id, server_capabilities);\n            lsp_store.language_server_statuses.insert(\n                server_id,\n                LanguageServerStatus {\n                    name: server_name.clone(),\n                    pending_work: Default::default(),\n                    has_pending_diagnostic_updates: false,\n                    progress_tokens: Default::default(),\n                    worktree: server.worktree_id.map(WorktreeId::from_proto),\n                },\n            );\n            cx.emit(LspStoreEvent::LanguageServerAdded(\n                server_id,\n                server_name,\n                server.worktree_id.map(WorktreeId::from_proto),\n            ));\n            cx.notify();\n        })?;\n        Ok(())\n    }\n\n    async fn handle_update_language_server(\n        lsp_store: Entity<Self>,\n        envelope: TypedEnvelope<proto::UpdateLanguageServer>,\n        mut cx: AsyncApp,\n    ) -> Result<()> {\n        lsp_store.update(&mut cx, |lsp_store, cx| {\n            let language_server_id = LanguageServerId(envelope.payload.language_server_id as usize);\n\n            match envelope.payload.variant.context(": "",
        ")? {\n                proto::update_language_server::Variant::WorkStart(payload) => {\n                    lsp_store.on_lsp_work_start(\n                        language_server_id,\n                        ProgressToken::from_proto(payload.token.context(": "",
        ")?)\n                            .context(": "",
        ")?,\n                        LanguageServerProgress {\n                            title: payload.title,\n                            is_disk_based_diagnostics_progress: false,\n                            is_cancellable: payload.is_cancellable.unwrap_or(false),\n                            message: payload.message,\n                            percentage: payload.percentage.map(|p| p as usize),\n                            last_update_at: cx.background_executor().now(),\n                        },\n                        cx,\n                    );\n                }\n                proto::update_language_server::Variant::WorkProgress(payload) => {\n                    lsp_store.on_lsp_work_progress(\n                        language_server_id,\n                        ProgressToken::from_proto(payload.token.context(": "",
        ")?,\n                        LanguageServerProgress {\n                            title: None,\n                            is_disk_based_diagnostics_progress: false,\n                            is_cancellable: payload.is_cancellable.unwrap_or(false),\n                            message: payload.message,\n                            percentage: payload.percentage.map(|p| p as usize),\n                            last_update_at: cx.background_executor().now(),\n                        },\n                        cx,\n                    );\n                }\n\n                proto::update_language_server::Variant::WorkEnd(payload) => {\n                    lsp_store.on_lsp_work_end(\n                        language_server_id,\n                        ProgressToken::from_proto(payload.token.context(": "",
        ")?,\n                        cx,\n                    );\n                }\n\n                proto::update_language_server::Variant::DiskBasedDiagnosticsUpdating(_) => {\n                    lsp_store.disk_based_diagnostics_started(language_server_id, cx);\n                }\n\n                proto::update_language_server::Variant::DiskBasedDiagnosticsUpdated(_) => {\n                    lsp_store.disk_based_diagnostics_finished(language_server_id, cx)\n                }\n\n                non_lsp @ proto::update_language_server::Variant::StatusUpdate(_)\n                | non_lsp @ proto::update_language_server::Variant::RegisteredForBuffer(_)\n                | non_lsp @ proto::update_language_server::Variant::MetadataUpdated(_) => {\n                    cx.emit(LspStoreEvent::LanguageServerUpdate {\n                        language_server_id,\n                        name: envelope\n                            .payload\n                            .server_name\n                            .map(SharedString::new)\n                            .map(LanguageServerName),\n                        message: non_lsp,\n                    });\n                }\n            }\n\n            Ok(())\n        })?\n    }\n\n    async fn handle_language_server_log(\n        this: Entity<Self>,\n        envelope: TypedEnvelope<proto::LanguageServerLog>,\n        mut cx: AsyncApp,\n    ) -> Result<()> {\n        let language_server_id = LanguageServerId(envelope.payload.language_server_id as usize);\n        let log_type = envelope\n            .payload\n            .log_type\n            .map(LanguageServerLogType::from_proto)\n            .context(": "",
        ")?;\n\n        let message = envelope.payload.message;\n\n        this.update(&mut cx, |_, cx| {\n            cx.emit(LspStoreEvent::LanguageServerLog(\n                language_server_id,\n                log_type,\n                message,\n            ));\n        })\n    }\n\n    async fn handle_lsp_ext_cancel_flycheck(\n        lsp_store: Entity<Self>,\n        envelope: TypedEnvelope<proto::LspExtCancelFlycheck>,\n        cx: AsyncApp,\n    ) -> Result<proto::Ack> {\n        let server_id = LanguageServerId(envelope.payload.language_server_id as usize);\n        let task = lsp_store.read_with(&cx, |lsp_store, _| {\n            if let Some(server) = lsp_store.language_server_for_id(server_id) {\n                Some(server.notify::<lsp_store::lsp_ext_command::LspExtCancelFlycheck>(()))\n            } else {\n                None\n            }\n        })?;\n        if let Some(task) = task {\n            task.context(": "",
        ")?;\n        }\n\n        Ok(proto::Ack {})\n    }\n\n    async fn handle_lsp_ext_run_flycheck(\n        lsp_store: Entity<Self>,\n        envelope: TypedEnvelope<proto::LspExtRunFlycheck>,\n        mut cx: AsyncApp,\n    ) -> Result<proto::Ack> {\n        let server_id = LanguageServerId(envelope.payload.language_server_id as usize);\n        lsp_store.update(&mut cx, |lsp_store, cx| {\n            if let Some(server) = lsp_store.language_server_for_id(server_id) {\n                let text_document = if envelope.payload.current_file_only {\n                    let buffer_id = envelope\n                        .payload\n                        .buffer_id\n                        .map(|id| BufferId::new(id))\n                        .transpose()?;\n                    buffer_id\n                        .and_then(|buffer_id| {\n                            lsp_store\n                                .buffer_store()\n                                .read(cx)\n                                .get(buffer_id)\n                                .and_then(|buffer| {\n                                    Some(buffer.read(cx).file()?.as_local()?.abs_path(cx))\n                                })\n                                .map(|path| make_text_document_identifier(&path))\n                        })\n                        .transpose()?\n                } else {\n                    None\n                };\n                server.notify::<lsp_store::lsp_ext_command::LspExtRunFlycheck>(\n                    lsp_store::lsp_ext_command::RunFlycheckParams { text_document },\n                )?;\n            }\n            anyhow::Ok(())\n        })??;\n\n        Ok(proto::Ack {})\n    }\n\n    async fn handle_lsp_ext_clear_flycheck(\n        lsp_store: Entity<Self>,\n        envelope: TypedEnvelope<proto::LspExtClearFlycheck>,\n        cx: AsyncApp,\n    ) -> Result<proto::Ack> {\n        let server_id = LanguageServerId(envelope.payload.language_server_id as usize);\n        lsp_store\n            .read_with(&cx, |lsp_store, _| {\n                if let Some(server) = lsp_store.language_server_for_id(server_id) {\n                    Some(server.notify::<lsp_store::lsp_ext_command::LspExtClearFlycheck>(()))\n                } else {\n                    None\n                }\n            })\n            .context(": "",
        ")?;\n\n        Ok(proto::Ack {})\n    }\n\n    pub fn disk_based_diagnostics_started(\n        &mut self,\n        language_server_id: LanguageServerId,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(language_server_status) =\n            self.language_server_statuses.get_mut(&language_server_id)\n        {\n            language_server_status.has_pending_diagnostic_updates = true;\n        }\n\n        cx.emit(LspStoreEvent::DiskBasedDiagnosticsStarted { language_server_id });\n        cx.emit(LspStoreEvent::LanguageServerUpdate {\n            language_server_id,\n            name: self\n                .language_server_adapter_for_id(language_server_id)\n                .map(|adapter| adapter.name()),\n            message: proto::update_language_server::Variant::DiskBasedDiagnosticsUpdating(\n                Default::default(),\n            ),\n        })\n    }\n\n    pub fn disk_based_diagnostics_finished(\n        &mut self,\n        language_server_id: LanguageServerId,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(language_server_status) =\n            self.language_server_statuses.get_mut(&language_server_id)\n        {\n            language_server_status.has_pending_diagnostic_updates = false;\n        }\n\n        cx.emit(LspStoreEvent::DiskBasedDiagnosticsFinished { language_server_id });\n        cx.emit(LspStoreEvent::LanguageServerUpdate {\n            language_server_id,\n            name: self\n                .language_server_adapter_for_id(language_server_id)\n                .map(|adapter| adapter.name()),\n            message: proto::update_language_server::Variant::DiskBasedDiagnosticsUpdated(\n                Default::default(),\n            ),\n        })\n    }\n\n    // After saving a buffer using a language server that doesn't provide a disk-based progress token,\n    // kick off a timer that will reset every time the buffer is saved. If the timer eventually fires,\n    // simulate disk-based diagnostics being finished so that other pieces of UI (e.g., project\n    // diagnostics view, diagnostic status bar) can update. We don't emit an event right away because\n    // the language server might take some time to publish diagnostics.\n    fn simulate_disk_based_diagnostics_events_if_needed(\n        &mut self,\n        language_server_id: LanguageServerId,\n        cx: &mut Context<Self>,\n    ) {\n        const DISK_BASED_DIAGNOSTICS_DEBOUNCE: Duration = Duration::from_secs(1);\n\n        let Some(LanguageServerState::Running {\n            simulate_disk_based_diagnostics_completion,\n            adapter,\n            ..\n        }) = self\n            .as_local_mut()\n            .and_then(|local_store| local_store.language_servers.get_mut(&language_server_id))\n        else {\n            return;\n        };\n\n        if adapter.disk_based_diagnostics_progress_token.is_some() {\n            return;\n        }\n\n        let prev_task =\n            simulate_disk_based_diagnostics_completion.replace(cx.spawn(async move |this, cx| {\n                cx.background_executor()\n                    .timer(DISK_BASED_DIAGNOSTICS_DEBOUNCE)\n                    .await;\n\n                this.update(cx, |this, cx| {\n                    this.disk_based_diagnostics_finished(language_server_id, cx);\n\n                    if let Some(LanguageServerState::Running {\n                        simulate_disk_based_diagnostics_completion,\n                        ..\n                    }) = this.as_local_mut().and_then(|local_store| {\n                        local_store.language_servers.get_mut(&language_server_id)\n                    }) {\n                        *simulate_disk_based_diagnostics_completion = None;\n                    }\n                })\n                .ok();\n            }));\n\n        if prev_task.is_none() {\n            self.disk_based_diagnostics_started(language_server_id, cx);\n        }\n    }\n\n    pub fn language_server_statuses(\n        &self,\n    ) -> impl DoubleEndedIterator<Item = (LanguageServerId, &LanguageServerStatus)> {\n        self.language_server_statuses\n            .iter()\n            .map(|(key, value)| (*key, value))\n    }\n\n    pub(super) fn did_rename_entry(\n        &self,\n        worktree_id: WorktreeId,\n        old_path: &Path,\n        new_path: &Path,\n        is_dir: bool,\n    ) {\n        maybe!({\n            let local_store = self.as_local()?;\n\n            let old_uri = lsp::Uri::from_file_path(old_path)\n                .ok()\n                .map(|uri| uri.to_string())?;\n            let new_uri = lsp::Uri::from_file_path(new_path)\n                .ok()\n                .map(|uri| uri.to_string())?;\n\n            for language_server in local_store.language_servers_for_worktree(worktree_id) {\n                let Some(filter) = local_store\n                    .language_server_paths_watched_for_rename\n                    .get(&language_server.server_id())\n                else {\n                    continue;\n                };\n\n                if filter.should_send_did_rename(&old_uri, is_dir) {\n                    language_server\n                        .notify::<DidRenameFiles>(RenameFilesParams {\n                            files: vec![FileRename {\n                                old_uri: old_uri.clone(),\n                                new_uri: new_uri.clone(),\n                            }],\n                        })\n                        .ok();\n                }\n            }\n            Some(())\n        });\n    }\n\n    pub(super) fn will_rename_entry(\n        this: WeakEntity<Self>,\n        worktree_id: WorktreeId,\n        old_path: &Path,\n        new_path: &Path,\n        is_dir: bool,\n        cx: AsyncApp,\n    ) -> Task<ProjectTransaction> {\n        let old_uri = lsp::Uri::from_file_path(old_path)\n            .ok()\n            .map(|uri| uri.to_string());\n        let new_uri = lsp::Uri::from_file_path(new_path)\n            .ok()\n            .map(|uri| uri.to_string());\n        cx.spawn(async move |cx| {\n            let mut tasks = vec![];\n            this.update(cx, |this, cx| {\n                let local_store = this.as_local()?;\n                let old_uri = old_uri?;\n                let new_uri = new_uri?;\n                for language_server in local_store.language_servers_for_worktree(worktree_id) {\n                    let Some(filter) = local_store\n                        .language_server_paths_watched_for_rename\n                        .get(&language_server.server_id())\n                    else {\n                        continue;\n                    };\n\n                    if filter.should_send_will_rename(&old_uri, is_dir) {\n                        let apply_edit = cx.spawn({\n                            let old_uri = old_uri.clone();\n                            let new_uri = new_uri.clone();\n                            let language_server = language_server.clone();\n                            async move |this, cx| {\n                                let edit = language_server\n                                    .request::<WillRenameFiles>(RenameFilesParams {\n                                        files: vec![FileRename { old_uri, new_uri }],\n                                    })\n                                    .await\n                                    .into_response()\n                                    .context(": "",
        ")\n                                    .log_err()\n                                    .flatten()?;\n\n                                let transaction = LocalLspStore::deserialize_workspace_edit(\n                                    this.upgrade()?,\n                                    edit,\n                                    false,\n                                    language_server.clone(),\n                                    cx,\n                                )\n                                .await\n                                .ok()?;\n                                Some(transaction)\n                            }\n                        });\n                        tasks.push(apply_edit);\n                    }\n                }\n                Some(())\n            })\n            .ok()\n            .flatten();\n            let mut merged_transaction = ProjectTransaction::default();\n            for task in tasks {\n                // Await on tasks sequentially so that the order of application of edits is deterministic\n                // (at least with regards to the order of registration of language servers)\n                if let Some(transaction) = task.await {\n                    for (buffer, buffer_transaction) in transaction.0 {\n                        merged_transaction.0.insert(buffer, buffer_transaction);\n                    }\n                }\n            }\n            merged_transaction\n        })\n    }\n\n    fn lsp_notify_abs_paths_changed(\n        &mut self,\n        server_id: LanguageServerId,\n        changes: Vec<PathEvent>,\n    ) {\n        maybe!({\n            let server = self.language_server_for_id(server_id)?;\n            let changes = changes\n                .into_iter()\n                .filter_map(|event| {\n                    let typ = match event.kind? {\n                        PathEventKind::Created => lsp::FileChangeType::CREATED,\n                        PathEventKind::Removed => lsp::FileChangeType::DELETED,\n                        PathEventKind::Changed => lsp::FileChangeType::CHANGED,\n                    };\n                    Some(lsp::FileEvent {\n                        uri: file_path_to_lsp_url(&event.path).log_err()?,\n                        typ,\n                    })\n                })\n                .collect::<Vec<_>>();\n            if !changes.is_empty() {\n                server\n                    .notify::<lsp::notification::DidChangeWatchedFiles>(\n                        lsp::DidChangeWatchedFilesParams { changes },\n                    )\n                    .ok();\n            }\n            Some(())\n        });\n    }\n\n    pub fn language_server_for_id(&self, id: LanguageServerId) -> Option<Arc<LanguageServer>> {\n        self.as_local()?.language_server_for_id(id)\n    }\n\n    fn on_lsp_progress(\n        &mut self,\n        progress_params: lsp::ProgressParams,\n        language_server_id: LanguageServerId,\n        disk_based_diagnostics_progress_token: Option<String>,\n        cx: &mut Context<Self>,\n    ) {\n        match progress_params.value {\n            lsp::ProgressParamsValue::WorkDone(progress) => {\n                self.handle_work_done_progress(\n                    progress,\n                    language_server_id,\n                    disk_based_diagnostics_progress_token,\n                    ProgressToken::from_lsp(progress_params.token),\n                    cx,\n                );\n            }\n            lsp::ProgressParamsValue::WorkspaceDiagnostic(report) => {\n                let identifier = match progress_params.token {\n                    lsp::NumberOrString::Number(_) => None,\n                    lsp::NumberOrString::String(token) => token\n                        .split_once(WORKSPACE_DIAGNOSTICS_TOKEN_START)\n                        .map(|(_, id)| id.to_owned()),\n                };\n                if let Some(LanguageServerState::Running {\n                    workspace_diagnostics_refresh_tasks,\n                    ..\n                }) = self\n                    .as_local_mut()\n                    .and_then(|local| local.language_servers.get_mut(&language_server_id))\n                    && let Some(workspace_diagnostics) =\n                        workspace_diagnostics_refresh_tasks.get_mut(&identifier)\n                {\n                    workspace_diagnostics.progress_tx.try_send(()).ok();\n                    self.apply_workspace_diagnostic_report(language_server_id, report, cx)\n                }\n            }\n        }\n    }\n\n    fn handle_work_done_progress(\n        &mut self,\n        progress: lsp::WorkDoneProgress,\n        language_server_id: LanguageServerId,\n        disk_based_diagnostics_progress_token: Option<String>,\n        token: ProgressToken,\n        cx: &mut Context<Self>,\n    ) {\n        let language_server_status =\n            if let Some(status) = self.language_server_statuses.get_mut(&language_server_id) {\n                status\n            } else {\n                return;\n            };\n\n        if !language_server_status.progress_tokens.contains(&token) {\n            return;\n        }\n\n        let is_disk_based_diagnostics_progress =\n            if let (Some(disk_based_token), ProgressToken::String(token)) =\n                (&disk_based_diagnostics_progress_token, &token)\n            {\n                token.starts_with(disk_based_token)\n            } else {\n                false\n            };\n\n        match progress {\n            lsp::WorkDoneProgress::Begin(report) => {\n                if is_disk_based_diagnostics_progress {\n                    self.disk_based_diagnostics_started(language_server_id, cx);\n                }\n                self.on_lsp_work_start(\n                    language_server_id,\n                    token.clone(),\n                    LanguageServerProgress {\n                        title: Some(report.title),\n                        is_disk_based_diagnostics_progress,\n                        is_cancellable: report.cancellable.unwrap_or(false),\n                        message: report.message.clone(),\n                        percentage: report.percentage.map(|p| p as usize),\n                        last_update_at: cx.background_executor().now(),\n                    },\n                    cx,\n                );\n            }\n            lsp::WorkDoneProgress::Report(report) => self.on_lsp_work_progress(\n                language_server_id,\n                token,\n                LanguageServerProgress {\n                    title: None,\n                    is_disk_based_diagnostics_progress,\n                    is_cancellable: report.cancellable.unwrap_or(false),\n                    message: report.message,\n                    percentage: report.percentage.map(|p| p as usize),\n                    last_update_at: cx.background_executor().now(),\n                },\n                cx,\n            ),\n            lsp::WorkDoneProgress::End(_) => {\n                language_server_status.progress_tokens.remove(&token);\n                self.on_lsp_work_end(language_server_id, token.clone(), cx);\n                if is_disk_based_diagnostics_progress {\n                    self.disk_based_diagnostics_finished(language_server_id, cx);\n                }\n            }\n        }\n    }\n\n    fn on_lsp_work_start(\n        &mut self,\n        language_server_id: LanguageServerId,\n        token: ProgressToken,\n        progress: LanguageServerProgress,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(status) = self.language_server_statuses.get_mut(&language_server_id) {\n            status.pending_work.insert(token.clone(), progress.clone());\n            cx.notify();\n        }\n        cx.emit(LspStoreEvent::LanguageServerUpdate {\n            language_server_id,\n            name: self\n                .language_server_adapter_for_id(language_server_id)\n                .map(|adapter| adapter.name()),\n            message: proto::update_language_server::Variant::WorkStart(proto::LspWorkStart {\n                token: Some(token.to_proto()),\n                title: progress.title,\n                message: progress.message,\n                percentage: progress.percentage.map(|p| p as u32),\n                is_cancellable: Some(progress.is_cancellable),\n            }),\n        })\n    }\n\n    fn on_lsp_work_progress(\n        &mut self,\n        language_server_id: LanguageServerId,\n        token: ProgressToken,\n        progress: LanguageServerProgress,\n        cx: &mut Context<Self>,\n    ) {\n        let mut did_update = false;\n        if let Some(status) = self.language_server_statuses.get_mut(&language_server_id) {\n            match status.pending_work.entry(token.clone()) {\n                btree_map::Entry::Vacant(entry) => {\n                    entry.insert(progress.clone());\n                    did_update = true;\n                }\n                btree_map::Entry::Occupied(mut entry) => {\n                    let entry = entry.get_mut();\n                    if (progress.last_update_at - entry.last_update_at)\n                        >= SERVER_PROGRESS_THROTTLE_TIMEOUT\n                    {\n                        entry.last_update_at = progress.last_update_at;\n                        if progress.message.is_some() {\n                            entry.message = progress.message.clone();\n                        }\n                        if progress.percentage.is_some() {\n                            entry.percentage = progress.percentage;\n                        }\n                        if progress.is_cancellable != entry.is_cancellable {\n                            entry.is_cancellable = progress.is_cancellable;\n                        }\n                        did_update = true;\n                    }\n                }\n            }\n        }\n\n        if did_update {\n            cx.emit(LspStoreEvent::LanguageServerUpdate {\n                language_server_id,\n                name: self\n                    .language_server_adapter_for_id(language_server_id)\n                    .map(|adapter| adapter.name()),\n                message: proto::update_language_server::Variant::WorkProgress(\n                    proto::LspWorkProgress {\n                        token: Some(token.to_proto()),\n                        message: progress.message,\n                        percentage: progress.percentage.map(|p| p as u32),\n                        is_cancellable: Some(progress.is_cancellable),\n                    },\n                ),\n            })\n        }\n    }\n\n    fn on_lsp_work_end(\n        &mut self,\n        language_server_id: LanguageServerId,\n        token: ProgressToken,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(status) = self.language_server_statuses.get_mut(&language_server_id) {\n            if let Some(work) = status.pending_work.remove(&token)\n                && !work.is_disk_based_diagnostics_progress\n            {\n                cx.emit(LspStoreEvent::RefreshInlayHints {\n                    server_id: language_server_id,\n                    request_id: None,\n                });\n            }\n            cx.notify();\n        }\n\n        cx.emit(LspStoreEvent::LanguageServerUpdate {\n            language_server_id,\n            name: self\n                .language_server_adapter_for_id(language_server_id)\n                .map(|adapter| adapter.name()),\n            message: proto::update_language_server::Variant::WorkEnd(proto::LspWorkEnd {\n                token: Some(token.to_proto()),\n            }),\n        })\n    }\n\n    pub async fn handle_resolve_completion_documentation(\n        this: Entity<Self>,\n        envelope: TypedEnvelope<proto::ResolveCompletionDocumentation>,\n        mut cx: AsyncApp,\n    ) -> Result<proto::ResolveCompletionDocumentationResponse> {\n        let lsp_completion = serde_json::from_slice(&envelope.payload.lsp_completion)?;\n\n        let completion = this\n            .read_with(&cx, |this, cx| {\n                let id = LanguageServerId(envelope.payload.language_server_id as usize);\n                let server = this\n                    .language_server_for_id(id)\n                    .with_context(|| format!(": "",
        "))?;\n\n                anyhow::Ok(cx.background_spawn(async move {\n                    let can_resolve = server\n                        .capabilities()\n                        .completion_provider\n                        .as_ref()\n                        .and_then(|options| options.resolve_provider)\n                        .unwrap_or(false);\n                    if can_resolve {\n                        server\n                            .request::<lsp::request::ResolveCompletionItem>(lsp_completion)\n                            .await\n                            .into_response()\n                            .context(": "",
        ")\n                    } else {\n                        anyhow::Ok(lsp_completion)\n                    }\n                }))\n            })??\n            .await?;\n\n        let mut documentation_is_markdown = false;\n        let lsp_completion = serde_json::to_string(&completion)?.into_bytes();\n        let documentation = match completion.documentation {\n            Some(lsp::Documentation::String(text)) => text,\n\n            Some(lsp::Documentation::MarkupContent(lsp::MarkupContent { kind, value })) => {\n                documentation_is_markdown = kind == lsp::MarkupKind::Markdown;\n                value\n            }\n\n            _ => String::new(),\n        };\n\n        // If we have a new buffer_id, that means we're talking to a new client\n        // and want to check for new text_edits in the completion too.\n        let mut old_replace_start = None;\n        let mut old_replace_end = None;\n        let mut old_insert_start = None;\n        let mut old_insert_end = None;\n        let mut new_text = String::default();\n        if let Ok(buffer_id) = BufferId::new(envelope.payload.buffer_id) {\n            let buffer_snapshot = this.update(&mut cx, |this, cx| {\n                let buffer = this.buffer_store.read(cx).get_existing(buffer_id)?;\n                anyhow::Ok(buffer.read(cx).snapshot())\n            })??;\n\n            if let Some(text_edit) = completion.text_edit.as_ref() {\n                let edit = parse_completion_text_edit(text_edit, &buffer_snapshot);\n\n                if let Some(mut edit) = edit {\n                    LineEnding::normalize(&mut edit.new_text);\n\n                    new_text = edit.new_text;\n                    old_replace_start = Some(serialize_anchor(&edit.replace_range.start));\n                    old_replace_end = Some(serialize_anchor(&edit.replace_range.end));\n                    if let Some(insert_range) = edit.insert_range {\n                        old_insert_start = Some(serialize_anchor(&insert_range.start));\n                        old_insert_end = Some(serialize_anchor(&insert_range.end));\n                    }\n                }\n            }\n        }\n\n        Ok(proto::ResolveCompletionDocumentationResponse {\n            documentation,\n            documentation_is_markdown,\n            old_replace_start,\n            old_replace_end,\n            new_text,\n            lsp_completion,\n            old_insert_start,\n            old_insert_end,\n        })\n    }\n\n    async fn handle_on_type_formatting(\n        this: Entity<Self>,\n        envelope: TypedEnvelope<proto::OnTypeFormatting>,\n        mut cx: AsyncApp,\n    ) -> Result<proto::OnTypeFormattingResponse> {\n        let on_type_formatting = this.update(&mut cx, |this, cx| {\n            let buffer_id = BufferId::new(envelope.payload.buffer_id)?;\n            let buffer = this.buffer_store.read(cx).get_existing(buffer_id)?;\n            let position = envelope\n                .payload\n                .position\n                .and_then(deserialize_anchor)\n                .context(": "",
        ")?;\n            anyhow::Ok(this.apply_on_type_formatting(\n                buffer,\n                position,\n                envelope.payload.trigger.clone(),\n                cx,\n            ))\n        })??;\n\n        let transaction = on_type_formatting\n            .await?\n            .as_ref()\n            .map(language::proto::serialize_transaction);\n        Ok(proto::OnTypeFormattingResponse { transaction })\n    }\n\n    async fn handle_refresh_inlay_hints(\n        lsp_store: Entity<Self>,\n        envelope: TypedEnvelope<proto::RefreshInlayHints>,\n        mut cx: AsyncApp,\n    ) -> Result<proto::Ack> {\n        lsp_store.update(&mut cx, |_, cx| {\n            cx.emit(LspStoreEvent::RefreshInlayHints {\n                server_id: LanguageServerId::from_proto(envelope.payload.server_id),\n                request_id: envelope.payload.request_id.map(|id| id as usize),\n            });\n        })?;\n        Ok(proto::Ack {})\n    }\n\n    async fn handle_pull_workspace_diagnostics(\n        lsp_store: Entity<Self>,\n        envelope: TypedEnvelope<proto::PullWorkspaceDiagnostics>,\n        mut cx: AsyncApp,\n    ) -> Result<proto::Ack> {\n        let server_id = LanguageServerId::from_proto(envelope.payload.server_id);\n        lsp_store.update(&mut cx, |lsp_store, _| {\n            lsp_store.pull_workspace_diagnostics(server_id);\n        })?;\n        Ok(proto::Ack {})\n    }\n\n    async fn handle_get_color_presentation(\n        lsp_store: Entity<Self>,\n        envelope: TypedEnvelope<proto::GetColorPresentation>,\n        mut cx: AsyncApp,\n    ) -> Result<proto::GetColorPresentationResponse> {\n        let buffer_id = BufferId::new(envelope.payload.buffer_id)?;\n        let buffer = lsp_store.update(&mut cx, |lsp_store, cx| {\n            lsp_store.buffer_store.read(cx).get_existing(buffer_id)\n        })??;\n\n        let color = envelope\n            .payload\n            .color\n            .context(": "",
        ")?;\n        let start = color\n            .lsp_range_start\n            .context(": "",
        ")?;\n        let end = color\n            .lsp_range_end\n            .context(": "",
        ")?;\n\n        let color = DocumentColor {\n            lsp_range: lsp::Range {\n                start: point_to_lsp(PointUtf16::new(start.row, start.column)),\n                end: point_to_lsp(PointUtf16::new(end.row, end.column)),\n            },\n            color: lsp::Color {\n                red: color.red,\n                green: color.green,\n                blue: color.blue,\n                alpha: color.alpha,\n            },\n            resolved: false,\n            color_presentations: Vec::new(),\n        };\n        let resolved_color = lsp_store\n            .update(&mut cx, |lsp_store, cx| {\n                lsp_store.resolve_color_presentation(\n                    color,\n                    buffer.clone(),\n                    LanguageServerId(envelope.payload.server_id as usize),\n                    cx,\n                )\n            })?\n            .await\n            .context(": "",
        ")?;\n\n        Ok(proto::GetColorPresentationResponse {\n            presentations: resolved_color\n                .color_presentations\n                .into_iter()\n                .map(|presentation| proto::ColorPresentation {\n                    label: presentation.label.to_string(),\n                    text_edit: presentation.text_edit.map(serialize_lsp_edit),\n                    additional_text_edits: presentation\n                        .additional_text_edits\n                        .into_iter()\n                        .map(serialize_lsp_edit)\n                        .collect(),\n                })\n                .collect(),\n        })\n    }\n\n    async fn handle_resolve_inlay_hint(\n        lsp_store: Entity<Self>,\n        envelope: TypedEnvelope<proto::ResolveInlayHint>,\n        mut cx: AsyncApp,\n    ) -> Result<proto::ResolveInlayHintResponse> {\n        let proto_hint = envelope\n            .payload\n            .hint\n            .expect(": "",
        ");\n        let hint = InlayHints::proto_to_project_hint(proto_hint)\n            .context(": "",
        ")?;\n        let buffer = lsp_store.update(&mut cx, |lsp_store, cx| {\n            let buffer_id = BufferId::new(envelope.payload.buffer_id)?;\n            lsp_store.buffer_store.read(cx).get_existing(buffer_id)\n        })??;\n        let response_hint = lsp_store\n            .update(&mut cx, |lsp_store, cx| {\n                lsp_store.resolve_inlay_hint(\n                    hint,\n                    buffer,\n                    LanguageServerId(envelope.payload.language_server_id as usize),\n                    cx,\n                )\n            })?\n            .await\n            .context(": "",
        ")?;\n        Ok(proto::ResolveInlayHintResponse {\n            hint: Some(InlayHints::project_to_proto_hint(response_hint)),\n        })\n    }\n\n    async fn handle_refresh_code_lens(\n        this: Entity<Self>,\n        _: TypedEnvelope<proto::RefreshCodeLens>,\n        mut cx: AsyncApp,\n    ) -> Result<proto::Ack> {\n        this.update(&mut cx, |_, cx| {\n            cx.emit(LspStoreEvent::RefreshCodeLens);\n        })?;\n        Ok(proto::Ack {})\n    }\n\n    async fn handle_open_buffer_for_symbol(\n        this: Entity<Self>,\n        envelope: TypedEnvelope<proto::OpenBufferForSymbol>,\n        mut cx: AsyncApp,\n    ) -> Result<proto::OpenBufferForSymbolResponse> {\n        let peer_id = envelope.original_sender_id().unwrap_or_default();\n        let symbol = envelope.payload.symbol.context(": "",
        ")?;\n        let symbol = Self::deserialize_symbol(symbol)?;\n        this.read_with(&cx, |this, _| {\n            if let SymbolLocation::OutsideProject {\n                abs_path,\n                signature,\n            } = &symbol.path\n            {\n                let new_signature = this.symbol_signature(&abs_path);\n                anyhow::ensure!(&new_signature == signature, ": "",
        ");\n            }\n            Ok(())\n        })??;\n        let buffer = this\n            .update(&mut cx, |this, cx| {\n                this.open_buffer_for_symbol(\n                    &Symbol {\n                        language_server_name: symbol.language_server_name,\n                        source_worktree_id: symbol.source_worktree_id,\n                        source_language_server_id: symbol.source_language_server_id,\n                        path: symbol.path,\n                        name: symbol.name,\n                        kind: symbol.kind,\n                        range: symbol.range,\n                        label: CodeLabel::default(),\n                    },\n                    cx,\n                )\n            })?\n            .await?;\n\n        this.update(&mut cx, |this, cx| {\n            let is_private = buffer\n                .read(cx)\n                .file()\n                .map(|f| f.is_private())\n                .unwrap_or_default();\n            if is_private {\n                Err(anyhow!(rpc::ErrorCode::UnsharedItem))\n            } else {\n                this.buffer_store\n                    .update(cx, |buffer_store, cx| {\n                        buffer_store.create_buffer_for_peer(&buffer, peer_id, cx)\n                    })\n                    .detach_and_log_err(cx);\n                let buffer_id = buffer.read(cx).remote_id().to_proto();\n                Ok(proto::OpenBufferForSymbolResponse { buffer_id })\n            }\n        })?\n    }\n\n    fn symbol_signature(&self, abs_path: &Path) -> [u8; 32] {\n        let mut hasher = Sha256::new();\n        hasher.update(abs_path.to_string_lossy().as_bytes());\n        hasher.update(self.nonce.to_be_bytes());\n        hasher.finalize().as_slice().try_into().unwrap()\n    }\n\n    pub async fn handle_get_project_symbols(\n        this: Entity<Self>,\n        envelope: TypedEnvelope<proto::GetProjectSymbols>,\n        mut cx: AsyncApp,\n    ) -> Result<proto::GetProjectSymbolsResponse> {\n        let symbols = this\n            .update(&mut cx, |this, cx| {\n                this.symbols(&envelope.payload.query, cx)\n            })?\n            .await?;\n\n        Ok(proto::GetProjectSymbolsResponse {\n            symbols: symbols.iter().map(Self::serialize_symbol).collect(),\n        })\n    }\n\n    pub async fn handle_restart_language_servers(\n        this: Entity<Self>,\n        envelope: TypedEnvelope<proto::RestartLanguageServers>,\n        mut cx: AsyncApp,\n    ) -> Result<proto::Ack> {\n        this.update(&mut cx, |lsp_store, cx| {\n            let buffers =\n                lsp_store.buffer_ids_to_buffers(envelope.payload.buffer_ids.into_iter(), cx);\n            lsp_store.restart_language_servers_for_buffers(\n                buffers,\n                envelope\n                    .payload\n                    .only_servers\n                    .into_iter()\n                    .filter_map(|selector| {\n                        Some(match selector.selector? {\n                            proto::language_server_selector::Selector::ServerId(server_id) => {\n                                LanguageServerSelector::Id(LanguageServerId::from_proto(server_id))\n                            }\n                            proto::language_server_selector::Selector::Name(name) => {\n                                LanguageServerSelector::Name(LanguageServerName(\n                                    SharedString::from(name),\n                                ))\n                            }\n                        })\n                    })\n                    .collect(),\n                cx,\n            );\n        })?;\n\n        Ok(proto::Ack {})\n    }\n\n    pub async fn handle_stop_language_servers(\n        lsp_store: Entity<Self>,\n        envelope: TypedEnvelope<proto::StopLanguageServers>,\n        mut cx: AsyncApp,\n    ) -> Result<proto::Ack> {\n        lsp_store.update(&mut cx, |lsp_store, cx| {\n            if envelope.payload.all\n                && envelope.payload.also_servers.is_empty()\n                && envelope.payload.buffer_ids.is_empty()\n            {\n                lsp_store.stop_all_language_servers(cx);\n            } else {\n                let buffers =\n                    lsp_store.buffer_ids_to_buffers(envelope.payload.buffer_ids.into_iter(), cx);\n                lsp_store\n                    .stop_language_servers_for_buffers(\n                        buffers,\n                        envelope\n                            .payload\n                            .also_servers\n                            .into_iter()\n                            .filter_map(|selector| {\n                                Some(match selector.selector? {\n                                    proto::language_server_selector::Selector::ServerId(\n                                        server_id,\n                                    ) => LanguageServerSelector::Id(LanguageServerId::from_proto(\n                                        server_id,\n                                    )),\n                                    proto::language_server_selector::Selector::Name(name) => {\n                                        LanguageServerSelector::Name(LanguageServerName(\n                                            SharedString::from(name),\n                                        ))\n                                    }\n                                })\n                            })\n                            .collect(),\n                        cx,\n                    )\n                    .detach_and_log_err(cx);\n            }\n        })?;\n\n        Ok(proto::Ack {})\n    }\n\n    pub async fn handle_cancel_language_server_work(\n        lsp_store: Entity<Self>,\n        envelope: TypedEnvelope<proto::CancelLanguageServerWork>,\n        mut cx: AsyncApp,\n    ) -> Result<proto::Ack> {\n        lsp_store.update(&mut cx, |lsp_store, cx| {\n            if let Some(work) = envelope.payload.work {\n                match work {\n                    proto::cancel_language_server_work::Work::Buffers(buffers) => {\n                        let buffers =\n                            lsp_store.buffer_ids_to_buffers(buffers.buffer_ids.into_iter(), cx);\n                        lsp_store.cancel_language_server_work_for_buffers(buffers, cx);\n                    }\n                    proto::cancel_language_server_work::Work::LanguageServerWork(work) => {\n                        let server_id = LanguageServerId::from_proto(work.language_server_id);\n                        let token = work\n                            .token\n                            .map(|token| {\n                                ProgressToken::from_proto(token)\n                                    .context(": "",
        ")\n                            })\n                            .transpose()?;\n                        lsp_store.cancel_language_server_work(server_id, token, cx);\n                    }\n                }\n            }\n            anyhow::Ok(())\n        })??;\n\n        Ok(proto::Ack {})\n    }\n\n    fn buffer_ids_to_buffers(\n        &mut self,\n        buffer_ids: impl Iterator<Item = u64>,\n        cx: &mut Context<Self>,\n    ) -> Vec<Entity<Buffer>> {\n        buffer_ids\n            .into_iter()\n            .flat_map(|buffer_id| {\n                self.buffer_store\n                    .read(cx)\n                    .get(BufferId::new(buffer_id).log_err()?)\n            })\n            .collect::<Vec<_>>()\n    }\n\n    async fn handle_apply_additional_edits_for_completion(\n        this: Entity<Self>,\n        envelope: TypedEnvelope<proto::ApplyCompletionAdditionalEdits>,\n        mut cx: AsyncApp,\n    ) -> Result<proto::ApplyCompletionAdditionalEditsResponse> {\n        let (buffer, completion) = this.update(&mut cx, |this, cx| {\n            let buffer_id = BufferId::new(envelope.payload.buffer_id)?;\n            let buffer = this.buffer_store.read(cx).get_existing(buffer_id)?;\n            let completion = Self::deserialize_completion(\n                envelope.payload.completion.context(": "",
        ")?,\n            )?;\n            anyhow::Ok((buffer, completion))\n        })??;\n\n        let apply_additional_edits = this.update(&mut cx, |this, cx| {\n            this.apply_additional_edits_for_completion(\n                buffer,\n                Rc::new(RefCell::new(Box::new([Completion {\n                    replace_range: completion.replace_range,\n                    new_text: completion.new_text,\n                    source: completion.source,\n                    documentation: None,\n                    label: CodeLabel::default(),\n                    insert_text_mode: None,\n                    icon_path: None,\n                    confirm: None,\n                }]))),\n                0,\n                false,\n                cx,\n            )\n        })?;\n\n        Ok(proto::ApplyCompletionAdditionalEditsResponse {\n            transaction: apply_additional_edits\n                .await?\n                .as_ref()\n                .map(language::proto::serialize_transaction),\n        })\n    }\n\n    pub fn last_formatting_failure(&self) -> Option<&str> {\n        self.last_formatting_failure.as_deref()\n    }\n\n    pub fn reset_last_formatting_failure(&mut self) {\n        self.last_formatting_failure = None;\n    }\n\n    pub fn environment_for_buffer(\n        &self,\n        buffer: &Entity<Buffer>,\n        cx: &mut Context<Self>,\n    ) -> Shared<Task<Option<HashMap<String, String>>>> {\n        if let Some(environment) = &self.as_local().map(|local| local.environment.clone()) {\n            environment.update(cx, |env, cx| {\n                env.buffer_environment(buffer, &self.worktree_store, cx)\n            })\n        } else {\n            Task::ready(None).shared()\n        }\n    }\n\n    pub fn format(\n        &mut self,\n        buffers: HashSet<Entity<Buffer>>,\n        target: LspFormatTarget,\n        push_to_history: bool,\n        trigger: FormatTrigger,\n        cx: &mut Context<Self>,\n    ) -> Task<anyhow::Result<ProjectTransaction>> {\n        let logger = zlog::scoped!(": "",
        ");\n        if self.as_local().is_some() {\n            zlog::trace!(logger => ": "",
        ");\n            let logger = zlog::scoped!(logger => ": "",
        ");\n            let buffers = buffers\n                .into_iter()\n                .map(|buffer_handle| {\n                    let buffer = buffer_handle.read(cx);\n                    let buffer_abs_path = File::from_dyn(buffer.file())\n                        .and_then(|file| file.as_local().map(|f| f.abs_path(cx)));\n\n                    (buffer_handle, buffer_abs_path, buffer.remote_id())\n                })\n                .collect::<Vec<_>>();\n\n            cx.spawn(async move |lsp_store, cx| {\n                let mut formattable_buffers = Vec::with_capacity(buffers.len());\n\n                for (handle, abs_path, id) in buffers {\n                    let env = lsp_store\n                        .update(cx, |lsp_store, cx| {\n                            lsp_store.environment_for_buffer(&handle, cx)\n                        })?\n                        .await;\n\n                    let ranges = match &target {\n                        LspFormatTarget::Buffers => None,\n                        LspFormatTarget::Ranges(ranges) => {\n                            Some(ranges.get(&id).context(": "",
        ")?.clone())\n                        }\n                    };\n\n                    formattable_buffers.push(FormattableBuffer {\n                        handle,\n                        abs_path,\n                        env,\n                        ranges,\n                    });\n                }\n                zlog::trace!(logger => ": "",
        ", formattable_buffers.len());\n\n                let format_timer = zlog::time!(logger => ": "",
        ");\n                let result = LocalLspStore::format_locally(\n                    lsp_store.clone(),\n                    formattable_buffers,\n                    push_to_history,\n                    trigger,\n                    logger,\n                    cx,\n                )\n                .await;\n                format_timer.end();\n\n                zlog::trace!(logger => ": "",
        ", result.as_ref().map(|_| ": "",
        "));\n\n                lsp_store.update(cx, |lsp_store, _| {\n                    lsp_store.update_last_formatting_failure(&result);\n                })?;\n\n                result\n            })\n        } else if let Some((client, project_id)) = self.upstream_client() {\n            zlog::trace!(logger => ": "",
        ");\n            // Don't support formatting ranges via remote\n            match target {\n                LspFormatTarget::Buffers => {}\n                LspFormatTarget::Ranges(_) => {\n                    zlog::trace!(logger => ": "",
        ");\n                    return Task::ready(Ok(ProjectTransaction::default()));\n                }\n            }\n\n            let buffer_store = self.buffer_store();\n            cx.spawn(async move |lsp_store, cx| {\n                zlog::trace!(logger => ": "",
        ");\n                let request_timer = zlog::time!(logger => ": "",
        ");\n                let result = client\n                    .request(proto::FormatBuffers {\n                        project_id,\n                        trigger: trigger as i32,\n                        buffer_ids: buffers\n                            .iter()\n                            .map(|buffer| buffer.read_with(cx, |buffer, _| buffer.remote_id().into()))\n                            .collect::<Result<_>>()?,\n                    })\n                    .await\n                    .and_then(|result| result.transaction.context(": "",
        "));\n                request_timer.end();\n\n                zlog::trace!(logger => ": "",
        "));\n\n                lsp_store.update(cx, |lsp_store, _| {\n                    lsp_store.update_last_formatting_failure(&result);\n                })?;\n\n                let transaction_response = result?;\n                let _timer = zlog::time!(logger => ": "",
        ");\n                buffer_store\n                    .update(cx, |buffer_store, cx| {\n                        buffer_store.deserialize_project_transaction(\n                            transaction_response,\n                            push_to_history,\n                            cx,\n                        )\n                    })?\n                    .await\n            })\n        } else {\n            zlog::trace!(logger => ": "",
        ");\n            Task::ready(Ok(ProjectTransaction::default()))\n        }\n    }\n\n    async fn handle_format_buffers(\n        this: Entity<Self>,\n        envelope: TypedEnvelope<proto::FormatBuffers>,\n        mut cx: AsyncApp,\n    ) -> Result<proto::FormatBuffersResponse> {\n        let sender_id = envelope.original_sender_id().unwrap_or_default();\n        let format = this.update(&mut cx, |this, cx| {\n            let mut buffers = HashSet::default();\n            for buffer_id in &envelope.payload.buffer_ids {\n                let buffer_id = BufferId::new(*buffer_id)?;\n                buffers.insert(this.buffer_store.read(cx).get_existing(buffer_id)?);\n            }\n            let trigger = FormatTrigger::from_proto(envelope.payload.trigger);\n            anyhow::Ok(this.format(buffers, LspFormatTarget::Buffers, false, trigger, cx))\n        })??;\n\n        let project_transaction = format.await?;\n        let project_transaction = this.update(&mut cx, |this, cx| {\n            this.buffer_store.update(cx, |buffer_store, cx| {\n                buffer_store.serialize_project_transaction_for_peer(\n                    project_transaction,\n                    sender_id,\n                    cx,\n                )\n            })\n        })?;\n        Ok(proto::FormatBuffersResponse {\n            transaction: Some(project_transaction),\n        })\n    }\n\n    async fn handle_apply_code_action_kind(\n        this: Entity<Self>,\n        envelope: TypedEnvelope<proto::ApplyCodeActionKind>,\n        mut cx: AsyncApp,\n    ) -> Result<proto::ApplyCodeActionKindResponse> {\n        let sender_id = envelope.original_sender_id().unwrap_or_default();\n        let format = this.update(&mut cx, |this, cx| {\n            let mut buffers = HashSet::default();\n            for buffer_id in &envelope.payload.buffer_ids {\n                let buffer_id = BufferId::new(*buffer_id)?;\n                buffers.insert(this.buffer_store.read(cx).get_existing(buffer_id)?);\n            }\n            let kind = match envelope.payload.kind.as_str() {\n                ": "",
        " => CodeActionKind::EMPTY,\n                ": "",
        " => CodeActionKind::QUICKFIX,\n                ": "",
        " => CodeActionKind::REFACTOR,\n                ": "",
        " => CodeActionKind::REFACTOR_EXTRACT,\n                ": "",
        " => CodeActionKind::REFACTOR_INLINE,\n                ": "",
        " => CodeActionKind::REFACTOR_REWRITE,\n                ": "",
        " => CodeActionKind::SOURCE,\n                ": "",
        " => CodeActionKind::SOURCE_ORGANIZE_IMPORTS,\n                ": "",
        " => CodeActionKind::SOURCE_FIX_ALL,\n                _ => anyhow::bail!(\n                    ": "",
        ",\n                    envelope.payload.kind.as_str()\n                ),\n            };\n            anyhow::Ok(this.apply_code_action_kind(buffers, kind, false, cx))\n        })??;\n\n        let project_transaction = format.await?;\n        let project_transaction = this.update(&mut cx, |this, cx| {\n            this.buffer_store.update(cx, |buffer_store, cx| {\n                buffer_store.serialize_project_transaction_for_peer(\n                    project_transaction,\n                    sender_id,\n                    cx,\n                )\n            })\n        })?;\n        Ok(proto::ApplyCodeActionKindResponse {\n            transaction: Some(project_transaction),\n        })\n    }\n\n    async fn shutdown_language_server(\n        server_state: Option<LanguageServerState>,\n        name: LanguageServerName,\n        cx: &mut AsyncApp,\n    ) {\n        let server = match server_state {\n            Some(LanguageServerState::Starting { startup, .. }) => {\n                let mut timer = cx\n                    .background_executor()\n                    .timer(SERVER_LAUNCHING_BEFORE_SHUTDOWN_TIMEOUT)\n                    .fuse();\n\n                select! {\n                    server = startup.fuse() => server,\n                    () = timer => {\n                        log::info!(": "",
        ");\n                        None\n                    },\n                }\n            }\n\n            Some(LanguageServerState::Running { server, .. }) => Some(server),\n\n            None => None,\n        };\n\n        if let Some(server) = server\n            && let Some(shutdown) = server.shutdown()\n        {\n            shutdown.await;\n        }\n    }\n\n    // Returns a list of all of the worktrees which no longer have a language server and the root path\n    // for the stopped server\n    fn stop_local_language_server(\n        &mut self,\n        server_id: LanguageServerId,\n        cx: &mut Context<Self>,\n    ) -> Task<()> {\n        let local = match &mut self.mode {\n            LspStoreMode::Local(local) => local,\n            _ => {\n                return Task::ready(());\n            }\n        };\n\n        // Remove this server ID from all entries in the given worktree.\n        local\n            .language_server_ids\n            .retain(|_, state| state.id != server_id);\n        self.buffer_store.update(cx, |buffer_store, cx| {\n            for buffer in buffer_store.buffers() {\n                buffer.update(cx, |buffer, cx| {\n                    buffer.update_diagnostics(server_id, DiagnosticSet::new([], buffer), cx);\n                    buffer.set_completion_triggers(server_id, Default::default(), cx);\n                });\n            }\n        });\n\n        for (worktree_id, summaries) in self.diagnostic_summaries.iter_mut() {\n            summaries.retain(|path, summaries_by_server_id| {\n                if summaries_by_server_id.remove(&server_id).is_some() {\n                    if let Some((client, project_id)) = self.downstream_client.clone() {\n                        client\n                            .send(proto::UpdateDiagnosticSummary {\n                                project_id,\n                                worktree_id: worktree_id.to_proto(),\n                                summary: Some(proto::DiagnosticSummary {\n                                    path: path.as_ref().to_proto(),\n                                    language_server_id: server_id.0 as u64,\n                                    error_count: 0,\n                                    warning_count: 0,\n                                }),\n                                more_summaries: Vec::new(),\n                            })\n                            .log_err();\n                    }\n                    !summaries_by_server_id.is_empty()\n                } else {\n                    true\n                }\n            });\n        }\n\n        let local = self.as_local_mut().unwrap();\n        for diagnostics in local.diagnostics.values_mut() {\n            diagnostics.retain(|_, diagnostics_by_server_id| {\n                if let Ok(ix) = diagnostics_by_server_id.binary_search_by_key(&server_id, |e| e.0) {\n                    diagnostics_by_server_id.remove(ix);\n                    !diagnostics_by_server_id.is_empty()\n                } else {\n                    true\n                }\n            });\n        }\n        local.language_server_watched_paths.remove(&server_id);\n\n        let server_state = local.language_servers.remove(&server_id);\n        self.cleanup_lsp_data(server_id);\n        let name = self\n            .language_server_statuses\n            .remove(&server_id)\n            .map(|status| status.name)\n            .or_else(|| {\n                if let Some(LanguageServerState::Running { adapter, .. }) = server_state.as_ref() {\n                    Some(adapter.name())\n                } else {\n                    None\n                }\n            });\n\n        if let Some(name) = name {\n            log::info!(": "",
        ");\n            self.languages\n                .update_lsp_binary_status(name.clone(), BinaryStatus::Stopping);\n            cx.notify();\n\n            return cx.spawn(async move |lsp_store, cx| {\n                Self::shutdown_language_server(server_state, name.clone(), cx).await;\n                lsp_store\n                    .update(cx, |lsp_store, cx| {\n                        lsp_store\n                            .languages\n                            .update_lsp_binary_status(name, BinaryStatus::Stopped);\n                        cx.emit(LspStoreEvent::LanguageServerRemoved(server_id));\n                        cx.notify();\n                    })\n                    .ok();\n            });\n        }\n\n        if server_state.is_some() {\n            cx.emit(LspStoreEvent::LanguageServerRemoved(server_id));\n        }\n        Task::ready(())\n    }\n\n    pub fn stop_all_language_servers(&mut self, cx: &mut Context<Self>) {\n        if let Some((client, project_id)) = self.upstream_client() {\n            let request = client.request(proto::StopLanguageServers {\n                project_id,\n                buffer_ids: Vec::new(),\n                also_servers: Vec::new(),\n                all: true,\n            });\n            cx.background_spawn(request).detach_and_log_err(cx);\n        } else {\n            let Some(local) = self.as_local_mut() else {\n                return;\n            };\n            let language_servers_to_stop = local\n                .language_server_ids\n                .values()\n                .map(|state| state.id)\n                .collect();\n            local.lsp_tree.remove_nodes(&language_servers_to_stop);\n            let tasks = language_servers_to_stop\n                .into_iter()\n                .map(|server| self.stop_local_language_server(server, cx))\n                .collect::<Vec<_>>();\n            cx.background_spawn(async move {\n                futures::future::join_all(tasks).await;\n            })\n            .detach();\n        }\n    }\n\n    pub fn restart_language_servers_for_buffers(\n        &mut self,\n        buffers: Vec<Entity<Buffer>>,\n        only_restart_servers: HashSet<LanguageServerSelector>,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some((client, project_id)) = self.upstream_client() {\n            let request = client.request(proto::RestartLanguageServers {\n                project_id,\n                buffer_ids: buffers\n                    .into_iter()\n                    .map(|b| b.read(cx).remote_id().to_proto())\n                    .collect(),\n                only_servers: only_restart_servers\n                    .into_iter()\n                    .map(|selector| {\n                        let selector = match selector {\n                            LanguageServerSelector::Id(language_server_id) => {\n                                proto::language_server_selector::Selector::ServerId(\n                                    language_server_id.to_proto(),\n                                )\n                            }\n                            LanguageServerSelector::Name(language_server_name) => {\n                                proto::language_server_selector::Selector::Name(\n                                    language_server_name.to_string(),\n                                )\n                            }\n                        };\n                        proto::LanguageServerSelector {\n                            selector: Some(selector),\n                        }\n                    })\n                    .collect(),\n                all: false,\n            });\n            cx.background_spawn(request).detach_and_log_err(cx);\n        } else {\n            let stop_task = if only_restart_servers.is_empty() {\n                self.stop_local_language_servers_for_buffers(&buffers, HashSet::default(), cx)\n            } else {\n                self.stop_local_language_servers_for_buffers(&[], only_restart_servers.clone(), cx)\n            };\n            cx.spawn(async move |lsp_store, cx| {\n                stop_task.await;\n                lsp_store\n                    .update(cx, |lsp_store, cx| {\n                        for buffer in buffers {\n                            lsp_store.register_buffer_with_language_servers(\n                                &buffer,\n                                only_restart_servers.clone(),\n                                true,\n                                cx,\n                            );\n                        }\n                    })\n                    .ok()\n            })\n            .detach();\n        }\n    }\n\n    pub fn stop_language_servers_for_buffers(\n        &mut self,\n        buffers: Vec<Entity<Buffer>>,\n        also_stop_servers: HashSet<LanguageServerSelector>,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<()>> {\n        if let Some((client, project_id)) = self.upstream_client() {\n            let request = client.request(proto::StopLanguageServers {\n                project_id,\n                buffer_ids: buffers\n                    .into_iter()\n                    .map(|b| b.read(cx).remote_id().to_proto())\n                    .collect(),\n                also_servers: also_stop_servers\n                    .into_iter()\n                    .map(|selector| {\n                        let selector = match selector {\n                            LanguageServerSelector::Id(language_server_id) => {\n                                proto::language_server_selector::Selector::ServerId(\n                                    language_server_id.to_proto(),\n                                )\n                            }\n                            LanguageServerSelector::Name(language_server_name) => {\n                                proto::language_server_selector::Selector::Name(\n                                    language_server_name.to_string(),\n                                )\n                            }\n                        };\n                        proto::LanguageServerSelector {\n                            selector: Some(selector),\n                        }\n                    })\n                    .collect(),\n                all: false,\n            });\n            cx.background_spawn(async move {\n                let _ = request.await?;\n                Ok(())\n            })\n        } else {\n            let task =\n                self.stop_local_language_servers_for_buffers(&buffers, also_stop_servers, cx);\n            cx.background_spawn(async move {\n                task.await;\n                Ok(())\n            })\n        }\n    }\n\n    fn stop_local_language_servers_for_buffers(\n        &mut self,\n        buffers: &[Entity<Buffer>],\n        also_stop_servers: HashSet<LanguageServerSelector>,\n        cx: &mut Context<Self>,\n    ) -> Task<()> {\n        let Some(local) = self.as_local_mut() else {\n            return Task::ready(());\n        };\n        let mut language_server_names_to_stop = BTreeSet::default();\n        let mut language_servers_to_stop = also_stop_servers\n            .into_iter()\n            .flat_map(|selector| match selector {\n                LanguageServerSelector::Id(id) => Some(id),\n                LanguageServerSelector::Name(name) => {\n                    language_server_names_to_stop.insert(name);\n                    None\n                }\n            })\n            .collect::<BTreeSet<_>>();\n\n        let mut covered_worktrees = HashSet::default();\n        for buffer in buffers {\n            buffer.update(cx, |buffer, cx| {\n                language_servers_to_stop.extend(local.language_server_ids_for_buffer(buffer, cx));\n                if let Some(worktree_id) = buffer.file().map(|f| f.worktree_id(cx))\n                    && covered_worktrees.insert(worktree_id)\n                {\n                    language_server_names_to_stop.retain(|name| {\n                        let old_ids_count = language_servers_to_stop.len();\n                        let all_language_servers_with_this_name = local\n                            .language_server_ids\n                            .iter()\n                            .filter_map(|(seed, state)| seed.name.eq(name).then(|| state.id));\n                        language_servers_to_stop.extend(all_language_servers_with_this_name);\n                        old_ids_count == language_servers_to_stop.len()\n                    });\n                }\n            });\n        }\n        for name in language_server_names_to_stop {\n            language_servers_to_stop.extend(\n                local\n                    .language_server_ids\n                    .iter()\n                    .filter_map(|(seed, v)| seed.name.eq(&name).then(|| v.id)),\n            );\n        }\n\n        local.lsp_tree.remove_nodes(&language_servers_to_stop);\n        let tasks = language_servers_to_stop\n            .into_iter()\n            .map(|server| self.stop_local_language_server(server, cx))\n            .collect::<Vec<_>>();\n\n        cx.background_spawn(futures::future::join_all(tasks).map(|_| ()))\n    }\n\n    fn get_buffer<'a>(&self, abs_path: &Path, cx: &'a App) -> Option<&'a Buffer> {\n        let (worktree, relative_path) =\n            self.worktree_store.read(cx).find_worktree(&abs_path, cx)?;\n\n        let project_path = ProjectPath {\n            worktree_id: worktree.read(cx).id(),\n            path: relative_path,\n        };\n\n        Some(\n            self.buffer_store()\n                .read(cx)\n                .get_by_path(&project_path)?\n                .read(cx),\n        )\n    }\n\n    #[cfg(any(test, feature = ": "",
        "))]\n    pub fn update_diagnostics(\n        &mut self,\n        server_id: LanguageServerId,\n        diagnostics: lsp::PublishDiagnosticsParams,\n        result_id: Option<String>,\n        source_kind: DiagnosticSourceKind,\n        disk_based_sources: &[String],\n        cx: &mut Context<Self>,\n    ) -> Result<()> {\n        self.merge_lsp_diagnostics(\n            source_kind,\n            vec![DocumentDiagnosticsUpdate {\n                diagnostics,\n                result_id,\n                server_id,\n                disk_based_sources: Cow::Borrowed(disk_based_sources),\n            }],\n            |_, _, _| false,\n            cx,\n        )\n    }\n\n    pub fn merge_lsp_diagnostics(\n        &mut self,\n        source_kind: DiagnosticSourceKind,\n        lsp_diagnostics: Vec<DocumentDiagnosticsUpdate<lsp::PublishDiagnosticsParams>>,\n        merge: impl Fn(&Buffer, &Diagnostic, &App) -> bool + Clone,\n        cx: &mut Context<Self>,\n    ) -> Result<()> {\n        anyhow::ensure!(self.mode.is_local(), ": "",
        ");\n        let updates = lsp_diagnostics\n            .into_iter()\n            .filter_map(|update| {\n                let abs_path = update.diagnostics.uri.to_file_path().ok()?;\n                Some(DocumentDiagnosticsUpdate {\n                    diagnostics: self.lsp_to_document_diagnostics(\n                        abs_path,\n                        source_kind,\n                        update.server_id,\n                        update.diagnostics,\n                        &update.disk_based_sources,\n                    ),\n                    result_id: update.result_id,\n                    server_id: update.server_id,\n                    disk_based_sources: update.disk_based_sources,\n                })\n            })\n            .collect();\n        self.merge_diagnostic_entries(updates, merge, cx)?;\n        Ok(())\n    }\n\n    fn lsp_to_document_diagnostics(\n        &mut self,\n        document_abs_path: PathBuf,\n        source_kind: DiagnosticSourceKind,\n        server_id: LanguageServerId,\n        mut lsp_diagnostics: lsp::PublishDiagnosticsParams,\n        disk_based_sources: &[String],\n    ) -> DocumentDiagnostics {\n        let mut diagnostics = Vec::default();\n        let mut primary_diagnostic_group_ids = HashMap::default();\n        let mut sources_by_group_id = HashMap::default();\n        let mut supporting_diagnostics = HashMap::default();\n\n        let adapter = self.language_server_adapter_for_id(server_id);\n\n        // Ensure that primary diagnostics are always the most severe\n        lsp_diagnostics\n            .diagnostics\n            .sort_by_key(|item| item.severity);\n\n        for diagnostic in &lsp_diagnostics.diagnostics {\n            let source = diagnostic.source.as_ref();\n            let range = range_from_lsp(diagnostic.range);\n            let is_supporting = diagnostic\n                .related_information\n                .as_ref()\n                .is_some_and(|infos| {\n                    infos.iter().any(|info| {\n                        primary_diagnostic_group_ids.contains_key(&(\n                            source,\n                            diagnostic.code.clone(),\n                            range_from_lsp(info.location.range),\n                        ))\n                    })\n                });\n\n            let is_unnecessary = diagnostic\n                .tags\n                .as_ref()\n                .is_some_and(|tags| tags.contains(&DiagnosticTag::UNNECESSARY));\n\n            let underline = self\n                .language_server_adapter_for_id(server_id)\n                .is_none_or(|adapter| adapter.underline_diagnostic(diagnostic));\n\n            if is_supporting {\n                supporting_diagnostics.insert(\n                    (source, diagnostic.code.clone(), range),\n                    (diagnostic.severity, is_unnecessary),\n                );\n            } else {\n                let group_id = post_inc(&mut self.as_local_mut().unwrap().next_diagnostic_group_id);\n                let is_disk_based =\n                    source.is_some_and(|source| disk_based_sources.contains(source));\n\n                sources_by_group_id.insert(group_id, source);\n                primary_diagnostic_group_ids\n                    .insert((source, diagnostic.code.clone(), range.clone()), group_id);\n\n                diagnostics.push(DiagnosticEntry {\n                    range,\n                    diagnostic: Diagnostic {\n                        source: diagnostic.source.clone(),\n                        source_kind,\n                        code: diagnostic.code.clone(),\n                        code_description: diagnostic\n                            .code_description\n                            .as_ref()\n                            .and_then(|d| d.href.clone()),\n                        severity: diagnostic.severity.unwrap_or(DiagnosticSeverity::ERROR),\n                        markdown: adapter.as_ref().and_then(|adapter| {\n                            adapter.diagnostic_message_to_markdown(&diagnostic.message)\n                        }),\n                        message: diagnostic.message.trim().to_string(),\n                        group_id,\n                        is_primary: true,\n                        is_disk_based,\n                        is_unnecessary,\n                        underline,\n                        data: diagnostic.data.clone(),\n                    },\n                });\n                if let Some(infos) = &diagnostic.related_information {\n                    for info in infos {\n                        if info.location.uri == lsp_diagnostics.uri && !info.message.is_empty() {\n                            let range = range_from_lsp(info.location.range);\n                            diagnostics.push(DiagnosticEntry {\n                                range,\n                                diagnostic: Diagnostic {\n                                    source: diagnostic.source.clone(),\n                                    source_kind,\n                                    code: diagnostic.code.clone(),\n                                    code_description: diagnostic\n                                        .code_description\n                                        .as_ref()\n                                        .and_then(|d| d.href.clone()),\n                                    severity: DiagnosticSeverity::INFORMATION,\n                                    markdown: adapter.as_ref().and_then(|adapter| {\n                                        adapter.diagnostic_message_to_markdown(&info.message)\n                                    }),\n                                    message: info.message.trim().to_string(),\n                                    group_id,\n                                    is_primary: false,\n                                    is_disk_based,\n                                    is_unnecessary: false,\n                                    underline,\n                                    data: diagnostic.data.clone(),\n                                },\n                            });\n                        }\n                    }\n                }\n            }\n        }\n\n        for entry in &mut diagnostics {\n            let diagnostic = &mut entry.diagnostic;\n            if !diagnostic.is_primary {\n                let source = *sources_by_group_id.get(&diagnostic.group_id).unwrap();\n                if let Some(&(severity, is_unnecessary)) = supporting_diagnostics.get(&(\n                    source,\n                    diagnostic.code.clone(),\n                    entry.range.clone(),\n                )) {\n                    if let Some(severity) = severity {\n                        diagnostic.severity = severity;\n                    }\n                    diagnostic.is_unnecessary = is_unnecessary;\n                }\n            }\n        }\n\n        DocumentDiagnostics {\n            diagnostics,\n            document_abs_path,\n            version: lsp_diagnostics.version,\n        }\n    }\n\n    fn insert_newly_running_language_server(\n        &mut self,\n        adapter: Arc<CachedLspAdapter>,\n        language_server: Arc<LanguageServer>,\n        server_id: LanguageServerId,\n        key: LanguageServerSeed,\n        workspace_folders: Arc<Mutex<BTreeSet<Uri>>>,\n        cx: &mut Context<Self>,\n    ) {\n        let Some(local) = self.as_local_mut() else {\n            return;\n        };\n        // If the language server for this key doesn't match the server id, don't store the\n        // server. Which will cause it to be dropped, killing the process\n        if local\n            .language_server_ids\n            .get(&key)\n            .map(|state| state.id != server_id)\n            .unwrap_or(false)\n        {\n            return;\n        }\n\n        // Update language_servers collection with Running variant of LanguageServerState\n        // indicating that the server is up and running and ready\n        let workspace_folders = workspace_folders.lock().clone();\n        language_server.set_workspace_folders(workspace_folders);\n\n        let workspace_diagnostics_refresh_tasks = language_server\n            .capabilities()\n            .diagnostic_provider\n            .and_then(|provider| {\n                local\n                    .language_server_dynamic_registrations\n                    .entry(server_id)\n                    .or_default()\n                    .diagnostics\n                    .entry(None)\n                    .or_insert(provider.clone());\n                let workspace_refresher =\n                    lsp_workspace_diagnostics_refresh(None, provider, language_server.clone(), cx)?;\n\n                Some((None, workspace_refresher))\n            })\n            .into_iter()\n            .collect();\n        local.language_servers.insert(\n            server_id,\n            LanguageServerState::Running {\n                workspace_diagnostics_refresh_tasks,\n                adapter: adapter.clone(),\n                server: language_server.clone(),\n                simulate_disk_based_diagnostics_completion: None,\n            },\n        );\n        local\n            .languages\n            .update_lsp_binary_status(adapter.name(), BinaryStatus::None);\n        if let Some(file_ops_caps) = language_server\n            .capabilities()\n            .workspace\n            .as_ref()\n            .and_then(|ws| ws.file_operations.as_ref())\n        {\n            let did_rename_caps = file_ops_caps.did_rename.as_ref();\n            let will_rename_caps = file_ops_caps.will_rename.as_ref();\n            if did_rename_caps.or(will_rename_caps).is_some() {\n                let watcher = RenamePathsWatchedForServer::default()\n                    .with_did_rename_patterns(did_rename_caps)\n                    .with_will_rename_patterns(will_rename_caps);\n                local\n                    .language_server_paths_watched_for_rename\n                    .insert(server_id, watcher);\n            }\n        }\n\n        self.language_server_statuses.insert(\n            server_id,\n            LanguageServerStatus {\n                name: language_server.name(),\n                pending_work: Default::default(),\n                has_pending_diagnostic_updates: false,\n                progress_tokens: Default::default(),\n                worktree: Some(key.worktree_id),\n            },\n        );\n\n        cx.emit(LspStoreEvent::LanguageServerAdded(\n            server_id,\n            language_server.name(),\n            Some(key.worktree_id),\n        ));\n\n        let server_capabilities = language_server.capabilities();\n        if let Some((downstream_client, project_id)) = self.downstream_client.as_ref() {\n            downstream_client\n                .send(proto::StartLanguageServer {\n                    project_id: *project_id,\n                    server: Some(proto::LanguageServer {\n                        id: server_id.to_proto(),\n                        name: language_server.name().to_string(),\n                        worktree_id: Some(key.worktree_id.to_proto()),\n                    }),\n                    capabilities: serde_json::to_string(&server_capabilities)\n                        .expect(": "",
        "),\n                })\n                .log_err();\n        }\n        self.lsp_server_capabilities\n            .insert(server_id, server_capabilities);\n\n        // Tell the language server about every open buffer in the worktree that matches the language.\n        // Also check for buffers in worktrees that reused this server\n        let mut worktrees_using_server = vec![key.worktree_id];\n        if let Some(local) = self.as_local() {\n            // Find all worktrees that have this server in their language server tree\n            for (worktree_id, servers) in &local.lsp_tree.instances {\n                if *worktree_id != key.worktree_id {\n                    for server_map in servers.roots.values() {\n                        if server_map\n                            .values()\n                            .any(|(node, _)| node.id() == Some(server_id))\n                        {\n                            worktrees_using_server.push(*worktree_id);\n                        }\n                    }\n                }\n            }\n        }\n\n        let mut buffer_paths_registered = Vec::new();\n        self.buffer_store.clone().update(cx, |buffer_store, cx| {\n            let mut lsp_adapters = HashMap::default();\n            for buffer_handle in buffer_store.buffers() {\n                let buffer = buffer_handle.read(cx);\n                let file = match File::from_dyn(buffer.file()) {\n                    Some(file) => file,\n                    None => continue,\n                };\n                let language = match buffer.language() {\n                    Some(language) => language,\n                    None => continue,\n                };\n\n                if !worktrees_using_server.contains(&file.worktree.read(cx).id())\n                    || !lsp_adapters\n                        .entry(language.name())\n                        .or_insert_with(|| self.languages.lsp_adapters(&language.name()))\n                        .iter()\n                        .any(|a| a.name == key.name)\n                {\n                    continue;\n                }\n                // didOpen\n                let file = match file.as_local() {\n                    Some(file) => file,\n                    None => continue,\n                };\n\n                let local = self.as_local_mut().unwrap();\n\n                let buffer_id = buffer.remote_id();\n                if local.registered_buffers.contains_key(&buffer_id) {\n                    let versions = local\n                        .buffer_snapshots\n                        .entry(buffer_id)\n                        .or_default()\n                        .entry(server_id)\n                        .and_modify(|_| {\n                            assert!(\n                            false,\n                            ": "",
        "\n                        )\n                        })\n                        .or_insert_with(|| {\n                            vec![LspBufferSnapshot {\n                                version: 0,\n                                snapshot: buffer.text_snapshot(),\n                            }]\n                        });\n\n                    let snapshot = versions.last().unwrap();\n                    let version = snapshot.version;\n                    let initial_snapshot = &snapshot.snapshot;\n                    let uri = lsp::Uri::from_file_path(file.abs_path(cx)).unwrap();\n                    language_server.register_buffer(\n                        uri,\n                        adapter.language_id(&language.name()),\n                        version,\n                        initial_snapshot.text(),\n                    );\n                    buffer_paths_registered.push((buffer_id, file.abs_path(cx)));\n                    local\n                        .buffers_opened_in_servers\n                        .entry(buffer_id)\n                        .or_default()\n                        .insert(server_id);\n                }\n                buffer_handle.update(cx, |buffer, cx| {\n                    buffer.set_completion_triggers(\n                        server_id,\n                        language_server\n                            .capabilities()\n                            .completion_provider\n                            .as_ref()\n                            .and_then(|provider| {\n                                provider\n                                    .trigger_characters\n                                    .as_ref()\n                                    .map(|characters| characters.iter().cloned().collect())\n                            })\n                            .unwrap_or_default(),\n                        cx,\n                    )\n                });\n            }\n        });\n\n        for (buffer_id, abs_path) in buffer_paths_registered {\n            cx.emit(LspStoreEvent::LanguageServerUpdate {\n                language_server_id: server_id,\n                name: Some(adapter.name()),\n                message: proto::update_language_server::Variant::RegisteredForBuffer(\n                    proto::RegisteredForBuffer {\n                        buffer_abs_path: abs_path.to_string_lossy().into_owned(),\n                        buffer_id: buffer_id.to_proto(),\n                    },\n                ),\n            });\n        }\n\n        cx.notify();\n    }\n\n    pub fn language_servers_running_disk_based_diagnostics(\n        &self,\n    ) -> impl Iterator<Item = LanguageServerId> + '_ {\n        self.language_server_statuses\n            .iter()\n            .filter_map(|(id, status)| {\n                if status.has_pending_diagnostic_updates {\n                    Some(*id)\n                } else {\n                    None\n                }\n            })\n    }\n\n    pub(crate) fn cancel_language_server_work_for_buffers(\n        &mut self,\n        buffers: impl IntoIterator<Item = Entity<Buffer>>,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some((client, project_id)) = self.upstream_client() {\n            let request = client.request(proto::CancelLanguageServerWork {\n                project_id,\n                work: Some(proto::cancel_language_server_work::Work::Buffers(\n                    proto::cancel_language_server_work::Buffers {\n                        buffer_ids: buffers\n                            .into_iter()\n                            .map(|b| b.read(cx).remote_id().to_proto())\n                            .collect(),\n                    },\n                )),\n            });\n            cx.background_spawn(request).detach_and_log_err(cx);\n        } else if let Some(local) = self.as_local() {\n            let servers = buffers\n                .into_iter()\n                .flat_map(|buffer| {\n                    buffer.update(cx, |buffer, cx| {\n                        local.language_server_ids_for_buffer(buffer, cx).into_iter()\n                    })\n                })\n                .collect::<HashSet<_>>();\n            for server_id in servers {\n                self.cancel_language_server_work(server_id, None, cx);\n            }\n        }\n    }\n\n    pub(crate) fn cancel_language_server_work(\n        &mut self,\n        server_id: LanguageServerId,\n        token_to_cancel: Option<ProgressToken>,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(local) = self.as_local() {\n            let status = self.language_server_statuses.get(&server_id);\n            let server = local.language_servers.get(&server_id);\n            if let Some((LanguageServerState::Running { server, .. }, status)) = server.zip(status)\n            {\n                for (token, progress) in &status.pending_work {\n                    if let Some(token_to_cancel) = token_to_cancel.as_ref()\n                        && token != token_to_cancel\n                    {\n                        continue;\n                    }\n                    if progress.is_cancellable {\n                        server\n                            .notify::<lsp::notification::WorkDoneProgressCancel>(\n                                WorkDoneProgressCancelParams {\n                                    token: token.to_lsp(),\n                                },\n                            )\n                            .ok();\n                    }\n                }\n            }\n        } else if let Some((client, project_id)) = self.upstream_client() {\n            let request = client.request(proto::CancelLanguageServerWork {\n                project_id,\n                work: Some(\n                    proto::cancel_language_server_work::Work::LanguageServerWork(\n                        proto::cancel_language_server_work::LanguageServerWork {\n                            language_server_id: server_id.to_proto(),\n                            token: token_to_cancel.map(|token| token.to_proto()),\n                        },\n                    ),\n                ),\n            });\n            cx.background_spawn(request).detach_and_log_err(cx);\n        }\n    }\n\n    fn register_supplementary_language_server(\n        &mut self,\n        id: LanguageServerId,\n        name: LanguageServerName,\n        server: Arc<LanguageServer>,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(local) = self.as_local_mut() {\n            local\n                .supplementary_language_servers\n                .insert(id, (name.clone(), server));\n            cx.emit(LspStoreEvent::LanguageServerAdded(id, name, None));\n        }\n    }\n\n    fn unregister_supplementary_language_server(\n        &mut self,\n        id: LanguageServerId,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(local) = self.as_local_mut() {\n            local.supplementary_language_servers.remove(&id);\n            cx.emit(LspStoreEvent::LanguageServerRemoved(id));\n        }\n    }\n\n    pub(crate) fn supplementary_language_servers(\n        &self,\n    ) -> impl '_ + Iterator<Item = (LanguageServerId, LanguageServerName)> {\n        self.as_local().into_iter().flat_map(|local| {\n            local\n                .supplementary_language_servers\n                .iter()\n                .map(|(id, (name, _))| (*id, name.clone()))\n        })\n    }\n\n    pub fn language_server_adapter_for_id(\n        &self,\n        id: LanguageServerId,\n    ) -> Option<Arc<CachedLspAdapter>> {\n        self.as_local()\n            .and_then(|local| local.language_servers.get(&id))\n            .and_then(|language_server_state| match language_server_state {\n                LanguageServerState::Running { adapter, .. } => Some(adapter.clone()),\n                _ => None,\n            })\n    }\n\n    pub(super) fn update_local_worktree_language_servers(\n        &mut self,\n        worktree_handle: &Entity<Worktree>,\n        changes: &[(Arc<RelPath>, ProjectEntryId, PathChange)],\n        cx: &mut Context<Self>,\n    ) {\n        if changes.is_empty() {\n            return;\n        }\n\n        let Some(local) = self.as_local() else { return };\n\n        local.prettier_store.update(cx, |prettier_store, cx| {\n            prettier_store.update_prettier_settings(worktree_handle, changes, cx)\n        });\n\n        let worktree_id = worktree_handle.read(cx).id();\n        let mut language_server_ids = local\n            .language_server_ids\n            .iter()\n            .filter_map(|(seed, v)| seed.worktree_id.eq(&worktree_id).then(|| v.id))\n            .collect::<Vec<_>>();\n        language_server_ids.sort();\n        language_server_ids.dedup();\n\n        // let abs_path = worktree_handle.read(cx).abs_path();\n        for server_id in &language_server_ids {\n            if let Some(LanguageServerState::Running { server, .. }) =\n                local.language_servers.get(server_id)\n                && let Some(watched_paths) = local\n                    .language_server_watched_paths\n                    .get(server_id)\n                    .and_then(|paths| paths.worktree_paths.get(&worktree_id))\n            {\n                let params = lsp::DidChangeWatchedFilesParams {\n                    changes: changes\n                        .iter()\n                        .filter_map(|(path, _, change)| {\n                            if !watched_paths.is_match(path.as_std_path()) {\n                                return None;\n                            }\n                            let typ = match change {\n                                PathChange::Loaded => return None,\n                                PathChange::Added => lsp::FileChangeType::CREATED,\n                                PathChange::Removed => lsp::FileChangeType::DELETED,\n                                PathChange::Updated => lsp::FileChangeType::CHANGED,\n                                PathChange::AddedOrUpdated => lsp::FileChangeType::CHANGED,\n                            };\n                            let uri = lsp::Uri::from_file_path(\n                                worktree_handle.read(cx).absolutize(&path),\n                            )\n                            .ok()?;\n                            Some(lsp::FileEvent { uri, typ })\n                        })\n                        .collect(),\n                };\n                if !params.changes.is_empty() {\n                    server\n                        .notify::<lsp::notification::DidChangeWatchedFiles>(params)\n                        .ok();\n                }\n            }\n        }\n        for (path, _, _) in changes {\n            if let Some(file_name) = path.file_name()\n                && local.watched_manifest_filenames.contains(file_name)\n            {\n                self.request_workspace_config_refresh();\n                break;\n            }\n        }\n    }\n\n    pub fn wait_for_remote_buffer(\n        &mut self,\n        id: BufferId,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Entity<Buffer>>> {\n        self.buffer_store.update(cx, |buffer_store, cx| {\n            buffer_store.wait_for_remote_buffer(id, cx)\n        })\n    }\n\n    fn serialize_symbol(symbol: &Symbol) -> proto::Symbol {\n        let mut result = proto::Symbol {\n            language_server_name: symbol.language_server_name.0.to_string(),\n            source_worktree_id: symbol.source_worktree_id.to_proto(),\n            language_server_id: symbol.source_language_server_id.to_proto(),\n            name: symbol.name.clone(),\n            kind: unsafe { mem::transmute::<lsp::SymbolKind, i32>(symbol.kind) },\n            start: Some(proto::PointUtf16 {\n                row: symbol.range.start.0.row,\n                column: symbol.range.start.0.column,\n            }),\n            end: Some(proto::PointUtf16 {\n                row: symbol.range.end.0.row,\n                column: symbol.range.end.0.column,\n            }),\n            worktree_id: Default::default(),\n            path: Default::default(),\n            signature: Default::default(),\n        };\n        match &symbol.path {\n            SymbolLocation::InProject(path) => {\n                result.worktree_id = path.worktree_id.to_proto();\n                result.path = path.path.to_proto();\n            }\n            SymbolLocation::OutsideProject {\n                abs_path,\n                signature,\n            } => {\n                result.path = abs_path.to_string_lossy().into_owned();\n                result.signature = signature.to_vec();\n            }\n        }\n        result\n    }\n\n    fn deserialize_symbol(serialized_symbol: proto::Symbol) -> Result<CoreSymbol> {\n        let source_worktree_id = WorktreeId::from_proto(serialized_symbol.source_worktree_id);\n        let worktree_id = WorktreeId::from_proto(serialized_symbol.worktree_id);\n        let kind = unsafe { mem::transmute::<i32, lsp::SymbolKind>(serialized_symbol.kind) };\n\n        let path = if serialized_symbol.signature.is_empty() {\n            SymbolLocation::InProject(ProjectPath {\n                worktree_id,\n                path: RelPath::from_proto(&serialized_symbol.path)\n                    .context(": "",
        ")?,\n            })\n        } else {\n            SymbolLocation::OutsideProject {\n                abs_path: Path::new(&serialized_symbol.path).into(),\n                signature: serialized_symbol\n                    .signature\n                    .try_into()\n                    .map_err(|_| anyhow!(": "",
        "))?,\n            }\n        };\n\n        let start = serialized_symbol.start.context(": "",
        ")?;\n        let end = serialized_symbol.end.context(": "",
        ")?;\n        Ok(CoreSymbol {\n            language_server_name: LanguageServerName(serialized_symbol.language_server_name.into()),\n            source_worktree_id,\n            source_language_server_id: LanguageServerId::from_proto(\n                serialized_symbol.language_server_id,\n            ),\n            path,\n            name: serialized_symbol.name,\n            range: Unclipped(PointUtf16::new(start.row, start.column))\n                ..Unclipped(PointUtf16::new(end.row, end.column)),\n            kind,\n        })\n    }\n\n    pub(crate) fn serialize_completion(completion: &CoreCompletion) -> proto::Completion {\n        let mut serialized_completion = proto::Completion {\n            old_replace_start: Some(serialize_anchor(&completion.replace_range.start)),\n            old_replace_end: Some(serialize_anchor(&completion.replace_range.end)),\n            new_text: completion.new_text.clone(),\n            ..proto::Completion::default()\n        };\n        match &completion.source {\n            CompletionSource::Lsp {\n                insert_range,\n                server_id,\n                lsp_completion,\n                lsp_defaults,\n                resolved,\n            } => {\n                let (old_insert_start, old_insert_end) = insert_range\n                    .as_ref()\n                    .map(|range| (serialize_anchor(&range.start), serialize_anchor(&range.end)))\n                    .unzip();\n\n                serialized_completion.old_insert_start = old_insert_start;\n                serialized_completion.old_insert_end = old_insert_end;\n                serialized_completion.source = proto::completion::Source::Lsp as i32;\n                serialized_completion.server_id = server_id.0 as u64;\n                serialized_completion.lsp_completion = serde_json::to_vec(lsp_completion).unwrap();\n                serialized_completion.lsp_defaults = lsp_defaults\n                    .as_deref()\n                    .map(|lsp_defaults| serde_json::to_vec(lsp_defaults).unwrap());\n                serialized_completion.resolved = *resolved;\n            }\n            CompletionSource::BufferWord {\n                word_range,\n                resolved,\n            } => {\n                serialized_completion.source = proto::completion::Source::BufferWord as i32;\n                serialized_completion.buffer_word_start = Some(serialize_anchor(&word_range.start));\n                serialized_completion.buffer_word_end = Some(serialize_anchor(&word_range.end));\n                serialized_completion.resolved = *resolved;\n            }\n            CompletionSource::Custom => {\n                serialized_completion.source = proto::completion::Source::Custom as i32;\n                serialized_completion.resolved = true;\n            }\n            CompletionSource::Dap { sort_text } => {\n                serialized_completion.source = proto::completion::Source::Dap as i32;\n                serialized_completion.sort_text = Some(sort_text.clone());\n            }\n        }\n\n        serialized_completion\n    }\n\n    pub(crate) fn deserialize_completion(completion: proto::Completion) -> Result<CoreCompletion> {\n        let old_replace_start = completion\n            .old_replace_start\n            .and_then(deserialize_anchor)\n            .context(": "",
        ")?;\n        let old_replace_end = completion\n            .old_replace_end\n            .and_then(deserialize_anchor)\n            .context(": "",
        ")?;\n        let insert_range = {\n            match completion.old_insert_start.zip(completion.old_insert_end) {\n                Some((start, end)) => {\n                    let start = deserialize_anchor(start).context(": "",
        ")?;\n                    let end = deserialize_anchor(end).context(": "",
        ")?;\n                    Some(start..end)\n                }\n                None => None,\n            }\n        };\n        Ok(CoreCompletion {\n            replace_range: old_replace_start..old_replace_end,\n            new_text: completion.new_text,\n            source: match proto::completion::Source::from_i32(completion.source) {\n                Some(proto::completion::Source::Custom) => CompletionSource::Custom,\n                Some(proto::completion::Source::Lsp) => CompletionSource::Lsp {\n                    insert_range,\n                    server_id: LanguageServerId::from_proto(completion.server_id),\n                    lsp_completion: serde_json::from_slice(&completion.lsp_completion)?,\n                    lsp_defaults: completion\n                        .lsp_defaults\n                        .as_deref()\n                        .map(serde_json::from_slice)\n                        .transpose()?,\n                    resolved: completion.resolved,\n                },\n                Some(proto::completion::Source::BufferWord) => {\n                    let word_range = completion\n                        .buffer_word_start\n                        .and_then(deserialize_anchor)\n                        .context(": "",
        ")?\n                        ..completion\n                            .buffer_word_end\n                            .and_then(deserialize_anchor)\n                            .context(": "",
        ")?;\n                    CompletionSource::BufferWord {\n                        word_range,\n                        resolved: completion.resolved,\n                    }\n                }\n                Some(proto::completion::Source::Dap) => CompletionSource::Dap {\n                    sort_text: completion\n                        .sort_text\n                        .context(": "",
        ")?,\n                },\n                _ => anyhow::bail!(": "",
        ", completion.source),\n            },\n        })\n    }\n\n    pub(crate) fn serialize_code_action(action: &CodeAction) -> proto::CodeAction {\n        let (kind, lsp_action) = match &action.lsp_action {\n            LspAction::Action(code_action) => (\n                proto::code_action::Kind::Action as i32,\n                serde_json::to_vec(code_action).unwrap(),\n            ),\n            LspAction::Command(command) => (\n                proto::code_action::Kind::Command as i32,\n                serde_json::to_vec(command).unwrap(),\n            ),\n            LspAction::CodeLens(code_lens) => (\n                proto::code_action::Kind::CodeLens as i32,\n                serde_json::to_vec(code_lens).unwrap(),\n            ),\n        };\n\n        proto::CodeAction {\n            server_id: action.server_id.0 as u64,\n            start: Some(serialize_anchor(&action.range.start)),\n            end: Some(serialize_anchor(&action.range.end)),\n            lsp_action,\n            kind,\n            resolved: action.resolved,\n        }\n    }\n\n    pub(crate) fn deserialize_code_action(action: proto::CodeAction) -> Result<CodeAction> {\n        let start = action\n            .start\n            .and_then(deserialize_anchor)\n            .context(": "",
        ")?;\n        let end = action\n            .end\n            .and_then(deserialize_anchor)\n            .context(": "",
        ")?;\n        let lsp_action = match proto::code_action::Kind::from_i32(action.kind) {\n            Some(proto::code_action::Kind::Action) => {\n                LspAction::Action(serde_json::from_slice(&action.lsp_action)?)\n            }\n            Some(proto::code_action::Kind::Command) => {\n                LspAction::Command(serde_json::from_slice(&action.lsp_action)?)\n            }\n            Some(proto::code_action::Kind::CodeLens) => {\n                LspAction::CodeLens(serde_json::from_slice(&action.lsp_action)?)\n            }\n            None => anyhow::bail!(": "",
        ", action.kind),\n        };\n        Ok(CodeAction {\n            server_id: LanguageServerId(action.server_id as usize),\n            range: start..end,\n            resolved: action.resolved,\n            lsp_action,\n        })\n    }\n\n    fn update_last_formatting_failure<T>(&mut self, formatting_result: &anyhow::Result<T>) {\n        match &formatting_result {\n            Ok(_) => self.last_formatting_failure = None,\n            Err(error) => {\n                let error_string = format!(": "",
        ");\n                log::error!(": "",
        ");\n                self.last_formatting_failure\n                    .replace(error_string.lines().join(": "",
        "));\n            }\n        }\n    }\n\n    fn cleanup_lsp_data(&mut self, for_server: LanguageServerId) {\n        self.lsp_server_capabilities.remove(&for_server);\n        for lsp_data in self.lsp_data.values_mut() {\n            lsp_data.remove_server_data(for_server);\n        }\n        if let Some(local) = self.as_local_mut() {\n            local.buffer_pull_diagnostics_result_ids.remove(&for_server);\n            for buffer_servers in local.buffers_opened_in_servers.values_mut() {\n                buffer_servers.remove(&for_server);\n            }\n        }\n    }\n\n    pub fn result_id(\n        &self,\n        server_id: LanguageServerId,\n        buffer_id: BufferId,\n        cx: &App,\n    ) -> Option<String> {\n        let abs_path = self\n            .buffer_store\n            .read(cx)\n            .get(buffer_id)\n            .and_then(|b| File::from_dyn(b.read(cx).file()))\n            .map(|f| f.abs_path(cx))?;\n        self.as_local()?\n            .buffer_pull_diagnostics_result_ids\n            .get(&server_id)?\n            .get(&abs_path)?\n            .clone()\n    }\n\n    pub fn all_result_ids(&self, server_id: LanguageServerId) -> HashMap<PathBuf, String> {\n        let Some(local) = self.as_local() else {\n            return HashMap::default();\n        };\n        local\n            .buffer_pull_diagnostics_result_ids\n            .get(&server_id)\n            .into_iter()\n            .flatten()\n            .filter_map(|(abs_path, result_id)| Some((abs_path.clone(), result_id.clone()?)))\n            .collect()\n    }\n\n    pub fn pull_workspace_diagnostics(&mut self, server_id: LanguageServerId) {\n        if let Some(LanguageServerState::Running {\n            workspace_diagnostics_refresh_tasks,\n            ..\n        }) = self\n            .as_local_mut()\n            .and_then(|local| local.language_servers.get_mut(&server_id))\n        {\n            for diagnostics in workspace_diagnostics_refresh_tasks.values_mut() {\n                diagnostics.refresh_tx.try_send(()).ok();\n            }\n        }\n    }\n\n    pub fn pull_workspace_diagnostics_for_buffer(&mut self, buffer_id: BufferId, cx: &mut App) {\n        let Some(buffer) = self.buffer_store().read(cx).get_existing(buffer_id).ok() else {\n            return;\n        };\n        let Some(local) = self.as_local_mut() else {\n            return;\n        };\n\n        for server_id in buffer.update(cx, |buffer, cx| {\n            local.language_server_ids_for_buffer(buffer, cx)\n        }) {\n            if let Some(LanguageServerState::Running {\n                workspace_diagnostics_refresh_tasks,\n                ..\n            }) = local.language_servers.get_mut(&server_id)\n            {\n                for diagnostics in workspace_diagnostics_refresh_tasks.values_mut() {\n                    diagnostics.refresh_tx.try_send(()).ok();\n                }\n            }\n        }\n    }\n\n    fn apply_workspace_diagnostic_report(\n        &mut self,\n        server_id: LanguageServerId,\n        report: lsp::WorkspaceDiagnosticReportResult,\n        cx: &mut Context<Self>,\n    ) {\n        let workspace_diagnostics =\n            GetDocumentDiagnostics::deserialize_workspace_diagnostics_report(report, server_id);\n        let mut unchanged_buffers = HashSet::default();\n        let mut changed_buffers = HashSet::default();\n        let workspace_diagnostics_updates = workspace_diagnostics\n            .into_iter()\n            .filter_map(\n                |workspace_diagnostics| match workspace_diagnostics.diagnostics {\n                    LspPullDiagnostics::Response {\n                        server_id,\n                        uri,\n                        diagnostics,\n                    } => Some((server_id, uri, diagnostics, workspace_diagnostics.version)),\n                    LspPullDiagnostics::Default => None,\n                },\n            )\n            .fold(\n                HashMap::default(),\n                |mut acc, (server_id, uri, diagnostics, version)| {\n                    let (result_id, diagnostics) = match diagnostics {\n                        PulledDiagnostics::Unchanged { result_id } => {\n                            unchanged_buffers.insert(uri.clone());\n                            (Some(result_id), Vec::new())\n                        }\n                        PulledDiagnostics::Changed {\n                            result_id,\n                            diagnostics,\n                        } => {\n                            changed_buffers.insert(uri.clone());\n                            (result_id, diagnostics)\n                        }\n                    };\n                    let disk_based_sources = Cow::Owned(\n                        self.language_server_adapter_for_id(server_id)\n                            .as_ref()\n                            .map(|adapter| adapter.disk_based_diagnostic_sources.as_slice())\n                            .unwrap_or(&[])\n                            .to_vec(),\n                    );\n                    acc.entry(server_id)\n                        .or_insert_with(Vec::new)\n                        .push(DocumentDiagnosticsUpdate {\n                            server_id,\n                            diagnostics: lsp::PublishDiagnosticsParams {\n                                uri,\n                                diagnostics,\n                                version,\n                            },\n                            result_id,\n                            disk_based_sources,\n                        });\n                    acc\n                },\n            );\n\n        for diagnostic_updates in workspace_diagnostics_updates.into_values() {\n            self.merge_lsp_diagnostics(\n                DiagnosticSourceKind::Pulled,\n                diagnostic_updates,\n                |buffer, old_diagnostic, cx| {\n                    File::from_dyn(buffer.file())\n                        .and_then(|file| {\n                            let abs_path = file.as_local()?.abs_path(cx);\n                            lsp::Uri::from_file_path(abs_path).ok()\n                        })\n                        .is_none_or(|buffer_uri| {\n                            unchanged_buffers.contains(&buffer_uri)\n                                || match old_diagnostic.source_kind {\n                                    DiagnosticSourceKind::Pulled => {\n                                        !changed_buffers.contains(&buffer_uri)\n                                    }\n                                    DiagnosticSourceKind::Other | DiagnosticSourceKind::Pushed => {\n                                        true\n                                    }\n                                }\n                        })\n                },\n                cx,\n            )\n            .log_err();\n        }\n    }\n\n    fn register_server_capabilities(\n        &mut self,\n        server_id: LanguageServerId,\n        params: lsp::RegistrationParams,\n        cx: &mut Context<Self>,\n    ) -> anyhow::Result<()> {\n        let server = self\n            .language_server_for_id(server_id)\n            .with_context(|| format!(": "",
        "))?;\n        for reg in params.registrations {\n            match reg.method.as_str() {\n                ": "",
        " => {\n                    if let Some(options) = reg.register_options {\n                        let notify = if let Some(local_lsp_store) = self.as_local_mut() {\n                            let caps = serde_json::from_value(options)?;\n                            local_lsp_store\n                                .on_lsp_did_change_watched_files(server_id, &reg.id, caps, cx);\n                            true\n                        } else {\n                            false\n                        };\n                        if notify {\n                            notify_server_capabilities_updated(&server, cx);\n                        }\n                    }\n                }\n                ": "",
        " => {\n                    // Ignore payload since we notify clients of setting changes unconditionally, relying on them pulling the latest settings.\n                }\n                ": "",
        " => {\n                    // In this case register options is an empty object, we can ignore it\n                    let caps = lsp::WorkspaceFoldersServerCapabilities {\n                        supported: Some(true),\n                        change_notifications: Some(OneOf::Right(reg.id)),\n                    };\n                    server.update_capabilities(|capabilities| {\n                        capabilities\n                            .workspace\n                            .get_or_insert_default()\n                            .workspace_folders = Some(caps);\n                    });\n                    notify_server_capabilities_updated(&server, cx);\n                }\n                ": "",
        " => {\n                    let options = parse_register_capabilities(reg)?;\n                    server.update_capabilities(|capabilities| {\n                        capabilities.workspace_symbol_provider = Some(options);\n                    });\n                    notify_server_capabilities_updated(&server, cx);\n                }\n                ": "",
        " => {\n                    if let Some(options) = reg.register_options {\n                        let caps = serde_json::from_value(options)?;\n                        server.update_capabilities(|capabilities| {\n                            capabilities\n                                .workspace\n                                .get_or_insert_default()\n                                .file_operations = Some(caps);\n                        });\n                        notify_server_capabilities_updated(&server, cx);\n                    }\n                }\n                ": "",
        " => {\n                    if let Some(options) = reg.register_options {\n                        let options = serde_json::from_value(options)?;\n                        server.update_capabilities(|capabilities| {\n                            capabilities.execute_command_provider = Some(options);\n                        });\n                        notify_server_capabilities_updated(&server, cx);\n                    }\n                }\n                ": "",
        " => {\n                    let options = parse_register_capabilities(reg)?;\n                    server.update_capabilities(|capabilities| {\n                        capabilities.document_range_formatting_provider = Some(options);\n                    });\n                    notify_server_capabilities_updated(&server, cx);\n                }\n                ": "",
        " => {\n                    if let Some(options) = reg\n                        .register_options\n                        .map(serde_json::from_value)\n                        .transpose()?\n                    {\n                        server.update_capabilities(|capabilities| {\n                            capabilities.document_on_type_formatting_provider = Some(options);\n                        });\n                        notify_server_capabilities_updated(&server, cx);\n                    }\n                }\n                ": "",
        " => {\n                    let options = parse_register_capabilities(reg)?;\n                    server.update_capabilities(|capabilities| {\n                        capabilities.document_formatting_provider = Some(options);\n                    });\n                    notify_server_capabilities_updated(&server, cx);\n                }\n                ": "",
        " => {\n                    let options = parse_register_capabilities(reg)?;\n                    server.update_capabilities(|capabilities| {\n                        capabilities.rename_provider = Some(options);\n                    });\n                    notify_server_capabilities_updated(&server, cx);\n                }\n                ": "",
        " => {\n                    let options = parse_register_capabilities(reg)?;\n                    server.update_capabilities(|capabilities| {\n                        capabilities.inlay_hint_provider = Some(options);\n                    });\n                    notify_server_capabilities_updated(&server, cx);\n                }\n                ": "",
        " => {\n                    let options = parse_register_capabilities(reg)?;\n                    server.update_capabilities(|capabilities| {\n                        capabilities.document_symbol_provider = Some(options);\n                    });\n                    notify_server_capabilities_updated(&server, cx);\n                }\n                ": "",
        " => {\n                    let options = parse_register_capabilities(reg)?;\n                    let provider = match options {\n                        OneOf::Left(value) => lsp::CodeActionProviderCapability::Simple(value),\n                        OneOf::Right(caps) => caps,\n                    };\n                    server.update_capabilities(|capabilities| {\n                        capabilities.code_action_provider = Some(provider);\n                    });\n                    notify_server_capabilities_updated(&server, cx);\n                }\n                ": "",
        " => {\n                    let options = parse_register_capabilities(reg)?;\n                    server.update_capabilities(|capabilities| {\n                        capabilities.definition_provider = Some(options);\n                    });\n                    notify_server_capabilities_updated(&server, cx);\n                }\n                ": "",
        " => {\n                    if let Some(caps) = reg\n                        .register_options\n                        .map(serde_json::from_value::<CompletionOptions>)\n                        .transpose()?\n                    {\n                        server.update_capabilities(|capabilities| {\n                            capabilities.completion_provider = Some(caps.clone());\n                        });\n\n                        if let Some(local) = self.as_local() {\n                            let mut buffers_with_language_server = Vec::new();\n                            for handle in self.buffer_store.read(cx).buffers() {\n                                let buffer_id = handle.read(cx).remote_id();\n                                if local\n                                    .buffers_opened_in_servers\n                                    .get(&buffer_id)\n                                    .filter(|s| s.contains(&server_id))\n                                    .is_some()\n                                {\n                                    buffers_with_language_server.push(handle);\n                                }\n                            }\n                            let triggers = caps\n                                .trigger_characters\n                                .unwrap_or_default()\n                                .into_iter()\n                                .collect::<BTreeSet<_>>();\n                            for handle in buffers_with_language_server {\n                                let triggers = triggers.clone();\n                                let _ = handle.update(cx, move |buffer, cx| {\n                                    buffer.set_completion_triggers(server_id, triggers, cx);\n                                });\n                            }\n                        }\n                        notify_server_capabilities_updated(&server, cx);\n                    }\n                }\n                ": "",
        " => {\n                    let options = parse_register_capabilities(reg)?;\n                    let provider = match options {\n                        OneOf::Left(value) => lsp::HoverProviderCapability::Simple(value),\n                        OneOf::Right(caps) => caps,\n                    };\n                    server.update_capabilities(|capabilities| {\n                        capabilities.hover_provider = Some(provider);\n                    });\n                    notify_server_capabilities_updated(&server, cx);\n                }\n                ": "",
        " => {\n                    if let Some(caps) = reg\n                        .register_options\n                        .map(serde_json::from_value)\n                        .transpose()?\n                    {\n                        server.update_capabilities(|capabilities| {\n                            capabilities.signature_help_provider = Some(caps);\n                        });\n                        notify_server_capabilities_updated(&server, cx);\n                    }\n                }\n                ": "",
        " => {\n                    if let Some(sync_kind) = reg\n                        .register_options\n                        .and_then(|opts| opts.get(": "",
        ").cloned())\n                        .map(serde_json::from_value::<lsp::TextDocumentSyncKind>)\n                        .transpose()?\n                    {\n                        server.update_capabilities(|capabilities| {\n                            let mut sync_options =\n                                Self::take_text_document_sync_options(capabilities);\n                            sync_options.change = Some(sync_kind);\n                            capabilities.text_document_sync =\n                                Some(lsp::TextDocumentSyncCapability::Options(sync_options));\n                        });\n                        notify_server_capabilities_updated(&server, cx);\n                    }\n                }\n                ": "",
        " => {\n                    if let Some(include_text) = reg\n                        .register_options\n                        .map(|opts| {\n                            let transpose = opts\n                                .get(": "",
        ")\n                                .cloned()\n                                .map(serde_json::from_value::<Option<bool>>)\n                                .transpose();\n                            match transpose {\n                                Ok(value) => Ok(value.flatten()),\n                                Err(e) => Err(e),\n                            }\n                        })\n                        .transpose()?\n                    {\n                        server.update_capabilities(|capabilities| {\n                            let mut sync_options =\n                                Self::take_text_document_sync_options(capabilities);\n                            sync_options.save =\n                                Some(TextDocumentSyncSaveOptions::SaveOptions(lsp::SaveOptions {\n                                    include_text,\n                                }));\n                            capabilities.text_document_sync =\n                                Some(lsp::TextDocumentSyncCapability::Options(sync_options));\n                        });\n                        notify_server_capabilities_updated(&server, cx);\n                    }\n                }\n                ": "",
        " => {\n                    if let Some(caps) = reg\n                        .register_options\n                        .map(serde_json::from_value)\n                        .transpose()?\n                    {\n                        server.update_capabilities(|capabilities| {\n                            capabilities.code_lens_provider = Some(caps);\n                        });\n                        notify_server_capabilities_updated(&server, cx);\n                    }\n                }\n                ": "",
        " => {\n                    if let Some(caps) = reg\n                        .register_options\n                        .map(serde_json::from_value::<DiagnosticServerCapabilities>)\n                        .transpose()?\n                    {\n                        let local = self\n                            .as_local_mut()\n                            .context(": "",
        ")?;\n                        let state = local\n                            .language_servers\n                            .get_mut(&server_id)\n                            .context(": "",
        ")?;\n                        local\n                            .language_server_dynamic_registrations\n                            .entry(server_id)\n                            .or_default()\n                            .diagnostics\n                            .insert(Some(reg.id.clone()), caps.clone());\n\n                        if let LanguageServerState::Running {\n                            workspace_diagnostics_refresh_tasks,\n                            ..\n                        } = state\n                            && let Some(task) = lsp_workspace_diagnostics_refresh(\n                                Some(reg.id.clone()),\n                                caps.clone(),\n                                server.clone(),\n                                cx,\n                            )\n                        {\n                            workspace_diagnostics_refresh_tasks.insert(Some(reg.id), task);\n                        }\n\n                        let mut did_update_caps = false;\n                        server.update_capabilities(|capabilities| {\n                            if capabilities.diagnostic_provider.as_ref().is_none_or(\n                                |current_caps| {\n                                    let supports_workspace_diagnostics =\n                                        |capabilities: &DiagnosticServerCapabilities| {\n                                            match capabilities {\n                                            DiagnosticServerCapabilities::Options(\n                                                diagnostic_options,\n                                            ) => diagnostic_options.workspace_diagnostics,\n                                            DiagnosticServerCapabilities::RegistrationOptions(\n                                                diagnostic_registration_options,\n                                            ) => {\n                                                diagnostic_registration_options\n                                                    .diagnostic_options\n                                                    .workspace_diagnostics\n                                            }\n                                        }\n                                        };\n                                    // We don't actually care about capabilities.diagnostic_provider, but it IS relevant for the remote peer\n                                    // to know that there's at least one provider. Otherwise, it will never ask us to issue documentdiagnostic calls on their behalf,\n                                    // as it'll think that they're not supported.\n                                    // If we did not support any workspace diagnostics up to this point but now do, let's update.\n                                    !supports_workspace_diagnostics(current_caps)\n                                        & supports_workspace_diagnostics(&caps)\n                                },\n                            ) {\n                                did_update_caps = true;\n                                capabilities.diagnostic_provider = Some(caps);\n                            }\n                        });\n                        if did_update_caps {\n                            notify_server_capabilities_updated(&server, cx);\n                        }\n                    }\n                }\n                ": "",
        " => {\n                    let options = parse_register_capabilities(reg)?;\n                    let provider = match options {\n                        OneOf::Left(value) => lsp::ColorProviderCapability::Simple(value),\n                        OneOf::Right(caps) => caps,\n                    };\n                    server.update_capabilities(|capabilities| {\n                        capabilities.color_provider = Some(provider);\n                    });\n                    notify_server_capabilities_updated(&server, cx);\n                }\n                _ => log::warn!(": "",
        "),\n            }\n        }\n\n        Ok(())\n    }\n\n    fn unregister_server_capabilities(\n        &mut self,\n        server_id: LanguageServerId,\n        params: lsp::UnregistrationParams,\n        cx: &mut Context<Self>,\n    ) -> anyhow::Result<()> {\n        let server = self\n            .language_server_for_id(server_id)\n            .with_context(|| format!(": "",
        "))?;\n        for unreg in params.unregisterations.iter() {\n            match unreg.method.as_str() {\n                ": "",
        " => {\n                    let notify = if let Some(local_lsp_store) = self.as_local_mut() {\n                        local_lsp_store\n                            .on_lsp_unregister_did_change_watched_files(server_id, &unreg.id, cx);\n                        true\n                    } else {\n                        false\n                    };\n                    if notify {\n                        notify_server_capabilities_updated(&server, cx);\n                    }\n                }\n                ": "",
        " => {\n                    server.update_capabilities(|capabilities| {\n                        capabilities\n                            .workspace\n                            .get_or_insert_with(|| lsp::WorkspaceServerCapabilities {\n                                workspace_folders: None,\n                                file_operations: None,\n                            })\n                            .workspace_folders = None;\n                    });\n                    notify_server_capabilities_updated(&server, cx);\n                }\n                ": "",
        " => {\n                    server.update_capabilities(|capabilities| {\n                        capabilities.workspace_symbol_provider = None\n                    });\n                    notify_server_capabilities_updated(&server, cx);\n                }\n                ": "",
        " => {\n                    server.update_capabilities(|capabilities| {\n                        capabilities\n                            .workspace\n                            .get_or_insert_with(|| lsp::WorkspaceServerCapabilities {\n                                workspace_folders: None,\n                                file_operations: None,\n                            })\n                            .file_operations = None;\n                    });\n                    notify_server_capabilities_updated(&server, cx);\n                }\n                ": "",
        " => {\n                    server.update_capabilities(|capabilities| {\n                        capabilities.execute_command_provider = None;\n                    });\n                    notify_server_capabilities_updated(&server, cx);\n                }\n                ": "",
        " => {\n                    server.update_capabilities(|capabilities| {\n                        capabilities.document_range_formatting_provider = None\n                    });\n                    notify_server_capabilities_updated(&server, cx);\n                }\n                ": "",
        " => {\n                    server.update_capabilities(|capabilities| {\n                        capabilities.document_on_type_formatting_provider = None;\n                    });\n                    notify_server_capabilities_updated(&server, cx);\n                }\n                ": "",
        " => {\n                    server.update_capabilities(|capabilities| {\n                        capabilities.document_formatting_provider = None;\n                    });\n                    notify_server_capabilities_updated(&server, cx);\n                }\n                ": "",
        " => {\n                    server.update_capabilities(|capabilities| capabilities.rename_provider = None);\n                    notify_server_capabilities_updated(&server, cx);\n                }\n                ": "",
        " => {\n                    server.update_capabilities(|capabilities| {\n                        capabilities.code_action_provider = None;\n                    });\n                    notify_server_capabilities_updated(&server, cx);\n                }\n                ": "",
        " => {\n                    server.update_capabilities(|capabilities| {\n                        capabilities.definition_provider = None;\n                    });\n                    notify_server_capabilities_updated(&server, cx);\n                }\n                ": "",
        " => {\n                    server.update_capabilities(|capabilities| {\n                        capabilities.completion_provider = None;\n                    });\n                    notify_server_capabilities_updated(&server, cx);\n                }\n                ": "",
        " => {\n                    server.update_capabilities(|capabilities| {\n                        capabilities.hover_provider = None;\n                    });\n                    notify_server_capabilities_updated(&server, cx);\n                }\n                ": "",
        " => {\n                    server.update_capabilities(|capabilities| {\n                        capabilities.signature_help_provider = None;\n                    });\n                    notify_server_capabilities_updated(&server, cx);\n                }\n                ": "",
        " => {\n                    server.update_capabilities(|capabilities| {\n                        let mut sync_options = Self::take_text_document_sync_options(capabilities);\n                        sync_options.change = None;\n                        capabilities.text_document_sync =\n                            Some(lsp::TextDocumentSyncCapability::Options(sync_options));\n                    });\n                    notify_server_capabilities_updated(&server, cx);\n                }\n                ": "",
        " => {\n                    server.update_capabilities(|capabilities| {\n                        let mut sync_options = Self::take_text_document_sync_options(capabilities);\n                        sync_options.save = None;\n                        capabilities.text_document_sync =\n                            Some(lsp::TextDocumentSyncCapability::Options(sync_options));\n                    });\n                    notify_server_capabilities_updated(&server, cx);\n                }\n                ": "",
        " => {\n                    server.update_capabilities(|capabilities| {\n                        capabilities.code_lens_provider = None;\n                    });\n                    notify_server_capabilities_updated(&server, cx);\n                }\n                ": "",
        " => {\n                    let local = self\n                        .as_local_mut()\n                        .context(": "",
        ")?;\n\n                    let state = local\n                        .language_servers\n                        .get_mut(&server_id)\n                        .context(": "",
        ")?;\n                    let options = local\n                        .language_server_dynamic_registrations\n                        .get_mut(&server_id)\n                        .with_context(|| {\n                            format!(": "",
        ")\n                        })?.diagnostics\n                        .remove(&Some(unreg.id.clone()))\n                        .with_context(|| format!(\n                            ": "",
        ",\n                            unreg.id)\n                        )?;\n\n                    let mut has_any_diagnostic_providers_still = true;\n                    if let Some(identifier) = diagnostic_identifier(&options)\n                        && let LanguageServerState::Running {\n                            workspace_diagnostics_refresh_tasks,\n                            ..\n                        } = state\n                    {\n                        workspace_diagnostics_refresh_tasks.remove(&identifier);\n                        has_any_diagnostic_providers_still =\n                            !workspace_diagnostics_refresh_tasks.is_empty();\n                    }\n\n                    if !has_any_diagnostic_providers_still {\n                        server.update_capabilities(|capabilities| {\n                            debug_assert!(capabilities.diagnostic_provider.is_some());\n                            capabilities.diagnostic_provider = None;\n                        });\n                    }\n\n                    notify_server_capabilities_updated(&server, cx);\n                }\n                ": "",
        " => {\n                    server.update_capabilities(|capabilities| {\n                        capabilities.color_provider = None;\n                    });\n                    notify_server_capabilities_updated(&server, cx);\n                }\n                _ => log::warn!(": "",
        "),\n            }\n        }\n\n        Ok(())\n    }\n\n    async fn deduplicate_range_based_lsp_requests<T>(\n        lsp_store: &Entity<Self>,\n        server_id: Option<LanguageServerId>,\n        lsp_request_id: LspRequestId,\n        proto_request: &T::ProtoRequest,\n        range: Range<Anchor>,\n        cx: &mut AsyncApp,\n    ) -> Result<()>\n    where\n        T: LspCommand,\n        T::ProtoRequest: proto::LspRequestMessage,\n    {\n        let buffer_id = BufferId::new(proto_request.buffer_id())?;\n        let version = deserialize_version(proto_request.buffer_version());\n        let buffer = lsp_store.update(cx, |this, cx| {\n            this.buffer_store.read(cx).get_existing(buffer_id)\n        })??;\n        buffer\n            .update(cx, |buffer, _| buffer.wait_for_version(version))?\n            .await?;\n        lsp_store.update(cx, |lsp_store, cx| {\n            let lsp_data = lsp_store.latest_lsp_data(&buffer, cx);\n            let chunks_queried_for = lsp_data\n                .inlay_hints\n                .applicable_chunks(&[range])\n                .collect::<Vec<_>>();\n            match chunks_queried_for.as_slice() {\n                &[chunk] => {\n                    let key = LspKey {\n                        request_type: TypeId::of::<T>(),\n                        server_queried: server_id,\n                    };\n                    let previous_request = lsp_data\n                        .chunk_lsp_requests\n                        .entry(key)\n                        .or_default()\n                        .insert(chunk, lsp_request_id);\n                    if let Some((previous_request, running_requests)) =\n                        previous_request.zip(lsp_data.lsp_requests.get_mut(&key))\n                    {\n                        running_requests.remove(&previous_request);\n                    }\n                }\n                _ambiguous_chunks => {\n                    // Have not found a unique chunk for the query range — be lenient and let the query to be spawned,\n                    // there, a buffer version-based check will be performed and outdated requests discarded.\n                }\n            }\n            anyhow::Ok(())\n        })??;\n\n        Ok(())\n    }\n\n    async fn query_lsp_locally<T>(\n        lsp_store: Entity<Self>,\n        for_server_id: Option<LanguageServerId>,\n        sender_id: proto::PeerId,\n        lsp_request_id: LspRequestId,\n        proto_request: T::ProtoRequest,\n        position: Option<Anchor>,\n        cx: &mut AsyncApp,\n    ) -> Result<()>\n    where\n        T: LspCommand + Clone,\n        T::ProtoRequest: proto::LspRequestMessage,\n        <T::ProtoRequest as proto::RequestMessage>::Response:\n            Into<<T::ProtoRequest as proto::LspRequestMessage>::Response>,\n    {\n        let buffer_id = BufferId::new(proto_request.buffer_id())?;\n        let version = deserialize_version(proto_request.buffer_version());\n        let buffer = lsp_store.update(cx, |this, cx| {\n            this.buffer_store.read(cx).get_existing(buffer_id)\n        })??;\n        buffer\n            .update(cx, |buffer, _| buffer.wait_for_version(version.clone()))?\n            .await?;\n        let buffer_version = buffer.read_with(cx, |buffer, _| buffer.version())?;\n        let request =\n            T::from_proto(proto_request, lsp_store.clone(), buffer.clone(), cx.clone()).await?;\n        let key = LspKey {\n            request_type: TypeId::of::<T>(),\n            server_queried: for_server_id,\n        };\n        lsp_store.update(cx, |lsp_store, cx| {\n            let request_task = match for_server_id {\n                Some(server_id) => {\n                    let server_task = lsp_store.request_lsp(\n                        buffer.clone(),\n                        LanguageServerToQuery::Other(server_id),\n                        request.clone(),\n                        cx,\n                    );\n                    cx.background_spawn(async move {\n                        let mut responses = Vec::new();\n                        match server_task.await {\n                            Ok(response) => responses.push((server_id, response)),\n                            // rust-analyzer likes to error with this when its still loading up\n                            Err(e) if format!(": "",
        "\n                            ),\n                        }\n                        responses\n                    })\n                }\n                None => lsp_store.request_multiple_lsp_locally(&buffer, position, request, cx),\n            };\n            let lsp_data = lsp_store.latest_lsp_data(&buffer, cx);\n            if T::ProtoRequest::stop_previous_requests() {\n                if let Some(lsp_requests) = lsp_data.lsp_requests.get_mut(&key) {\n                    lsp_requests.clear();\n                }\n            }\n            lsp_data.lsp_requests.entry(key).or_default().insert(\n                lsp_request_id,\n                cx.spawn(async move |lsp_store, cx| {\n                    let response = request_task.await;\n                    lsp_store\n                        .update(cx, |lsp_store, cx| {\n                            if let Some((client, project_id)) = lsp_store.downstream_client.clone()\n                            {\n                                let response = response\n                                    .into_iter()\n                                    .map(|(server_id, response)| {\n                                        (\n                                            server_id.to_proto(),\n                                            T::response_to_proto(\n                                                response,\n                                                lsp_store,\n                                                sender_id,\n                                                &buffer_version,\n                                                cx,\n                                            )\n                                            .into(),\n                                        )\n                                    })\n                                    .collect::<HashMap<_, _>>();\n                                match client.send_lsp_response::<T::ProtoRequest>(\n                                    project_id,\n                                    lsp_request_id,\n                                    response,\n                                ) {\n                                    Ok(()) => {}\n                                    Err(e) => {\n                                        log::error!(": "",
        ",)\n                                    }\n                                }\n                            }\n                        })\n                        .ok();\n                }),\n            );\n        })?;\n        Ok(())\n    }\n\n    fn take_text_document_sync_options(\n        capabilities: &mut lsp::ServerCapabilities,\n    ) -> lsp::TextDocumentSyncOptions {\n        match capabilities.text_document_sync.take() {\n            Some(lsp::TextDocumentSyncCapability::Options(sync_options)) => sync_options,\n            Some(lsp::TextDocumentSyncCapability::Kind(sync_kind)) => {\n                let mut sync_options = lsp::TextDocumentSyncOptions::default();\n                sync_options.change = Some(sync_kind);\n                sync_options\n            }\n            None => lsp::TextDocumentSyncOptions::default(),\n        }\n    }\n\n    #[cfg(any(test, feature = ": "",
        "))]\n    pub fn forget_code_lens_task(&mut self, buffer_id: BufferId) -> Option<CodeLensTask> {\n        Some(\n            self.lsp_data\n                .get_mut(&buffer_id)?\n                .code_lens\n                .take()?\n                .update\n                .take()?\n                .1,\n        )\n    }\n\n    pub fn downstream_client(&self) -> Option<(AnyProtoClient, u64)> {\n        self.downstream_client.clone()\n    }\n\n    pub fn worktree_store(&self) -> Entity<WorktreeStore> {\n        self.worktree_store.clone()\n    }\n\n    /// Gets what's stored in the LSP data for the given buffer.\n    pub fn current_lsp_data(&mut self, buffer_id: BufferId) -> Option<&mut BufferLspData> {\n        self.lsp_data.get_mut(&buffer_id)\n    }\n\n    /// Gets the most recent LSP data for the given buffer: if the data is absent or out of date,\n    /// new [`BufferLspData`] will be created to replace the previous state.\n    pub fn latest_lsp_data(&mut self, buffer: &Entity<Buffer>, cx: &mut App) -> &mut BufferLspData {\n        let (buffer_id, buffer_version) =\n            buffer.read_with(cx, |buffer, _| (buffer.remote_id(), buffer.version()));\n        let lsp_data = self\n            .lsp_data\n            .entry(buffer_id)\n            .or_insert_with(|| BufferLspData::new(buffer, cx));\n        if buffer_version.changed_since(&lsp_data.buffer_version) {\n            *lsp_data = BufferLspData::new(buffer, cx);\n        }\n        lsp_data\n    }\n}\n\n// Registration with registerOptions as null, should fallback to true.\n// https://github.com/microsoft/vscode-languageserver-node/blob/d90a87f9557a0df9142cfb33e251cfa6fe27d970/client/src/common/client.ts#L2133\nfn parse_register_capabilities<T: serde::de::DeserializeOwned>(\n    reg: lsp::Registration,\n) -> Result<OneOf<bool, T>> {\n    Ok(match reg.register_options {\n        Some(options) => OneOf::Right(serde_json::from_value::<T>(options)?),\n        None => OneOf::Left(true),\n    })\n}\n\nfn subscribe_to_binary_statuses(\n    languages: &Arc<LanguageRegistry>,\n    cx: &mut Context<'_, LspStore>,\n) -> Task<()> {\n    let mut server_statuses = languages.language_server_binary_statuses();\n    cx.spawn(async move |lsp_store, cx| {\n        while let Some((server_name, binary_status)) = server_statuses.next().await {\n            if lsp_store\n                .update(cx, |_, cx| {\n                    let mut message = None;\n                    let binary_status = match binary_status {\n                        BinaryStatus::None => proto::ServerBinaryStatus::None,\n                        BinaryStatus::CheckingForUpdate => {\n                            proto::ServerBinaryStatus::CheckingForUpdate\n                        }\n                        BinaryStatus::Downloading => proto::ServerBinaryStatus::Downloading,\n                        BinaryStatus::Starting => proto::ServerBinaryStatus::Starting,\n                        BinaryStatus::Stopping => proto::ServerBinaryStatus::Stopping,\n                        BinaryStatus::Stopped => proto::ServerBinaryStatus::Stopped,\n                        BinaryStatus::Failed { error } => {\n                            message = Some(error);\n                            proto::ServerBinaryStatus::Failed\n                        }\n                    };\n                    cx.emit(LspStoreEvent::LanguageServerUpdate {\n                        // Binary updates are about the binary that might not have any language server id at that point.\n                        // Reuse `LanguageServerUpdate` for them and provide a fake id that won't be used on the receiver side.\n                        language_server_id: LanguageServerId(0),\n                        name: Some(server_name),\n                        message: proto::update_language_server::Variant::StatusUpdate(\n                            proto::StatusUpdate {\n                                message,\n                                status: Some(proto::status_update::Status::Binary(\n                                    binary_status as i32,\n                                )),\n                            },\n                        ),\n                    });\n                })\n                .is_err()\n            {\n                break;\n            }\n        }\n    })\n}\n\nfn lsp_workspace_diagnostics_refresh(\n    registration_id: Option<String>,\n    options: DiagnosticServerCapabilities,\n    server: Arc<LanguageServer>,\n    cx: &mut Context<'_, LspStore>,\n) -> Option<WorkspaceRefreshTask> {\n    let identifier = diagnostic_identifier(&options)?;\n\n    let (progress_tx, mut progress_rx) = mpsc::channel(1);\n    let (mut refresh_tx, mut refresh_rx) = mpsc::channel(1);\n    refresh_tx.try_send(()).ok();\n\n    let workspace_query_language_server = cx.spawn(async move |lsp_store, cx| {\n        let mut attempts = 0;\n        let max_attempts = 50;\n        let mut requests = 0;\n\n        loop {\n            let Some(()) = refresh_rx.recv().await else {\n                return;\n            };\n\n            'request: loop {\n                requests += 1;\n                if attempts > max_attempts {\n                    log::error!(\n                        ": "",
        "\n                    );\n                    return;\n                }\n                let backoff_millis = (50 * (1 << attempts)).clamp(30, 1000);\n                cx.background_executor()\n                    .timer(Duration::from_millis(backoff_millis))\n                    .await;\n                attempts += 1;\n\n                let Ok(previous_result_ids) = lsp_store.update(cx, |lsp_store, _| {\n                    lsp_store\n                        .all_result_ids(server.server_id())\n                        .into_iter()\n                        .filter_map(|(abs_path, result_id)| {\n                            let uri = file_path_to_lsp_url(&abs_path).ok()?;\n                            Some(lsp::PreviousResultId {\n                                uri,\n                                value: result_id,\n                            })\n                        })\n                        .collect()\n                }) else {\n                    return;\n                };\n\n                let token = if let Some(identifier) = &registration_id {\n                    format!(\n                        ": "",
        ",\n                        server.server_id(),\n                    )\n                } else {\n                    format!(": "",
        ", server.server_id())\n                };\n\n                progress_rx.try_recv().ok();\n                let timer =\n                    LanguageServer::default_request_timer(cx.background_executor().clone()).fuse();\n                let progress = pin!(progress_rx.recv().fuse());\n                let response_result = server\n                    .request_with_timer::<lsp::WorkspaceDiagnosticRequest, _>(\n                        lsp::WorkspaceDiagnosticParams {\n                            previous_result_ids,\n                            identifier: identifier.clone(),\n                            work_done_progress_params: Default::default(),\n                            partial_result_params: lsp::PartialResultParams {\n                                partial_result_token: Some(lsp::ProgressToken::String(token)),\n                            },\n                        },\n                        select(timer, progress).then(|either| match either {\n                            Either::Left((message, ..)) => ready(message).left_future(),\n                            Either::Right(..) => pending::<String>().right_future(),\n                        }),\n                    )\n                    .await;\n\n                // https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#diagnostic_refresh\n                // >  If a server closes a workspace diagnostic pull request the client should re-trigger the request.\n                match response_result {\n                    ConnectionResult::Timeout => {\n                        log::error!(": "",
        ");\n                        continue 'request;\n                    }\n                    ConnectionResult::ConnectionReset => {\n                        log::error!(": "",
        ");\n                        continue 'request;\n                    }\n                    ConnectionResult::Result(Err(e)) => {\n                        log::error!(": "",
        ");\n                        break 'request;\n                    }\n                    ConnectionResult::Result(Ok(pulled_diagnostics)) => {\n                        attempts = 0;\n                        if lsp_store\n                            .update(cx, |lsp_store, cx| {\n                                lsp_store.apply_workspace_diagnostic_report(\n                                    server.server_id(),\n                                    pulled_diagnostics,\n                                    cx,\n                                )\n                            })\n                            .is_err()\n                        {\n                            return;\n                        }\n                        break 'request;\n                    }\n                }\n            }\n        }\n    });\n\n    Some(WorkspaceRefreshTask {\n        refresh_tx,\n        progress_tx,\n        task: workspace_query_language_server,\n    })\n}\n\nfn diagnostic_identifier(options: &DiagnosticServerCapabilities) -> Option<Option<String>> {\n    match &options {\n        lsp::DiagnosticServerCapabilities::Options(diagnostic_options) => {\n            if !diagnostic_options.workspace_diagnostics {\n                return None;\n            }\n            Some(diagnostic_options.identifier.clone())\n        }\n        lsp::DiagnosticServerCapabilities::RegistrationOptions(registration_options) => {\n            let diagnostic_options = &registration_options.diagnostic_options;\n            if !diagnostic_options.workspace_diagnostics {\n                return None;\n            }\n            Some(diagnostic_options.identifier.clone())\n        }\n    }\n}\n\nfn resolve_word_completion(snapshot: &BufferSnapshot, completion: &mut Completion) {\n    let CompletionSource::BufferWord {\n        word_range,\n        resolved,\n    } = &mut completion.source\n    else {\n        return;\n    };\n    if *resolved {\n        return;\n    }\n\n    if completion.new_text\n        != snapshot\n            .text_for_range(word_range.clone())\n            .collect::<String>()\n    {\n        return;\n    }\n\n    let mut offset = 0;\n    for chunk in snapshot.chunks(word_range.clone(), true) {\n        let end_offset = offset + chunk.text.len();\n        if let Some(highlight_id) = chunk.syntax_highlight_id {\n            completion\n                .label\n                .runs\n                .push((offset..end_offset, highlight_id));\n        }\n        offset = end_offset;\n    }\n    *resolved = true;\n}\n\nimpl EventEmitter<LspStoreEvent> for LspStore {}\n\nfn remove_empty_hover_blocks(mut hover: Hover) -> Option<Hover> {\n    hover\n        .contents\n        .retain(|hover_block| !hover_block.text.trim().is_empty());\n    if hover.contents.is_empty() {\n        None\n    } else {\n        Some(hover)\n    }\n}\n\nasync fn populate_labels_for_completions(\n    new_completions: Vec<CoreCompletion>,\n    language: Option<Arc<Language>>,\n    lsp_adapter: Option<Arc<CachedLspAdapter>>,\n) -> Vec<Completion> {\n    let lsp_completions = new_completions\n        .iter()\n        .filter_map(|new_completion| {\n            new_completion\n                .source\n                .lsp_completion(true)\n                .map(|lsp_completion| lsp_completion.into_owned())\n        })\n        .collect::<Vec<_>>();\n\n    let mut labels = if let Some((language, lsp_adapter)) = language.as_ref().zip(lsp_adapter) {\n        lsp_adapter\n            .labels_for_completions(&lsp_completions, language)\n            .await\n            .log_err()\n            .unwrap_or_default()\n    } else {\n        Vec::new()\n    }\n    .into_iter()\n    .fuse();\n\n    let mut completions = Vec::new();\n    for completion in new_completions {\n        match completion.source.lsp_completion(true) {\n            Some(lsp_completion) => {\n                let documentation = lsp_completion.documentation.clone().map(|docs| docs.into());\n\n                let mut label = labels.next().flatten().unwrap_or_else(|| {\n                    CodeLabel::fallback_for_completion(&lsp_completion, language.as_deref())\n                });\n                ensure_uniform_list_compatible_label(&mut label);\n                completions.push(Completion {\n                    label,\n                    documentation,\n                    replace_range: completion.replace_range,\n                    new_text: completion.new_text,\n                    insert_text_mode: lsp_completion.insert_text_mode,\n                    source: completion.source,\n                    icon_path: None,\n                    confirm: None,\n                });\n            }\n            None => {\n                let mut label = CodeLabel::plain(completion.new_text.clone(), None);\n                ensure_uniform_list_compatible_label(&mut label);\n                completions.push(Completion {\n                    label,\n                    documentation: None,\n                    replace_range: completion.replace_range,\n                    new_text: completion.new_text,\n                    source: completion.source,\n                    insert_text_mode: None,\n                    icon_path: None,\n                    confirm: None,\n                });\n            }\n        }\n    }\n    completions\n}\n\n#[derive(Debug)]\npub enum LanguageServerToQuery {\n    /// Query language servers in order of users preference, up until one capable of handling the request is found.\n    FirstCapable,\n    /// Query a specific language server.\n    Other(LanguageServerId),\n}\n\n#[derive(Default)]\nstruct RenamePathsWatchedForServer {\n    did_rename: Vec<RenameActionPredicate>,\n    will_rename: Vec<RenameActionPredicate>,\n}\n\nimpl RenamePathsWatchedForServer {\n    fn with_did_rename_patterns(\n        mut self,\n        did_rename: Option<&FileOperationRegistrationOptions>,\n    ) -> Self {\n        if let Some(did_rename) = did_rename {\n            self.did_rename = did_rename\n                .filters\n                .iter()\n                .filter_map(|filter| filter.try_into().log_err())\n                .collect();\n        }\n        self\n    }\n    fn with_will_rename_patterns(\n        mut self,\n        will_rename: Option<&FileOperationRegistrationOptions>,\n    ) -> Self {\n        if let Some(will_rename) = will_rename {\n            self.will_rename = will_rename\n                .filters\n                .iter()\n                .filter_map(|filter| filter.try_into().log_err())\n                .collect();\n        }\n        self\n    }\n\n    fn should_send_did_rename(&self, path: &str, is_dir: bool) -> bool {\n        self.did_rename.iter().any(|pred| pred.eval(path, is_dir))\n    }\n    fn should_send_will_rename(&self, path: &str, is_dir: bool) -> bool {\n        self.will_rename.iter().any(|pred| pred.eval(path, is_dir))\n    }\n}\n\nimpl TryFrom<&FileOperationFilter> for RenameActionPredicate {\n    type Error = globset::Error;\n    fn try_from(ops: &FileOperationFilter) -> Result<Self, globset::Error> {\n        Ok(Self {\n            kind: ops.pattern.matches.clone(),\n            glob: GlobBuilder::new(&ops.pattern.glob)\n                .case_insensitive(\n                    ops.pattern\n                        .options\n                        .as_ref()\n                        .is_some_and(|ops| ops.ignore_case.unwrap_or(false)),\n                )\n                .build()?\n                .compile_matcher(),\n        })\n    }\n}\nstruct RenameActionPredicate {\n    glob: GlobMatcher,\n    kind: Option<FileOperationPatternKind>,\n}\n\nimpl RenameActionPredicate {\n    // Returns true if language server should be notified\n    fn eval(&self, path: &str, is_dir: bool) -> bool {\n        self.kind.as_ref().is_none_or(|kind| {\n            let expected_kind = if is_dir {\n                FileOperationPatternKind::Folder\n            } else {\n                FileOperationPatternKind::File\n            };\n            kind == &expected_kind\n        }) && self.glob.is_match(path)\n    }\n}\n\n#[derive(Default)]\nstruct LanguageServerWatchedPaths {\n    worktree_paths: HashMap<WorktreeId, GlobSet>,\n    abs_paths: HashMap<Arc<Path>, (GlobSet, Task<()>)>,\n}\n\n#[derive(Default)]\nstruct LanguageServerWatchedPathsBuilder {\n    worktree_paths: HashMap<WorktreeId, GlobSet>,\n    abs_paths: HashMap<Arc<Path>, GlobSet>,\n}\n\nimpl LanguageServerWatchedPathsBuilder {\n    fn watch_worktree(&mut self, worktree_id: WorktreeId, glob_set: GlobSet) {\n        self.worktree_paths.insert(worktree_id, glob_set);\n    }\n    fn watch_abs_path(&mut self, path: Arc<Path>, glob_set: GlobSet) {\n        self.abs_paths.insert(path, glob_set);\n    }\n    fn build(\n        self,\n        fs: Arc<dyn Fs>,\n        language_server_id: LanguageServerId,\n        cx: &mut Context<LspStore>,\n    ) -> LanguageServerWatchedPaths {\n        let lsp_store = cx.weak_entity();\n\n        const LSP_ABS_PATH_OBSERVE: Duration = Duration::from_millis(100);\n        let abs_paths = self\n            .abs_paths\n            .into_iter()\n            .map(|(abs_path, globset)| {\n                let task = cx.spawn({\n                    let abs_path = abs_path.clone();\n                    let fs = fs.clone();\n\n                    let lsp_store = lsp_store.clone();\n                    async move |_, cx| {\n                        maybe!(async move {\n                            let mut push_updates = fs.watch(&abs_path, LSP_ABS_PATH_OBSERVE).await;\n                            while let Some(update) = push_updates.0.next().await {\n                                let action = lsp_store\n                                    .update(cx, |this, _| {\n                                        let Some(local) = this.as_local() else {\n                                            return ControlFlow::Break(());\n                                        };\n                                        let Some(watcher) = local\n                                            .language_server_watched_paths\n                                            .get(&language_server_id)\n                                        else {\n                                            return ControlFlow::Break(());\n                                        };\n                                        let (globs, _) = watcher.abs_paths.get(&abs_path).expect(\n                                            ": "",
        ",\n                                        );\n                                        let matching_entries = update\n                                            .into_iter()\n                                            .filter(|event| globs.is_match(&event.path))\n                                            .collect::<Vec<_>>();\n                                        this.lsp_notify_abs_paths_changed(\n                                            language_server_id,\n                                            matching_entries,\n                                        );\n                                        ControlFlow::Continue(())\n                                    })\n                                    .ok()?;\n\n                                if action.is_break() {\n                                    break;\n                                }\n                            }\n                            Some(())\n                        })\n                        .await;\n                    }\n                });\n                (abs_path, (globset, task))\n            })\n            .collect();\n        LanguageServerWatchedPaths {\n            worktree_paths: self.worktree_paths,\n            abs_paths,\n        }\n    }\n}\n\nstruct LspBufferSnapshot {\n    version: i32,\n    snapshot: TextBufferSnapshot,\n}\n\n/// A prompt requested by LSP server.\n#[derive(Clone, Debug)]\npub struct LanguageServerPromptRequest {\n    pub level: PromptLevel,\n    pub message: String,\n    pub actions: Vec<MessageActionItem>,\n    pub lsp_name: String,\n    pub(crate) response_channel: Sender<MessageActionItem>,\n}\n\nimpl LanguageServerPromptRequest {\n    pub async fn respond(self, index: usize) -> Option<()> {\n        if let Some(response) = self.actions.into_iter().nth(index) {\n            self.response_channel.send(response).await.ok()\n        } else {\n            None\n        }\n    }\n}\nimpl PartialEq for LanguageServerPromptRequest {\n    fn eq(&self, other: &Self) -> bool {\n        self.message == other.message && self.actions == other.actions\n    }\n}\n\n#[derive(Clone, Debug, PartialEq)]\npub enum LanguageServerLogType {\n    Log(MessageType),\n    Trace { verbose_info: Option<String> },\n    Rpc { received: bool },\n}\n\nimpl LanguageServerLogType {\n    pub fn to_proto(&self) -> proto::language_server_log::LogType {\n        match self {\n            Self::Log(log_type) => {\n                use proto::log_message::LogLevel;\n                let level = match *log_type {\n                    MessageType::ERROR => LogLevel::Error,\n                    MessageType::WARNING => LogLevel::Warning,\n                    MessageType::INFO => LogLevel::Info,\n                    MessageType::LOG => LogLevel::Log,\n                    other => {\n                        log::warn!(": "",
        ");\n                        LogLevel::Log\n                    }\n                };\n                proto::language_server_log::LogType::Log(proto::LogMessage {\n                    level: level as i32,\n                })\n            }\n            Self::Trace { verbose_info } => {\n                proto::language_server_log::LogType::Trace(proto::TraceMessage {\n                    verbose_info: verbose_info.to_owned(),\n                })\n            }\n            Self::Rpc { received } => {\n                let kind = if *received {\n                    proto::rpc_message::Kind::Received\n                } else {\n                    proto::rpc_message::Kind::Sent\n                };\n                let kind = kind as i32;\n                proto::language_server_log::LogType::Rpc(proto::RpcMessage { kind })\n            }\n        }\n    }\n\n    pub fn from_proto(log_type: proto::language_server_log::LogType) -> Self {\n        use proto::log_message::LogLevel;\n        use proto::rpc_message;\n        match log_type {\n            proto::language_server_log::LogType::Log(message_type) => Self::Log(\n                match LogLevel::from_i32(message_type.level).unwrap_or(LogLevel::Log) {\n                    LogLevel::Error => MessageType::ERROR,\n                    LogLevel::Warning => MessageType::WARNING,\n                    LogLevel::Info => MessageType::INFO,\n                    LogLevel::Log => MessageType::LOG,\n                },\n            ),\n            proto::language_server_log::LogType::Trace(trace_message) => Self::Trace {\n                verbose_info: trace_message.verbose_info,\n            },\n            proto::language_server_log::LogType::Rpc(message) => Self::Rpc {\n                received: match rpc_message::Kind::from_i32(message.kind)\n                    .unwrap_or(rpc_message::Kind::Received)\n                {\n                    rpc_message::Kind::Received => true,\n                    rpc_message::Kind::Sent => false,\n                },\n            },\n        }\n    }\n}\n\npub struct WorkspaceRefreshTask {\n    refresh_tx: mpsc::Sender<()>,\n    progress_tx: mpsc::Sender<()>,\n    #[allow(dead_code)]\n    task: Task<()>,\n}\n\npub enum LanguageServerState {\n    Starting {\n        startup: Task<Option<Arc<LanguageServer>>>,\n        /// List of language servers that will be added to the workspace once it's initialization completes.\n        pending_workspace_folders: Arc<Mutex<BTreeSet<Uri>>>,\n    },\n\n    Running {\n        adapter: Arc<CachedLspAdapter>,\n        server: Arc<LanguageServer>,\n        simulate_disk_based_diagnostics_completion: Option<Task<()>>,\n        workspace_diagnostics_refresh_tasks: HashMap<Option<String>, WorkspaceRefreshTask>,\n    },\n}\n\nimpl LanguageServerState {\n    fn add_workspace_folder(&self, uri: Uri) {\n        match self {\n            LanguageServerState::Starting {\n                pending_workspace_folders,\n                ..\n            } => {\n                pending_workspace_folders.lock().insert(uri);\n            }\n            LanguageServerState::Running { server, .. } => {\n                server.add_workspace_folder(uri);\n            }\n        }\n    }\n    fn _remove_workspace_folder(&self, uri: Uri) {\n        match self {\n            LanguageServerState::Starting {\n                pending_workspace_folders,\n                ..\n            } => {\n                pending_workspace_folders.lock().remove(&uri);\n            }\n            LanguageServerState::Running { server, .. } => server.remove_workspace_folder(uri),\n        }\n    }\n}\n\nimpl std::fmt::Debug for LanguageServerState {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        match self {\n            LanguageServerState::Starting { .. } => {\n                f.debug_struct(": "",
        ").finish()\n            }\n            LanguageServerState::Running { .. } => {\n                f.debug_struct(": "",
        ").finish()\n            }\n        }\n    }\n}\n\n#[derive(Clone, Debug, Serialize)]\npub struct LanguageServerProgress {\n    pub is_disk_based_diagnostics_progress: bool,\n    pub is_cancellable: bool,\n    pub title: Option<String>,\n    pub message: Option<String>,\n    pub percentage: Option<usize>,\n    #[serde(skip_serializing)]\n    pub last_update_at: Instant,\n}\n\n#[derive(Copy, Clone, Debug, Default, PartialEq, Serialize)]\npub struct DiagnosticSummary {\n    pub error_count: usize,\n    pub warning_count: usize,\n}\n\nimpl DiagnosticSummary {\n    pub fn new<'a, T: 'a>(diagnostics: impl IntoIterator<Item = &'a DiagnosticEntry<T>>) -> Self {\n        let mut this = Self {\n            error_count: 0,\n            warning_count: 0,\n        };\n\n        for entry in diagnostics {\n            if entry.diagnostic.is_primary {\n                match entry.diagnostic.severity {\n                    DiagnosticSeverity::ERROR => this.error_count += 1,\n                    DiagnosticSeverity::WARNING => this.warning_count += 1,\n                    _ => {}\n                }\n            }\n        }\n\n        this\n    }\n\n    pub fn is_empty(&self) -> bool {\n        self.error_count == 0 && self.warning_count == 0\n    }\n\n    pub fn to_proto(\n        self,\n        language_server_id: LanguageServerId,\n        path: &RelPath,\n    ) -> proto::DiagnosticSummary {\n        proto::DiagnosticSummary {\n            path: path.to_proto(),\n            language_server_id: language_server_id.0 as u64,\n            error_count: self.error_count as u32,\n            warning_count: self.warning_count as u32,\n        }\n    }\n}\n\n#[derive(Clone, Debug)]\npub enum CompletionDocumentation {\n    /// There is no documentation for this completion.\n    Undocumented,\n    /// A single line of documentation.\n    SingleLine(SharedString),\n    /// Multiple lines of plain text documentation.\n    MultiLinePlainText(SharedString),\n    /// Markdown documentation.\n    MultiLineMarkdown(SharedString),\n    /// Both single line and multiple lines of plain text documentation.\n    SingleLineAndMultiLinePlainText {\n        single_line: SharedString,\n        plain_text: Option<SharedString>,\n    },\n}\n\nimpl CompletionDocumentation {\n    #[cfg(any(test, feature = ": "",
        "))]\n    pub fn text(&self) -> SharedString {\n        match self {\n            CompletionDocumentation::Undocumented => ": "",
        ".into(),\n            CompletionDocumentation::SingleLine(s) => s.clone(),\n            CompletionDocumentation::MultiLinePlainText(s) => s.clone(),\n            CompletionDocumentation::MultiLineMarkdown(s) => s.clone(),\n            CompletionDocumentation::SingleLineAndMultiLinePlainText { single_line, .. } => {\n                single_line.clone()\n            }\n        }\n    }\n}\n\nimpl From<lsp::Documentation> for CompletionDocumentation {\n    fn from(docs: lsp::Documentation) -> Self {\n        match docs {\n            lsp::Documentation::String(text) => {\n                if text.lines().count() <= 1 {\n                    CompletionDocumentation::SingleLine(text.into())\n                } else {\n                    CompletionDocumentation::MultiLinePlainText(text.into())\n                }\n            }\n\n            lsp::Documentation::MarkupContent(lsp::MarkupContent { kind, value }) => match kind {\n                lsp::MarkupKind::PlainText => {\n                    if value.lines().count() <= 1 {\n                        CompletionDocumentation::SingleLine(value.into())\n                    } else {\n                        CompletionDocumentation::MultiLinePlainText(value.into())\n                    }\n                }\n\n                lsp::MarkupKind::Markdown => {\n                    CompletionDocumentation::MultiLineMarkdown(value.into())\n                }\n            },\n        }\n    }\n}\n\npub enum ResolvedHint {\n    Resolved(InlayHint),\n    Resolving(Shared<Task<()>>),\n}\n\nfn glob_literal_prefix(glob: &Path) -> PathBuf {\n    glob.components()\n        .take_while(|component| match component {\n            path::Component::Normal(part) => !part.to_string_lossy().contains(['*', '?', '{', '}']),\n            _ => true,\n        })\n        .collect()\n}\n\npub struct SshLspAdapter {\n    name: LanguageServerName,\n    binary: LanguageServerBinary,\n    initialization_options: Option<String>,\n    code_action_kinds: Option<Vec<CodeActionKind>>,\n}\n\nimpl SshLspAdapter {\n    pub fn new(\n        name: LanguageServerName,\n        binary: LanguageServerBinary,\n        initialization_options: Option<String>,\n        code_action_kinds: Option<String>,\n    ) -> Self {\n        Self {\n            name,\n            binary,\n            initialization_options,\n            code_action_kinds: code_action_kinds\n                .as_ref()\n                .and_then(|c| serde_json::from_str(c).ok()),\n        }\n    }\n}\n\nimpl LspInstaller for SshLspAdapter {\n    type BinaryVersion = ();\n    async fn check_if_user_installed(\n        &self,\n        _: &dyn LspAdapterDelegate,\n        _: Option<Toolchain>,\n        _: &AsyncApp,\n    ) -> Option<LanguageServerBinary> {\n        Some(self.binary.clone())\n    }\n\n    async fn cached_server_binary(\n        &self,\n        _: PathBuf,\n        _: &dyn LspAdapterDelegate,\n    ) -> Option<LanguageServerBinary> {\n        None\n    }\n\n    async fn fetch_latest_server_version(\n        &self,\n        _: &dyn LspAdapterDelegate,\n        _: bool,\n        _: &mut AsyncApp,\n    ) -> Result<()> {\n        anyhow::bail!(": "",
        ")\n    }\n\n    async fn fetch_server_binary(\n        &self,\n        _: (),\n        _: PathBuf,\n        _: &dyn LspAdapterDelegate,\n    ) -> Result<LanguageServerBinary> {\n        anyhow::bail!(": "",
        ")\n    }\n}\n\n#[async_trait(?Send)]\nimpl LspAdapter for SshLspAdapter {\n    fn name(&self) -> LanguageServerName {\n        self.name.clone()\n    }\n\n    async fn initialization_options(\n        self: Arc<Self>,\n        _: &Arc<dyn LspAdapterDelegate>,\n    ) -> Result<Option<serde_json::Value>> {\n        let Some(options) = &self.initialization_options else {\n            return Ok(None);\n        };\n        let result = serde_json::from_str(options)?;\n        Ok(result)\n    }\n\n    fn code_action_kinds(&self) -> Option<Vec<CodeActionKind>> {\n        self.code_action_kinds.clone()\n    }\n}\n\npub fn language_server_settings<'a>(\n    delegate: &'a dyn LspAdapterDelegate,\n    language: &LanguageServerName,\n    cx: &'a App,\n) -> Option<&'a LspSettings> {\n    language_server_settings_for(\n        SettingsLocation {\n            worktree_id: delegate.worktree_id(),\n            path: RelPath::empty(),\n        },\n        language,\n        cx,\n    )\n}\n\npub(crate) fn language_server_settings_for<'a>(\n    location: SettingsLocation<'a>,\n    language: &LanguageServerName,\n    cx: &'a App,\n) -> Option<&'a LspSettings> {\n    ProjectSettings::get(Some(location), cx).lsp.get(language)\n}\n\npub struct LocalLspAdapterDelegate {\n    lsp_store: WeakEntity<LspStore>,\n    worktree: worktree::Snapshot,\n    fs: Arc<dyn Fs>,\n    http_client: Arc<dyn HttpClient>,\n    language_registry: Arc<LanguageRegistry>,\n    load_shell_env_task: Shared<Task<Option<HashMap<String, String>>>>,\n}\n\nimpl LocalLspAdapterDelegate {\n    pub fn new(\n        language_registry: Arc<LanguageRegistry>,\n        environment: &Entity<ProjectEnvironment>,\n        lsp_store: WeakEntity<LspStore>,\n        worktree: &Entity<Worktree>,\n        http_client: Arc<dyn HttpClient>,\n        fs: Arc<dyn Fs>,\n        cx: &mut App,\n    ) -> Arc<Self> {\n        let load_shell_env_task =\n            environment.update(cx, |env, cx| env.worktree_environment(worktree.clone(), cx));\n\n        Arc::new(Self {\n            lsp_store,\n            worktree: worktree.read(cx).snapshot(),\n            fs,\n            http_client,\n            language_registry,\n            load_shell_env_task,\n        })\n    }\n\n    fn from_local_lsp(\n        local: &LocalLspStore,\n        worktree: &Entity<Worktree>,\n        cx: &mut App,\n    ) -> Arc<Self> {\n        Self::new(\n            local.languages.clone(),\n            &local.environment,\n            local.weak.clone(),\n            worktree,\n            local.http_client.clone(),\n            local.fs.clone(),\n            cx,\n        )\n    }\n}\n\n#[async_trait]\nimpl LspAdapterDelegate for LocalLspAdapterDelegate {\n    fn show_notification(&self, message: &str, cx: &mut App) {\n        self.lsp_store\n            .update(cx, |_, cx| {\n                cx.emit(LspStoreEvent::Notification(message.to_owned()))\n            })\n            .ok();\n    }\n\n    fn http_client(&self) -> Arc<dyn HttpClient> {\n        self.http_client.clone()\n    }\n\n    fn worktree_id(&self) -> WorktreeId {\n        self.worktree.id()\n    }\n\n    fn worktree_root_path(&self) -> &Path {\n        self.worktree.abs_path().as_ref()\n    }\n\n    async fn shell_env(&self) -> HashMap<String, String> {\n        let task = self.load_shell_env_task.clone();\n        task.await.unwrap_or_default()\n    }\n\n    async fn npm_package_installed_version(\n        &self,\n        package_name: &str,\n    ) -> Result<Option<(PathBuf, String)>> {\n        let local_package_directory = self.worktree_root_path();\n        let node_modules_directory = local_package_directory.join(": "",
        ");\n\n        if let Some(version) =\n            read_package_installed_version(node_modules_directory.clone(), package_name).await?\n        {\n            return Ok(Some((node_modules_directory, version)));\n        }\n        let Some(npm) = self.which(": "",
        ".as_ref()).await else {\n            log::warn!(\n                ": "",
        ",\n                local_package_directory\n            );\n            return Ok(None);\n        };\n\n        let env = self.shell_env().await;\n        let output = util::command::new_smol_command(&npm)\n            .args([": "",
        "])\n            .envs(env)\n            .current_dir(local_package_directory)\n            .output()\n            .await?;\n        let global_node_modules =\n            PathBuf::from(String::from_utf8_lossy(&output.stdout).to_string());\n\n        if let Some(version) =\n            read_package_installed_version(global_node_modules.clone(), package_name).await?\n        {\n            return Ok(Some((global_node_modules, version)));\n        }\n        return Ok(None);\n    }\n\n    async fn which(&self, command: &OsStr) -> Option<PathBuf> {\n        let mut worktree_abs_path = self.worktree_root_path().to_path_buf();\n        if self.fs.is_file(&worktree_abs_path).await {\n            worktree_abs_path.pop();\n        }\n\n        let env = self.shell_env().await;\n\n        let shell_path = env.get(": "",
        ").cloned();\n\n        which::which_in(command, shell_path.as_ref(), worktree_abs_path).ok()\n    }\n\n    async fn try_exec(&self, command: LanguageServerBinary) -> Result<()> {\n        let mut working_dir = self.worktree_root_path().to_path_buf();\n        if self.fs.is_file(&working_dir).await {\n            working_dir.pop();\n        }\n        let output = util::command::new_smol_command(&command.path)\n            .args(command.arguments)\n            .envs(command.env.clone().unwrap_or_default())\n            .current_dir(working_dir)\n            .output()\n            .await?;\n\n        anyhow::ensure!(\n            output.status.success(),\n            ": "",
        ",\n            output.status,\n            String::from_utf8_lossy(&output.stdout),\n            String::from_utf8_lossy(&output.stderr)\n        );\n        Ok(())\n    }\n\n    fn update_status(&self, server_name: LanguageServerName, status: language::BinaryStatus) {\n        self.language_registry\n            .update_lsp_binary_status(server_name, status);\n    }\n\n    fn registered_lsp_adapters(&self) -> Vec<Arc<dyn LspAdapter>> {\n        self.language_registry\n            .all_lsp_adapters()\n            .into_iter()\n            .map(|adapter| adapter.adapter.clone() as Arc<dyn LspAdapter>)\n            .collect()\n    }\n\n    async fn language_server_download_dir(&self, name: &LanguageServerName) -> Option<Arc<Path>> {\n        let dir = self.language_registry.language_server_download_dir(name)?;\n\n        if !dir.exists() {\n            smol::fs::create_dir_all(&dir)\n                .await\n                .context(": "",
        ")\n                .log_err()?;\n        }\n\n        Some(dir)\n    }\n\n    async fn read_text_file(&self, path: &RelPath) -> Result<String> {\n        let entry = self\n            .worktree\n            .entry_for_path(path)\n            .with_context(|| format!(": "",
        "))?;\n        let abs_path = self.worktree.absolutize(&entry.path);\n        self.fs.load(&abs_path).await\n    }\n}\n\nasync fn populate_labels_for_symbols(\n    symbols: Vec<CoreSymbol>,\n    language_registry: &Arc<LanguageRegistry>,\n    lsp_adapter: Option<Arc<CachedLspAdapter>>,\n    output: &mut Vec<Symbol>,\n) {\n    #[allow(clippy::mutable_key_type)]\n    let mut symbols_by_language = HashMap::<Option<Arc<Language>>, Vec<CoreSymbol>>::default();\n\n    let mut unknown_paths = BTreeSet::<Arc<str>>::new();\n    for symbol in symbols {\n        let Some(file_name) = symbol.path.file_name() else {\n            continue;\n        };\n        let language = language_registry\n            .load_language_for_file_path(Path::new(file_name))\n            .await\n            .ok()\n            .or_else(|| {\n                unknown_paths.insert(file_name.into());\n                None\n            });\n        symbols_by_language\n            .entry(language)\n            .or_default()\n            .push(symbol);\n    }\n\n    for unknown_path in unknown_paths {\n        log::info!(": "",
        ");\n    }\n\n    let mut label_params = Vec::new();\n    for (language, mut symbols) in symbols_by_language {\n        label_params.clear();\n        label_params.extend(\n            symbols\n                .iter_mut()\n                .map(|symbol| (mem::take(&mut symbol.name), symbol.kind)),\n        );\n\n        let mut labels = Vec::new();\n        if let Some(language) = language {\n            let lsp_adapter = lsp_adapter.clone().or_else(|| {\n                language_registry\n                    .lsp_adapters(&language.name())\n                    .first()\n                    .cloned()\n            });\n            if let Some(lsp_adapter) = lsp_adapter {\n                labels = lsp_adapter\n                    .labels_for_symbols(&label_params, &language)\n                    .await\n                    .log_err()\n                    .unwrap_or_default();\n            }\n        }\n\n        for ((symbol, (name, _)), label) in symbols\n            .into_iter()\n            .zip(label_params.drain(..))\n            .zip(labels.into_iter().chain(iter::repeat(None)))\n        {\n            output.push(Symbol {\n                language_server_name: symbol.language_server_name,\n                source_worktree_id: symbol.source_worktree_id,\n                source_language_server_id: symbol.source_language_server_id,\n                path: symbol.path,\n                label: label.unwrap_or_else(|| CodeLabel::plain(name.clone(), None)),\n                name,\n                kind: symbol.kind,\n                range: symbol.range,\n            });\n        }\n    }\n}\n\nfn include_text(server: &lsp::LanguageServer) -> Option<bool> {\n    match server.capabilities().text_document_sync.as_ref()? {\n        lsp::TextDocumentSyncCapability::Options(opts) => match opts.save.as_ref()? {\n            // Server wants didSave but didn't specify includeText.\n            lsp::TextDocumentSyncSaveOptions::Supported(true) => Some(false),\n            // Server doesn't want didSave at all.\n            lsp::TextDocumentSyncSaveOptions::Supported(false) => None,\n            // Server provided SaveOptions.\n            lsp::TextDocumentSyncSaveOptions::SaveOptions(save_options) => {\n                Some(save_options.include_text.unwrap_or(false))\n            }\n        },\n        // We do not have any save info. Kind affects didChange only.\n        lsp::TextDocumentSyncCapability::Kind(_) => None,\n    }\n}\n\n/// Completion items are displayed in a `UniformList`.\n/// Usually, those items are single-line strings, but in LSP responses,\n/// completion items `label`, `detail` and `label_details.description` may contain newlines or long spaces.\n/// Many language plugins construct these items by joining these parts together, and we may use `CodeLabel::fallback_for_completion` that uses `label` at least.\n/// All that may lead to a newline being inserted into resulting `CodeLabel.text`, which will force `UniformList` to bloat each entry to occupy more space,\n/// breaking the completions menu presentation.\n///\n/// Sanitize the text to ensure there are no newlines, or, if there are some, remove them and also remove long space sequences if there were newlines.\nfn ensure_uniform_list_compatible_label(label: &mut CodeLabel) {\n    let mut new_text = String::with_capacity(label.text.len());\n    let mut offset_map = vec![0; label.text.len() + 1];\n    let mut last_char_was_space = false;\n    let mut new_idx = 0;\n    let chars = label.text.char_indices().fuse();\n    let mut newlines_removed = false;\n\n    for (idx, c) in chars {\n        offset_map[idx] = new_idx;\n\n        match c {\n            '\\n' if last_char_was_space => {\n                newlines_removed = true;\n            }\n            '\\t' | ' ' if last_char_was_space => {}\n            '\\n' if !last_char_was_space => {\n                new_text.push(' ');\n                new_idx += 1;\n                last_char_was_space = true;\n                newlines_removed = true;\n            }\n            ' ' | '\\t' => {\n                new_text.push(' ');\n                new_idx += 1;\n                last_char_was_space = true;\n            }\n            _ => {\n                new_text.push(c);\n                new_idx += c.len_utf8();\n                last_char_was_space = false;\n            }\n        }\n    }\n    offset_map[label.text.len()] = new_idx;\n\n    // Only modify the label if newlines were removed.\n    if !newlines_removed {\n        return;\n    }\n\n    let last_index = new_idx;\n    let mut run_ranges_errors = Vec::new();\n    label.runs.retain_mut(|(range, _)| {\n        match offset_map.get(range.start) {\n            Some(&start) => range.start = start,\n            None => {\n                run_ranges_errors.push(range.clone());\n                return false;\n            }\n        }\n\n        match offset_map.get(range.end) {\n            Some(&end) => range.end = end,\n            None => {\n                run_ranges_errors.push(range.clone());\n                range.end = last_index;\n            }\n        }\n        true\n    });\n    if !run_ranges_errors.is_empty() {\n        log::error!(\n            ": "",
        ",\n            label.text\n        );\n    }\n\n    let mut wrong_filter_range = None;\n    if label.filter_range == (0..label.text.len()) {\n        label.filter_range = 0..new_text.len();\n    } else {\n        let mut original_filter_range = Some(label.filter_range.clone());\n        match offset_map.get(label.filter_range.start) {\n            Some(&start) => label.filter_range.start = start,\n            None => {\n                wrong_filter_range = original_filter_range.take();\n                label.filter_range.start = last_index;\n            }\n        }\n\n        match offset_map.get(label.filter_range.end) {\n            Some(&end) => label.filter_range.end = end,\n            None => {\n                wrong_filter_range = original_filter_range.take();\n                label.filter_range.end = last_index;\n            }\n        }\n    }\n    if let Some(wrong_filter_range) = wrong_filter_range {\n        log::error!(\n            ": "",
        ",\n            label.text\n        );\n    }\n\n    label.text = new_text;\n}\n\n#[cfg(test)]\nmod tests {\n    use language::HighlightId;\n\n    use super::*;\n\n    #[test]\n    fn test_glob_literal_prefix() {\n        assert_eq!(glob_literal_prefix(Path::new(": "",
        ")), Path::new(": "",
        "));\n        assert_eq!(\n            glob_literal_prefix(Path::new(": "",
        ")),\n            Path::new(": "",
        ")\n        );\n        assert_eq!(\n            glob_literal_prefix(Path::new(": "",
        ")\n        );\n\n        #[cfg(target_os = ": "",
        ")]\n        {\n            assert_eq!(glob_literal_prefix(Path::new(": "",
        "));\n            assert_eq!(\n                glob_literal_prefix(Path::new(": "",
        ")),\n                Path::new(": "",
        ")\n            );\n            assert_eq!(\n                glob_literal_prefix(Path::new(": "",
        ")\n            );\n        }\n    }\n\n    #[test]\n    fn test_multi_len_chars_normalization() {\n        let mut label = CodeLabel::new(\n            ": "",
        ".to_string(),\n            0..6,\n            vec![(0..6, HighlightId(1))],\n        );\n        ensure_uniform_list_compatible_label(&mut label);\n        assert_eq!(\n            label,\n            CodeLabel::new(\n                ": ""
    },
    "zed/crates/project/src/prettier_store.rs": {
        "Found already started prettier in {prettier_dir:?}": "",
        "Found prettier in {prettier_dir:?}, starting.": "",
        "Failed to determine prettier path for buffer: {e:#}": "",
        "Found prettier ignore in {ignore_dir:?}": "",
        "Failed to determine prettier ignore path for buffer: {e:#}": "",
        "Starting prettier at path {prettier_dir:?}": "",
        "default prettier spawn": "",
        "Default prettier is not installed and cannot be started": "",
        "Waiting for default prettier to install": "",
        "Cannot start default prettier due to its installation failure: {e:#}": "",
        "Started default prettier in {prettier_dir:?}": "",
        "Started prettier in {prettier_dir:?}": "",
        "prettier (default)": "",
        "prettier ({name})": "",
        "prettier ({})": "",
        "node_modules": "",
        "Prettier config file {config_path:?} changed, reloading prettier instances for worktree {current_worktree_id}": "",
        "Failed to clear prettier {prettier_path:?} cache for worktree {worktree_id:?} on prettier settings update: {e:#}": "",
        "Failed to clear default prettier cache for worktree {worktree_id:?} on prettier settings update: {e:#}": "",
        "Default prettier installation had failed {installation_attempt} times, not attempting again": "",
        "locate prettier installation": "",
        "Failed to install default prettier: {e:#}": "",
        "Initializing default prettier with plugins {new_plugins:?}": "",
        "prettier & plugins install": "",
        "Initialized default prettier with plugins: {installed_plugins:?}": "",
        "prettier at {path:?}": "",
        "default prettier instance": "",
        "{} failed to format buffer": "",
        "{prettier_description} failed to spawn: {error:#}": "",
        "Prettier from path {prettier_dir:?} exceeded launch threshold, not starting": "",
        "Default prettier exceeded launch threshold, not starting": "",
        "prettier": "",
        "fetching latest npm version for package {returned_package_name}": "",
        "fetching latest npm versions": "",
        "fetching FS metadata for default prettier dir {default_prettier_dir:?}": "",
        "default prettier dir {default_prettier_dir:?} is not a directory": "",
        "creating default prettier dir {default_prettier_dir:?}": "",
        "Installing default prettier and plugins: {packages_to_versions:?}": "",
        "fetching formatter packages": "",
        "writing {} file at {prettier_wrapper_path:?}": ""
    },
    "zed/crates/project/src/project_settings.rs": {
        "source": "",
        "default_true": "",
        "error": "",
        "GoToDiagnosticSeverity::min": "",
        "hint": "",
        "GoToDiagnosticSeverity::max": "",
        "unknown kind {kind}": "",
        "setting new user settings": "",
        "parsing VSCode tasks, file {abs_path:?}": "",
        "converting VSCode tasks into Zed ones, file {abs_path:?}": "",
        "serializing Zed tasks into JSON, file {abs_path:?}": "",
        "parsing VSCode debug tasks, file {abs_path:?}": "",
        "converting VSCode debug tasks into Zed ones, file {abs_path:?}": "",
        "Failed to set local settings in {path:?}: {message}": "",
        "Failed to set local settings: {e}": "",
        "Failed to set local tasks in {path:?}: {message:?}": "",
        "Failed to set local tasks: {e}": "",
        "Failed to set local debug scenarios in {path:?}: {message:?}": ""
    },
    "zed/crates/project/src/project.rs": {
        "RemotelyCreatedModelGuard dropped too many times": "",
        "Completion": "",
        "replace_range": "",
        "new_text": "",
        "label": "",
        "documentation": "",
        "source": "",
        "Unknown command": "",
        "command": "",
        "code lens": "",
        "DirectoryLister::Project({project:?})": "",
        "DirectoryLister::Local({project:?})": "",
        "C:\\\\": "",
        "Toolchain store to be local": "",
        "No worktree for path {project_path:?}": "",
        "No worktree for entry {entry_id:?}": "",
        "no task": "",
        "project was already shared": "",
        "attempted to unshare a remote project": "",
        "attempted to unshare an unshared project": "",
        "called create_local_buffer on a remote project": "",
        "no such path": "",
        "buffer {id} does not exist": "",
        "cannot open buffer while disconnected": "",
        "Project dropped": "",
        "dap": "",
        "lsp": "",
        "Failed to set local settings in {path:?}:\\n{message}": "",
        "local-settings-{path:?}": "",
        "Failed to set local tasks in {path:?}:\\n{message}": "",
        "local-tasks-{path:?}": "",
        "Failed to set local debug scenarios in {path:?}:\\n{message}": "",
        "local-debug-scenarios-{path:?}": "",
        "This project does not support toolchains": "",
        "not an ssh project": "",
        "code lens fetch failed: {e:#}": "",
        "cannot list directory in remote project": "",
        "empty collaborator": "",
        "missing old peer id": "",
        "missing new peer id": "",
        "received UpdateProjectCollaborator for unknown peer": "",
        "peer {} became {}": "",
        "invalid peer id": "",
        "unknown peer {peer_id:?}": "",
        "Invalid prompt level": "",
        "invalid log type": "",
        "missing query field": "",
        "can't synchronize remote buffers on a readonly project": "",
        "can't synchronize remote buffers on a local project": "",
        "Failed to load settings file": "",
        "Failed to write settings file": "",
        "Default should allow AI": "",
        "disable_ai": "",
        "Local false cannot override global true": ""
    },
    "zed/crates/project/src/search_history.rs": {
        "No current selection should be set for the default search history": "",
        "rust": "",
        "Newly added item should be selected": "",
        "Should not add a duplicate": "",
        "rustlang": "",
        "Should replace previous item if it's a substring": "",
        "php": "",
        "Should add item": "",
        "item{i}": "",
        "Default search history should not have a next item": "",
        "JavaScript": "",
        "TypeScript": "",
        "Should start from the end after reset on previous item query": "",
        "Python": "",
        "Java": "",
        "C++": ""
    },
    "zed/crates/project/src/search.rs": {
        "\\B": "",
        "Failed to create WORD_MATCH_TEST": "",
        "\\\\b": "",
        "\\\\n": "",
        "\\\\c": "",
        "\\\\C": "",
        "\\\\\\\\|\\\\n|\\\\t": "",
        "\\t": "",
        "Unexpected escape sequence: {}": "",
        "file": "",
        "Cargo.toml": "",
        ".DS_Store": "",
        "~/dir/another_dir/": "",
        "./dir/file": "",
        "dir/[a-z].txt": "",
        "../dir/filé": "",
        "Valid path {valid_path} should be accepted, but got: {e}": "",
        "Path matcher for valid path {valid_path} should match itself": "",
        "dir/[].txt": "",
        "dir/[a-z.txt": "",
        "dir/{file": "",
        "Invalid glob {invalid_glob} should not be accepted": "",
        "dir/?ile": "",
        "dir/*.txt": "",
        "dir/**/file": "",
        "{dir,file}": "",
        "Valid glob should be accepted, but got: {e}": "",
        "test\\\\C": "",
        "Should be able to create a regex SearchQuery": "",
        "Case sensitivity should be enabled when \\\\C pattern item is present in the query.": "",
        "test\\\\c": "",
        "Case sensitivity should be disabled when \\\\c pattern item is present, even if initially set to true.": "",
        "test\\\\c\\\\C": "",
        "Case sensitivity should be enabled when \\\\C is the last pattern item, even after a \\\\c.": "",
        "tests\\\\\\\\C": "",
        "Case sensitivity should not be enabled when \\\\C pattern item is preceded by a backslash.": ""
    },
    "zed/crates/project/src/task_inventory.rs": {
        "Inventory": "",
        "last_scheduled_tasks": "",
        "last_scheduled_scenarios": "",
        "templates_from_settings": "",
        "scenarios_from_settings": "",
        "tasks.json": "",
        "tasks": "",
        "debug.json": "",
        "debug scenarios": "",
        "local worktree {} from directory {directory:?}": "",
        "global {}": "",
        "oneshot": "",
        "{id_base}_{}": "",
        "{id_base}_{id}_{}": "",
        "language_{name}": "",
        "lsp_{language_name}_{server}": "",
        "usage": "",
        "Failed to parse tasks file content as a JSON array: {e}": "",
        "Failed to find task with name {task_name}": "",
        "Failed to resolve task with name {task_name}": "",
        "No tasks expected for empty inventory, but got {initial_tasks:?}": "",
        "1_a_task": "",
        "1_task": "",
        "2_task": "",
        "3_task": "",
        "Tasks with equal amount of usages should be sorted alphanumerically": "",
        "Most recently used task should be at the top": "",
        "worktree_task_1": "",
        "Most recently used worktree task should be at the top": "",
        "10_hello": "",
        "11_hello": "",
        "After global tasks update, worktree task usage is not erased and it's the first still; global task is back to regular order as its file was updated": "",
        "\n                        [{\n                            ": "",
        ": ": "",
        ",\n                            ": "",
        ",\n                        }]\n                        ": "",
        "Delve": "",
        "common_task_name": "",
        "global tasks.json": "",
        "static_source_1": "",
        "static_source_2": "",
        ".zed": "",
        "local worktree tasks from directory \\\".zed\\\"": "",
        "worktree_1": "",
        "worktree_2": "",
        "Without a worktree, only worktree-independent tasks should be listed": "",
        "label": "",
        "command": "",
        "echo": "",
        "args": ""
    },
    "zed/crates/project/src/task_store.rs": {
        "no location given for task context handling": "",
        "empty task store cannot handle task context requests": "",
        "no buffer store when handling task context request": "",
        "cannot handle task context request for invalid buffer id: {}": "",
        "missing task context location start": "",
        "missing task context location end": "",
        "no local buffer with id {buffer_id}": "",
        "Unknown variable name: {variable_name}": "",
        "building basic default context": "",
        "building provider context": ""
    },
    "zed/crates/project/src/terminals.rs": {
        "Python": "",
        " ": "",
        "exec {shell} -l": "",
        "{separator} ": "",
        "{activation_script}{separator} {to_run}": "",
        "\\\"{arg}\\\"": "",
        "TERM": "",
        "xterm-256color": "",
        "Connecting to a remote server: {:?}": "",
        "{} — Terminal": ""
    },
    "zed/crates/project/src/toolchain_store.rs": {
        "Missing `toolchain` in payload": "",
        "Language {} not found": "",
        "Language {} does not support toolchains": "",
        "Failed to resolve toolchain via RPC": "",
        "Deserializing ResolveToolchain LSP response": "",
        "{error}": ""
    },
    "zed/crates/project/src/worktree_store.rs": {
        "no such worktree": "",
        "no such entry": "",
        "no parent for path {:?}": "",
        "renaming {old_path:?} into {new_path:?}": "",
        "creating parent directory {parent:?}": "",
        "cannot create worktrees via collab": "",
        "Dropped worktree store": "",
        "invalid project": "",
        "Missing worktree for id {source}": "",
        "Missing worktree for id {destination}": "",
        "listing ignored path {abs_path:?}": "",
        "fetching fs metadata for {abs_path:?}": "",
        "getting relative path": "",
        "obviously binary": "",
        "Invalid UTF-8 sequence in file {abs_path:?} at byte position {starting_position}": "",
        "worktree not found": "",
        "no downstream client": "",
        "entry is private": "",
        "no entry": "",
        "received invalid relative path {:?}": "",
        "missing entry": "",
        "invalid request": ""
    },
    "zed/crates/project_panel/src/project_panel.rs": {
        "ProjectPanel": "",
        "Failed to open file": "",
        "Disconnected from SSH host": "",
        "Disconnected from remote project": "",
        "{} is not shared by the host. This could be because it has been marked as `private`": "",
        "Try Again": "",
        "File is too large to load": "",
        "loading project panel": "",
        "Search Inside": "",
        "New File": "",
        "New Folder": "",
        "Reveal in Finder": "",
        "Reveal in File Manager": "",
        "Open in Default App": "",
        "Open in Terminal": "",
        "Find in Folder…": "",
        "Unfold Directory": "",
        "Fold Directory": "",
        "Compare marked files": "",
        "Cut": "",
        "Copy": "",
        "Duplicate": "",
        "Paste": "",
        "Copy Path": "",
        "Copy Relative Path": "",
        "Rename": "",
        "Trash": "",
        "Delete": "",
        "Add Folder to Project…": "",
        "Remove from Project": "",
        "Collapse All": "",
        "File or directory name cannot be empty.": "",
        "File or directory name contains leading or trailing whitespace.": "",
        "File or directory '{}' already exists at location. Please choose a different name.": "",
        "excluded-directory": "",
        "Created an excluded directory at {abs_path:?}.\\nAlter `file_scan_exclusions` in the settings to show it in the panel": "",
        "\\n\\nIt has unsaved changes, which will be lost.": "",
        "{operation} {path}?{unsaved_warning}": "",
        ".. 1 file not shown": "",
        ".. {} files not shown": "",
        "\\n\\n1 of these has unsaved changes, which will be lost.": "",
        "\\n\\n{dirty_buffers} of these have unsaved changes, which will be lost.": "",
        "Do you want to {} the following {} files?\\n{}{unsaved_warning}": "",
        "Cancel": "",
        "no such entry": "",
        " copy": "",
        " {}": "",
        "\\0": "",
        "Non-root entry has no file name: {entry:?}": "",
        "Project Panel Updated": "",
        "A file or folder with name {filename} already exists in the destination folder. Do you want to replace it?": "",
        "Replace": "",
        "failed to copy external paths": "",
        "Edited sub-entry should be an ancestor of selected leaf entry": "",
        "project_entry": "",
        "project_panel_sticky_item_{}": "",
        "symlink_icon": "",
        "Symbolic Link": "",
        "project_panel_path_component_{}_{index}": "",
        "menu": "",
        "editing": "",
        "not_editing": "",
        "can't reveal a non-existent entry in the project panel": "",
        "can't reveal an ignored entry in the project panel": "",
        "project-panel": "",
        "entries": "",
        "project-panel-blank-area": "",
        "empty-project_panel": "",
        "open_project": "",
        "Open Project": "",
        "or": "",
        "clone_repo": "",
        "Clone Repository": "",
        "{} entries": "",
        "Project Panel": ""
    },
    "zed/crates/recent_projects/src/disconnected_overlay.rs": {
        "Failed to reconnect": "",
        "Your connection to the remote project has been lost.": "",
        "\\nUnsaved changes are stored locally.": "",
        "Your connection to {} has been lost.{}": "",
        "disconnected": "",
        "Disconnected": "",
        "close-window": "",
        "Close Window": "",
        "reconnect": "",
        "Reconnect": ""
    },
    "zed/crates/recent_projects/src/recent_projects.rs": {
        "\n                        Invalid path specified when trying to open a folder inside WSL.\n\n                        Please note that Zed currently does not support opening network share folders inside wsl.\n                    ": "",
        "Invalid path": "",
        "Ok": "",
        "RecentProjects": "",
        "{reuse_window} reuses this window, {create_window} opens a new one": "",
        "Failed to open project": "",
        "Recently opened projects will show up here": "",
        "No matches": "",
        ", ": "",
        "delete": "",
        "Delete from Recent Projects...": "",
        "remote": "",
        "Open Remote Folder": "",
        "local": "",
        "Open Local Folder": "",
        "/dir": "",
        "main.ts": "",
        "a": "",
        "EDIT": "",
        "After inserting more text into the editor without saving, we should have a dirty project": "",
        "fake candidate": "",
        "/test/path": "",
        "Should have no pending prompt on dirty project before opening the new recent project": "",
        "Should remove the modal after selecting new recent project": "",
        "Dirty workspace should prompt before opening the new recent project": "",
        "Cancel": "",
        "Should have no pending prompt after cancelling": "",
        "Should be in the same dirty project after cancelling": ""
    },
    "zed/crates/recent_projects/src/remote_servers.rs": {
        "Add a nickname for this server": "",
        "SSH Project Created": "",
        "could not parse: {:?}": "",
        "Failed to connect": "",
        "ssh server created": "",
        "SSH Server Created": "",
        "WSL Distro Added": "",
        "server index and connection options mismatch": "",
        "C:\\\\": "",
        "ssh-server": "",
        "WSL:": "",
        "No projects.": "",
        "new-remote-project-container": "",
        "new-remote-project": "",
        "Open Folder": "",
        "server-options-container": "",
        "server-options": "",
        "View Server Options": "",
        "remote-project-{}": "",
        "ssh-{index}": "",
        "wsl-{index}": "",
        "remote-project-container-{element_id_base}": "",
        "Failed to connect: {e:#}": "",
        "Ok": "",
        ", ": "",
        "remove-remote-project": "",
        "Delete Remote Project": "",
        "ssh user@example -p 2222": "",
        "create-remote-server": "",
        "Enter the command you use to SSH into this server.": "",
        "learn-more": "",
        "Learn More": "",
        "add-wsl-distro": "",
        "ssh-options-copy-server-address": "",
        "go-back": "",
        "Go Back": "",
        "Remove WSL distro `{}`?": "",
        "Yes, remove it": "",
        "No, keep it": "",
        "wsl-options-remove-distro": "",
        "remove-distro": "",
        "Remove Distro": "",
        "Edit Nickname": "",
        "Add Nickname to Server": "",
        "ssh-options-add-nickname": "",
        "add-nickname": "",
        "Copied server address ({}) to clipboard": "",
        "copy-server-address": "",
        "Copy Server Address": "",
        "Remove server `{}`?": "",
        "remove-server": "",
        "Remove Server": "",
        "ssh-edit-nickname": "",
        "ssh-connect-new-server-container": "",
        "register-remove-server-button": "",
        "Connect New Server": "",
        "wsl-connect-new-server": "",
        "wsl-add-new-server": "",
        "Add WSL Distro": "",
        "ssh-server-list": "",
        "No remote servers registered yet.": "",
        "{reuse_window} reuses this window, {create_window} opens a new one": "",
        "remote-projects": "",
        "Remote Projects": "",
        "RemoteServerModal": ""
    },
    "zed/crates/refineable/derive_refineable/src/derive_refineable.rs": {
        "refineable": "",
        "Debug": "",
        "Serialize": "",
        "{}Refinement": "",
        "This derive macro only supports structs with named fields": "",
        "::refineable::IsEmpty::is_empty": "",
        "::std::option::Option::is_none": "",
        "Option": "",
        "Expected struct type for a refineable field": ""
    },
    "zed/crates/repl/src/components/kernel_options.rs": {
        "Select a kernel...": "",
        "Python Env": "",
        "Remote": "",
        "kernel-docs": "",
        "Kernel Docs": "",
        "kernel-switcher": ""
    },
    "zed/crates/repl/src/kernels/native_kernel.rs": {
        "Empty argv in kernelspec {}": "",
        "Invalid argv in kernelspec {}": "",
        "{connection_file}": "",
        "Missing 'connection_file' in argv in kernelspec {}": "",
        "RunningKernel": "",
        "process": "",
        "hmac-sha256": "",
        "zed-{}": "",
        "Failed to create jupyter runtime dir {runtime_dir:?}": "",
        "kernel-zed-{entity_id}.json": "",
        "failed to start the kernel process": "",
        "kernel: {}": "",
        "iopub task": "",
        "shell task": "",
        "control task": "",
        "routing task": "",
        "kernel: handling failed for {name}: {err:?}": "",
        "handling failed for {name}: {err}": "",
        "kernel process exited successfully": "",
        "kernel process exited with status: {:?}": "",
        "kernel process exited with error: {:?}": "",
        "killing the kernel process": "",
        "Invalid kernelspec directory: {path:?}": "",
        "Not a directory: {path:?}": "",
        "kernel.json": "",
        "Error reading kernelspec directory: {err:?}": "",
        "CONDA_PREFIX": "",
        "share": "",
        "jupyter": "",
        "python": "",
        "-c": "",
        "import sys; print(sys.prefix)": "",
        "kernels": "",
        "/jupyter": "",
        ".zed": "",
        "settings.json": "",
        "{ ": "",
        ": 8 }": "",
        "tasks.json": "",
        "[{\n                        ": "",
        ": ": "",
        ",\n                        ": "",
        ": [": "",
        ", ": "",
        "]\n                    },]": "",
        "{\n                            ": "",
        ",\n                            ": "",
        "],\n                            ": "",
        ": {}\n                        }": "",
        "deno": "",
        "/jupyter/kernels": ""
    },
    "zed/crates/repl/src/kernels/remote_kernels.rs": {
        "POST": "",
        "/kernels": "",
        "Authorization": "",
        "token {}": "",
        "Failed to launch kernel: {body}": "",
        "/kernelspecs": "",
        "GET": "",
        "Failed to fetch kernel specs: {}": "",
        "No kernel specs found": "",
        "{}/api/kernels/{}/channels?token={}": "",
        "http": "",
        "ws": "",
        "User-Agent": "",
        "Zed/{} ({}; {})": "",
        "repl": "",
        "Error receiving message: {:?}": "",
        "RemoteRunningKernel": "",
        "remote_server url": "",
        "working_directory": "",
        "request_tx": "",
        "execution_state": "",
        "kernel_info": "",
        "/kernels/{}": "",
        "DELETE": "",
        "Failed to shutdown kernel: {}": ""
    },
    "zed/crates/repl/src/notebook/notebook_ui.rs": {
        "LOCAL_NOTEBOOK_DEV": "",
        "Cells would all run here, if that was implemented!": "",
        "Open notebook triggered": "",
        "Move cell up triggered": "",
        "Move cell down triggered": "",
        "Add markdown block triggered": "",
        "Add code block triggered": "",
        "run-all-cells": "",
        "Execute all cells": "",
        "clear-all-outputs": "",
        "Clear all outputs": "",
        "move-cell-up": "",
        "Move cell up": "",
        "move-cell-down": "",
        "Move cell down": "",
        "new-markdown-cell": "",
        "Add markdown block": "",
        "new-code-cell": "",
        "Add code block": "",
        "more-menu": "",
        "repl": "",
        "notebook": "",
        "notebook-cells": "",
        "ipynb": "",
        "finding the absolute path of {path:?}": "",
        "Failed to parse notebook: {:?}": "",
        "Entry not found": "",
        "notebook controls": "",
        "save() must be implemented if can_save() returns true": "",
        "save_as() must be implemented if can_save() returns true": "",
        "reload() must be implemented if can_save() returns true": ""
    },
    "zed/crates/repl/src/outputs/image.rs": {
        "unsupported image format {format:?}": ""
    },
    "zed/crates/repl/src/outputs.rs": {
        "copy-output": "",
        "Copy Output": "",
        "open-in-buffer": "",
        "Open in Buffer": "",
        "REPL Output": "",
        "output-content": "",
        "copy-full-error-traceback": "",
        "Copy Full Error": "",
        "{}: {}\\n{}": "",
        "open-full-error-in-buffer-traceback": "",
        "Open Full Error in Buffer": "",
        "Full Error": "",
        "Failed to load image: {}": "",
        "Unsupported media type": "",
        "the output": "",
        "Connecting to kernel...": "",
        "Executing...": "",
        "Unknown status": "",
        "Kernel shutting down...": "",
        "Kernel restarting...": "",
        "Kernel shutdown": "",
        "Queued...": "",
        "Kernel error: {}": ""
    },
    "zed/crates/repl/src/repl_editor.rs": {
        "editor is not in a worktree": "",
        "editor was dropped": "",
        "No kernel found for language: {}": "",
        "{comment_prefix}%%": "",
        "python": "",
        "Python": "",
        "TestLang": "",
        "# ": "",
        "\n                    print(1 + 1)\n                    print(2 + 2)\n\n                    print(4 + 4)\n\n\n                ": "",
        "print(1 + 1)": "",
        "\n                print(1 + 1)\n                print(2 + 2)": "",
        "\n                print(1 + 1)\n                print(2 + 2)\n\n                print(4 + 4)": "",
        "\n                    # Hello!\n                    # %% [markdown]\n                    # This is some arithmetic\n                    print(1 + 1)\n                    print(2 + 2)\n\n                    # %%\n                    print(3 + 3)\n                    print(4 + 4)\n\n                    print(5 + 5)\n\n\n\n                ": "",
        "\n                # %% [markdown]\n                # This is some arithmetic\n                print(1 + 1)\n                print(2 + 2)": "",
        "\n                    # %% [markdown]\n                    # This is some arithmetic\n                    print(1 + 1)\n                    print(2 + 2)": "",
        "\n                    # %%\n                    print(3 + 3)\n                    print(4 + 4)\n\n                    print(5 + 5)": "",
        "typescript": "",
        "TypeScript": "",
        "markdown": "",
        "\n                    Hey this is Markdown!\n\n                    ```typescript\n                    let foo = 999;\n                    console.log(foo + 1999);\n                    ```\n\n                    ```typescript\n                    console.log(": "",
        ")\n                    ```\n                    ": "",
        "\n                    let foo = 999;\n                    console.log(foo + 1999);\n                    ": "",
        "console.log(\\\"foo\\\")\\n": "",
        "\n                    Hey this is Markdown!\n\n                    ```typescript\n                    let foo = 999;\n                    console.log(foo + 1999);\n                    ```\n\n                    ```ts\n                    console.log(": "",
        ")\n                    ```\n\n                    ```typescript\n                    console.log(": "",
        ")\n                    ```\n                ": "",
        "console.log(\\\"another code block\\\")\\n": "",
        "\n                    Hey this is Markdown!\n\n                    ```python\n                    print(": "",
        ")\n                    print(": "",
        "\n                print(": "",
        ")\n                print(": "",
        ")\n                ": ""
    },
    "zed/crates/repl/src/repl_sessions_ui.rs": {
        "Python": "",
        "REPL Sessions": "",
        "REPL Session Started": "",
        "To start interactively running code in your editor, you need to install and configure Jupyter kernels.": "",
        "No Jupyter Kernels Available": "",
        "install-kernels": "",
        "Install Kernels": "",
        "To run code in a Jupyter kernel, select some code and use the 'repl::Run' command.": "",
        "No Jupyter Kernel Sessions": "",
        "Jupyter Kernel Sessions": ""
    },
    "zed/crates/repl/src/repl_store.rs": {
        "repl": "",
        "getting python kernelspecs": "",
        "JUPYTER_SERVER": "",
        "JUPYTER_TOKEN": ""
    },
    "zed/crates/repl/src/session.rs": {
        "editor is not open": "",
        "workspace dropped": "",
        "close_output_area": "",
        "Close output area": "",
        "Kernel Status Changed": "",
        "restarting kernel": "",
        "interrupt": "",
        "Interrupt": "",
        "Starting": "",
        "Error: {err}": "",
        "Shutting Down": "",
        "Shutdown": "",
        "Restarting": "",
        "({status_text})": "",
        "shutdown": ""
    },
    "zed/crates/reqwest_client/src/reqwest_client.rs": {
        "key=[^&]+": "",
        "Failed to initialize HTTP client": "",
        "Failed to parse proxy URL '{}': {}": "",
        "no tokio runtime found, creating one for Reqwest...": "",
        "key=REDACTED": "",
        "test": "",
        "socks4://localhost:10808": "",
        "socks4a://localhost:10808": "",
        "socks5://localhost:10808": "",
        "socks5h://localhost:10808": "",
        "socks://127.0.0.1:20170": "",
        "An invalid proxy URL should add no proxy to the client!": ""
    },
    "zed/crates/rope/src/chunk.rs": {
        "byte index {} is out of bounds of `{:?}` (length: {})": "",
        "byte index {} is not a char boundary; it is inside {:?} (bytes {:?})": "",
        "point {:?} extends beyond rows for string {:?}": "",
        "point {:?} extends beyond row for string {:?}": "",
        "point {:?} is beyond this chunk's extent {:?}": "",
        "point {:?} is beyond the end of the line in chunk {:?}": "",
        "point {:?} is within character in chunk {:?}": "",
        "Chunk: {:?}": "",
        "Range: {:?}": "",
        "nth_set_bit({:0128b}, {})": "",
        "Verifying chunk {:?}": "",
        "mismatch at offset {}": "",
        "mismatch at point {:?}": "",
        "mismatch at offset_utf16 {:?}": "",
        "mismatch at point_utf16 {:?}": "",
        "mismatch for unclipped_point_utf16_to_point at {:?}": "",
        "incorrect left clip at {:?}": "",
        "incorrect right clip at {:?}": "",
        "incorrect left clip within multi-byte char at {:?}": "",
        "incorrect right clip within multi-byte char at {:?}": "",
        "incorrect unclipped_point_utf16_to_point within multi-byte char at {:?}": "",
        "incorrect left clip_point_utf16 within multi-byte char at {:?}": "",
        "incorrect right clip_point_utf16 within multi-byte char at {:?}": "",
        "incorrect left clip_offset_utf16 within multi-byte char at {:?}": "",
        "incorrect right clip_offset_utf16 within multi-byte char at {:?}": "",
        "mismatch at final offset {}": "",
        "mismatch at final point {:?}": "",
        "mismatch at final point_utf16 {:?}": "",
        "mismatch for unclipped_point_utf16_to_point at final point {:?}": "",
        "incorrect left clip at final point {:?}": "",
        "incorrect right clip at final point {:?}": "",
        "incorrect left clip_point_utf16 at final point {:?}": "",
        "incorrect right clip_point_utf16 at final point {:?}": "",
        "incorrect left clip_offset_utf16 at final offset {:?}": "",
        "incorrect right clip_offset_utf16 at final offset {:?}": ""
    },
    "zed/crates/rpc/src/auth.rs": {
        "failed to encrypt string with public key": "",
        "failed to base64-decode encrypted string": "",
        "failed to decrypt string with private key": "",
        "decrypted content was not valid utf8": "",
        "failed to serialize public key": "",
        "failed to base64-decode public key string": "",
        "failed to parse public key": "",
        "MIGJAoGBAMPvufou8wOuUIF1Wlkbtn0ZMM9nC55QJ06nTZvgMfZv5esFVU9-cQO_JC1P9ZoEcMDJweFERnQuQLqzsrMDLFbkdgL128ZU43WOLiQraxaICFIZsPUeTtWMKp2D5bPWsNxs-lnCma7vCAry6fpXuj5AKQdk7cTZJNucgvZQ0uUfAgMBAAE=": "",
        "token {:?} has non-printable char {}": "",
        "token {:?} is not URL-safe": ""
    },
    "zed/crates/rpc/src/peer.rs": {
        "handle io future: start": "",
        "connection closed": "",
        "handle io future: end": "",
        "outer loop iteration start": "",
        "inner loop iteration start": "",
        "outgoing rpc message: writing": "",
        "outgoing rpc message: done writing": "",
        "failed to write RPC message": "",
        "keepalive interval: resetting after sending message": "",
        "outgoing rpc message: writing timed out": "",
        "timed out writing message": "",
        "outgoing rpc message: channel closed": "",
        "keepalive interval: pinging": "",
        "keepalive interval: done pinging": "",
        "failed to send keepalive": "",
        "keepalive interval: resetting after pinging": "",
        "keepalive interval: pinging timed out": "",
        "timed out sending keepalive": "",
        "error reading rpc message from socket": "",
        "incoming rpc message: received": "",
        "receive timeout: resetting": "",
        "incoming rpc message: processing": "",
        "incoming rpc message: processed": "",
        "incoming rpc message: channel closed": "",
        "incoming rpc message: processing timed out": "",
        "timed out processing incoming message": "",
        "receive timeout: delay between messages too long": "",
        "delay between messages too long": "",
        "incoming message future: start": "",
        "incoming message future: end": "",
        "incoming response: received": "",
        "incoming response: request future dropped": "",
        "incoming response: waiting to resume requester": "",
        "incoming response: requester resumed": "",
        "incoming stream response: request future dropped": "",
        "incoming stream response: waiting to resume requester": "",
        "incoming stream response: requester resumed": "",
        "incoming response: unknown request": "",
        "incoming message: received": "",
        "unable to construct a typed envelope": "",
        "received response of the wrong type": "",
        "connection was closed": "",
        "message {} was not handled": "",
        "no such connection: {connection_id}": "",
        "Peer": "",
        "connections": "",
        "unknown message type": "",
        "message 1": "",
        "message 2": "",
        "response": "",
        "response 2": ""
    },
    "zed/crates/rpc/src/proto_client.rs": {
        "registered handler for the same message twice": "",
        "EntityMessageSubscriber::Entity": "",
        "handle": "",
        "EntityMessageSubscriber::Pending": "",
        "envelopes": "",
        "received response of the wrong type": "",
        "sending LSP proto request": "",
        "waiting for LSP proto response": "",
        "converting LSP proto response": "",
        "already subscribed to entity": ""
    },
    "zed/crates/search/src/buffer_search.rs": {
        "util::serde::default_true": "",
        "search_bar": "",
        "Search…": "",
        "Replace with…": "",
        "0/0": "",
        "editor-scroll": "",
        "buffer-search-bar-toggle": "",
        "Toggle Replace": "",
        "buffer-search-bar-toggle-search-selection-button": "",
        "Toggle Search Selection": "",
        "buffer-search-nav-button": "",
        "Select Previous Match": "",
        "Select Next Match": "",
        "Select All Matches": "",
        "buffer-search": "",
        "Close Search Bar": "",
        "Find in results": "",
        "buffer-search-replace-button": "",
        "Replace Next Match": "",
        "Replace All Matches": "",
        "BufferSearchBar": "",
        "in_replace": "",
        "buffer_search": "",
        "buffer_search_deployed": "",
        "query editor should be backed by a singleton buffer": "",
        "regex": "",
        "loading regex language": "",
        "\n                A regular expression (shortened as regex or regexp;[1] also referred to as\n                rational expression[2][3]) is a sequence of characters that specifies a search\n                pattern in text. Usually such patterns are used by string-searching algorithms\n                for ": "",
        " or ": "",
        " operations on strings, or for input validation.\n                ": "",
        "keymaps/default-macos.json": "",
        "us": "",
        "or": "",
        "\n        A regular expression (shortened as regex or regexp;[1] also referred to as\n        rational expression[2][3]) is a sequence of characters that specifies a search\n        pattern in text. Usually such patterns are used by string-searching algorithms\n        for ": "",
        " operations on strings, or for input validation.\n        ": "",
        "Should pick a query with multiple results": "",
        "a": "",
        "Initially, the editor should not be focused": "",
        "Expected to have only one selection before adding carets to all matches, but got: {initial_selections:?}": "",
        "Should focus editor after successful SelectAllMatches": "",
        "Should select all `a` characters in the buffer, but got: {all_selections:?}": "",
        "Match index should not change after selecting all matches": "",
        "Should still have editor focused after SelectNextMatch": "",
        "On next match, should deselect items and select the next match": "",
        "Next match should be different from the first selection": "",
        "Match index should be updated to the next one": "",
        "Should still have editor focused after SelectPreviousMatch": "",
        "On previous match, should deselect items and select the previous item": "",
        "Previous match should be the same as the first selection": "",
        "Match index should be updated to the previous one": "",
        "abas_nonexistent_match": "",
        "Should not switch focus to editor if SelectAllMatches does not find any matches": "",
        "Should not select anything new if there are no matches": "",
        "For no matches, there should be no active match index": "",
        "\n        self.buffer.update(cx, |buffer, cx| {\n            buffer.edit(\n                edits,\n                Some(AutoindentMode::Block {\n                    original_indent_columns,\n                }),\n                cx,\n            )\n        });\n\n        this.buffer.update(cx, |buffer, cx| {\n            buffer.edit([(end_of_line..start_of_next_line, replace)], None, cx)\n        });\n        ": "",
        "edit\\\\(": "",
        "Should select all `edit(` in the buffer, but got: {all_selections:?}": "",
        "edit(": "",
        "b": "",
        "c": "",
        "ba": "",
        "expression": "",
        "expr$1": "",
        "\n        A regular expr$1 (shortened as regex or regexp;[1] also referred to as\n        rational expr$1[2][3]) is a sequence of characters that specifies a search\n        pattern in text. Usually such patterns are used by string-searching algorithms\n        for ": "",
        "banana": "",
        "\n        A regular expr$1 (shortened as regex banana regexp;[1] also referred to as\n        rational expr$1[2][3]) is a sequence of characters that specifies a search\n        pattern in text. Usually such patterns are used by string-searching algorithms\n        for ": "",
        "${1}number": "",
        "\n        A regular expr$1 (shortened as regex banana regexp;1number also referred to as\n        rational expr$12number3number) is a sequence of characters that specifies a search\n        pattern in text. Usually such patterns are used by string-searching algorithms\n        for ": "",
        "a\\\\w+s": "",
        "things": "",
        "\n        A regular expr$1 (shortened as regex banana regexp;1number also referred to as\n        rational expr$12number3number) is a sequence of characters that specifies a search\n        pattern in text. Usually such patterns are used by string-searching things\n        for ": "",
        "\n            A regular \\n (shortened as regex or regexp;[1] also referred to as\n            rational \\n[2][3]) is a sequence of characters that specifies a search\n            pattern in text. Usually such patterns are used by string-searching algorithms\n            for ": "",
        " operations on strings, or for input validation.\n            ": "",
        "\\\\\\n\\\\\\\\": "",
        "find": "",
        "find and replace": "",
        "#\n            .unindent(),\n        })\n        .await;\n\n        run_replacement_test(ReplacementTestParams {\n            editor: &editor,\n            search_bar: &search_bar,\n            cx,\n            search_text: r": "",
        ",\n            search_options: Some(SearchOptions::REGEX),\n            replacement_text: r": "",
        ",\n            replace_all: true,\n            expected_text: r#": "",
        "#\n            .unindent(),\n        })\n        .await;\n    }\n\n    #[perf]\n    #[gpui::test]\n    async fn test_find_matches_in_selections_singleton_buffer_multiple_selections(\n        cx: &mut TestAppContext,\n    ) {\n        init_globals(cx);\n        let buffer = cx.new(|cx| {\n            Buffer::local(\n                r#": "",
        "#\n                .unindent(),\n                cx,\n            )\n        });\n        let cx = cx.add_empty_window();\n        let editor =\n            cx.new_window_entity(|window, cx| Editor::for_buffer(buffer.clone(), None, window, cx));\n\n        let search_bar = cx.new_window_entity(|window, cx| {\n            let mut search_bar = BufferSearchBar::new(None, window, cx);\n            search_bar.set_active_pane_item(Some(&editor), window, cx);\n            search_bar.show(window, cx);\n            search_bar\n        });\n\n        editor.update_in(cx, |editor, window, cx| {\n            editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n                s.select_ranges(vec![Point::new(1, 0)..Point::new(2, 4)])\n            })\n        });\n\n        search_bar.update_in(cx, |search_bar, window, cx| {\n            let deploy = Deploy {\n                focus: true,\n                replace_enabled: false,\n                selection_search_enabled: true,\n            };\n            search_bar.deploy(&deploy, window, cx);\n        });\n\n        cx.run_until_parked();\n\n        search_bar\n            .update_in(cx, |search_bar, window, cx| {\n                search_bar.search(": "",
        ", None, true, window, cx)\n            })\n            .await\n            .unwrap();\n\n        editor.update(cx, |editor, cx| {\n            assert_eq!(\n                editor.search_background_highlights(cx),\n                &[\n                    Point::new(1, 0)..Point::new(1, 3),\n                    Point::new(1, 8)..Point::new(1, 11),\n                    Point::new(2, 0)..Point::new(2, 3),\n                ]\n            );\n        });\n    }\n\n    #[perf]\n    #[gpui::test]\n    async fn test_find_matches_in_selections_multiple_excerpts_buffer_multiple_selections(\n        cx: &mut TestAppContext,\n    ) {\n        init_globals(cx);\n        let text = r#": "",
        "#\n        .unindent();\n\n        let cx = cx.add_empty_window();\n        let editor = cx.new_window_entity(|window, cx| {\n            let multibuffer = MultiBuffer::build_multi(\n                [\n                    (\n                        &text,\n                        vec![\n                            Point::new(0, 0)..Point::new(2, 0),\n                            Point::new(4, 0)..Point::new(5, 0),\n                        ],\n                    ),\n                    (&text, vec![Point::new(9, 0)..Point::new(11, 0)]),\n                ],\n                cx,\n            );\n            Editor::for_multibuffer(multibuffer, None, window, cx)\n        });\n\n        let search_bar = cx.new_window_entity(|window, cx| {\n            let mut search_bar = BufferSearchBar::new(None, window, cx);\n            search_bar.set_active_pane_item(Some(&editor), window, cx);\n            search_bar.show(window, cx);\n            search_bar\n        });\n\n        editor.update_in(cx, |editor, window, cx| {\n            editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n                s.select_ranges(vec![\n                    Point::new(1, 0)..Point::new(1, 4),\n                    Point::new(5, 3)..Point::new(6, 4),\n                ])\n            })\n        });\n\n        search_bar.update_in(cx, |search_bar, window, cx| {\n            let deploy = Deploy {\n                focus: true,\n                replace_enabled: false,\n                selection_search_enabled: true,\n            };\n            search_bar.deploy(&deploy, window, cx);\n        });\n\n        cx.run_until_parked();\n\n        search_bar\n            .update_in(cx, |search_bar, window, cx| {\n                search_bar.search(": "",
        ", None, true, window, cx)\n            })\n            .await\n            .unwrap();\n\n        editor.update(cx, |editor, cx| {\n            assert_eq!(\n                editor.search_background_highlights(cx),\n                &[\n                    Point::new(1, 0)..Point::new(1, 3),\n                    Point::new(5, 8)..Point::new(5, 11),\n                    Point::new(6, 0)..Point::new(6, 3),\n                ]\n            );\n        });\n    }\n\n    #[perf]\n    #[gpui::test]\n    async fn test_invalid_regexp_search_after_valid(cx: &mut TestAppContext) {\n        let (editor, search_bar, cx) = init_test(cx);\n        // Search using valid regexp\n        search_bar\n            .update_in(cx, |search_bar, window, cx| {\n                search_bar.enable_search_option(SearchOptions::REGEX, window, cx);\n                search_bar.search(": "",
        ", None, true, window, cx)\n            })\n            .await\n            .unwrap();\n        editor.update_in(cx, |editor, window, cx| {\n            assert_eq!(\n                display_points_of(editor.all_text_background_highlights(window, cx)),\n                &[\n                    DisplayPoint::new(DisplayRow(0), 10)..DisplayPoint::new(DisplayRow(0), 20),\n                    DisplayPoint::new(DisplayRow(1), 9)..DisplayPoint::new(DisplayRow(1), 19),\n                ],\n            );\n        });\n\n        // Now, the expression is invalid\n        search_bar\n            .update_in(cx, |search_bar, window, cx| {\n                search_bar.search(": "",
        ", None, true, window, cx)\n            })\n            .await\n            .unwrap_err();\n        editor.update_in(cx, |editor, window, cx| {\n            assert!(\n                display_points_of(editor.all_text_background_highlights(window, cx)).is_empty(),\n            );\n        });\n    }\n\n    #[perf]\n    #[gpui::test]\n    async fn test_search_options_changes(cx: &mut TestAppContext) {\n        let (_editor, search_bar, cx) = init_test(cx);\n        update_search_settings(\n            SearchSettings {\n                button: true,\n                whole_word: false,\n                case_sensitive: false,\n                include_ignored: false,\n                regex: false,\n                center_on_match: false,\n            },\n            cx,\n        );\n\n        let deploy = Deploy {\n            focus: true,\n            replace_enabled: false,\n            selection_search_enabled: true,\n        };\n\n        search_bar.update_in(cx, |search_bar, window, cx| {\n            assert_eq!(\n                search_bar.search_options,\n                SearchOptions::NONE,\n                ": "",
        "\n            );\n            search_bar.toggle_search_option(SearchOptions::WHOLE_WORD, window, cx);\n            assert_eq!(\n                search_bar.search_options,\n                SearchOptions::WHOLE_WORD,\n                ": "",
        "\n            );\n            assert!(\n                !search_bar.dismissed,\n                ": "",
        "\n            );\n            search_bar.deploy(&deploy, window, cx);\n            assert_eq!(\n                search_bar.search_options,\n                SearchOptions::WHOLE_WORD,\n                ": "",
        "\n            );\n\n            search_bar.dismiss(&Dismiss, window, cx);\n            search_bar.deploy(&deploy, window, cx);\n            assert_eq!(\n                search_bar.search_options,\n                SearchOptions::WHOLE_WORD,\n                ": "",
        "\n            );\n\n            search_bar.toggle_search_option(SearchOptions::REGEX, window, cx);\n            search_bar.toggle_search_option(SearchOptions::WHOLE_WORD, window, cx);\n            assert_eq!(\n                search_bar.search_options,\n                SearchOptions::REGEX,\n                ": "",
        "\n            );\n            search_bar.toggle_search_option(SearchOptions::WHOLE_WORD, window, cx);\n        });\n\n        update_search_settings(\n            SearchSettings {\n                button: true,\n                whole_word: false,\n                case_sensitive: true,\n                include_ignored: false,\n                regex: false,\n                center_on_match: false,\n            },\n            cx,\n        );\n        search_bar.update_in(cx, |search_bar, window, cx| {\n            assert_eq!(\n                search_bar.search_options,\n                SearchOptions::REGEX | SearchOptions::WHOLE_WORD,\n                ": "",
        "\n            );\n\n            search_bar.deploy(&deploy, window, cx);\n            assert_eq!(\n                search_bar.search_options,\n                SearchOptions::REGEX | SearchOptions::WHOLE_WORD,\n                ": "",
        "\n            );\n            search_bar.dismiss(&Dismiss, window, cx);\n            search_bar.deploy(&deploy, window, cx);\n            assert_eq!(\n                search_bar.configured_options,\n                SearchOptions::CASE_SENSITIVE,\n                ": "",
        "\n            );\n            assert_eq!(\n                search_bar.search_options,\n                SearchOptions::CASE_SENSITIVE,\n                ": "",
        "\n            );\n        });\n\n        update_search_settings(\n            SearchSettings {\n                button: true,\n                whole_word: true,\n                case_sensitive: true,\n                include_ignored: false,\n                regex: false,\n                center_on_match: false,\n            },\n            cx,\n        );\n\n        search_bar.update_in(cx, |search_bar, window, cx| {\n            search_bar.deploy(&deploy, window, cx);\n            search_bar.dismiss(&Dismiss, window, cx);\n            search_bar.show(window, cx);\n            assert_eq!(\n                search_bar.search_options,\n                SearchOptions::CASE_SENSITIVE | SearchOptions::WHOLE_WORD,\n                ": "",
        "\n            );\n        });\n    }\n\n    #[gpui::test]\n    async fn test_select_occurrence_case_sensitivity(cx: &mut TestAppContext) {\n        let (editor, search_bar, cx) = init_test(cx);\n        let mut editor_cx = EditorTestContext::for_editor_in(editor, cx).await;\n\n        // Start with case sensitive search settings.\n        let mut search_settings = SearchSettings::default();\n        search_settings.case_sensitive = true;\n        update_search_settings(search_settings, cx);\n        search_bar.update(cx, |search_bar, cx| {\n            let mut search_options = search_bar.search_options;\n            search_options.insert(SearchOptions::CASE_SENSITIVE);\n            search_bar.set_search_options(search_options, cx);\n        });\n\n        editor_cx.set_state(": "",
        ");\n        editor_cx.update_editor(|e, window, cx| {\n            e.select_next(&Default::default(), window, cx).unwrap();\n        });\n        editor_cx.assert_editor_state(": "",
        ");\n\n        // Update the search bar's case sensitivite toggle, so we can later\n        // confirm that `select_next` will now be case-insensitive.\n        editor_cx.set_state(": "",
        ");\n        search_bar.update_in(cx, |search_bar, window, cx| {\n            search_bar.toggle_case_sensitive(&Default::default(), window, cx);\n        });\n        editor_cx.update_editor(|e, window, cx| {\n            e.select_next(&Default::default(), window, cx).unwrap();\n        });\n        editor_cx.assert_editor_state(": "",
        ");\n\n        // Confirm that, after dismissing the search bar, only the editor's\n        // search settings actually affect the behavior of `select_next`.\n        search_bar.update_in(cx, |search_bar, window, cx| {\n            search_bar.dismiss(&Default::default(), window, cx);\n        });\n        editor_cx.set_state(": "",
        ");\n\n        // Update the editor's search settings, disabling case sensitivity, to\n        // check that the value is respected.\n        let mut search_settings = SearchSettings::default();\n        search_settings.case_sensitive = false;\n        update_search_settings(search_settings, cx);\n        editor_cx.set_state(": ""
    },
    "zed/crates/search/src/project_search.rs": {
        "Searching…": "",
        "No Results": "",
        "Search All Files": "",
        "No results found in this project for the provided query": "",
        "project-search-landing-page": "",
        "Project Search": "",
        "Project Search Opened": "",
        "save_as should not have been called": "",
        "Expand All Search Results": "",
        "Collapse All Search Results": "",
        "project-search-collapse-expand": "",
        "Search all files…": "",
        "Replace in project…": "",
        "Include: crates/**/*.toml": "",
        "Exclude: vendor/*, *.lock": "",
        "regex": "",
        "loading regex language": "",
        "Save": "",
        "Don't Save": "",
        "Cancel": "",
        "Project search buffer contains unsaved edits. Do you want to save it?": "",
        "Hit enter to search. For more options:": "",
        "filter-paths": "",
        "Include/exclude specific paths": "",
        "find-replace": "",
        "Find and replace": "",
        "Match with regex": "",
        "match-case": "",
        "Match case": "",
        "match-whole-words": "",
        "Match whole words": "",
        "query editor should be backed by a singleton buffer": "",
        "{index}/{match_quantity}+": "",
        "{index}/{match_quantity}": "",
        "0/0": "",
        "project-search-nav-button": "",
        "Select Previous Match": "",
        "Select Next Match": "",
        "matches": "",
        "Search limits reached.\\nTry narrowing your search.": "",
        "project-search-filter-button": "",
        "Toggle Filters": "",
        "project-search": "",
        "Toggle Replace": "",
        "project-search-replace-button": "",
        "Replace Next Match": "",
        "Replace All Matches": "",
        "project-search-opened-only": "",
        "Only Search Open Files": "",
        "ProjectSearchBar": "",
        "in_replace": "",
        "/dir": "",
        "one.rs": "",
        "const ONE: usize = 1;": "",
        "two.rs": "",
        "const TWO: usize = one::ONE + one::ONE;": "",
        "three.rs": "",
        "const THREE: usize = one::ONE + two::TWO;": "",
        "four.rs": "",
        "const FOUR: usize = one::ONE + three::THREE;": "",
        "TWO": "",
        "\\n\\nconst THREE: usize = one::ONE + two::TWO;\\n\\n\\nconst TWO: usize = one::ONE + one::ONE;": "",
        "Expected no search panel to be active": "",
        "Search view expected to appear after new search event trigger": "",
        "Empty search view should be focused after the toggle focus event: no results panel to focus on": "",
        "Search view should be focused after the new search view is activated": "",
        "New search query should be empty but got '{query_text}'": "",
        "Empty search view should have no results but got '{results_text}'": "",
        "sOMETHINGtHATsURELYdOESnOTeXIST": "",
        "Search view for mismatching query should have no results but got '{results_text}'": "",
        "Search view should be focused after mismatching query had been used in search": "",
        "Search view with mismatching query should be focused after the toggle focus event: still no results panel to focus on": "",
        "Search view results should match the query": "",
        "Search view with mismatching query should be focused after search results are available": "",
        "Search view with matching query should still have its results editor focused after the toggle focus event": "",
        "two": "",
        "Query should be updated to first search result after search view 2nd open in a row": "",
        "Results should be unchanged after search view 2nd open in a row": "",
        "Focus should be moved into query editor again after search view 2nd open in a row": "",
        "Search view with matching query should switch focus to the results editor after the toggle focus event": "",
        "const FOUR": "",
        "Search view for query with the only match in an excluded file should have no results but got '{results_text}'": "",
        "\\n\\nconst FOUR: usize = one::ONE + three::THREE;": "",
        "Search view results should contain the queried result in the previously excluded file with filters toggled off": "",
        "New search view should be open after `workspace::NewSearch` event": "",
        "First search view should not have an updated query": "",
        "Results of the first search view should not update too": "",
        "Focus should be moved away from the first search view": "",
        "New search view should get the query from the text cursor was at during the event spawn (first search view's first result)": "",
        "No search results should be in the 2nd view yet, as we did not spawn a search for it": "",
        "Focus should be moved into query editor of the new window": "",
        "FOUR": "",
        "New search view with the updated query should have new search results": "",
        "a": "",
        "b": "",
        "no entry for /a/ directory": "",
        "Search view expected to appear after new search in directory event trigger": "",
        "On new search in directory, focus should be moved into query editor": "",
        "New search in directory should not have any excluded files": "",
        "New search in directory should have included dir entry path": "",
        "const": "",
        "\\n\\nconst ONE: usize = 1;\\n\\n\\nconst TWO: usize = one::ONE + one::ONE;": "",
        "New search in directory should have a filter that matches a certain directory": "",
        "ONE": "",
        "THREE": "",
        "JUST_TEXT_INPUT": "",
        "TWO_NEW": "",
        "1.txt": "",
        "\\n\\n\\n\\n\\n A \\n\\n\\n\\n\\n": "",
        "2.txt": "",
        "3.rs": "",
        "4.rs": "",
        "5.rs": "",
        "6.rs": "",
        "7.rs": "",
        "8.rs": "",
        "9.rs": "",
        "a.rs": "",
        "b.rs": "",
        "\\n\\n\\n\\n\\n B \\n\\n\\n\\n\\n": "",
        "c.rs": "",
        "d.rs": "",
        "e.rs": "",
        "f.rs": "",
        "g.rs": "",
        "h.rs": "",
        "i.rs": "",
        "j.rs": "",
        "k.rs": "",
        "A": "",
        " A ": "",
        "unable to update search view": "",
        "B": "",
        " B ": "",
        "search bar query": "",
        "should open a project search view after spawning a new search": "",
        "Project search should take the query from the buffer search bar since it got focused and had a query inside": "",
        "main.rs": "",
        "fn main() { let a = 2; }\\n": "",
        ": i32": "",
        "let ": "",
        "\\n\\nfn main() { let a: i32 = 2; }\\n": "",
        "New hints should have been queried": "",
        "We did drop the previous buffer when cleared the old project search results, hence another query was made": "",
        "fn main() { let a: i32 = 2; }\\n": "",
        "Newly opened editor should have the correct text with hints": "",
        "Opening the same buffer again should reuse the cached hints": "",
        "test": "",
        "testfn main() { l: i32et a = 2; }\\n": "",
        "We have edited the buffer and should send a new request": "",
        "We have edited the buffer again and should send a new request again": "",
        "After a simulated server refresh request, we should have sent another request": "",
        "New project search should reuse the cached hints": ""
    },
    "zed/crates/search/src/search.rs": {
        "Match Whole Words": "",
        "Match Case Sensitivity": "",
        "Also search files ignored by configuration": "",
        "Use Regular Expressions": "",
        "One Match Per Line": "",
        "Search Backwards": "",
        "{self:?} is not a named SearchOption": "",
        "{self:?} is not a toggle action": "",
        "No more matches": ""
    },
    "zed/crates/semantic_version/src/semantic_version.rs": {
        "missing major version number": "",
        "missing minor version number": "",
        "missing patch version number": "",
        "Invalid version string \\\"{string}\\\"": ""
    },
    "zed/crates/settings/src/keymap_file.rs": {
        ", ": "",
        "KeymapAction": "",
        "Error loading built-in keymap \\\"{asset_path}\\\": {error_message}": "",
        "JSON parse error in built-in keymap \\\"{asset_path}\\\": {error}": "",
        "{error_message}": "",
        "JSON parse error: {error}": "",
        " Parse error in section `context` field: {}": "",
        "\\n\\n - Unrecognized fields: {}": "",
        "  ": "",
        "\\n\\n- In binding {}, {indented_err}": "",
        "Errors in user keymap file.\\n": "",
        "\\n\\nIn section without context predicate:": "",
        "\\n\\nIn section with {}:": "",
        "context = \\\"{}\\\"": "",
        "{section_errors}": "",
        "invalid keystroke {}. {}": "",
        ",\n                        MarkdownInlineCode(&action.0.to_string())\n                    ));\n                }\n                let serde_json::Value::String(ref name) = items[0] else {\n                    return Err(format!(\n                        ": "",
        ",\n                        MarkdownInlineCode(&action.0.to_string())\n                    ));\n                };\n                Some((name, Some(&items[1])))\n            }\n            Value::String(name) => Some((name, None)),\n            Value::Null => None,\n            _ => {\n                return Err(format!(\n                    ": "",
        ",\n                    MarkdownInlineCode(&action.0.to_string())\n                ));\n            }\n        };\n        Ok(name_and_input)\n    }\n\n    fn build_keymap_action(\n        action: &KeymapAction,\n        cx: &App,\n    ) -> std::result::Result<(Box<dyn Action>, Option<String>), String> {\n        let (build_result, action_input_string) = match Self::parse_action(action)? {\n            Some((name, action_input)) if name.as_str() == ActionSequence::name_for_type() => {\n                match action_input {\n                    Some(action_input) => (\n                        ActionSequence::build_sequence(action_input.clone(), cx),\n                        None,\n                    ),\n                    None => (Err(ActionSequence::expected_array_error()), None),\n                }\n            }\n            Some((name, Some(action_input))) => {\n                let action_input_string = action_input.to_string();\n                (\n                    cx.build_action(name, Some(action_input.clone())),\n                    Some(action_input_string),\n                )\n            }\n            Some((name, None)) => (cx.build_action(name, None), None),\n            None => (Ok(NoAction.boxed_clone()), None),\n        };\n\n        let action = match build_result {\n            Ok(action) => action,\n            Err(ActionBuildError::NotFound { name }) => {\n                return Err(format!(\n                    ": "",
        ",\n                    MarkdownInlineCode(&format!(": "",
        "can't build {} action from input value {}: {}": "",
        "can't build {} action - it requires input data via [name, input]: {}": "",
        "deprecationMessage": "",
        "Deprecated, use {new_name}": "",
        "description": "",
        "type": "",
        "object": "",
        "string": "",
        "const": "",
        "No action named this.": "",
        "array": "",
        "items": "",
        "minItems": "",
        "maxItems": "",
        "null": "",
        "enum": "",
        "additionalProperties": "",
        "This action does not take input - just the action name string should be used.": "",
        "oneOf": "",
        "Failed to parse keymap": "",
        "Failed to generate target action JSON value": "",
        "Failed to find keybinding to remove": "",
        "bindings": "",
        "Failed to generate source action JSON value": "",
        "context": "",
        "Failed to find keybinding to update `{:?} -> {}` creating new binding for `{:?} -> {}` instead": "",
        "Failed to serialize action value. `use_key_equivalents` on new keybinding may be incorrect.": "",
        "use_key_equivalents": "",
        "Failed to parse action arguments as JSON": "",
        "action_name: {}, context: {}, action_arguments: {}, keystrokes: {}": "",
        "global": "",
        "none": "",
        "User": "",
        "Default": "",
        "Base": "",
        "Vim": "",
        "Unknown": "",
        "error at sequence index {index}: {err}": "",
        "expected array of actions": "",
        "action::Sequence": "",
        "{} cannot be built directly": "",
        ",\n        )\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use gpui::{DummyKeyboardMapper, KeybindingKeystroke, Keystroke};\n    use unindent::Unindent;\n\n    use crate::{\n        KeybindSource, KeymapFile,\n        keymap_file::{KeybindUpdateOperation, KeybindUpdateTarget},\n    };\n\n    #[test]\n    fn can_deserialize_keymap_with_trailing_comma() {\n        let json = indoc::indoc! {": "",
        "bindings\\\": {\n                  \\\"up\\\": \\\"menu::SelectPrevious\\\",\n                },\n              },\n            ]\n                  ": "",
        "Update succeeded": "",
        "Keystrokes valid": "",
        "ctrl-a": "",
        "zed::SomeAction": "",
        "[\n                {\n                    ": "",
        ": {\n                        ": "",
        ": ": "",
        "\n                    }\n                }\n            ]": "",
        "\\\\ a": "",
        "ctrl-b": "",
        "zed::SomeOtherAction": "",
        "\n                    }\n                },\n                {\n                    ": "",
        ": [\n                            ": "",
        ",\n                            {\n                                ": "",
        "\n                            }\n                        ]\n                    }\n                }\n            ]": "",
        "Zed > Editor && some_condition = true": "",
        ",\n                    ": "",
        "a": "",
        "\\\\ b": "",
        "zed::SomeNonexistentAction": "",
        ": {\n                        // some comment\n                        ": "",
        "\n                        // some other comment\n                    }\n                }\n            ]": "",
        "\n                            }\n                        ]\n                        // some other comment\n                    }\n                }\n            ]": "",
        ",\n                        ": "",
        ",\n                    }\n                }\n            ]": "",
        "foo::bar": "",
        "SomeContext": "",
        "c": "",
        "foo::baz": "",
        "SomeOtherContext": "",
        ",\n                    }\n                },\n                {\n                    ": "",
        ",\n                    }\n                },\n            ]": "",
        ": [": "",
        ", true],\n                        ": "",
        "true": "",
        ", true],\n                    }\n                },\n                {\n                    ": "",
        ": true,\n                    ": "",
        "b": "",
        ",\n                            true\n                        ]\n                    }\n                }\n            ]": "",
        ": null\n                    }\n                }\n            ]": "",
        "\n            [\n              {\n                ": "",
        ",\n                ": "",
        ": {\n                  ": "",
        ",\n                  ": "",
        ",\n                }\n              },\n            ]\n            ": "",
        "Editor": "",
        "cmd-k cmd-l": "",
        "editor::ConvertToLowerCase": ""
    },
    "zed/crates/settings/src/settings_file.rs": {
        "empty-theme": "",
        "ui_font_family": "",
        "Courier": "",
        "ui_font_features": "",
        "ui_font_size": "",
        "ui_font_fallback": "",
        "buffer_font_family": "",
        "buffer_font_features": "",
        "buffer_font_size": "",
        "buffer_font_fallbacks": "",
        "theme": "",
        "Courier New": "",
        "languages": ""
    },
    "zed/crates/settings/src/settings_store.rs": {
        "version": "",
        "creating editorconfig parser": "",
        "parsing editorconfig sections": "",
        "unregistered setting type {}": "",
        "no default value for setting type": "",
        "wrong value type for setting": "",
        "Failed to canonicalize settings path {:?}": "",
        "Failed to write settings to file {:?}": "",
        "Failed to update settings file: {}": "",
        "overrides": "",
        "Empty settings should always be valid": "",
        "Attempted to submit tasks into the settings store": "",
        "Attempted to submit debugger config into the settings store": "",
        "type": "",
        "object": "",
        "properties": "",
        "errorMessage": "",
        "No language with this name is installed.": "",
        "string": "",
        "enum": "",
        "Failed to migrate settings": "",
        "Failed to parse settings": "",
        "{message}": "",
        "SettingsStore": "",
        "types": "",
        "default_settings": "",
        "user_settings": "",
        "local_settings": "",
        "no default value for setting {}": "",
        "{\n                    ": "",
        ": false,\n                    ": "",
        ": {\n                      ": "",
        ": ": "",
        "\n                    }\n                }": "",
        "root1": "",
        "{ ": "",
        ": 5 }": "",
        "root1/subdir": "",
        ": 50 }": "",
        "root2": "",
        ": 9, ": "",
        ": true}": "",
        "root1/something": "",
        "root1/subdir/something": "",
        "root2/something": "",
        ": false }": "",
        "{\n                ": "",
        ": {\n                    ": "",
        ": {\n                        ": "",
        ": true\n                    }\n                }\n            }": "",
        "JSON": "",
        ": true\n                    },\n                    ": "",
        ": false\n                    }\n                }\n            }": "",
        ":   { ": "",
        ", ": "",
        "  }\n                }": "",
        ": 1, ": "",
        ": 2 }": "",
        ": true, ": "",
        ": {}\n            }": "",
        "\n                }\n            }": "",
        "{\n              ": "",
        ": {\n                ": "",
        ": true\n              }\n            }\n            ": "",
        "{\n            }\n            ": "",
        " { ": "",
        ": 37 } ": "",
        ",\n              ": "",
        ": 37\n            }\n            ": "",
        ": 99,\n            }\n            ": "",
        ": 42 }": "",
        ",\n                ": "",
        ": 42,\n                ": "",
        ": 99,\n                ": "",
        ": 42\n            }\n            ": "",
        ": true }": "",
        ": true\n              },\n              ": "",
        " }": "",
        ": [\n                ": "",
        "\n              ],\n              ": "",
        "\n            }\n            ": "",
        ": {\n                  ": "",
        ": true\n                }\n              }\n            }\n            ": "",
        ",\n                        ": "",
        ": true,\n                    }\n                }": "",
        ": 0}": "",
        ": 80}": "",
        "child1": "",
        "child2": "",
        ": 1}": "",
        ": 2}": "",
        "adjacent_child": "",
        ": 3}": "",
        "subdir": "",
        ": 100}": "",
        ": 120}": "",
        ": 90}": "",
        "child1/subdir": "",
        ": 140}": ""
    },
    "zed/crates/settings_ui/src/page_data.rs": {
        "NO DEFAULT": "",
        "General": "",
        "General Settings": "",
        "Project Name": "",
        "The displayed name of this project. If left empty, the root directory name will be displayed.": "",
        "project_name": "",
        "When Closing With No Tabs": "",
        "What to do when using the 'close active item' action with no tabs.": "",
        "when_closing_with_no_tabs": "",
        "On Last Window Closed": "",
        "What to do when the last window is closed.": "",
        "on_last_window_closed": "",
        "Use System Path Prompts": "",
        "Use native OS dialogs for 'Open' and 'Save As'.": "",
        "use_system_path_prompts": "",
        "Use System Prompts": "",
        "Use native OS dialogs for confirmations.": "",
        "use_system_prompts": "",
        "Redact Private Values": "",
        "Hide the values of variables in private files.": "",
        "redact_private_values": "",
        "Private Files": "",
        "Globs to match against file paths to determine if a file is private.": "",
        "worktree.private_files": "",
        "Workspace Restoration": "",
        "Restore Unsaved Buffers": "",
        "Whether or not to restore unsaved buffers on restart.": "",
        "session.restore_unsaved_buffers": "",
        "Restore On Startup": "",
        "What to restore from the previous session when opening Zed.": "",
        "restore_on_startup": "",
        "Scoped Settings": "",
        "Preview Channel": "",
        "Which settings should be activated only in Preview build of Zed.": "",
        "preview_channel_settings": "",
        "Settings Profiles": "",
        "Any number of settings profiles that are temporarily applied on top of your existing user settings.": "",
        "settings_profiles": "",
        "Privacy": "",
        "Telemetry Diagnostics": "",
        "Send debug information like crash reports.": "",
        "telemetry.diagnostics": "",
        "Telemetry Metrics": "",
        "Send anonymized usage data like what languages you're using Zed with.": "",
        "telemetry.metrics": "",
        "Auto Update": "",
        "Whether or not to automatically check for updates.": "",
        "auto_update": "",
        "Appearance": "",
        "Theme": "",
        "Theme Mode": "",
        "Choose a static, fixed theme or dynamically select themes based on appearance and light/dark modes.": "",
        "theme$": "",
        "Theme Name": "",
        "The name of your selected theme.": "",
        "theme": "",
        "Mode": "",
        "Choose whether to use the selected light or dark theme or to follow your OS appearance configuration.": "",
        "theme.mode": "",
        "Light Theme": "",
        "The theme to use when mode is set to light, or when mode is set to system and it is in light mode.": "",
        "theme.light": "",
        "Dark Theme": "",
        "The theme to use when mode is set to dark, or when mode is set to system and it is in dark mode.": "",
        "theme.dark": "",
        "Icon Theme": "",
        "The custom set of icons Zed will associate with files and directories.": "",
        "icon_theme$": "",
        "Icon Theme Name": "",
        "The name of your selected icon theme.": "",
        "icon_theme$string": "",
        "Choose whether to use the selected light or dark icon theme or to follow your OS appearance configuration.": "",
        "icon_theme": "",
        "Light Icon Theme": "",
        "The icon theme to use when mode is set to light, or when mode is set to system and it is in light mode.": "",
        "icon_theme.light": "",
        "Dark Icon Theme": "",
        "The icon theme to use when mode is set to dark, or when mode is set to system and it is in dark mode.": "",
        "icon_theme.dark": "",
        "Buffer Font": "",
        "Font Family": "",
        "Font family for editor text.": "",
        "buffer_font_family": "",
        "Font Size": "",
        "Font size for editor text.": "",
        "buffer_font_size": "",
        "Font Weight": "",
        "Font weight for editor text (100-900).": "",
        "buffer_font_weight": "",
        "Line Height": "",
        "Line height for editor text.": "",
        "buffer_line_height$": "",
        "Custom Line Height": "",
        "Custom line height value (must be at least 1.0).": "",
        "buffer_line_height": "",
        "Font Features": "",
        "The OpenType features to enable for rendering in text buffers.": "",
        "buffer_font_features": "",
        "Font Fallbacks": "",
        "The font fallbacks to use for rendering in text buffers.": "",
        "buffer_font_fallbacks": "",
        "UI Font": "",
        "Font family for UI elements.": "",
        "ui_font_family": "",
        "Font size for UI elements.": "",
        "ui_font_size": "",
        "Font weight for UI elements (100-900).": "",
        "ui_font_weight": "",
        "The OpenType features to enable for rendering in UI elements.": "",
        "ui_font_features": "",
        "The font fallbacks to use for rendering in the UI.": "",
        "ui_font_fallbacks": "",
        "Agent Panel Font": "",
        "UI Font Size": "",
        "Font size for agent response text in the agent panel. Falls back to the regular UI font size.": "",
        "agent_ui_font_size": "",
        "Buffer Font Size": "",
        "Font size for user messages text in the agent panel.": "",
        "agent_buffer_font_size": "",
        "Cursor": "",
        "Multi Cursor Modifier": "",
        "Modifier key for adding multiple cursors.": "",
        "multi_cursor_modifier": "",
        "Cursor Blink": "",
        "Whether the cursor blinks in the editor.": "",
        "cursor_blink": "",
        "Cursor Shape": "",
        "Cursor shape for the editor.": "",
        "cursor_shape": "",
        "Hide Mouse": "",
        "When to hide the mouse cursor.": "",
        "hide_mouse": "",
        "Highlighting": "",
        "Unnecessary Code Fade": "",
        "How much to fade out unused code (0.0 - 0.9).": "",
        "unnecessary_code_fade": "",
        "Current Line Highlight": "",
        "How to highlight the current line.": "",
        "current_line_highlight": "",
        "Selection Highlight": "",
        "Highlight all occurrences of selected text.": "",
        "selection_highlight": "",
        "Rounded Selection": "",
        "Whether the text selection should have rounded corners.": "",
        "rounded_selection": "",
        "Minimum Contrast For Highlights": "",
        "The minimum APCA perceptual contrast to maintain when rendering text over highlight backgrounds.": "",
        "minimum_contrast_for_highlights": "",
        "Guides": "",
        "Show Wrap Guides": "",
        "Show wrap guides (vertical rulers).": "",
        "show_wrap_guides": "",
        "Wrap Guides": "",
        "Character counts at which to show wrap guides.": "",
        "wrap_guides": "",
        "Keymap": "",
        "Base Keymap": "",
        "The name of a base set of key bindings to use.": "",
        "base_keymap": "",
        "Modal Editing": "",
        "Vim Mode": "",
        "Enable Vim mode and key bindings.": "",
        "vim_mode": "",
        "Helix Mode": "",
        "Enable Helix mode and key bindings.": "",
        "helix_mode": "",
        "Editor": "",
        "Auto Save": "",
        "Auto Save Mode": "",
        "When to auto save buffer changes.": "",
        "autosave$": "",
        "Delay (milliseconds)": "",
        "Save after inactivity period (in milliseconds).": "",
        "autosave.after_delay.milliseconds": "",
        "Multibuffer": "",
        "Double Click In Multibuffer": "",
        "What to do when multibuffer is double-clicked in some of its excerpts.": "",
        "double_click_in_multibuffer": "",
        "Expand Excerpt Lines": "",
        "How many lines to expand the multibuffer excerpts by default.": "",
        "expand_excerpt_lines": "",
        "Excerpt Context Lines": "",
        "How many lines of context to provide in multibuffer excerpts by default.": "",
        "excerpt_context_lines": "",
        "Expand Outlines With Depth": "",
        "Default depth to expand outline items in the current file.": "",
        "outline_panel.expand_outlines_with_depth": "",
        "Scrolling": "",
        "Scroll Beyond Last Line": "",
        "Whether the editor will scroll beyond the last line.": "",
        "scroll_beyond_last_line": "",
        "Vertical Scroll Margin": "",
        "The number of lines to keep above/below the cursor when auto-scrolling.": "",
        "vertical_scroll_margin": "",
        "Horizontal Scroll Margin": "",
        "The number of characters to keep on either side when scrolling with the mouse.": "",
        "horizontal_scroll_margin": "",
        "Scroll Sensitivity": "",
        "Scroll sensitivity multiplier for both horizontal and vertical scrolling.": "",
        "scroll_sensitivity": "",
        "Fast Scroll Sensitivity": "",
        "Fast scroll sensitivity multiplier for both horizontal and vertical scrolling.": "",
        "fast_scroll_sensitivity": "",
        "Autoscroll On Clicks": "",
        "Whether to scroll when clicking near the edge of the visible text area.": "",
        "autoscroll_on_clicks": "",
        "Sticky Scroll": "",
        "Whether to stick scopes to the top of the editor": "",
        "sticky_scroll.enabled": "",
        "Signature Help": "",
        "Auto Signature Help": "",
        "Automatically show a signature help pop-up.": "",
        "auto_signature_help": "",
        "Show Signature Help After Edits": "",
        "Show the signature help pop-up after completions or bracket pairs are inserted.": "",
        "show_signature_help_after_edits": "",
        "Snippet Sort Order": "",
        "Determines how snippets are sorted relative to other completion items.": "",
        "snippet_sort_order": "",
        "Hover Popover": "",
        "Enabled": "",
        "Show the informational hover box when moving the mouse over symbols in the editor.": "",
        "hover_popover_enabled": "",
        "Delay": "",
        "Time to wait in milliseconds before showing the informational hover box.": "",
        "Drag And Drop Selection": "",
        "Enable drag and drop selection.": "",
        "drag_and_drop_selection.enabled": "",
        "Delay in milliseconds before drag and drop selection starts.": "",
        "drag_and_drop_selection.delay": "",
        "Gutter": "",
        "Show Line Numbers": "",
        "Show line numbers in the gutter.": "",
        "gutter.line_numbers": "",
        "Relative Line Numbers": "",
        "Controls line number display in the editor's gutter. \\\"disabled\\\" shows absolute line numbers, \\\"enabled\\\" shows relative line numbers for each absolute line, and \\\"wrapped\\\" shows relative line numbers for every line, absolute or wrapped.": "",
        "relative_line_numbers": "",
        "Show Runnables": "",
        "Show runnable buttons in the gutter.": "",
        "gutter.runnables": "",
        "Show Breakpoints": "",
        "Show breakpoints in the gutter.": "",
        "gutter.breakpoints": "",
        "Show Folds": "",
        "Show code folding controls in the gutter.": "",
        "gutter.folds": "",
        "Min Line Number Digits": "",
        "Minimum number of characters to reserve space for in the gutter.": "",
        "gutter.min_line_number_digits": "",
        "Inline Code Actions": "",
        "Show code action button at start of buffer line.": "",
        "inline_code_actions": "",
        "Scrollbar": "",
        "Show": "",
        "When to show the scrollbar in the editor.": "",
        "scrollbar": "",
        "Cursors": "",
        "Show cursor positions in the scrollbar.": "",
        "scrollbar.cursors": "",
        "Git Diff": "",
        "Show Git diff indicators in the scrollbar.": "",
        "scrollbar.git_diff": "",
        "Search Results": "",
        "Show buffer search result indicators in the scrollbar.": "",
        "scrollbar.search_results": "",
        "Selected Text": "",
        "Show selected text occurrences in the scrollbar.": "",
        "scrollbar.selected_text": "",
        "Selected Symbol": "",
        "Show selected symbol occurrences in the scrollbar.": "",
        "scrollbar.selected_symbol": "",
        "Diagnostics": "",
        "Which diagnostic indicators to show in the scrollbar.": "",
        "scrollbar.diagnostics": "",
        "Horizontal Scrollbar": "",
        "When false, forcefully disables the horizontal scrollbar.": "",
        "scrollbar.axes.horizontal": "",
        "Vertical Scrollbar": "",
        "When false, forcefully disables the vertical scrollbar.": "",
        "scrollbar.axes.vertical": "",
        "Minimap": "",
        "When to show the minimap in the editor.": "",
        "minimap.show": "",
        "Display In": "",
        "Where to show the minimap in the editor.": "",
        "minimap.display_in": "",
        "Thumb": "",
        "When to show the minimap thumb.": "",
        "minimap.thumb": "",
        "Thumb Border": "",
        "Border style for the minimap's scrollbar thumb.": "",
        "minimap.thumb_border": "",
        "How to highlight the current line in the minimap.": "",
        "minimap.current_line_highlight": "",
        "Max Width Columns": "",
        "Maximum number of columns to display in the minimap.": "",
        "minimap.max_width_columns": "",
        "Toolbar": "",
        "Breadcrumbs": "",
        "Show breadcrumbs.": "",
        "toolbar.breadcrumbs": "",
        "Quick Actions": "",
        "Show quick action buttons (e.g., search, selection, editor controls, etc.).": "",
        "toolbar.quick_actions": "",
        "Selections Menu": "",
        "Show the selections menu in the editor toolbar.": "",
        "toolbar.selections_menu": "",
        "Agent Review": "",
        "Show agent review buttons in the editor toolbar.": "",
        "toolbar.agent_review": "",
        "Code Actions": "",
        "Show code action buttons in the editor toolbar.": "",
        "toolbar.code_actions": "",
        "Languages & Tools": "",
        "File Types": "",
        "File Type Associations": "",
        "A mapping from languages to files and file extensions that should be treated as that language.": "",
        "file_type_associations": "",
        "Max Severity": "",
        "Which level to use to filter out diagnostics displayed in the editor.": "",
        "diagnostics_max_severity": "",
        "Include Warnings": "",
        "Whether to show warnings or not by default.": "",
        "diagnostics.include_warnings": "",
        "Inline Diagnostics": "",
        "Whether to show diagnostics inline or not.": "",
        "diagnostics.inline.enabled": "",
        "Update Debounce": "",
        "The delay in milliseconds to show inline diagnostics after the last diagnostic update.": "",
        "diagnostics.inline.update_debounce_ms": "",
        "Padding": "",
        "The amount of padding between the end of the source line and the start of the inline diagnostic.": "",
        "diagnostics.inline.padding": "",
        "Minimum Column": "",
        "The minimum column at which to display inline diagnostics.": "",
        "diagnostics.inline.min_column": "",
        "LSP Pull Diagnostics": "",
        "Whether to pull for language server-powered diagnostics or not.": "",
        "diagnostics.lsp_pull_diagnostics.enabled": "",
        "Debounce": "",
        "Minimum time to wait before pulling diagnostics from the language server(s).": "",
        "diagnostics.lsp_pull_diagnostics.debounce_ms": "",
        "LSP Highlights": "",
        "The debounce delay before querying highlights from the language.": "",
        "lsp_highlight_debounce": "",
        "Search & Files": "",
        "Search": "",
        "Whole Word": "",
        "Search for whole words by default.": "",
        "search.whole_word": "",
        "Case Sensitive": "",
        "Search case-sensitively by default.": "",
        "search.case_sensitive": "",
        "Use Smartcase Search": "",
        "Whether to automatically enable case-sensitive search based on the search query.": "",
        "use_smartcase_search": "",
        "Include Ignored": "",
        "Include ignored files in search results by default.": "",
        "search.include_ignored": "",
        "Regex": "",
        "Use regex search by default.": "",
        "search.regex": "",
        "Search Wrap": "",
        "Whether the editor search results will loop.": "",
        "search_wrap": "",
        "Center on Match": "",
        "Whether to center the current match in the editor": "",
        "editor.search.center_on_match": "",
        "Seed Search Query From Cursor": "",
        "When to populate a new search's query based on the text under the cursor.": "",
        "seed_search_query_from_cursor": "",
        "File Finder": "",
        "Include Ignored in Search": "",
        "Use gitignored files when searching.": "",
        "file_finder.include_ignored": "",
        "File Icons": "",
        "Show file icons in the file finder.": "",
        "file_finder.file_icons": "",
        "Modal Max Width": "",
        "Determines how much space the file finder can take up in relation to the available window width.": "",
        "file_finder.modal_max_width": "",
        "Skip Focus For Active In Search": "",
        "Whether the file finder should skip focus for the active file in search results.": "",
        "file_finder.skip_focus_for_active_in_search": "",
        "Git Status": "",
        "Show the Git status in the file finder.": "",
        "file_finder.git_status": "",
        "File Scan": "",
        "File Scan Exclusions": "",
        "Files or globs of files that will be excluded by Zed entirely. They will be skipped during file scans, file searches, and not be displayed in the project file tree. Takes precedence over \\\"File Scan Inclusions\\\"": "",
        "file_scan_exclusions": "",
        "File Scan Inclusions": "",
        "Files or globs of files that will be included by Zed, even when ignored by git. This is useful for files that are not tracked by git, but are still important to your project. Note that globs that are overly broad can slow down Zed's file scanning. \\\"File Scan Exclusions\\\" takes precedence over these inclusions": "",
        "file_scan_inclusions": "",
        "Restore File State": "",
        "Restore previous file state when reopening.": "",
        "restore_on_file_reopen": "",
        "Close on File Delete": "",
        "Automatically close files that have been deleted.": "",
        "close_on_file_delete": "",
        "Window & Layout": "",
        "Status Bar": "",
        "Project Panel Button": "",
        "Show the project panel button in the status bar.": "",
        "project_panel.button": "",
        "Active Language Button": "",
        "Show the active language button in the status bar.": "",
        "status_bar.active_language_button": "",
        "Cursor Position Button": "",
        "Show the cursor position button in the status bar.": "",
        "status_bar.cursor_position_button": "",
        "Terminal Button": "",
        "Show the terminal button in the status bar.": "",
        "terminal.button": "",
        "Diagnostics Button": "",
        "Show the project diagnostics button in the status bar.": "",
        "diagnostics.button": "",
        "Project Search Button": "",
        "Show the project search button in the status bar.": "",
        "search.button": "",
        "Debugger Button": "",
        "Show the debugger button in the status bar.": "",
        "debugger.button": "",
        "Title Bar": "",
        "Show Branch Icon": "",
        "Show the branch icon beside branch switcher in the titlebar.": "",
        "title_bar.show_branch_icon": "",
        "Show Branch Name": "",
        "Show the branch name button in the titlebar.": "",
        "title_bar.show_branch_name": "",
        "Show Project Items": "",
        "Show the project host and name in the titlebar.": "",
        "title_bar.show_project_items": "",
        "Show Onboarding Banner": "",
        "Show banners announcing new features in the titlebar.": "",
        "title_bar.show_onboarding_banner": "",
        "Show User Picture": "",
        "Show user picture in the titlebar.": "",
        "title_bar.show_user_picture": "",
        "Show Sign In": "",
        "Show the sign in button in the titlebar.": "",
        "title_bar.show_sign_in": "",
        "Show Menus": "",
        "Show the menus in the titlebar.": "",
        "title_bar.show_menus": "",
        "Tab Bar": "",
        "Show Tab Bar": "",
        "Show the tab bar in the editor.": "",
        "tab_bar.show": "",
        "Show Git Status In Tabs": "",
        "Show the Git file status on a tab item.": "",
        "tabs.git_status": "",
        "Show File Icons In Tabs": "",
        "Show the file icon for a tab.": "",
        "tabs.file_icons": "",
        "Tab Close Position": "",
        "Position of the close button in a tab.": "",
        "tabs.close_position": "",
        "Maximum Tabs": "",
        "Maximum open tabs in a pane. Will not close an unsaved tab.": "",
        "max_tabs": "",
        "Show Navigation History Buttons": "",
        "Show the navigation history buttons in the tab bar.": "",
        "tab_bar.show_nav_history_buttons": "",
        "Tab Settings": "",
        "Activate On Close": "",
        "What to do after closing the current tab.": "",
        "tabs.activate_on_close": "",
        "Tab Show Diagnostics": "",
        "Which files containing diagnostic errors/warnings to mark in the tabs.": "",
        "tabs.show_diagnostics": "",
        "Show Close Button": "",
        "Controls the appearance behavior of the tab's close button.": "",
        "tabs.show_close_button": "",
        "Preview Tabs": "",
        "Preview Tabs Enabled": "",
        "Show opened editors as Preview tabs.": "",
        "preview_tabs.enabled": "",
        "Enable Preview From File Finder": "",
        "Whether to open tabs in Preview mode when selected from the file finder.": "",
        "preview_tabs.enable_preview_from_file_finder": "",
        "Enable Preview From Code Navigation": "",
        "Whether a preview tab gets replaced when code navigation is used to navigate away from the tab.": "",
        "preview_tabs.enable_preview_from_code_navigation": "",
        "Layout": "",
        "Bottom Dock Layout": "",
        "Layout mode for the bottom dock.": "",
        "bottom_dock_layout": "",
        "Centered Layout Left Padding": "",
        "Left padding for centered layout.": "",
        "centered_layout.left_padding": "",
        "Centered Layout Right Padding": "",
        "Right padding for centered layout.": "",
        "centered_layout.right_padding": "",
        "Window": "",
        "Use System Window Tabs": "",
        "(macOS only) whether to allow Windows to tab together.": "",
        "use_system_window_tabs": "",
        "Pane Modifiers": "",
        "Inactive Opacity": "",
        "Opacity of inactive panels (0.0 - 1.0).": "",
        "active_pane_modifiers.inactive_opacity": "",
        "Border Size": "",
        "Size of the border surrounding the active pane.": "",
        "active_pane_modifiers.border_size": "",
        "Zoomed Padding": "",
        "Show padding for zoomed panes.": "",
        "zoomed_padding": "",
        "Pane Split Direction": "",
        "Vertical Split Direction": "",
        "Direction to split vertically.": "",
        "pane_split_direction_vertical": "",
        "Horizontal Split Direction": "",
        "Direction to split horizontally.": "",
        "pane_split_direction_horizontal": "",
        "Panels": "",
        "Project Panel": "",
        "Project Panel Dock": "",
        "Where to dock the project panel.": "",
        "project_panel.dock": "",
        "Project Panel Default Width": "",
        "Default width of the project panel in pixels.": "",
        "project_panel.default_width": "",
        "Hide .gitignore": "",
        "Whether to hide the gitignore entries in the project panel.": "",
        "project_panel.hide_gitignore": "",
        "Entry Spacing": "",
        "Spacing between worktree entries in the project panel.": "",
        "project_panel.entry_spacing": "",
        "Show file icons in the project panel.": "",
        "project_panel.file_icons": "",
        "Folder Icons": "",
        "Whether to show folder icons or chevrons for directories in the project panel.": "",
        "project_panel.folder_icons": "",
        "Show the Git status in the project panel.": "",
        "project_panel.git_status": "",
        "Indent Size": "",
        "Amount of indentation for nested items.": "",
        "project_panel.indent_size": "",
        "Auto Reveal Entries": "",
        "Whether to reveal entries in the project panel automatically when a corresponding project entry becomes active.": "",
        "project_panel.auto_reveal_entries": "",
        "Starts Open": "",
        "Whether the project panel should open on startup.": "",
        "project_panel.starts_open": "",
        "Auto Fold Directories": "",
        "Whether to fold directories automatically and show compact folders when a directory has only one subdirectory inside.": "",
        "project_panel.auto_fold_dirs": "",
        "Show Scrollbar": "",
        "Show the scrollbar in the project panel.": "",
        "project_panel.scrollbar.show": "",
        "Show Diagnostics": "",
        "Which files containing diagnostic errors/warnings to mark in the project panel.": "",
        "project_panel.show_diagnostics": "",
        "Whether to stick parent directories at top of the project panel.": "",
        "project_panel.sticky_scroll": "",
        "Show Indent Guides": "",
        "Show indent guides in the project panel.": "",
        "project_panel.indent_guides.show": "",
        "Drag and Drop": "",
        "Whether to enable drag-and-drop operations in the project panel.": "",
        "project_panel.drag_and_drop": "",
        "Hide Root": "",
        "Whether to hide the root entry when only one folder is open in the window.": "",
        "Hide Hidden": "",
        "Whether to hide the hidden entries in the project panel.": "",
        "project_panel.hide_hidden": "",
        "Hidden Files": "",
        "Globs to match files that will be considered \\\"hidden\\\" and can be hidden from the project panel.": "",
        "worktree.hidden_files": "",
        "Open File on Paste": "",
        "Whether to automatically open files when pasting them in the project panel.": "",
        "project_panel.open_file_on_paste": "",
        "Terminal Panel": "",
        "Terminal Dock": "",
        "Where to dock the terminal panel.": "",
        "terminal.dock": "",
        "Outline Panel": "",
        "Outline Panel Button": "",
        "Show the outline panel button in the status bar.": "",
        "outline_panel.button": "",
        "Outline Panel Dock": "",
        "Where to dock the outline panel.": "",
        "outline_panel.dock": "",
        "Outline Panel Default Width": "",
        "Default width of the outline panel in pixels.": "",
        "outline_panel.default_width": "",
        "Show file icons in the outline panel.": "",
        "outline_panel.file_icons": "",
        "Whether to show folder icons or chevrons for directories in the outline panel.": "",
        "outline_panel.folder_icons": "",
        "Show the Git status in the outline panel.": "",
        "outline_panel.git_status": "",
        "outline_panel.indent_size": "",
        "Whether to reveal when a corresponding outline entry becomes active.": "",
        "outline_panel.auto_reveal_entries": "",
        "Whether to fold directories automatically when a directory contains only one subdirectory.": "",
        "outline_panel.auto_fold_dirs": "",
        "When to show indent guides in the outline panel.": "",
        "outline_panel.indent_guides.show": "",
        "Git Panel": "",
        "Git Panel Button": "",
        "Show the Git panel button in the status bar.": "",
        "git_panel.button": "",
        "Git Panel Dock": "",
        "Where to dock the Git panel.": "",
        "git_panel.dock": "",
        "Git Panel Default Width": "",
        "Default width of the Git panel in pixels.": "",
        "git_panel.default_width": "",
        "Git Panel Status Style": "",
        "How entry statuses are displayed.": "",
        "git_panel.status_style": "",
        "Fallback Branch Name": "",
        "Default branch name will be when init.defaultbranch is not set in Git.": "",
        "git_panel.fallback_branch_name": "",
        "Sort By Path": "",
        "Enable to sort entries in the panel by path, disable to sort by status.": "",
        "git_panel.sort_by_path": "",
        "Collapse Untracked Diff": "",
        "Whether to collapse untracked files in the diff panel.": "",
        "git_panel.collapse_untracked_diff": "",
        "Scroll Bar": "",
        "How and when the scrollbar should be displayed.": "",
        "git_panel.scrollbar.show": "",
        "Debugger Panel": "",
        "Debugger Panel Dock": "",
        "The dock position of the debug panel.": "",
        "debugger.dock": "",
        "Notification Panel": "",
        "Notification Panel Button": "",
        "Show the notification panel button in the status bar.": "",
        "notification_panel.button": "",
        "Notification Panel Dock": "",
        "Where to dock the notification panel.": "",
        "notification_panel.dock": "",
        "Notification Panel Default Width": "",
        "Default width of the notification panel in pixels.": "",
        "notification_panel.default_width": "",
        "Collaboration Panel": "",
        "Collaboration Panel Button": "",
        "Show the collaboration panel button in the status bar.": "",
        "collaboration_panel.button": "",
        "Collaboration Panel Dock": "",
        "Where to dock the collaboration panel.": "",
        "collaboration_panel.dock": "",
        "Collaboration Panel Default Width": "",
        "Default width of the collaboration panel in pixels.": "",
        "Agent Panel": "",
        "Agent Panel Button": "",
        "Whether to show the agent panel button in the status bar.": "",
        "agent.button": "",
        "Agent Panel Dock": "",
        "Where to dock the agent panel.": "",
        "agent.dock": "",
        "Agent Panel Default Width": "",
        "Default width when the agent panel is docked to the left or right.": "",
        "agent.default_width": "",
        "Agent Panel Default Height": "",
        "Default height when the agent panel is docked to the bottom.": "",
        "agent.default_height": "",
        "Debugger": "",
        "Stepping Granularity": "",
        "Determines the stepping granularity for debug operations.": "",
        "Save Breakpoints": "",
        "Whether breakpoints should be reused across Zed sessions.": "",
        "debugger.save_breakpoints": "",
        "Timeout": "",
        "Time in milliseconds until timeout error when connecting to a TCP debug adapter.": "",
        "debugger.timeout": "",
        "Log DAP Communications": "",
        "Whether to log messages between active debug adapters and Zed.": "",
        "debugger.log_dap_communications": "",
        "Format DAP Log Messages": "",
        "Whether to format DAP messages when adding them to debug adapter logger.": "",
        "debugger.format_dap_log_messages": "",
        "Terminal": "",
        "Environment": "",
        "Shell": "",
        "What shell to use when opening a terminal.": "",
        "terminal.shell$": "",
        "sh": "",
        "Program": "",
        "The shell program to use.": "",
        "terminal.shell": "",
        "The shell program to run.": "",
        "terminal.shell.program": "",
        "Arguments": "",
        "The arguments to pass to the shell program.": "",
        "terminal.shell.args": "",
        "Title Override": "",
        "An optional string to override the title of the terminal tab.": "",
        "terminal.shell.title_override": "",
        "Working Directory": "",
        "What working directory to use when launching the terminal.": "",
        "terminal.working_directory$": "",
        "Directory": "",
        "The directory path to use (will be shell expanded).": "",
        "terminal.working_directory.always": "",
        "Environment Variables": "",
        "Key-value pairs to add to the terminal's environment.": "",
        "terminal.env": "",
        "Detect Virtual Environment": "",
        "Activates the Python virtual environment, if one is found, in the terminal's working directory.": "",
        "terminal.detect_venv": "",
        "Font": "",
        "Font size for terminal text. If not set, defaults to buffer font size.": "",
        "terminal.font_size": "",
        "Font family for terminal text. If not set, defaults to buffer font family.": "",
        "terminal.font_family": "",
        "Font fallbacks for terminal text. If not set, defaults to buffer font fallbacks.": "",
        "terminal.font_fallbacks": "",
        "Font weight for terminal text in CSS weight units (100-900).": "",
        "terminal.font_weight": "",
        "Font features for terminal text.": "",
        "terminal.font_features": "",
        "Display Settings": "",
        "Line height for terminal text.": "",
        "terminal.line_height": "",
        "Default cursor shape for the terminal (bar, block, underline, or hollow).": "",
        "terminal.cursor_shape": "",
        "Cursor Blinking": "",
        "Sets the cursor blinking behavior in the terminal.": "",
        "terminal.blinking": "",
        "Alternate Scroll": "",
        "Whether alternate scroll mode is active by default (converts mouse scroll to arrow keys in apps like Vim).": "",
        "terminal.alternate_scroll": "",
        "Minimum Contrast": "",
        "The minimum APCA perceptual contrast between foreground and background colors (0-106).": "",
        "terminal.minimum_contrast": "",
        "Behavior Settings": "",
        "Option As Meta": "",
        "Whether the option key behaves as the meta key.": "",
        "terminal.option_as_meta": "",
        "Copy On Select": "",
        "Whether selecting text in the terminal automatically copies to the system clipboard.": "",
        "terminal.copy_on_select": "",
        "Keep Selection On Copy": "",
        "Whether to keep the text selection after copying it to the clipboard.": "",
        "terminal.keep_selection_on_copy": "",
        "Layout Settings": "",
        "Default Width": "",
        "Default width when the terminal is docked to the left or right (in pixels).": "",
        "terminal.default_width": "",
        "Default Height": "",
        "Default height when the terminal is docked to the bottom (in pixels).": "",
        "terminal.default_height": "",
        "Advanced Settings": "",
        "Max Scroll History Lines": "",
        "Maximum number of lines to keep in scrollback history (max: 100,000; 0 disables scrolling).": "",
        "terminal.max_scroll_history_lines": "",
        "Display the terminal title in breadcrumbs inside the terminal pane.": "",
        "terminal.toolbar.breadcrumbs": "",
        "When to show the scrollbar in the terminal.": "",
        "terminal.scrollbar.show": "",
        "Version Control": "",
        "Git Gutter": "",
        "Visibility": "",
        "Control whether Git status is shown in the editor's gutter.": "",
        "git.git_gutter": "",
        "Debounce threshold in milliseconds after which changes are reflected in the Git gutter.": "",
        "git.gutter_debounce": "",
        "Inline Git Blame": "",
        "Whether or not to show Git blame data inline in the currently focused line.": "",
        "git.inline_blame.enabled": "",
        "The delay after which the inline blame information is shown.": "",
        "git.inline_blame.delay_ms": "",
        "Padding between the end of the source line and the start of the inline blame in columns.": "",
        "git.inline_blame.padding": "",
        "The minimum column number at which to show the inline blame information.": "",
        "git.inline_blame.min_column": "",
        "Show Commit Summary": "",
        "Show commit summary as part of the inline blame.": "",
        "git.inline_blame.show_commit_summary": "",
        "Git Blame View": "",
        "Show Avatar": "",
        "Show the avatar of the author of the commit.": "",
        "git.blame.show_avatar": "",
        "Branch Picker": "",
        "Show Author Name": "",
        "Show author name as part of the commit information in branch picker.": "",
        "git.branch_picker.show_author_name": "",
        "Git Hunks": "",
        "Hunk Style": "",
        "How Git hunks are displayed visually in the editor.": "",
        "git.hunk_style": "",
        "Collaboration": "",
        "Calls": "",
        "Mute On Join": "",
        "Whether the microphone should be muted when joining a channel or a call.": "",
        "calls.mute_on_join": "",
        "Share On Join": "",
        "Whether your current project should be shared when joining an empty channel.": "",
        "calls.share_on_join": "",
        "Experimental": "",
        "Rodio Audio": "",
        "Opt into the new audio system.": "",
        "audio.experimental.rodio_audio": "",
        "Auto Microphone Volume": "",
        "Automatically adjust microphone volume (requires rodio audio).": "",
        "audio.experimental.auto_microphone_volume": "",
        "Auto Speaker Volume": "",
        "Automatically adjust volume of other call members (requires rodio audio).": "",
        "audio.experimental.auto_speaker_volume": "",
        "Denoise": "",
        "Remove background noises (requires rodio audio).": "",
        "audio.experimental.denoise": "",
        "Legacy Audio Compatible": "",
        "Use audio parameters compatible with previous versions (requires rodio audio).": "",
        "audio.experimental.legacy_audio_compatible": "",
        "AI": "",
        "Disable AI": "",
        "Whether to disable all AI features in Zed.": "",
        "disable_ai": "",
        "Agent Configuration": "",
        "Always Allow Tool Actions": "",
        "When enabled, the agent can run potentially destructive actions without asking for your confirmation. This setting has no effect on external agents.": "",
        "agent.always_allow_tool_actions": "",
        "Single File Review": "",
        "When enabled, agent edits will also be displayed in single-file buffers for review.": "",
        "agent.single_file_review": "",
        "Enable Feedback": "",
        "Show voting thumbs up/down icon buttons for feedback on agent edits.": "",
        "agent.enable_feedback": "",
        "Notify When Agent Waiting": "",
        "Where to show notifications when the agent has completed its response or needs confirmation before running a tool action.": "",
        "agent.notify_when_agent_waiting": "",
        "Play Sound When Agent Done": "",
        "Whether to play a sound when the agent has either completed its response, or needs user input.": "",
        "agent.play_sound_when_agent_done": "",
        "Expand Edit Card": "",
        "Whether to have edit cards in the agent panel expanded, showing a Preview of the diff.": "",
        "agent.expand_edit_card": "",
        "Expand Terminal Card": "",
        "Whether to have terminal cards in the agent panel expanded, showing the whole command output.": "",
        "agent.expand_terminal_card": "",
        "Use Modifier To Send": "",
        "Whether to always use cmd-enter (or ctrl-enter on Linux or Windows) to send messages.": "",
        "agent.use_modifier_to_send": "",
        "Message Editor Min Lines": "",
        "Minimum number of lines to display in the agent message editor.": "",
        "agent.message_editor_min_lines": "",
        "Display Mode": "",
        "When to show edit predictions previews in buffer. The eager mode displays them inline, while the subtle mode displays them only when holding a modifier key.": "",
        "edit_prediction.display_mode": "",
        "In Text Threads": "",
        "Whether edit predictions are enabled when editing text threads in the agent panel.": "",
        "edit_prediction.in_text_threads": "",
        "Copilot Provider": "",
        "Use GitHub Copilot as your edit prediction provider.": "",
        "edit_prediction.copilot_provider": "",
        "Codestral Provider": "",
        "Use Mistral's Codestral as your edit prediction provider.": "",
        "edit_prediction.codestral_provider": "",
        "Network": "",
        "Proxy": "",
        "The proxy to use for network requests.": "",
        "proxy": "",
        "socks5h://localhost:10808": "",
        "Server URL": "",
        "The URL of the Zed server to connect to.": "",
        "server_url": "",
        "Languages": "",
        "Indentation": "",
        "Tab Size": "",
        "How many columns a tab should occupy.": "",
        "languages.$(language).tab_size": "",
        "Hard Tabs": "",
        "Whether to indent lines using tab characters, as opposed to multiple spaces.": "",
        "languages.$(language).hard_tabs": "",
        "Auto Indent": "",
        "Whether indentation should be adjusted based on the context whilst typing.": "",
        "languages.$(language).auto_indent": "",
        "Auto Indent On Paste": "",
        "Whether indentation of pasted content should be adjusted based on the context.": "",
        "languages.$(language).auto_indent_on_paste": "",
        "Wrapping": "",
        "Soft Wrap": "",
        "How to soft-wrap long lines of text.": "",
        "languages.$(language).soft_wrap": "",
        "Show wrap guides in the editor.": "",
        "languages.$(language).show_wrap_guides": "",
        "Preferred Line Length": "",
        "The column at which to soft-wrap lines, for buffers where soft-wrap is enabled.": "",
        "languages.$(language).preferred_line_length": "",
        "Character counts at which to show wrap guides in the editor.": "",
        "languages.$(language).wrap_guides": "",
        "Allow Rewrap": "",
        "Controls where the `editor::rewrap` action is allowed for this language.": "",
        "languages.$(language).allow_rewrap": "",
        "Indent Guides": "",
        "Display indent guides in the editor.": "",
        "languages.$(language).indent_guides.enabled": "",
        "Line Width": "",
        "The width of the indent guides in pixels, between 1 and 10.": "",
        "languages.$(language).indent_guides.line_width": "",
        "Active Line Width": "",
        "The width of the active indent guide in pixels, between 1 and 10.": "",
        "languages.$(language).indent_guides.active_line_width": "",
        "Coloring": "",
        "Determines how indent guides are colored.": "",
        "languages.$(language).indent_guides.coloring": "",
        "Background Coloring": "",
        "Determines how indent guide backgrounds are colored.": "",
        "languages.$(language).indent_guides.background_coloring": "",
        "Formatting": "",
        "Format On Save": "",
        "Whether or not to perform a buffer format before saving.": "",
        "languages.$(language).format_on_save": "",
        "Remove Trailing Whitespace On Save": "",
        "Whether or not to remove any trailing whitespace from lines of a buffer before saving it.": "",
        "languages.$(language).remove_trailing_whitespace_on_save": "",
        "Ensure Final Newline On Save": "",
        "Whether or not to ensure there's a single newline at the end of a buffer when saving it.": "",
        "languages.$(language).ensure_final_newline_on_save": "",
        "Formatter": "",
        "How to perform a buffer format.": "",
        "languages.$(language).formatter": "",
        "Use On Type Format": "",
        "Whether to use additional LSP queries to format (and amend) the code after every \\\"trigger\\\" symbol input, defined by LSP server capabilities": "",
        "languages.$(language).use_on_type_format": "",
        "Code Actions On Format": "",
        "Additional code actions to run when formatting.": "",
        "languages.$(language).code_actions_on_format": "",
        "Autoclose": "",
        "Use Autoclose": "",
        "Whether to automatically type closing characters for you. For example, when you type '(', Zed will automatically add a closing ')' at the correct position.": "",
        "languages.$(language).use_autoclose": "",
        "Use Auto Surround": "",
        "Whether to automatically surround text with characters for you. For example, when you select text and type '(', Zed will automatically surround text with ().": "",
        "languages.$(language).use_auto_surround": "",
        "Always Treat Brackets As Autoclosed": "",
        "Controls whether the closing characters are always skipped over and auto-removed no matter how they were inserted.": "",
        "languages.$(language).always_treat_brackets_as_autoclosed": "",
        "Jsx Tag Auto Close": "",
        "Whether to automatically close JSX tags.": "",
        "languages.$(language).jsx_tag_auto_close": "",
        "Whitespace": "",
        "Show Whitespaces": "",
        "Whether to show tabs and spaces in the editor.": "",
        "languages.$(language).show_whitespaces": "",
        "Space Whitespace Indicator": "",
        "Visible character used to render space characters when show_whitespaces is enabled (default: \\\"•\\\")": "",
        "languages.$(language).whitespace_map.space": "",
        "Tab Whitespace Indicator": "",
        "Visible character used to render tab characters when show_whitespaces is enabled (default: \\\"→\\\")": "",
        "languages.$(language).whitespace_map.tab": "",
        "Completions": "",
        "Show Completions On Input": "",
        "Whether to pop the completions menu while typing in an editor without explicitly requesting it.": "",
        "languages.$(language).show_completions_on_input": "",
        "Show Completion Documentation": "",
        "Whether to display inline and alongside documentation for items in the completions menu.": "",
        "languages.$(language).show_completion_documentation": "",
        "Words": "",
        "Controls how words are completed.": "",
        "languages.$(language).completions.words": "",
        "Words Min Length": "",
        "How many characters has to be in the completions query to automatically show the words-based completions.": "",
        "languages.$(language).completions.words_min_length": "",
        "Completion Menu Scrollbar": "",
        "When to show the scrollbar in the completion menu.": "",
        "editor.completion_menu_scrollbar": "",
        "Inlay Hints": "",
        "Global switch to toggle hints on and off.": "",
        "languages.$(language).inlay_hints.enabled": "",
        "Show Value Hints": "",
        "Global switch to toggle inline values on and off when debugging.": "",
        "languages.$(language).inlay_hints.show_value_hints": "",
        "Show Type Hints": "",
        "Whether type hints should be shown.": "",
        "languages.$(language).inlay_hints.show_type_hints": "",
        "Show Parameter Hints": "",
        "Whether parameter hints should be shown.": "",
        "languages.$(language).inlay_hints.show_parameter_hints": "",
        "Show Other Hints": "",
        "Whether other hints should be shown.": "",
        "languages.$(language).inlay_hints.show_other_hints": "",
        "Show Background": "",
        "Show a background for inlay hints.": "",
        "languages.$(language).inlay_hints.show_background": "",
        "Edit Debounce Ms": "",
        "Whether or not to debounce inlay hints updates after buffer edits (set to 0 to disable debouncing).": "",
        "languages.$(language).inlay_hints.edit_debounce_ms": "",
        "Scroll Debounce Ms": "",
        "Whether or not to debounce inlay hints updates after buffer scrolls (set to 0 to disable debouncing).": "",
        "languages.$(language).inlay_hints.scroll_debounce_ms": "",
        "Toggle On Modifiers Press": "",
        "Toggles inlay hints (hides or shows) when the user presses the modifiers specified.": "",
        "languages.$(language).inlay_hints.toggle_on_modifiers_press": "",
        "LSP Document Colors": "",
        "How to render LSP color previews in the editor.": "",
        "lsp_document_colors": "",
        "Tasks": "",
        "Whether tasks are enabled for this language.": "",
        "languages.$(language).tasks.enabled": "",
        "Variables": "",
        "Extra task variables to set for a particular language.": "",
        "languages.$(language).tasks.variables": "",
        "Prefer LSP": "",
        "Use LSP tasks over Zed language extension tasks.": "",
        "languages.$(language).tasks.prefer_lsp": "",
        "Miscellaneous": "",
        "Debuggers": "",
        "Preferred debuggers for this language.": "",
        "languages.$(language).debuggers": "",
        "Middle Click Paste": "",
        "Enable middle-click paste on Linux.": "",
        "languages.$(language).editor.middle_click_paste": "",
        "Extend Comment On Newline": "",
        "Whether to start a new line with a comment when a previous line is a comment as well.": "",
        "languages.$(language).extend_comment_on_newline": "",
        "Image Viewer": "",
        "The unit for image file sizes.": "",
        "image_viewer.unit": "",
        "Auto Replace Emoji Shortcode": "",
        "Whether to automatically replace emoji shortcodes with emoji characters.": "",
        "message_editor.auto_replace_emoji_shortcode": "",
        "Drop Size Target": "",
        "Relative size of the drop target in the editor that will open dropped file as a split pane.": "",
        "drop_target_size": "",
        "LSP": "",
        "Enable Language Server": "",
        "Whether to use language servers to provide code intelligence.": "",
        "languages.$(language).enable_language_server": "",
        "Language Servers": "",
        "The list of language servers to use (or disable) for this language.": "",
        "languages.$(language).language_servers": "",
        "Linked Edits": "",
        "Whether to perform linked edits of associated ranges, if the LS supports it. For example, when editing opening <html> tag, the contents of the closing </html> tag will be edited as well.": "",
        "languages.$(language).linked_edits": "",
        "Go To Definition Fallback": "",
        "Whether to follow-up empty Go to definition responses from the language server.": "",
        "go_to_definition_fallback": "",
        "LSP Completions": "",
        "Whether to fetch LSP completions or not.": "",
        "languages.$(language).completions.lsp": "",
        "Fetch Timeout (milliseconds)": "",
        "When fetching LSP completions, determines how long to wait for a response of a particular server (set to 0 to wait indefinitely).": "",
        "languages.$(language).completions.lsp_fetch_timeout_ms": "",
        "Insert Mode": "",
        "Controls how LSP completions are inserted.": "",
        "languages.$(language).completions.lsp_insert_mode": "",
        "Prettier": "",
        "Allowed": "",
        "Enables or disables formatting with Prettier for a given language.": "",
        "languages.$(language).prettier.allowed": "",
        "Parser": "",
        "Forces Prettier integration to use a specific parser name when formatting files with the language.": "",
        "languages.$(language).prettier.parser": "",
        "Plugins": "",
        "Forces Prettier integration to use specific plugins when formatting files with the language.": "",
        "languages.$(language).prettier.plugins": "",
        "Options": "",
        "Default Prettier options, in the format as in package.json section for Prettier.": "",
        "languages.$(language).prettier.options": "",
        "Edit Predictions": "",
        "Show Edit Predictions": "",
        "Controls whether edit predictions are shown immediately or manually by triggering `editor::showeditprediction` (false).": "",
        "languages.$(language).show_edit_predictions": "",
        "Edit Predictions Disabled In": "",
        "Controls whether edit predictions are shown in the given language scopes.": "",
        "languages.$(language).edit_predictions_disabled_in": ""
    },
    "zed/crates/snippet/src/snippet.rs": {
        "failed to parse snippet": "",
        "expected a closing brace": "",
        "expected an integer": "",
        "Placeholder choice doesn't contain closing pipe-character '|'": "",
        "one-two-three": "",
        "one$1two": "",
        "onetwo": "",
        "one$123-$99-two": "",
        "one--two": "",
        "foo.$1": "",
        "foo.": "",
        "<div class=": "",
        ">$0</div>": "",
        "></div>": "",
        "one${1:two}three${2:four}": "",
        "onetwothreefour": "",
        "type ${1|i32, u32|} = $2": "",
        "Should be able to unpack choice placeholders": "",
        "type i32 = ": "",
        "i32": "",
        " u32": "",
        "${1|\\$\\{1\\|one\\,two\\,tree\\|\\}|}": "",
        "Should be able to parse choice with escape characters": "",
        "${1|one,two,tree|}": "",
        "for (${1:var ${2:i} = 0; ${2:i} < ${3:${4:array}.length}; ${2:i}++}) {$0}": "",
        "for (var i = 0; i < array.length; i++) {}": "",
        "\\\"\\\\$schema\\\": $1": "",
        "\\\"$schema\\\": ": "",
        "{a\\\\}": "",
        "{a}": "",
        "a\\\\b": "",
        "one\\\\\\\\$1two": "",
        "one\\\\two": ""
    },
    "zed/crates/snippets_ui/src/snippets_ui.rs": {
        "{}.json": "",
        "global": "",
        "snippets": "",
        "json": "",
        "default": "",
        "Select snippet scope...": ""
    },
    "zed/crates/sqlez/src/bindable.rs": {
        "Failed to bind bool at index {start_index}": "",
        "Failed to read bool at index {start_index}": "",
        "Failed to bind &[u8] at index {start_index}": "",
        "Failed to bind &[u8; C] at index {start_index}": "",
        "Failed to bind Vec<u8> at index {start_index}": "",
        "Failed to read Vec<u8> at index {start_index}": "",
        "Failed to bind f64 at index {start_index}": "",
        "Failed to parse f64 at index {start_index}": "",
        "Failed to parse f32 at index {start_index}": "",
        "Failed to bind i32 at index {start_index}": "",
        "Failed to bind i64 at index {start_index}": "",
        "Failed to bind usize at index {start_index}": ""
    },
    "zed/crates/sqlez/src/connection.rs": {
        "file:{}?mode=memory&cache=shared": "",
        ":memory:": "",
        "Could not create fallback in memory db": "",
        "main": "",
        "CREATE TABLE {table_to_alter}({column})": "",
        "Sqlite call failed with code {code} and message: {message:?}": "",
        "alter": "",
        "table": "",
        "rename column": "",
        "drop column": "",
        "__place_holder_column_for_syntax_checking": "",
        "string_round_trips": "",
        "\n            CREATE TABLE text (\n                text TEXT\n            );": "",
        "Some test text": "",
        "INSERT INTO text (text) VALUES (?);": "",
        "SELECT text FROM text;": "",
        "tuple_round_trips": "",
        "\n                CREATE TABLE test (\n                    text TEXT,\n                    integer INTEGER,\n                    blob BLOB\n                );": "",
        "test": "",
        "test2": "",
        "INSERT INTO test (text, integer, blob) VALUES (?, ?, ?)": "",
        "SELECT * FROM test": "",
        "bool_round_trips": "",
        "\n                CREATE TABLE bools (\n                    t INTEGER,\n                    f INTEGER\n                );": "",
        "INSERT INTO bools(t, f) VALUES (?, ?)": "",
        "SELECT * FROM bools;": "",
        "backup_works": "",
        "\n                CREATE TABLE blobs (\n                    data BLOB\n                );": "",
        "INSERT INTO blobs (data) VALUES (?);": "",
        "backup_works_other": "",
        "SELECT * FROM blobs;": "",
        "multi_step_statement_works": "",
        "\n                CREATE TABLE test (\n                    col INTEGER\n                )": "",
        "\n            INSERT INTO test(col) VALUES (2)": "",
        "test_sql_has_syntax_errors": "",
        "CREATE TABLE kv_store(key TEXT PRIMARY KEY, value TEXT NOT NULL) STRICT ;": "",
        "SELECT FROM": "",
        "{}\\n{}": "",
        "test_alter_table_syntax": "",
        "ALTER TABLE test ADD x TEXT": "",
        "ALTER TABLE test AAD x TEXT": ""
    },
    "zed/crates/sqlez/src/migrations.rs": {
        "Error creating cstr": "",
        "Prepare call failed for query:\\n{}": "",
        "migrating": "",
        "\n                CREATE TABLE IF NOT EXISTS migrations (\n                    domain TEXT,\n                    step INTEGER,\n                    migration TEXT\n                )": "",
        "\n                    SELECT domain, step, migration FROM migrations\n                    WHERE domain = ?\n                    ORDER BY step\n                    ": "",
        "INSERT INTO migrations (domain, step, migration) VALUES (?, ?, ?)": "",
        "\n                            Migration changed for {domain} at step {index}\n\n                            Stored migration:\n                            {completed_migration}\n\n                            Proposed migration:\n                            {migration}": "",
        "PRAGMA foreign_key_check;": "",
        "\n                SELECT DISTINCT\n                    schema.name as child_table,\n                    foreign_keys.[from] as child_key,\n                    foreign_keys.[table] as parent_table,\n                    foreign_keys.[to] as parent_key\n                FROM sqlite_schema schema\n                JOIN pragma_foreign_key_list(schema.name) foreign_keys\n                WHERE\n                    schema.type = 'table' AND\n                    schema.name NOT LIKE ": "",
        "\n            ": "",
        "Found {} foreign key relationships to check": "",
        "\n                DELETE FROM {child_table}\n                WHERE {child_key} IS NOT NULL and {child_key} NOT IN\n                (SELECT {parent_key} FROM {parent_table})\n                ": "",
        "migrations_are_added_to_table": "",
        "test": "",
        "\n                CREATE TABLE test1 (\n                    a TEXT,\n                    b TEXT\n                )": "",
        "SELECT (migration) FROM migrations": "",
        "CREATE TABLE test1 (a TEXT, b TEXT)": "",
        "\n                    CREATE TABLE test1 (\n                        a TEXT,\n                        b TEXT\n                    )": "",
        "\n                    CREATE TABLE test2 (\n                        c TEXT,\n                        d TEXT\n                    )": "",
        "CREATE TABLE test2 (c TEXT, d TEXT)": "",
        "migration_setup_works": "",
        "\n                CREATE TABLE IF NOT EXISTS migrations (\n                    domain TEXT,\n                    step INTEGER,\n                    migration TEXT\n                );": "",
        "\n                INSERT INTO migrations (domain, step, migration)\n                VALUES (?, ?, ?)": "",
        "test_domain": "",
        "CREATE TABLE table{} ( test TEXT );": "",
        "migrations_dont_rerun": "",
        "\n                CREATE TABLE test_table (\n                    test_column INTEGER\n                );": "",
        "\n            INSERT INTO test_table (test_column) VALUES (1);": "",
        "SELECT * FROM test_table": "",
        "DELETE FROM test_table": "",
        "INSERT INTO test_table (test_column) VALUES (2)": "",
        "changed_migration_fails": "",
        "test migration": "",
        "CREATE TABLE test (col INTEGER)": "",
        "INSERT INTO test (col) VALUES (1)": "",
        "CREATE TABLE test (color INTEGER )": "",
        "INSERT INTO test (color) VALUES (1)": "",
        "CREATE TABLE test (color INTEGER)": "",
        "test_create_alter_drop": "",
        "first_migration": "",
        "CREATE TABLE table1(a TEXT) STRICT;": "",
        "INSERT INTO table1(a) VALUES (\\\"test text\\\");": "",
        "second_migration": "",
        "\n                    CREATE TABLE table2(b TEXT) STRICT;\n\n                    INSERT INTO table2 (b)\n                    SELECT a FROM table1;\n\n                    DROP TABLE table1;\n\n                    ALTER TABLE table2 RENAME TO table1;\n                ": "",
        "SELECT b FROM table1": "",
        "test text": ""
    },
    "zed/crates/sqlez/src/savepoint.rs": {
        "SAVEPOINT {name}": "",
        "RELEASE {name}": "",
        "\n                    ROLLBACK TO {name};\n                    RELEASE {name}": "",
        "nested_savepoints": "",
        "\n            CREATE TABLE text (\n                text TEXT,\n                idx INTEGER\n            );": "",
        "test save1": "",
        "test save2": "",
        "first": "",
        "INSERT INTO text(text, idx) VALUES (?, ?)": "",
        "second": "",
        "SELECT text FROM text ORDER BY text.idx ASC": "",
        "Failed second save point :(": ""
    },
    "zed/crates/sqlez/src/statement.rs": {
        "Error creating cstr": "",
        "Parsing remaining sql": "",
        "Prepare call failed for query:\\n{}": "",
        "Write statement prepared with connection that is not write capable. SQL:\\n{} ": "",
        "Failed to bind value at index {index}": "",
        "Failed to bind parameters": "",
        "Failed to read blob at index {index}": "",
        "Failed to read length of blob at index {index}": "",
        "Failed to read double at index {index}": "",
        "Failed to read int at index {index}": "",
        "Failed to read i64 at index {index}": "",
        "Failed to read text from column {index}": "",
        "Failed to read text length at {index}": "",
        "Column type returned was incorrect": "",
        "Statement step returned SQLITE_MISUSE": "",
        "Step returned error code and last error failed to catch it": "",
        "single called with query that returns no rows.": "",
        "single called with a query that returns more than one row.": "",
        "Failed on step call": "",
        "Failed to parse row result": "",
        "Second step call": "",
        "maybe called with a query that returns more than one row.": "",
        "binding_multiple_statements_with_parameter_gaps": "",
        "\n            CREATE TABLE test (\n                col INTEGER\n            )": "",
        "\n                INSERT INTO test(col) VALUES (?3);\n                SELECT * FROM test WHERE col = ?1": "",
        "Could not bind parameter to first index": "",
        "Could not bind parameter to second index": "",
        "Could not bind parameter to third index": "",
        "blob_round_trips": "",
        "\n                CREATE TABLE blobs (\n                    data BLOB\n                )": "",
        "INSERT INTO blobs (data) VALUES (?)": "",
        "SELECT * FROM blobs": "",
        "DELETE FROM blobs": "",
        "maybe_returns_options": "",
        "\n                CREATE TABLE texts (\n                    text TEXT\n                )": "",
        "SELECT text FROM texts": "",
        "This is a test": "",
        "INSERT INTO texts VALUES (?)": ""
    },
    "zed/crates/sqlez/src/thread_safe_connection.rs": {
        "Db initialize query failed to execute: {}": "",
        "Migration never run": "",
        "PRAGMA foreign_keys": "",
        "PRAGMA foreign_keys = OFF;": "",
        "thread_safe_multi_migration": "",
        "PRAGMA foreign_keys = ON;": "",
        "Queues are inserted when build is called. This should always succeed": "",
        "Write queue unexpectedly closed": "",
        "Initialize query failed to execute: {}": "",
        "sqlezWorker": "",
        "Could not send write action to background thread": "",
        "test": "",
        "CREATE TABLE test(col1 TEXT, col2 TEXT) STRICT;": "",
        "annoying-test.db": "",
        "PRAGMA journal_mode=WAL": "",
        "\n                                PRAGMA synchronous=NORMAL;\n                                PRAGMA busy_timeout=1;\n                                PRAGMA foreign_keys=TRUE;\n                                PRAGMA case_sensitive_like=TRUE;\n                            ": "",
        "workspace": "",
        "\n                    CREATE TABLE workspaces(\n                        workspace_id INTEGER PRIMARY KEY,\n                        dock_visible INTEGER, -- Boolean\n                        dock_anchor TEXT, -- Enum: 'Bottom' / 'Right' / 'Expanded'\n                        dock_pane INTEGER, -- NULL indicates that we don't have a dock pane yet\n                        timestamp TEXT DEFAULT CURRENT_TIMESTAMP NOT NULL,\n                        FOREIGN KEY(dock_pane) REFERENCES panes(pane_id),\n                        FOREIGN KEY(active_pane) REFERENCES panes(pane_id)\n                    ) STRICT;\n\n                    CREATE TABLE panes(\n                        pane_id INTEGER PRIMARY KEY,\n                        workspace_id INTEGER NOT NULL,\n                        active INTEGER NOT NULL, -- Boolean\n                        FOREIGN KEY(workspace_id) REFERENCES workspaces(workspace_id)\n                            ON DELETE CASCADE\n                            ON UPDATE CASCADE\n                    ) STRICT;\n                ": "",
        "wild_zed_lost_failure": "",
        "PRAGMA FOREIGN_KEYS=true": ""
    },
    "zed/crates/sqlez/src/typed_statements.rs": {
        "Bindings failed": "",
        "Maybe row failed": ""
    },
    "zed/crates/streaming_diff/src/streaming_diff.rs": {
        "column out of bounds": "",
        "row out of bounds": "",
        "{:5}": "",
        "aaaa\\nbbbb": "",
        "\\ncccc": "",
        "aaaa\\nbbbb\\ncccc": "",
        "BBBB": "",
        "aaaa\\nbbbb\\ncccc\\ndddd": "",
        "A": "",
        "\\nEEEE": "",
        "aaaabbbb": "",
        "\\n\\n": "",
        "aaaa\\n\\n\\nbbbb": "",
        "line1\\nline2\\nline3\\nline4": "",
        "inserted\\n": "",
        "\\nnewline": "",
        "line1\\ninserted\\nline3\\nnewline\\nline4": "",
        "        for y in 0..size.y() {\\n": "",
        "            let a = 10;\\n": "",
        "            let b = 20;\\n": "",
        "        }": "",
        "let": "",
        " mut": "",
        " y": "",
        " =": "",
        " 0": "",
        "        while": "",
        " < size": "",
        "y": "",
        " {": "",
        "    y": "",
        " +=": "",
        " 1": "",
        "        ": "",
        "OLD_TEXT_LEN": "",
        "invalid `OLD_TEXT_LEN` variable": "",
        "old text: {:?}": "",
        "new text: {:?}": "",
        "char operations: {:?}": "",
        "line operations: {:?}": "",
        "ITERATIONS": "",
        "invalid `ITERATIONS` variable": "",
        "SEED": "",
        "invalid `SEED` variable": "",
        "Running test with {} iterations and seed {}": "",
        "Iteration {}": "",
        "Hello, world!": "",
        "Hello, Rust!": ""
    },
    "zed/crates/tab_switcher/src/tab_switcher.rs": {
        "TabSwitcher": "",
        "Search all tabs…": "",
        "No tabs": "",
        "close-button": "",
        "close_tab": "",
        "Close": ""
    },
    "zed/crates/task/src/task_template.rs": {
        "regular": "",
        "main": "",
        "non_empty_string_vec": "",
        "default_true": "",
        "We want to clone the full_label to avoid borrowing it in the fold closure": "",
        "\\\\n": "",
        "hashing task template": "",
        "hashing task variables": "",
        "{id_base}_{task_hash}_{variables_hash}": "",
        "serializing the object": "",
        "Unknown variable name: {variable_name}": "",
        "${{{var}}}": "",
        "test_base": "",
        "test_label": "",
        "test_command": "",
        "test_arg": "",
        "test_env_key": "",
        "test_env_var": "",
        "should not resolve task with blank label and/or command: {task_with_blank_property:?}": "",
        "test task": "",
        "echo 4": "",
        "failed to resolve task {task_without_cwd:?}": "",
        "When neither task nor task context have cwd, it should be None": "",
        "a": "",
        "b": "",
        "c": "",
        "TaskContext's cwd should be taken on resolve if task's cwd is None": "",
        "d": "",
        "e": "",
        "f": "",
        "TaskTemplate's cwd should be taken on resolve if TaskContext's cwd is None": "",
        "TaskTemplate's cwd should be taken on resolve if TaskContext's cwd is not None": "",
        "custom_variable_1": "",
        "custom_variable_2": "",
        "test_file": "",
        "test_selected_text": "",
        "/test_root/": "",
        "test_custom_variable_1": "",
        "test_custom_variable_2": "",
        "test label for {} and {}": "",
        "echo {} {}": "",
        "arg1 {}": "",
        "arg2 {}": "",
        "arg3 {}": "",
        "env_key_1": "",
        "env_key_2": "",
        "env_var_2 {} {}": "",
        "env_key_3": "",
        "env_var_3 {}": "",
        "Should successfully resolve task {task_with_all_variables:?} with variables {all_variables:?}": "",
        "Step {i}, for the same task template and context, there should be the same resolved task id": "",
        "Resolved task should store its template without changes": "",
        "test label for 1234 and {long_value}": "",
        "Resolved task label should be substituted with variables and those should not be shortened": "",
        "test label for 1234 and …{}": "",
        "Human-readable label should have long substitutions trimmed": "",
        "echo test_file {long_value}": "",
        "Command should be substituted with variables and those should not be shortened": "",
        "arg1 test_selected_text": "",
        "arg2 5678": "",
        "arg3 010101010101010101010101010101010101010101010101010101010101": "",
        "Args should be substituted with variables": "",
        "{} arg1 test_selected_text arg2 5678 arg3 {long_value}": "",
        "Command label args should be substituted with variables and those should not be shortened": "",
        "env_var_2 test_custom_variable_1 test_custom_variable_2": "",
        "env_var_3 {long_value}": "",
        "Env vars should be substituted with variables and those should not be shortened": "",
        "If any of the Zed task variables is not substituted, the task should not be resolved, but got some resolution without the variable {removed_variable:?} (index {i})": "",
        "My task": "",
        "echo": "",
        "$PATH": "",
        "$ZED_VARIABLE": "",
        "test_symbol": "",
        "test_label_{}": "",
        "test_command_{}": "",
        "test_arg_{}": "",
        "test_env_var_{}": "",
        "Failed to resolve task {symbol_dependent_task:?}": "",
        "(index {i}) Expected the task to depend on symbol task variable: {resolved:?}": "",
        "go test {}/{}": "",
        "go": "",
        "my-symbol": "",
        "base": "",
        "my symbol": "",
        "my task": "",
        "TASK_ENV_VAR1": "",
        "TASK_ENV_VAR1_VALUE": "",
        "TASK_ENV_VAR2": "",
        "PROJECT_ENV_WILL_BE_OVERWRITTEN": "",
        "overwritten": "",
        "PROJECT_ENV_VAR1": "",
        "PROJECT_ENV_VAR1_VALUE": "",
        "PROJECT_ENV_WILL_BE_OVERWRITTEN_VALUE": "",
        "env_var_2 1234 5678": "",
        "test with defaults": "",
        "echo ${{{}}}": "",
        ":fallback.txt": "",
        "${ZED_MISSING_VAR:default_value}": "",
        ":42": "",
        "actual_file.rs": "",
        "Should resolve task with existing variables": "",
        "echo actual_file.rs": "",
        "Should use actual ZED_FILE value, not default": "",
        "default_value": "",
        "Should use default for missing var, actual value for existing var": "",
        "Should resolve task using default values": "",
        "echo fallback.txt": "",
        "Should use default value when ZED_FILE is missing": "",
        "Should use defaults for missing vars": "",
        "test no default": "",
        "${ZED_MISSING_NO_DEFAULT}": "",
        "Should fail when ZED variable has no default and doesn't exist": ""
    },
    "zed/crates/task/src/vscode_format.rs": {
        "camelCase": "",
        "type": "",
        "dependsOn": "",
        "Skipping deserializing of a task `{}` with the unsupported `dependsOn` key": "",
        "Missing `type` field in task": "",
        "npm": "",
        "run": "",
        "gulp": "",
        "workspaceFolder": "",
        "file": "",
        "lineNumber": "",
        "selectedText": "",
        "Food": "",
        "$PATH is an environment variable": "",
        "${PATH}": "",
        "${PATH:food}": "",
        "PATH": "",
        "ZED_PATH": "",
        "${ZED_PATH} is an environment variable": "",
        "${ZED_PATH}": "",
        "${ZED_PATH:food}": "",
        "gulp: tests": "",
        "build:tests:notypecheck": "",
        "tsc: watch ./src": "",
        "node": "",
        "${workspaceFolder}/node_modules/typescript/lib/tsc.js": "",
        "--build": "",
        "${workspaceFolder}/src": "",
        "--watch": "",
        "npm: build:compiler": "",
        "build:compiler": "",
        "npm: build:tests": "",
        "${ZED_WORKTREE_ROOT}/node_modules/typescript/lib/tsc.js": "",
        "${ZED_WORKTREE_ROOT}/src": "",
        "Build Extension in Background": "",
        "watch": "",
        "Build Extension": "",
        "build": "",
        "Build Server": "",
        "cargo build --package rust-analyzer": "",
        "Build Server (Release)": "",
        "cargo build --release --package rust-analyzer": "",
        "Pretest": "",
        "pretest": "",
        "Build Server and Extension": "",
        "Build Server (Release) and Extension": ""
    },
    "zed/crates/tasks_ui/src/modal.rs": {
        "Find a task, or run a command in the central pane": "",
        "Find a task, or run a command": "",
        ".zed": "",
        ".vscode": "",
        "TasksModal": "",
        "\\n#{}": "",
        "tasks-modal-{ix}": "",
        " ": "",
        "delete": "",
        "Delete Previously Scheduled Task": "",
        "Rerun Last Task": "",
        "edit-current-task": "",
        "Spawn Oneshot Without History": "",
        "Spawn Oneshot": "",
        "spawn-onehshot": "",
        "Rerun Without History": "",
        "Spawn Without History": "",
        "spawn": "",
        "Rerun": "",
        "Spawn": "",
        "/dir": "",
        "tasks.json": "",
        "[\n                        {\n                            ": "",
        ": ": "",
        ",\n                            ": "",
        ": [": "",
        "]\n                        },\n                        {\n                            ": "",
        "]\n                        },\n                    ]": "",
        "a.ts": "",
        "a": "",
        "Initial query should be empty": "",
        "another one": "",
        "example task": "",
        "With no global tasks and no open item, a single worktree should be used and its tasks listed": "",
        "Initial tasks should be listed in alphabetical order": "",
        "tas": "",
        "Only one task should match the query {query_str}": "",
        "echo 4": "",
        "Query should be set to the selected task's command": "",
        "No task should be listed": "",
        "Query should be reset after confirming": "",
        "New oneshot task should be listed first": "",
        "New oneshot should match custom command query": "",
        "Last recently used one show task should be listed first": "",
        "Query should be set to the custom task's name": "",
        "Only custom task should be listed": "",
        "echo 40": "",
        "New oneshot should not match any command query": "",
        "No query should be added to the list, as it was submitted with secondary action (that maps to omit_history = true)": "",
        ", ": "",
        "]\n                        }\n                    ]": "",
        "file_without_extension": "",
        "aaaaaaaaaaaaaaaaaaaa\\naaaaaaaaaaaaaaaaaa": "",
        "file_with.odd_extension": "",
        "b": "",
        "opened now: ": "",
        "When no file is open for a single worktree, should autodetect all worktree-related tasks": "",
        "/dir/file_with.odd_extension": "",
        "hello from ": "",
        "/dir/file_with.odd_extension:1:1": "",
        "Second opened buffer should fill the context, labels should be trimmed if long enough": "",
        "/dir/file_without_extension": "",
        "/dir/file_without_extension:2:3": "",
        "Opened buffer should fill the context, labels should be trimmed if long enough": "",
        "a1.ts": "",
        "// a1": "",
        "a2.ts": "",
        "// a2": "",
        "b.rs": "",
        "// b": "",
        "TypeScript": "",
        "ts": "",
        "Task without variables": "",
        "npm run clean": "",
        "TypeScript task from file $ZED_FILE": "",
        "npm run build": "",
        "Another task from file $ZED_FILE": "",
        "npm run lint": "",
        "Rust task": "",
        "cargo check": "",
        "Another task from file ": "",
        "TypeScript task from file ": "",
        "Should open spawn TypeScript tasks for the opened file, tasks with most template variables above, all groups sorted alphanumerically": "",
        "After spawning the task and getting it into the history, it should be up in the sort as recently used.\n            Tasks with the same labels and context are deduplicated.": "",
        "Even when both TS files are open, should only show the history (on the top), and tasks, resolved for the current file": "",
        "Even when both TS files are open and one TS task spawned, opened file's language tasks should be displayed only": "",
        "\n        );\n    }\n\n    fn emulate_task_schedule(\n        tasks_picker: Entity<Picker<TasksModalDelegate>>,\n        project: &Entity<Project>,\n        scheduled_task_label: &str,\n        cx: &mut VisualTestContext,\n    ) {\n        let scheduled_task = tasks_picker.read_with(cx, |tasks_picker, _| {\n            tasks_picker\n                .delegate\n                .candidates\n                .iter()\n                .flatten()\n                .find(|(_, task)| task.resolved_label == scheduled_task_label)\n                .cloned()\n                .unwrap()\n        });\n        project.update(cx, |project, cx| {\n            if let Some(task_inventory) = project.task_store().read(cx).task_inventory().cloned() {\n                task_inventory.update(cx, |inventory, _| {\n                    let (kind, task) = scheduled_task;\n                    inventory.task_scheduled(kind, task);\n                });\n            }\n        });\n        tasks_picker.update(cx, |_, cx| {\n            cx.emit(DismissEvent);\n        });\n        drop(tasks_picker);\n        cx.executor().run_until_parked()\n    }\n\n    fn open_spawn_tasks(\n        workspace: &Entity<Workspace>,\n        cx: &mut VisualTestContext,\n    ) -> Entity<Picker<TasksModalDelegate>> {\n        cx.dispatch_action(Spawn::modal());\n        workspace.update(cx, |workspace, cx| {\n            workspace\n                .active_modal::<TasksModal>(cx)\n                .expect(": ""
    },
    "zed/crates/terminal/src/terminal.rs": {
        "<non-utf8 path> {}": "",
        "<none specified>": "",
        "{} {} ({})": "",
        "<system defined shell>": "",
        " ": "",
        "{} {}": "",
        "Working directory: {} Shell command: `{}`, IOError: {}": "",
        "LANG": "",
        "en_US.UTF-8": "",
        "ZED_TERM": "",
        "true": "",
        "TERM_PROGRAM": "",
        "TERM": "",
        "xterm-256color": "",
        "COLORTERM": "",
        "truecolor": "",
        "TERM_PROGRAM_VERSION": "",
        "Using {program} as shell": "",
        "failed to create event loop": "",
        "\\x0d": "",
        "clear": "",
        "cls": "",
        "echo": "",
        "\\\\?\\\") || !path.contains(&['/', '\\\\']) {\n            path.to_string()\n        } else {\n            r": "",
        ".to_string() + path\n        };\n\n        let required_length = unsafe { SearchPathW(None, &HSTRING::from(&path), None, None, None) };\n        let mut buf = vec![0u16; required_length as usize];\n        let size = unsafe { SearchPathW(None, &HSTRING::from(&path), None, Some(&mut buf), None) };\n\n        Ok(String::from_utf16(&buf[..size as usize])?)\n    }\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize)]\npub struct IndexedCell {\n    pub point: AlacPoint,\n    pub cell: Cell,\n}\n\nimpl Deref for IndexedCell {\n    type Target = Cell;\n\n    #[inline]\n    fn deref(&self) -> &Cell {\n        &self.cell\n    }\n}\n\n// TODO: Un-pub\n#[derive(Clone)]\npub struct TerminalContent {\n    pub cells: Vec<IndexedCell>,\n    pub mode: TermMode,\n    pub display_offset: usize,\n    pub selection_text: Option<String>,\n    pub selection: Option<SelectionRange>,\n    pub cursor: RenderableCursor,\n    pub cursor_char: char,\n    pub terminal_bounds: TerminalBounds,\n    pub last_hovered_word: Option<HoveredWord>,\n    pub scrolled_to_top: bool,\n    pub scrolled_to_bottom: bool,\n}\n\n#[derive(Debug, Clone, Eq, PartialEq)]\npub struct HoveredWord {\n    pub word: String,\n    pub word_match: RangeInclusive<AlacPoint>,\n    pub id: usize,\n}\n\nimpl Default for TerminalContent {\n    fn default() -> Self {\n        TerminalContent {\n            cells: Default::default(),\n            mode: Default::default(),\n            display_offset: Default::default(),\n            selection_text: Default::default(),\n            selection: Default::default(),\n            cursor: RenderableCursor {\n                shape: alacritty_terminal::vte::ansi::CursorShape::Block,\n                point: AlacPoint::new(Line(0), Column(0)),\n            },\n            cursor_char: Default::default(),\n            terminal_bounds: Default::default(),\n            last_hovered_word: None,\n            scrolled_to_top: false,\n            scrolled_to_bottom: false,\n        }\n    }\n}\n\n#[derive(PartialEq, Eq)]\npub enum SelectionPhase {\n    Selecting,\n    Ended,\n}\n\nenum TerminalType {\n    Pty {\n        pty_tx: Notifier,\n        info: PtyProcessInfo,\n    },\n    DisplayOnly,\n}\n\npub struct Terminal {\n    terminal_type: TerminalType,\n    completion_tx: Option<Sender<Option<ExitStatus>>>,\n    term: Arc<FairMutex<Term<ZedListener>>>,\n    term_config: Config,\n    events: VecDeque<InternalEvent>,\n    /// This is only used for mouse mode cell change detection\n    last_mouse: Option<(AlacPoint, AlacDirection)>,\n    pub matches: Vec<RangeInclusive<AlacPoint>>,\n    pub last_content: TerminalContent,\n    pub selection_head: Option<AlacPoint>,\n    pub breadcrumb_text: String,\n    title_override: Option<String>,\n    scroll_px: Pixels,\n    next_link_id: usize,\n    selection_phase: SelectionPhase,\n    hyperlink_regex_searches: RegexSearches,\n    task: Option<TaskState>,\n    vi_mode_enabled: bool,\n    is_remote_terminal: bool,\n    last_mouse_move_time: Instant,\n    last_hyperlink_search_position: Option<Point<Pixels>>,\n    #[cfg(windows)]\n    shell_program: Option<String>,\n    template: CopyTemplate,\n    activation_script: Vec<String>,\n    child_exited: Option<ExitStatus>,\n    event_loop_task: Task<Result<(), anyhow::Error>>,\n}\n\nstruct CopyTemplate {\n    shell: Shell,\n    env: HashMap<String, String>,\n    cursor_shape: CursorShape,\n    alternate_scroll: AlternateScroll,\n    max_scroll_history_lines: Option<usize>,\n    window_id: u64,\n}\n\n#[derive(Debug)]\npub struct TaskState {\n    pub status: TaskStatus,\n    pub completion_rx: Receiver<Option<ExitStatus>>,\n    pub spawned_task: SpawnInTerminal,\n}\n\n/// A status of the current terminal tab's task.\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum TaskStatus {\n    /// The task had been started, but got cancelled or somehow otherwise it did not\n    /// report its exit code before the terminal event loop was shut down.\n    Unknown,\n    /// The task is started and running currently.\n    Running,\n    /// After the start, the task stopped running and reported its error code back.\n    Completed { success: bool },\n}\n\nimpl TaskStatus {\n    fn register_terminal_exit(&mut self) {\n        if self == &Self::Running {\n            *self = Self::Unknown;\n        }\n    }\n\n    fn register_task_exit(&mut self, error_code: i32) {\n        *self = TaskStatus::Completed {\n            success: error_code == 0,\n        };\n    }\n}\n\nimpl Terminal {\n    fn process_event(&mut self, event: AlacTermEvent, cx: &mut Context<Self>) {\n        match event {\n            AlacTermEvent::Title(title) => {\n                // ignore default shell program title change as windows always sends those events\n                // and it would end up showing the shell executable path in breadcrumbs\n                #[cfg(windows)]\n                {\n                    if self\n                        .shell_program\n                        .as_ref()\n                        .map(|e| *e == title)\n                        .unwrap_or(false)\n                    {\n                        return;\n                    }\n                }\n\n                self.breadcrumb_text = title;\n                cx.emit(Event::BreadcrumbsChanged);\n            }\n            AlacTermEvent::ResetTitle => {\n                self.breadcrumb_text = String::new();\n                cx.emit(Event::BreadcrumbsChanged);\n            }\n            AlacTermEvent::ClipboardStore(_, data) => {\n                cx.write_to_clipboard(ClipboardItem::new_string(data))\n            }\n            AlacTermEvent::ClipboardLoad(_, format) => {\n                self.write_to_pty(\n                    match &cx.read_from_clipboard().and_then(|item| item.text()) {\n                        // The terminal only supports pasting strings, not images.\n                        Some(text) => format(text),\n                        _ => format(": "",
        "),\n                    }\n                    .into_bytes(),\n                )\n            }\n            AlacTermEvent::PtyWrite(out) => self.write_to_pty(out.into_bytes()),\n            AlacTermEvent::TextAreaSizeRequest(format) => {\n                self.write_to_pty(format(self.last_content.terminal_bounds.into()).into_bytes())\n            }\n            AlacTermEvent::CursorBlinkingChange => {\n                let terminal = self.term.lock();\n                let blinking = terminal.cursor_style().blinking;\n                cx.emit(Event::BlinkChanged(blinking));\n            }\n            AlacTermEvent::Bell => {\n                cx.emit(Event::Bell);\n            }\n            AlacTermEvent::Exit => self.register_task_finished(None, cx),\n            AlacTermEvent::MouseCursorDirty => {\n                //NOOP, Handled in render\n            }\n            AlacTermEvent::Wakeup => {\n                cx.emit(Event::Wakeup);\n\n                if let TerminalType::Pty { info, .. } = &mut self.terminal_type {\n                    if info.has_changed() {\n                        cx.emit(Event::TitleChanged);\n                    }\n                }\n            }\n            AlacTermEvent::ColorRequest(index, format) => {\n                // It's important that the color request is processed here to retain relative order\n                // with other PTY writes. Otherwise applications might witness out-of-order\n                // responses to requests. For example: An application sending `OSC 11 ; ? ST`\n                // (color request) followed by `CSI c` (request device attributes) would receive\n                // the response to `CSI c` first.\n                // Instead of locking, we could store the colors in `self.last_content`. But then\n                // we might respond with out of date value if a ": "",
        " sequence is immediately\n                // followed by a color request sequence.\n                let color = self.term.lock().colors()[index]\n                    .unwrap_or_else(|| to_alac_rgb(get_color_at_index(index, cx.theme().as_ref())));\n                self.write_to_pty(format(color).into_bytes());\n            }\n            AlacTermEvent::ChildExit(error_code) => {\n                self.register_task_finished(Some(error_code), cx);\n            }\n        }\n    }\n\n    pub fn selection_started(&self) -> bool {\n        self.selection_phase == SelectionPhase::Selecting\n    }\n\n    fn process_terminal_event(\n        &mut self,\n        event: &InternalEvent,\n        term: &mut Term<ZedListener>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        match event {\n            &InternalEvent::Resize(mut new_bounds) => {\n                trace!(": "",
        ");\n                new_bounds.bounds.size.height =\n                    cmp::max(new_bounds.line_height, new_bounds.height());\n                new_bounds.bounds.size.width = cmp::max(new_bounds.cell_width, new_bounds.width());\n\n                self.last_content.terminal_bounds = new_bounds;\n\n                if let TerminalType::Pty { pty_tx, .. } = &self.terminal_type {\n                    pty_tx.0.send(Msg::Resize(new_bounds.into())).ok();\n                }\n\n                term.resize(new_bounds);\n            }\n            InternalEvent::Clear => {\n                trace!(": "",
        ");\n                // Clear back buffer\n                term.clear_screen(ClearMode::Saved);\n\n                let cursor = term.grid().cursor.point;\n\n                // Clear the lines above\n                term.grid_mut().reset_region(..cursor.line);\n\n                // Copy the current line up\n                let line = term.grid()[cursor.line][..Column(term.grid().columns())]\n                    .iter()\n                    .cloned()\n                    .enumerate()\n                    .collect::<Vec<(usize, Cell)>>();\n\n                for (i, cell) in line {\n                    term.grid_mut()[Line(0)][Column(i)] = cell;\n                }\n\n                // Reset the cursor\n                term.grid_mut().cursor.point =\n                    AlacPoint::new(Line(0), term.grid_mut().cursor.point.column);\n                let new_cursor = term.grid().cursor.point;\n\n                // Clear the lines below the new cursor\n                if (new_cursor.line.0 as usize) < term.screen_lines() - 1 {\n                    term.grid_mut().reset_region((new_cursor.line + 1)..);\n                }\n\n                cx.emit(Event::Wakeup);\n            }\n            InternalEvent::Scroll(scroll) => {\n                trace!(": "",
        ");\n                term.scroll_display(*scroll);\n                self.refresh_hovered_word(window);\n\n                if self.vi_mode_enabled {\n                    match *scroll {\n                        AlacScroll::Delta(delta) => {\n                            term.vi_mode_cursor = term.vi_mode_cursor.scroll(term, delta);\n                        }\n                        AlacScroll::PageUp => {\n                            let lines = term.screen_lines() as i32;\n                            term.vi_mode_cursor = term.vi_mode_cursor.scroll(term, lines);\n                        }\n                        AlacScroll::PageDown => {\n                            let lines = -(term.screen_lines() as i32);\n                            term.vi_mode_cursor = term.vi_mode_cursor.scroll(term, lines);\n                        }\n                        AlacScroll::Top => {\n                            let point = AlacPoint::new(term.topmost_line(), Column(0));\n                            term.vi_mode_cursor = ViModeCursor::new(point);\n                        }\n                        AlacScroll::Bottom => {\n                            let point = AlacPoint::new(term.bottommost_line(), Column(0));\n                            term.vi_mode_cursor = ViModeCursor::new(point);\n                        }\n                    }\n                    if let Some(mut selection) = term.selection.take() {\n                        let point = term.vi_mode_cursor.point;\n                        selection.update(point, AlacDirection::Right);\n                        term.selection = Some(selection);\n\n                        #[cfg(any(target_os = ": "",
        ", target_os = ": "",
        "))]\n                        if let Some(selection_text) = term.selection_to_string() {\n                            cx.write_to_primary(ClipboardItem::new_string(selection_text));\n                        }\n\n                        self.selection_head = Some(point);\n                        cx.emit(Event::SelectionsChanged)\n                    }\n                }\n            }\n            InternalEvent::SetSelection(selection) => {\n                trace!(": "",
        ");\n                term.selection = selection.as_ref().map(|(sel, _)| sel.clone());\n\n                #[cfg(any(target_os = ": "",
        "))]\n                if let Some(selection_text) = term.selection_to_string() {\n                    cx.write_to_primary(ClipboardItem::new_string(selection_text));\n                }\n\n                if let Some((_, head)) = selection {\n                    self.selection_head = Some(*head);\n                }\n                cx.emit(Event::SelectionsChanged)\n            }\n            InternalEvent::UpdateSelection(position) => {\n                trace!(": "",
        ");\n                if let Some(mut selection) = term.selection.take() {\n                    let (point, side) = grid_point_and_side(\n                        *position,\n                        self.last_content.terminal_bounds,\n                        term.grid().display_offset(),\n                    );\n\n                    selection.update(point, side);\n                    term.selection = Some(selection);\n\n                    #[cfg(any(target_os = ": "",
        "))]\n                    if let Some(selection_text) = term.selection_to_string() {\n                        cx.write_to_primary(ClipboardItem::new_string(selection_text));\n                    }\n\n                    self.selection_head = Some(point);\n                    cx.emit(Event::SelectionsChanged)\n                }\n            }\n\n            InternalEvent::Copy(keep_selection) => {\n                trace!(": "",
        ");\n                if let Some(txt) = term.selection_to_string() {\n                    cx.write_to_clipboard(ClipboardItem::new_string(txt));\n                    if !keep_selection.unwrap_or_else(|| {\n                        let settings = TerminalSettings::get_global(cx);\n                        settings.keep_selection_on_copy\n                    }) {\n                        self.events.push_back(InternalEvent::SetSelection(None));\n                    }\n                }\n            }\n            InternalEvent::ScrollToAlacPoint(point) => {\n                trace!(": "",
        ");\n                term.scroll_to_point(*point);\n                self.refresh_hovered_word(window);\n            }\n            InternalEvent::MoveViCursorToAlacPoint(point) => {\n                trace!(": "",
        ");\n                term.vi_goto_point(*point);\n                self.refresh_hovered_word(window);\n            }\n            InternalEvent::ToggleViMode => {\n                trace!(": "",
        ");\n                self.vi_mode_enabled = !self.vi_mode_enabled;\n                term.toggle_vi_mode();\n            }\n            InternalEvent::ViMotion(motion) => {\n                trace!(": "",
        ");\n                term.vi_motion(*motion);\n            }\n            InternalEvent::FindHyperlink(position, open) => {\n                trace!(": "",
        ");\n                let prev_hovered_word = self.last_content.last_hovered_word.take();\n\n                let point = grid_point(\n                    *position,\n                    self.last_content.terminal_bounds,\n                    term.grid().display_offset(),\n                )\n                .grid_clamp(term, Boundary::Grid);\n\n                match terminal_hyperlinks::find_from_grid_point(\n                    term,\n                    point,\n                    &mut self.hyperlink_regex_searches,\n                ) {\n                    Some((maybe_url_or_path, is_url, url_match)) => {\n                        let target = if is_url {\n                            // Treat ": "",
        " URLs like file paths to ensure\n                            // that line numbers at the end of the path are\n                            // handled correctly.\n                            // file://{path} should be urldecoded, returning a urldecoded {path}\n                            if let Some(path) = maybe_url_or_path.strip_prefix(": "",
        ") {\n                                let decoded_path = urlencoding::decode(path)\n                                    .map(|decoded| decoded.into_owned())\n                                    .unwrap_or(path.to_owned());\n\n                                MaybeNavigationTarget::PathLike(PathLikeTarget {\n                                    maybe_path: decoded_path,\n                                    terminal_dir: self.working_directory(),\n                                })\n                            } else {\n                                MaybeNavigationTarget::Url(maybe_url_or_path.clone())\n                            }\n                        } else {\n                            MaybeNavigationTarget::PathLike(PathLikeTarget {\n                                maybe_path: maybe_url_or_path.clone(),\n                                terminal_dir: self.working_directory(),\n                            })\n                        };\n                        if *open {\n                            cx.emit(Event::Open(target));\n                        } else {\n                            self.update_selected_word(\n                                prev_hovered_word,\n                                url_match,\n                                maybe_url_or_path,\n                                target,\n                                cx,\n                            );\n                        }\n                    }\n                    None => {\n                        cx.emit(Event::NewNavigationTarget(None));\n                    }\n                }\n            }\n        }\n    }\n\n    fn update_selected_word(\n        &mut self,\n        prev_word: Option<HoveredWord>,\n        word_match: RangeInclusive<AlacPoint>,\n        word: String,\n        navigation_target: MaybeNavigationTarget,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(prev_word) = prev_word\n            && prev_word.word == word\n            && prev_word.word_match == word_match\n        {\n            self.last_content.last_hovered_word = Some(HoveredWord {\n                word,\n                word_match,\n                id: prev_word.id,\n            });\n            return;\n        }\n\n        self.last_content.last_hovered_word = Some(HoveredWord {\n            word,\n            word_match,\n            id: self.next_link_id(),\n        });\n        cx.emit(Event::NewNavigationTarget(Some(navigation_target)));\n        cx.notify()\n    }\n\n    fn next_link_id(&mut self) -> usize {\n        let res = self.next_link_id;\n        self.next_link_id = self.next_link_id.wrapping_add(1);\n        res\n    }\n\n    pub fn last_content(&self) -> &TerminalContent {\n        &self.last_content\n    }\n\n    pub fn set_cursor_shape(&mut self, cursor_shape: CursorShape) {\n        self.term_config.default_cursor_style = cursor_shape.into();\n        self.term.lock().set_options(self.term_config.clone());\n    }\n\n    pub fn write_output(&mut self, bytes: &[u8], cx: &mut Context<Self>) {\n        // Inject bytes directly into the terminal emulator and refresh the UI.\n        // This bypasses the PTY/event loop for display-only terminals.\n        //\n        // We first convert LF to CRLF, to get the expected line wrapping in Alacritty.\n        // When output comes from piped commands (not a PTY) such as codex-acp, and that\n        // output only contains LF (\\n) without a CR (\\r) after it, such as the output\n        // of the `ls` command when running outside a PTY, Alacritty moves the cursor\n        // cursor down a line but does not move it back to the initial column. This makes\n        // the rendered output look ridiculous. To prevent this, we insert a CR (\\r) before\n        // each LF that didn't already have one. (Alacritty doesn't have a setting for this.)\n        let mut converted = Vec::with_capacity(bytes.len());\n        let mut prev_byte = 0u8;\n        for &byte in bytes {\n            if byte == b'\\n' && prev_byte != b'\\r' {\n                converted.push(b'\\r');\n            }\n            converted.push(byte);\n            prev_byte = byte;\n        }\n\n        let mut processor = alacritty_terminal::vte::ansi::Processor::<\n            alacritty_terminal::vte::ansi::StdSyncHandler,\n        >::new();\n        {\n            let mut term = self.term.lock();\n            processor.advance(&mut *term, &converted);\n        }\n        cx.emit(Event::Wakeup);\n    }\n\n    pub fn total_lines(&self) -> usize {\n        self.term.lock_unfair().total_lines()\n    }\n\n    pub fn viewport_lines(&self) -> usize {\n        self.term.lock_unfair().screen_lines()\n    }\n\n    //To test:\n    //- Activate match on terminal (scrolling and selection)\n    //- Editor search snapping behavior\n\n    pub fn activate_match(&mut self, index: usize) {\n        if let Some(search_match) = self.matches.get(index).cloned() {\n            self.set_selection(Some((make_selection(&search_match), *search_match.end())));\n            if self.vi_mode_enabled {\n                self.events\n                    .push_back(InternalEvent::MoveViCursorToAlacPoint(*search_match.end()));\n            } else {\n                self.events\n                    .push_back(InternalEvent::ScrollToAlacPoint(*search_match.start()));\n            }\n        }\n    }\n\n    pub fn select_matches(&mut self, matches: &[RangeInclusive<AlacPoint>]) {\n        let matches_to_select = self\n            .matches\n            .iter()\n            .filter(|self_match| matches.contains(self_match))\n            .cloned()\n            .collect::<Vec<_>>();\n        for match_to_select in matches_to_select {\n            self.set_selection(Some((\n                make_selection(&match_to_select),\n                *match_to_select.end(),\n            )));\n        }\n    }\n\n    pub fn select_all(&mut self) {\n        let term = self.term.lock();\n        let start = AlacPoint::new(term.topmost_line(), Column(0));\n        let end = AlacPoint::new(term.bottommost_line(), term.last_column());\n        drop(term);\n        self.set_selection(Some((make_selection(&(start..=end)), end)));\n    }\n\n    fn set_selection(&mut self, selection: Option<(Selection, AlacPoint)>) {\n        self.events\n            .push_back(InternalEvent::SetSelection(selection));\n    }\n\n    pub fn copy(&mut self, keep_selection: Option<bool>) {\n        self.events.push_back(InternalEvent::Copy(keep_selection));\n    }\n\n    pub fn clear(&mut self) {\n        self.events.push_back(InternalEvent::Clear)\n    }\n\n    pub fn scroll_line_up(&mut self) {\n        self.events\n            .push_back(InternalEvent::Scroll(AlacScroll::Delta(1)));\n    }\n\n    pub fn scroll_up_by(&mut self, lines: usize) {\n        self.events\n            .push_back(InternalEvent::Scroll(AlacScroll::Delta(lines as i32)));\n    }\n\n    pub fn scroll_line_down(&mut self) {\n        self.events\n            .push_back(InternalEvent::Scroll(AlacScroll::Delta(-1)));\n    }\n\n    pub fn scroll_down_by(&mut self, lines: usize) {\n        self.events\n            .push_back(InternalEvent::Scroll(AlacScroll::Delta(-(lines as i32))));\n    }\n\n    pub fn scroll_page_up(&mut self) {\n        self.events\n            .push_back(InternalEvent::Scroll(AlacScroll::PageUp));\n    }\n\n    pub fn scroll_page_down(&mut self) {\n        self.events\n            .push_back(InternalEvent::Scroll(AlacScroll::PageDown));\n    }\n\n    pub fn scroll_to_top(&mut self) {\n        self.events\n            .push_back(InternalEvent::Scroll(AlacScroll::Top));\n    }\n\n    pub fn scroll_to_bottom(&mut self) {\n        self.events\n            .push_back(InternalEvent::Scroll(AlacScroll::Bottom));\n    }\n\n    pub fn scrolled_to_top(&self) -> bool {\n        self.last_content.scrolled_to_top\n    }\n\n    pub fn scrolled_to_bottom(&self) -> bool {\n        self.last_content.scrolled_to_bottom\n    }\n\n    ///Resize the terminal and the PTY.\n    pub fn set_size(&mut self, new_bounds: TerminalBounds) {\n        if self.last_content.terminal_bounds != new_bounds {\n            self.events.push_back(InternalEvent::Resize(new_bounds))\n        }\n    }\n\n    /// Write the Input payload to the PTY, if applicable.\n    /// (This is a no-op for display-only terminals.)\n    fn write_to_pty(&self, input: impl Into<Cow<'static, [u8]>>) {\n        if let TerminalType::Pty { pty_tx, .. } = &self.terminal_type {\n            pty_tx.notify(input.into());\n        }\n    }\n\n    pub fn input(&mut self, input: impl Into<Cow<'static, [u8]>>) {\n        self.events\n            .push_back(InternalEvent::Scroll(AlacScroll::Bottom));\n        self.events.push_back(InternalEvent::SetSelection(None));\n\n        self.write_to_pty(input);\n    }\n\n    pub fn toggle_vi_mode(&mut self) {\n        self.events.push_back(InternalEvent::ToggleViMode);\n    }\n\n    pub fn vi_motion(&mut self, keystroke: &Keystroke) {\n        if !self.vi_mode_enabled {\n            return;\n        }\n\n        let key: Cow<'_, str> = if keystroke.modifiers.shift {\n            Cow::Owned(keystroke.key.to_uppercase())\n        } else {\n            Cow::Borrowed(keystroke.key.as_str())\n        };\n\n        let motion: Option<ViMotion> = match key.as_ref() {\n            ": "",
        " | ": "",
        " => Some(ViMotion::Left),\n            ": "",
        " => Some(ViMotion::Down),\n            ": "",
        " => Some(ViMotion::Up),\n            ": "",
        " => Some(ViMotion::Right),\n            ": "",
        " => Some(ViMotion::WordRight),\n            ": "",
        " if !keystroke.modifiers.control => Some(ViMotion::WordLeft),\n            ": "",
        " => Some(ViMotion::WordRightEnd),\n            ": "",
        " => Some(ViMotion::Bracket),\n            ": "",
        " => Some(ViMotion::Last),\n            ": "",
        " => Some(ViMotion::First),\n            ": "",
        " => Some(ViMotion::FirstOccupied),\n            ": "",
        " => Some(ViMotion::High),\n            ": "",
        " => Some(ViMotion::Middle),\n            ": "",
        " => Some(ViMotion::Low),\n            _ => None,\n        };\n\n        if let Some(motion) = motion {\n            let cursor = self.last_content.cursor.point;\n            let cursor_pos = Point {\n                x: cursor.column.0 as f32 * self.last_content.terminal_bounds.cell_width,\n                y: cursor.line.0 as f32 * self.last_content.terminal_bounds.line_height,\n            };\n            self.events\n                .push_back(InternalEvent::UpdateSelection(cursor_pos));\n            self.events.push_back(InternalEvent::ViMotion(motion));\n            return;\n        }\n\n        let scroll_motion = match key.as_ref() {\n            ": "",
        " => Some(AlacScroll::Top),\n            ": "",
        " => Some(AlacScroll::Bottom),\n            ": "",
        " if keystroke.modifiers.control => Some(AlacScroll::PageUp),\n            ": "",
        " if keystroke.modifiers.control => Some(AlacScroll::PageDown),\n            ": "",
        " if keystroke.modifiers.control => {\n                let amount = self.last_content.terminal_bounds.line_height().to_f64() as i32 / 2;\n                Some(AlacScroll::Delta(-amount))\n            }\n            ": "",
        " if keystroke.modifiers.control => {\n                let amount = self.last_content.terminal_bounds.line_height().to_f64() as i32 / 2;\n                Some(AlacScroll::Delta(amount))\n            }\n            _ => None,\n        };\n\n        if let Some(scroll_motion) = scroll_motion {\n            self.events.push_back(InternalEvent::Scroll(scroll_motion));\n            return;\n        }\n\n        match key.as_ref() {\n            ": "",
        " => {\n                let point = self.last_content.cursor.point;\n                let selection_type = SelectionType::Simple;\n                let side = AlacDirection::Right;\n                let selection = Selection::new(selection_type, point, side);\n                self.events\n                    .push_back(InternalEvent::SetSelection(Some((selection, point))));\n            }\n\n            ": "",
        " => {\n                self.events.push_back(InternalEvent::SetSelection(None));\n            }\n\n            ": "",
        " => {\n                self.copy(Some(false));\n            }\n\n            ": "",
        " => {\n                self.scroll_to_bottom();\n                self.toggle_vi_mode();\n            }\n            _ => {}\n        }\n    }\n\n    pub fn try_keystroke(&mut self, keystroke: &Keystroke, option_as_meta: bool) -> bool {\n        if self.vi_mode_enabled {\n            self.vi_motion(keystroke);\n            return true;\n        }\n\n        // Keep default terminal behavior\n        let esc = to_esc_str(keystroke, &self.last_content.mode, option_as_meta);\n        if let Some(esc) = esc {\n            match esc {\n                Cow::Borrowed(string) => self.input(string.as_bytes()),\n                Cow::Owned(string) => self.input(string.into_bytes()),\n            };\n            true\n        } else {\n            false\n        }\n    }\n\n    pub fn try_modifiers_change(\n        &mut self,\n        modifiers: &Modifiers,\n        window: &Window,\n        cx: &mut Context<Self>,\n    ) {\n        if self\n            .last_content\n            .terminal_bounds\n            .bounds\n            .contains(&window.mouse_position())\n            && modifiers.secondary()\n        {\n            self.refresh_hovered_word(window);\n        }\n        cx.notify();\n    }\n\n    ///Paste text into the terminal\n    pub fn paste(&mut self, text: &str) {\n        let paste_text = if self.last_content.mode.contains(TermMode::BRACKETED_PASTE) {\n            format!(": "",
        ", ": "",
        ", text.replace('\\x1b', ": "",
        "), ": "",
        ")\n        } else {\n            text.replace(": "",
        ").replace('\\n', ": "",
        ")\n        };\n\n        self.input(paste_text.into_bytes());\n    }\n\n    pub fn sync(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n        let term = self.term.clone();\n        let mut terminal = term.lock_unfair();\n        //Note that the ordering of events matters for event processing\n        while let Some(e) = self.events.pop_front() {\n            self.process_terminal_event(&e, &mut terminal, window, cx)\n        }\n\n        self.last_content = Self::make_content(&terminal, &self.last_content);\n    }\n\n    fn make_content(term: &Term<ZedListener>, last_content: &TerminalContent) -> TerminalContent {\n        let content = term.renderable_content();\n\n        // Pre-allocate with estimated size to reduce reallocations\n        let estimated_size = content.display_iter.size_hint().0;\n        let mut cells = Vec::with_capacity(estimated_size);\n\n        cells.extend(content.display_iter.map(|ic| IndexedCell {\n            point: ic.point,\n            cell: ic.cell.clone(),\n        }));\n\n        let selection_text = if content.selection.is_some() {\n            term.selection_to_string()\n        } else {\n            None\n        };\n\n        TerminalContent {\n            cells,\n            mode: content.mode,\n            display_offset: content.display_offset,\n            selection_text,\n            selection: content.selection,\n            cursor: content.cursor,\n            cursor_char: term.grid()[content.cursor.point].c,\n            terminal_bounds: last_content.terminal_bounds,\n            last_hovered_word: last_content.last_hovered_word.clone(),\n            scrolled_to_top: content.display_offset == term.history_size(),\n            scrolled_to_bottom: content.display_offset == 0,\n        }\n    }\n\n    pub fn get_content(&self) -> String {\n        let term = self.term.lock_unfair();\n        let start = AlacPoint::new(term.topmost_line(), Column(0));\n        let end = AlacPoint::new(term.bottommost_line(), term.last_column());\n        term.bounds_to_string(start, end)\n    }\n\n    pub fn last_n_non_empty_lines(&self, n: usize) -> Vec<String> {\n        let term = self.term.clone();\n        let terminal = term.lock_unfair();\n        let grid = terminal.grid();\n        let mut lines = Vec::new();\n\n        let mut current_line = grid.bottommost_line().0;\n        let topmost_line = grid.topmost_line().0;\n\n        while current_line >= topmost_line && lines.len() < n {\n            let logical_line_start = self.find_logical_line_start(grid, current_line, topmost_line);\n            let logical_line = self.construct_logical_line(grid, logical_line_start, current_line);\n\n            if let Some(line) = self.process_line(logical_line) {\n                lines.push(line);\n            }\n\n            // Move to the line above the start of the current logical line\n            current_line = logical_line_start - 1;\n        }\n\n        lines.reverse();\n        lines\n    }\n\n    fn find_logical_line_start(&self, grid: &Grid<Cell>, current: i32, topmost: i32) -> i32 {\n        let mut line_start = current;\n        while line_start > topmost {\n            let prev_line = Line(line_start - 1);\n            let last_cell = &grid[prev_line][Column(grid.columns() - 1)];\n            if !last_cell.flags.contains(Flags::WRAPLINE) {\n                break;\n            }\n            line_start -= 1;\n        }\n        line_start\n    }\n\n    fn construct_logical_line(&self, grid: &Grid<Cell>, start: i32, end: i32) -> String {\n        let mut logical_line = String::new();\n        for row in start..=end {\n            let grid_row = &grid[Line(row)];\n            logical_line.push_str(&row_to_string(grid_row));\n        }\n        logical_line\n    }\n\n    fn process_line(&self, line: String) -> Option<String> {\n        let trimmed = line.trim_end().to_string();\n        if !trimmed.is_empty() {\n            Some(trimmed)\n        } else {\n            None\n        }\n    }\n\n    pub fn focus_in(&self) {\n        if self.last_content.mode.contains(TermMode::FOCUS_IN_OUT) {\n            self.write_to_pty(": "",
        ".as_bytes());\n        }\n    }\n\n    pub fn focus_out(&mut self) {\n        if self.last_content.mode.contains(TermMode::FOCUS_IN_OUT) {\n            self.write_to_pty(": "",
        ".as_bytes());\n        }\n    }\n\n    pub fn mouse_changed(&mut self, point: AlacPoint, side: AlacDirection) -> bool {\n        match self.last_mouse {\n            Some((old_point, old_side)) => {\n                if old_point == point && old_side == side {\n                    false\n                } else {\n                    self.last_mouse = Some((point, side));\n                    true\n                }\n            }\n            None => {\n                self.last_mouse = Some((point, side));\n                true\n            }\n        }\n    }\n\n    pub fn mouse_mode(&self, shift: bool) -> bool {\n        self.last_content.mode.intersects(TermMode::MOUSE_MODE) && !shift\n    }\n\n    pub fn mouse_move(&mut self, e: &MouseMoveEvent, cx: &mut Context<Self>) {\n        let position = e.position - self.last_content.terminal_bounds.bounds.origin;\n        if self.mouse_mode(e.modifiers.shift) {\n            let (point, side) = grid_point_and_side(\n                position,\n                self.last_content.terminal_bounds,\n                self.last_content.display_offset,\n            );\n\n            if self.mouse_changed(point, side)\n                && let Some(bytes) =\n                    mouse_moved_report(point, e.pressed_button, e.modifiers, self.last_content.mode)\n            {\n                self.write_to_pty(bytes);\n            }\n        } else if e.modifiers.secondary() {\n            self.word_from_position(e.position);\n        }\n        cx.notify();\n    }\n\n    fn word_from_position(&mut self, position: Point<Pixels>) {\n        if self.selection_phase == SelectionPhase::Selecting {\n            self.last_content.last_hovered_word = None;\n        } else if self.last_content.terminal_bounds.bounds.contains(&position) {\n            // Throttle hyperlink searches to avoid excessive processing\n            let now = Instant::now();\n            let should_search = if let Some(last_pos) = self.last_hyperlink_search_position {\n                // Only search if mouse moved significantly or enough time passed\n                let distance_moved =\n                    ((position.x - last_pos.x).abs() + (position.y - last_pos.y).abs()) > px(5.0);\n                let time_elapsed = now.duration_since(self.last_mouse_move_time).as_millis() > 100;\n                distance_moved || time_elapsed\n            } else {\n                true\n            };\n\n            if should_search {\n                self.last_mouse_move_time = now;\n                self.last_hyperlink_search_position = Some(position);\n                self.events.push_back(InternalEvent::FindHyperlink(\n                    position - self.last_content.terminal_bounds.bounds.origin,\n                    false,\n                ));\n            }\n        } else {\n            self.last_content.last_hovered_word = None;\n        }\n    }\n\n    pub fn select_word_at_event_position(&mut self, e: &MouseDownEvent) {\n        let position = e.position - self.last_content.terminal_bounds.bounds.origin;\n        let (point, side) = grid_point_and_side(\n            position,\n            self.last_content.terminal_bounds,\n            self.last_content.display_offset,\n        );\n        let selection = Selection::new(SelectionType::Semantic, point, side);\n        self.events\n            .push_back(InternalEvent::SetSelection(Some((selection, point))));\n    }\n\n    pub fn mouse_drag(\n        &mut self,\n        e: &MouseMoveEvent,\n        region: Bounds<Pixels>,\n        cx: &mut Context<Self>,\n    ) {\n        let position = e.position - self.last_content.terminal_bounds.bounds.origin;\n        if !self.mouse_mode(e.modifiers.shift) {\n            self.selection_phase = SelectionPhase::Selecting;\n            // Alacritty has the same ordering, of first updating the selection\n            // then scrolling 15ms later\n            self.events\n                .push_back(InternalEvent::UpdateSelection(position));\n\n            // Doesn't make sense to scroll the alt screen\n            if !self.last_content.mode.contains(TermMode::ALT_SCREEN) {\n                let scroll_lines = match self.drag_line_delta(e, region) {\n                    Some(value) => value,\n                    None => return,\n                };\n\n                self.events\n                    .push_back(InternalEvent::Scroll(AlacScroll::Delta(scroll_lines)));\n            }\n\n            cx.notify();\n        }\n    }\n\n    fn drag_line_delta(&self, e: &MouseMoveEvent, region: Bounds<Pixels>) -> Option<i32> {\n        let top = region.origin.y;\n        let bottom = region.bottom_left().y;\n\n        let scroll_lines = if e.position.y < top {\n            let scroll_delta = (top - e.position.y).pow(1.1);\n            (scroll_delta / self.last_content.terminal_bounds.line_height).ceil() as i32\n        } else if e.position.y > bottom {\n            let scroll_delta = -((e.position.y - bottom).pow(1.1));\n            (scroll_delta / self.last_content.terminal_bounds.line_height).floor() as i32\n        } else {\n            return None;\n        };\n\n        Some(scroll_lines.clamp(-3, 3))\n    }\n\n    pub fn mouse_down(&mut self, e: &MouseDownEvent, _cx: &mut Context<Self>) {\n        let position = e.position - self.last_content.terminal_bounds.bounds.origin;\n        let point = grid_point(\n            position,\n            self.last_content.terminal_bounds,\n            self.last_content.display_offset,\n        );\n\n        if self.mouse_mode(e.modifiers.shift) {\n            if let Some(bytes) =\n                mouse_button_report(point, e.button, e.modifiers, true, self.last_content.mode)\n            {\n                self.write_to_pty(bytes);\n            }\n        } else {\n            match e.button {\n                MouseButton::Left => {\n                    let (point, side) = grid_point_and_side(\n                        position,\n                        self.last_content.terminal_bounds,\n                        self.last_content.display_offset,\n                    );\n\n                    let selection_type = match e.click_count {\n                        0 => return, //This is a release\n                        1 => Some(SelectionType::Simple),\n                        2 => Some(SelectionType::Semantic),\n                        3 => Some(SelectionType::Lines),\n                        _ => None,\n                    };\n\n                    if selection_type == Some(SelectionType::Simple) && e.modifiers.shift {\n                        self.events\n                            .push_back(InternalEvent::UpdateSelection(position));\n                        return;\n                    }\n\n                    let selection = selection_type\n                        .map(|selection_type| Selection::new(selection_type, point, side));\n\n                    if let Some(sel) = selection {\n                        self.events\n                            .push_back(InternalEvent::SetSelection(Some((sel, point))));\n                    }\n                }\n                #[cfg(any(target_os = ": "",
        "))]\n                MouseButton::Middle => {\n                    if let Some(item) = _cx.read_from_primary() {\n                        let text = item.text().unwrap_or_default();\n                        self.input(text.into_bytes());\n                    }\n                }\n                _ => {}\n            }\n        }\n    }\n\n    pub fn mouse_up(&mut self, e: &MouseUpEvent, cx: &Context<Self>) {\n        let setting = TerminalSettings::get_global(cx);\n\n        let position = e.position - self.last_content.terminal_bounds.bounds.origin;\n        if self.mouse_mode(e.modifiers.shift) {\n            let point = grid_point(\n                position,\n                self.last_content.terminal_bounds,\n                self.last_content.display_offset,\n            );\n\n            if let Some(bytes) =\n                mouse_button_report(point, e.button, e.modifiers, false, self.last_content.mode)\n            {\n                self.write_to_pty(bytes);\n            }\n        } else {\n            if e.button == MouseButton::Left && setting.copy_on_select {\n                self.copy(Some(true));\n            }\n\n            //Hyperlinks\n            if self.selection_phase == SelectionPhase::Ended {\n                let mouse_cell_index =\n                    content_index_for_mouse(position, &self.last_content.terminal_bounds);\n                if let Some(link) = self.last_content.cells[mouse_cell_index].hyperlink() {\n                    cx.open_url(link.uri());\n                } else if e.modifiers.secondary() {\n                    self.events\n                        .push_back(InternalEvent::FindHyperlink(position, true));\n                }\n            }\n        }\n\n        self.selection_phase = SelectionPhase::Ended;\n        self.last_mouse = None;\n    }\n\n    ///Scroll the terminal\n    pub fn scroll_wheel(&mut self, e: &ScrollWheelEvent) {\n        let mouse_mode = self.mouse_mode(e.shift);\n\n        if let Some(scroll_lines) = self.determine_scroll_lines(e, mouse_mode) {\n            if mouse_mode {\n                let point = grid_point(\n                    e.position - self.last_content.terminal_bounds.bounds.origin,\n                    self.last_content.terminal_bounds,\n                    self.last_content.display_offset,\n                );\n\n                if let Some(scrolls) = scroll_report(point, scroll_lines, e, self.last_content.mode)\n                {\n                    for scroll in scrolls {\n                        self.write_to_pty(scroll);\n                    }\n                };\n            } else if self\n                .last_content\n                .mode\n                .contains(TermMode::ALT_SCREEN | TermMode::ALTERNATE_SCROLL)\n                && !e.shift\n            {\n                self.write_to_pty(alt_scroll(scroll_lines));\n            } else if scroll_lines != 0 {\n                let scroll = AlacScroll::Delta(scroll_lines);\n\n                self.events.push_back(InternalEvent::Scroll(scroll));\n            }\n        }\n    }\n\n    fn refresh_hovered_word(&mut self, window: &Window) {\n        self.word_from_position(window.mouse_position());\n    }\n\n    fn determine_scroll_lines(&mut self, e: &ScrollWheelEvent, mouse_mode: bool) -> Option<i32> {\n        let scroll_multiplier = if mouse_mode { 1. } else { SCROLL_MULTIPLIER };\n        let line_height = self.last_content.terminal_bounds.line_height;\n        match e.touch_phase {\n            /* Reset scroll state on started */\n            TouchPhase::Started => {\n                self.scroll_px = px(0.);\n                None\n            }\n            /* Calculate the appropriate scroll lines */\n            TouchPhase::Moved => {\n                let old_offset = (self.scroll_px / line_height) as i32;\n\n                self.scroll_px += e.delta.pixel_delta(line_height).y * scroll_multiplier;\n\n                let new_offset = (self.scroll_px / line_height) as i32;\n\n                // Whenever we hit the edges, reset our stored scroll to 0\n                // so we can respond to changes in direction quickly\n                self.scroll_px %= self.last_content.terminal_bounds.height();\n\n                Some(new_offset - old_offset)\n            }\n            TouchPhase::Ended => None,\n        }\n    }\n\n    pub fn find_matches(\n        &self,\n        mut searcher: RegexSearch,\n        cx: &Context<Self>,\n    ) -> Task<Vec<RangeInclusive<AlacPoint>>> {\n        let term = self.term.clone();\n        cx.background_spawn(async move {\n            let term = term.lock();\n\n            all_search_matches(&term, &mut searcher).collect()\n        })\n    }\n\n    pub fn working_directory(&self) -> Option<PathBuf> {\n        if self.is_remote_terminal {\n            // We can't yet reliably detect the working directory of a shell on the\n            // SSH host. Until we can do that, it doesn't make sense to display\n            // the working directory on the client and persist that.\n            None\n        } else {\n            self.client_side_working_directory()\n        }\n    }\n\n    /// Returns the working directory of the process that's connected to the PTY.\n    /// That means it returns the working directory of the local shell or program\n    /// that's running inside the terminal.\n    ///\n    /// This does *not* return the working directory of the shell that runs on the\n    /// remote host, in case Zed is connected to a remote host.\n    fn client_side_working_directory(&self) -> Option<PathBuf> {\n        match &self.terminal_type {\n            TerminalType::Pty { info, .. } => {\n                info.current.as_ref().map(|process| process.cwd.clone())\n            }\n            TerminalType::DisplayOnly => None,\n        }\n    }\n\n    pub fn title(&self, truncate: bool) -> String {\n        const MAX_CHARS: usize = 25;\n        match &self.task {\n            Some(task_state) => {\n                if truncate {\n                    truncate_and_trailoff(&task_state.spawned_task.label, MAX_CHARS)\n                } else {\n                    task_state.spawned_task.full_label.clone()\n                }\n            }\n            None => self\n                .title_override\n                .as_ref()\n                .map(|title_override| title_override.to_string())\n                .unwrap_or_else(|| match &self.terminal_type {\n                    TerminalType::Pty { info, .. } => info\n                        .current\n                        .as_ref()\n                        .map(|fpi| {\n                            let process_file = fpi\n                                .cwd\n                                .file_name()\n                                .map(|name| name.to_string_lossy().into_owned())\n                                .unwrap_or_default();\n\n                            let argv = fpi.argv.as_slice();\n                            let process_name = format!(\n                                ": "",
        ",\n                                fpi.name,\n                                if !argv.is_empty() {\n                                    format!(": "",
        ", (argv[1..]).join(": "",
        "))\n                                } else {\n                                    ": "",
        ".to_string()\n                                }\n                            );\n                            let (process_file, process_name) = if truncate {\n                                (\n                                    truncate_and_trailoff(&process_file, MAX_CHARS),\n                                    truncate_and_trailoff(&process_name, MAX_CHARS),\n                                )\n                            } else {\n                                (process_file, process_name)\n                            };\n                            format!(": "",
        ")\n                        })\n                        .unwrap_or_else(|| ": "",
        ".to_string()),\n                    TerminalType::DisplayOnly => ": "",
        ".to_string(),\n                }),\n        }\n    }\n\n    pub fn kill_active_task(&mut self) {\n        if let Some(task) = self.task()\n            && task.status == TaskStatus::Running\n        {\n            if let TerminalType::Pty { info, .. } = &mut self.terminal_type {\n                info.kill_current_process();\n            }\n        }\n    }\n\n    pub fn pid(&self) -> Option<sysinfo::Pid> {\n        match &self.terminal_type {\n            TerminalType::Pty { info, .. } => info.pid(),\n            TerminalType::DisplayOnly => None,\n        }\n    }\n\n    pub fn pid_getter(&self) -> Option<&ProcessIdGetter> {\n        match &self.terminal_type {\n            TerminalType::Pty { info, .. } => Some(info.pid_getter()),\n            TerminalType::DisplayOnly => None,\n        }\n    }\n\n    pub fn task(&self) -> Option<&TaskState> {\n        self.task.as_ref()\n    }\n\n    pub fn wait_for_completed_task(&self, cx: &App) -> Task<Option<ExitStatus>> {\n        if let Some(task) = self.task() {\n            if task.status == TaskStatus::Running {\n                let completion_receiver = task.completion_rx.clone();\n                return cx.spawn(async move |_| completion_receiver.recv().await.ok().flatten());\n            } else if let Ok(status) = task.completion_rx.try_recv() {\n                return Task::ready(status);\n            }\n        }\n        Task::ready(None)\n    }\n\n    fn register_task_finished(&mut self, error_code: Option<i32>, cx: &mut Context<Terminal>) {\n        let e: Option<ExitStatus> = error_code.map(|code| {\n            #[cfg(unix)]\n            {\n                std::os::unix::process::ExitStatusExt::from_raw(code)\n            }\n            #[cfg(windows)]\n            {\n                std::os::windows::process::ExitStatusExt::from_raw(code as u32)\n            }\n        });\n\n        if let Some(tx) = &self.completion_tx {\n            tx.try_send(e).ok();\n        }\n        if let Some(e) = e {\n            self.child_exited = Some(e);\n        }\n        let task = match &mut self.task {\n            Some(task) => task,\n            None => {\n                if self.child_exited.is_none_or(|e| e.code() == Some(0)) {\n                    cx.emit(Event::CloseTerminal);\n                }\n                return;\n            }\n        };\n        if task.status != TaskStatus::Running {\n            return;\n        }\n        match error_code {\n            Some(error_code) => {\n                task.status.register_task_exit(error_code);\n            }\n            None => {\n                task.status.register_terminal_exit();\n            }\n        };\n\n        let (finished_successfully, task_line, command_line) = task_summary(task, error_code);\n        let mut lines_to_show = Vec::new();\n        if task.spawned_task.show_summary {\n            lines_to_show.push(task_line.as_str());\n        }\n        if task.spawned_task.show_command {\n            lines_to_show.push(command_line.as_str());\n        }\n\n        if !lines_to_show.is_empty() {\n            // SAFETY: the invocation happens on non `TaskStatus::Running` tasks, once,\n            // after either `AlacTermEvent::Exit` or `AlacTermEvent::ChildExit` events that are spawned\n            // when Zed task finishes and no more output is made.\n            // After the task summary is output once, no more text is appended to the terminal.\n            unsafe { append_text_to_term(&mut self.term.lock(), &lines_to_show) };\n        }\n\n        match task.spawned_task.hide {\n            HideStrategy::Never => {}\n            HideStrategy::Always => {\n                cx.emit(Event::CloseTerminal);\n            }\n            HideStrategy::OnSuccess => {\n                if finished_successfully {\n                    cx.emit(Event::CloseTerminal);\n                }\n            }\n        }\n    }\n\n    pub fn vi_mode_enabled(&self) -> bool {\n        self.vi_mode_enabled\n    }\n\n    pub fn clone_builder(&self, cx: &App, cwd: Option<PathBuf>) -> Task<Result<TerminalBuilder>> {\n        let working_directory = self.working_directory().or_else(|| cwd);\n        TerminalBuilder::new(\n            working_directory,\n            None,\n            self.template.shell.clone(),\n            self.template.env.clone(),\n            self.template.cursor_shape,\n            self.template.alternate_scroll,\n            self.template.max_scroll_history_lines,\n            self.is_remote_terminal,\n            self.template.window_id,\n            None,\n            cx,\n            self.activation_script.clone(),\n        )\n    }\n}\n\n// Helper function to convert a grid row to a string\npub fn row_to_string(row: &Row<Cell>) -> String {\n    row[..Column(row.len())]\n        .iter()\n        .map(|cell| cell.c)\n        .collect::<String>()\n}\n\nconst TASK_DELIMITER: &str = ": "",
        ";\nfn task_summary(task: &TaskState, error_code: Option<i32>) -> (bool, String, String) {\n    let escaped_full_label = task\n        .spawned_task\n        .full_label\n        .replace(": "",
        ")\n        .replace('\\n', ": "",
        ");\n    let success = error_code == Some(0);\n    let task_line = match error_code {\n        Some(0) => format!(": "",
        "),\n        Some(error_code) => format!(\n            ": "",
        "\n        ),\n        None => format!(": "",
        "),\n    };\n    let escaped_command_label = task\n        .spawned_task\n        .command_label\n        .replace(": "",
        ");\n    let command_line = format!(": "",
        ");\n    (success, task_line, command_line)\n}\n\n/// Appends a stringified task summary to the terminal, after its output.\n///\n/// SAFETY: This function should only be called after terminal's PTY is no longer alive.\n/// New text being added to the terminal here, uses ": "",
        " APIs,\n/// which are not maintaining the entire terminal state intact.\n///\n///\n/// The library\n///\n/// * does not increment inner grid cursor's _lines_ on `input` calls\n///   (but displaying the lines correctly and incrementing cursor's columns)\n///\n/// * ignores `\\n` and \\r` character input, requiring the `newline` call instead\n///\n/// * does not alter grid state after `newline` call\n///   so its `bottommost_line` is always the same additions, and\n///   the cursor's `point` is not updated to the new line and column values\n///\n/// * ??? there could be more consequences, and any further ": "",
        " streaming from the PTY might bug and/or panic.\n///   Still, subsequent `append_text_to_term` invocations are possible and display the contents correctly.\n///\n/// Despite the quirks, this is the simplest approach to appending text to the terminal: its alternative, `grid_mut` manipulations,\n/// do not properly set the scrolling state and display odd text after appending; also those manipulations are more tedious and error-prone.\n/// The function achieves proper display and scrolling capabilities, at a cost of grid state not properly synchronized.\n/// This is enough for printing moderately-sized texts like task summaries, but might break or perform poorly for larger texts.\nunsafe fn append_text_to_term(term: &mut Term<ZedListener>, text_lines: &[&str]) {\n    term.newline();\n    term.grid_mut().cursor.point.column = Column(0);\n    for line in text_lines {\n        for c in line.chars() {\n            term.input(c);\n        }\n        term.newline();\n        term.grid_mut().cursor.point.column = Column(0);\n    }\n}\n\nimpl Drop for Terminal {\n    fn drop(&mut self) {\n        if let TerminalType::Pty { pty_tx, info } = &mut self.terminal_type {\n            info.kill_child_process();\n            pty_tx.0.send(Msg::Shutdown).ok();\n        }\n    }\n}\n\nimpl EventEmitter<Event> for Terminal {}\n\nfn make_selection(range: &RangeInclusive<AlacPoint>) -> Selection {\n    let mut selection = Selection::new(SelectionType::Simple, *range.start(), AlacDirection::Left);\n    selection.update(*range.end(), AlacDirection::Right);\n    selection\n}\n\nfn all_search_matches<'a, T>(\n    term: &'a Term<T>,\n    regex: &'a mut RegexSearch,\n) -> impl Iterator<Item = Match> + 'a {\n    let start = AlacPoint::new(term.grid().topmost_line(), Column(0));\n    let end = AlacPoint::new(term.grid().bottommost_line(), term.grid().last_column());\n    RegexIter::new(start, end, AlacDirection::Right, term, regex)\n}\n\nfn content_index_for_mouse(pos: Point<Pixels>, terminal_bounds: &TerminalBounds) -> usize {\n    let col = (pos.x / terminal_bounds.cell_width()).round() as usize;\n    let clamped_col = min(col, terminal_bounds.columns() - 1);\n    let row = (pos.y / terminal_bounds.line_height()).round() as usize;\n    let clamped_row = min(row, terminal_bounds.screen_lines() - 1);\n    clamped_row * terminal_bounds.columns() + clamped_col\n}\n\n/// Converts an 8 bit ANSI color to its GPUI equivalent.\n/// Accepts `usize` for compatibility with the `alacritty::Colors` interface,\n/// Other than that use case, should only be called with values in the `[0,255]` range\npub fn get_color_at_index(index: usize, theme: &Theme) -> Hsla {\n    let colors = theme.colors();\n\n    match index {\n        // 0-15 are the same as the named colors above\n        0 => colors.terminal_ansi_black,\n        1 => colors.terminal_ansi_red,\n        2 => colors.terminal_ansi_green,\n        3 => colors.terminal_ansi_yellow,\n        4 => colors.terminal_ansi_blue,\n        5 => colors.terminal_ansi_magenta,\n        6 => colors.terminal_ansi_cyan,\n        7 => colors.terminal_ansi_white,\n        8 => colors.terminal_ansi_bright_black,\n        9 => colors.terminal_ansi_bright_red,\n        10 => colors.terminal_ansi_bright_green,\n        11 => colors.terminal_ansi_bright_yellow,\n        12 => colors.terminal_ansi_bright_blue,\n        13 => colors.terminal_ansi_bright_magenta,\n        14 => colors.terminal_ansi_bright_cyan,\n        15 => colors.terminal_ansi_bright_white,\n        // 16-231 are a 6x6x6 RGB color cube, mapped to 0-255 using steps defined by XTerm.\n        // See: https://github.com/xterm-x11/xterm-snapshots/blob/master/256colres.pl\n        16..=231 => {\n            let (r, g, b) = rgb_for_index(index as u8);\n            rgba_color(\n                if r == 0 { 0 } else { r * 40 + 55 },\n                if g == 0 { 0 } else { g * 40 + 55 },\n                if b == 0 { 0 } else { b * 40 + 55 },\n            )\n        }\n        // 232-255 are a 24-step grayscale ramp from (8, 8, 8) to (238, 238, 238).\n        232..=255 => {\n            let i = index as u8 - 232; // Align index to 0..24\n            let value = i * 10 + 8;\n            rgba_color(value, value, value)\n        }\n        // For compatibility with the alacritty::Colors interface\n        // See: https://github.com/alacritty/alacritty/blob/master/alacritty_terminal/src/term/color.rs\n        256 => colors.terminal_foreground,\n        257 => colors.terminal_background,\n        258 => theme.players().local().cursor,\n        259 => colors.terminal_ansi_dim_black,\n        260 => colors.terminal_ansi_dim_red,\n        261 => colors.terminal_ansi_dim_green,\n        262 => colors.terminal_ansi_dim_yellow,\n        263 => colors.terminal_ansi_dim_blue,\n        264 => colors.terminal_ansi_dim_magenta,\n        265 => colors.terminal_ansi_dim_cyan,\n        266 => colors.terminal_ansi_dim_white,\n        267 => colors.terminal_bright_foreground,\n        268 => colors.terminal_ansi_black, // 'Dim Background', non-standard color\n\n        _ => black(),\n    }\n}\n\n/// Generates the RGB channels in [0, 5] for a given index into the 6x6x6 ANSI color cube.\n///\n/// See: [8 bit ANSI color](https://en.wikipedia.org/wiki/ANSI_escape_code#8-bit).\n///\n/// Wikipedia gives a formula for calculating the index for a given color:\n///\n/// ```text\n/// index = 16 + 36 × r + 6 × g + b (0 ≤ r, g, b ≤ 5)\n/// ```\n///\n/// This function does the reverse, calculating the `r`, `g`, and `b` components from a given index.\nfn rgb_for_index(i: u8) -> (u8, u8, u8) {\n    debug_assert!((16..=231).contains(&i));\n    let i = i - 16;\n    let r = (i - (i % 36)) / 36;\n    let g = ((i % 36) - (i % 6)) / 6;\n    let b = (i % 36) % 6;\n    (r, g, b)\n}\n\npub fn rgba_color(r: u8, g: u8, b: u8) -> Hsla {\n    Rgba {\n        r: (r as f32 / 255.),\n        g: (g as f32 / 255.),\n        b: (b as f32 / 255.),\n        a: 1.,\n    }\n    .into()\n}\n\n#[cfg(test)]\nmod tests {\n    use std::time::Duration;\n\n    use super::*;\n    use crate::{\n        IndexedCell, TerminalBounds, TerminalBuilder, TerminalContent, content_index_for_mouse,\n        rgb_for_index,\n    };\n    use alacritty_terminal::{\n        index::{Column, Line, Point as AlacPoint},\n        term::cell::Cell,\n    };\n    use collections::HashMap;\n    use gpui::{Pixels, Point, TestAppContext, bounds, point, size, smol_timeout};\n    use rand::{Rng, distr, rngs::ThreadRng};\n    use task::ShellBuilder;\n\n    #[gpui::test]\n    async fn test_basic_terminal(cx: &mut TestAppContext) {\n        cx.executor().allow_parking();\n\n        let (completion_tx, completion_rx) = smol::channel::unbounded();\n        let (program, args) = ShellBuilder::new(&Shell::System, false)\n            .build(Some(": "",
        ".to_owned()), &[": "",
        ".to_owned()]);\n        let builder = cx\n            .update(|cx| {\n                TerminalBuilder::new(\n                    None,\n                    None,\n                    task::Shell::WithArguments {\n                        program,\n                        args,\n                        title_override: None,\n                    },\n                    HashMap::default(),\n                    CursorShape::default(),\n                    AlternateScroll::On,\n                    None,\n                    false,\n                    0,\n                    Some(completion_tx),\n                    cx,\n                    vec![],\n                )\n            })\n            .await\n            .unwrap();\n        let terminal = cx.new(|cx| builder.subscribe(cx));\n        assert_eq!(\n            completion_rx.recv().await.unwrap(),\n            Some(ExitStatus::default())\n        );\n        assert_eq!(\n            terminal.update(cx, |term, _| term.get_content()).trim(),\n            ": "",
        "\n        );\n\n        // Inject additional output directly into the emulator (display-only path)\n        terminal.update(cx, |term, cx| {\n            term.write_output(b": "",
        ", cx);\n        });\n\n        let content_after = terminal.update(cx, |term, _| term.get_content());\n        assert!(\n            content_after.contains(": "",
        "),\n            ": "",
        "\n        );\n    }\n\n    // TODO should be tested on Linux too, but does not work there well\n    #[cfg(target_os = ": "",
        ")]\n    #[gpui::test(iterations = 10)]\n    async fn test_terminal_eof(cx: &mut TestAppContext) {\n        cx.executor().allow_parking();\n\n        let (completion_tx, completion_rx) = smol::channel::unbounded();\n        let builder = cx\n            .update(|cx| {\n                TerminalBuilder::new(\n                    None,\n                    None,\n                    task::Shell::System,\n                    HashMap::default(),\n                    CursorShape::default(),\n                    AlternateScroll::On,\n                    None,\n                    false,\n                    0,\n                    Some(completion_tx),\n                    cx,\n                    Vec::new(),\n                )\n            })\n            .await\n            .unwrap();\n        // Build an empty command, which will result in a tty shell spawned.\n        let terminal = cx.new(|cx| builder.subscribe(cx));\n\n        let (event_tx, event_rx) = smol::channel::unbounded::<Event>();\n        cx.update(|cx| {\n            cx.subscribe(&terminal, move |_, e, _| {\n                event_tx.send_blocking(e.clone()).unwrap();\n            })\n        })\n        .detach();\n        cx.background_spawn(async move {\n            assert_eq!(\n                completion_rx.recv().await.unwrap(),\n                Some(ExitStatus::default()),\n                ": "",
        ",\n            );\n        })\n        .detach();\n\n        let first_event = Event::Wakeup;\n        let wakeup = event_rx.recv().await.expect(": "",
        ");\n        assert_eq!(wakeup, first_event, ": "",
        ");\n\n        terminal.update(cx, |terminal, _| {\n            let success = terminal.try_keystroke(&Keystroke::parse(": "",
        ").unwrap(), false);\n            assert!(success, ": "",
        ");\n        });\n        terminal.update(cx, |terminal, _| {\n            let success = terminal.try_keystroke(&Keystroke::parse(": "",
        ");\n        });\n\n        let mut all_events = vec![first_event];\n        while let Ok(Ok(new_event)) = smol_timeout(Duration::from_secs(1), event_rx.recv()).await {\n            all_events.push(new_event.clone());\n            if new_event == Event::CloseTerminal {\n                break;\n            }\n        }\n        assert!(\n            all_events.contains(&Event::CloseTerminal),\n            ": "",
        ",\n        );\n    }\n\n    #[gpui::test(iterations = 10)]\n    async fn test_terminal_no_exit_on_spawn_failure(cx: &mut TestAppContext) {\n        cx.executor().allow_parking();\n\n        let (completion_tx, completion_rx) = smol::channel::unbounded();\n        let (program, args) = ShellBuilder::new(&Shell::System, false)\n            .build(Some(": "",
        ".to_owned()]);\n        let builder = cx\n            .update(|cx| {\n                TerminalBuilder::new(\n                    None,\n                    None,\n                    task::Shell::WithArguments {\n                        program,\n                        args,\n                        title_override: None,\n                    },\n                    HashMap::default(),\n                    CursorShape::default(),\n                    AlternateScroll::On,\n                    None,\n                    false,\n                    0,\n                    Some(completion_tx),\n                    cx,\n                    Vec::new(),\n                )\n            })\n            .await\n            .unwrap();\n        let terminal = cx.new(|cx| builder.subscribe(cx));\n\n        let (event_tx, event_rx) = smol::channel::unbounded::<Event>();\n        cx.update(|cx| {\n            cx.subscribe(&terminal, move |_, e, _| {\n                event_tx.send_blocking(e.clone()).unwrap();\n            })\n        })\n        .detach();\n        cx.background_spawn(async move {\n            #[cfg(target_os = ": "",
        ")]\n            {\n                let exit_status = completion_rx.recv().await.ok().flatten();\n                if let Some(exit_status) = exit_status {\n                    assert!(\n                        !exit_status.success(),\n                        ": "",
        "\n                    );\n                    assert_eq!(exit_status.code(), Some(1));\n                }\n            }\n            #[cfg(not(target_os = ": "",
        "))]\n            {\n                let exit_status = completion_rx.recv().await.unwrap().unwrap();\n                assert!(\n                    !exit_status.success(),\n                    ": "",
        "\n                );\n                assert_eq!(exit_status.code(), None);\n            }\n        })\n        .detach();\n\n        let mut all_events = Vec::new();\n        while let Ok(Ok(new_event)) =\n            smol_timeout(Duration::from_millis(500), event_rx.recv()).await\n        {\n            all_events.push(new_event.clone());\n        }\n\n        assert!(\n            !all_events\n                .iter()\n                .any(|event| event == &Event::CloseTerminal),\n            ": "",
        ",\n        );\n    }\n\n    #[test]\n    fn test_rgb_for_index() {\n        // Test every possible value in the color cube.\n        for i in 16..=231 {\n            let (r, g, b) = rgb_for_index(i);\n            assert_eq!(i, 16 + 36 * r + 6 * g + b);\n        }\n    }\n\n    #[test]\n    fn test_mouse_to_cell_test() {\n        let mut rng = rand::rng();\n        const ITERATIONS: usize = 10;\n        const PRECISION: usize = 1000;\n\n        for _ in 0..ITERATIONS {\n            let viewport_cells = rng.random_range(15..20);\n            let cell_size =\n                rng.random_range(5 * PRECISION..20 * PRECISION) as f32 / PRECISION as f32;\n\n            let size = crate::TerminalBounds {\n                cell_width: Pixels::from(cell_size),\n                line_height: Pixels::from(cell_size),\n                bounds: bounds(\n                    Point::default(),\n                    size(\n                        Pixels::from(cell_size * (viewport_cells as f32)),\n                        Pixels::from(cell_size * (viewport_cells as f32)),\n                    ),\n                ),\n            };\n\n            let cells = get_cells(size, &mut rng);\n            let content = convert_cells_to_content(size, &cells);\n\n            for row in 0..(viewport_cells - 1) {\n                let row = row as usize;\n                for col in 0..(viewport_cells - 1) {\n                    let col = col as usize;\n\n                    let row_offset = rng.random_range(0..PRECISION) as f32 / PRECISION as f32;\n                    let col_offset = rng.random_range(0..PRECISION) as f32 / PRECISION as f32;\n\n                    let mouse_pos = point(\n                        Pixels::from(col as f32 * cell_size + col_offset),\n                        Pixels::from(row as f32 * cell_size + row_offset),\n                    );\n\n                    let content_index =\n                        content_index_for_mouse(mouse_pos, &content.terminal_bounds);\n                    let mouse_cell = content.cells[content_index].c;\n                    let real_cell = cells[row][col];\n\n                    assert_eq!(mouse_cell, real_cell);\n                }\n            }\n        }\n    }\n\n    #[test]\n    fn test_mouse_to_cell_clamp() {\n        let mut rng = rand::rng();\n\n        let size = crate::TerminalBounds {\n            cell_width: Pixels::from(10.),\n            line_height: Pixels::from(10.),\n            bounds: bounds(\n                Point::default(),\n                size(Pixels::from(100.), Pixels::from(100.)),\n            ),\n        };\n\n        let cells = get_cells(size, &mut rng);\n        let content = convert_cells_to_content(size, &cells);\n\n        assert_eq!(\n            content.cells[content_index_for_mouse(\n                point(Pixels::from(-10.), Pixels::from(-10.)),\n                &content.terminal_bounds,\n            )]\n            .c,\n            cells[0][0]\n        );\n        assert_eq!(\n            content.cells[content_index_for_mouse(\n                point(Pixels::from(1000.), Pixels::from(1000.)),\n                &content.terminal_bounds,\n            )]\n            .c,\n            cells[9][9]\n        );\n    }\n\n    fn get_cells(size: TerminalBounds, rng: &mut ThreadRng) -> Vec<Vec<char>> {\n        let mut cells = Vec::new();\n\n        for _ in 0..((size.height() / size.line_height()) as usize) {\n            let mut row_vec = Vec::new();\n            for _ in 0..((size.width() / size.cell_width()) as usize) {\n                let cell_char = rng.sample(distr::Alphanumeric) as char;\n                row_vec.push(cell_char)\n            }\n            cells.push(row_vec)\n        }\n\n        cells\n    }\n\n    fn convert_cells_to_content(\n        terminal_bounds: TerminalBounds,\n        cells: &[Vec<char>],\n    ) -> TerminalContent {\n        let mut ic = Vec::new();\n\n        for (index, row) in cells.iter().enumerate() {\n            for (cell_index, cell_char) in row.iter().enumerate() {\n                ic.push(IndexedCell {\n                    point: AlacPoint::new(Line(index as i32), Column(cell_index)),\n                    cell: Cell {\n                        c: *cell_char,\n                        ..Default::default()\n                    },\n                });\n            }\n        }\n\n        TerminalContent {\n            cells: ic,\n            terminal_bounds,\n            ..Default::default()\n        }\n    }\n\n    #[gpui::test]\n    async fn test_write_output_converts_lf_to_crlf(cx: &mut TestAppContext) {\n        let terminal = cx.new(|cx| {\n            TerminalBuilder::new_display_only(CursorShape::default(), AlternateScroll::On, None, 0)\n                .unwrap()\n                .subscribe(cx)\n        });\n\n        // Test simple LF conversion\n        terminal.update(cx, |terminal, cx| {\n            terminal.write_output(b": "",
        ", cx);\n        });\n\n        // Get the content by directly accessing the term\n        let content = terminal.update(cx, |terminal, _cx| {\n            let term = terminal.term.lock_unfair();\n            Terminal::make_content(&term, &terminal.last_content)\n        });\n\n        // If LF is properly converted to CRLF, each line should start at column 0\n        // The diagonal staircase bug would cause increasing column positions\n\n        // Get the cells and check that lines start at column 0\n        let cells = &content.cells;\n        let mut line1_col0 = false;\n        let mut line2_col0 = false;\n\n        for cell in cells {\n            if cell.c == 'l' && cell.point.column.0 == 0 {\n                if cell.point.line.0 == 0 && !line1_col0 {\n                    line1_col0 = true;\n                } else if cell.point.line.0 == 1 && !line2_col0 {\n                    line2_col0 = true;\n                }\n            }\n        }\n\n        assert!(line1_col0, ": "",
        ");\n        assert!(line2_col0, ": "",
        ");\n    }\n\n    #[gpui::test]\n    async fn test_write_output_preserves_existing_crlf(cx: &mut TestAppContext) {\n        let terminal = cx.new(|cx| {\n            TerminalBuilder::new_display_only(CursorShape::default(), AlternateScroll::On, None, 0)\n                .unwrap()\n                .subscribe(cx)\n        });\n\n        // Test that existing CRLF doesn't get doubled\n        terminal.update(cx, |terminal, cx| {\n            terminal.write_output(b": "",
        ", cx);\n        });\n\n        // Get the content by directly accessing the term\n        let content = terminal.update(cx, |terminal, _cx| {\n            let term = terminal.term.lock_unfair();\n            Terminal::make_content(&term, &terminal.last_content)\n        });\n\n        let cells = &content.cells;\n\n        // Check that both lines start at column 0\n        let mut found_lines_at_column_0 = 0;\n        for cell in cells {\n            if cell.c == 'l' && cell.point.column.0 == 0 {\n                found_lines_at_column_0 += 1;\n            }\n        }\n\n        assert!(\n            found_lines_at_column_0 >= 2,\n            ": "",
        "\n        );\n    }\n\n    #[gpui::test]\n    async fn test_write_output_preserves_bare_cr(cx: &mut TestAppContext) {\n        let terminal = cx.new(|cx| {\n            TerminalBuilder::new_display_only(CursorShape::default(), AlternateScroll::On, None, 0)\n                .unwrap()\n                .subscribe(cx)\n        });\n\n        // Test that bare CR (without LF) is preserved\n        terminal.update(cx, |terminal, cx| {\n            terminal.write_output(b": "",
        ", cx);\n        });\n\n        // Get the content by directly accessing the term\n        let content = terminal.update(cx, |terminal, _cx| {\n            let term = terminal.term.lock_unfair();\n            Terminal::make_content(&term, &terminal.last_content)\n        });\n\n        let cells = &content.cells;\n\n        // Check that we have ": "",
        " at the beginning of the line\n        let mut text = String::new();\n        for cell in cells.iter().take(5) {\n            if cell.point.line.0 == 0 {\n                text.push(cell.c);\n            }\n        }\n\n        assert!(\n            text.starts_with(": ""
    },
    "zed/crates/terminal_view/src/persistence.rs": {
        "no window present": "",
        "horizontal": "",
        "vertical": "",
        "Invalid axis value: '{invalid}'": "",
        "Saving working directory {working_directory:?} for item {item_id} in workspace {workspace_id:?}": "",
        "INSERT INTO terminals(item_id, workspace_id, working_directory, working_directory_path)\n            VALUES (?1, ?2, ?3, ?4)\n            ON CONFLICT DO UPDATE SET\n                item_id = ?1,\n                workspace_id = ?2,\n                working_directory = ?3,\n                working_directory_path = ?4": ""
    },
    "zed/crates/terminal_view/src/terminal_panel.rs": {
        "TerminalPanel": "",
        "terminal-tab-bar-popover-menu": "",
        "plus": "",
        "New…": "",
        "New Terminal": "",
        "Spawn task": "",
        "terminal-pane-tab-bar-split": "",
        "terminal-pane-split": "",
        "Split Pane": "",
        "Split Right": "",
        "Split Left": "",
        "Split Up": "",
        "Split Down": "",
        "toggle_zoom": "",
        "Zoom Out": "",
        "Zoom In": "",
        "failed to read workspace": "",
        "cannot spawn tasks as a guest": "",
        "terminal not yet supported for remote projects": "",
        "terminal not yet supported for collaborative projects": "",
        "Failed to retrieve terminal pane": "",
        " {path:?}": "",
        "settings-popover": "",
        "icon-button-popover": "",
        "Open Settings": "",
        "Edit settings.json": "",
        "Failed to spawn terminal": "",
        "open-settings-ui": "",
        "Edit Settings": "",
        "Terminal Panel": "",
        "terminal_inline_assistant": "",
        "Inline Assist": "",
        "When spawning a task, should have the task metadata": "",
        "Empty tasks should spawn a -i shell": "",
        "We show the shell launch for empty commands": "",
        "Terminal panel should bypass max_tabs limit and have all 5 terminals": "",
        "REPO_URL=$(git remote get-url origin | sed -e \\\"s/^git@\\\\(.*\\\\):\\\\(.*\\\\)\\\\.git$/https:\\\\/\\\\/\\\\1\\\\/\\\\2/\\\"); COMMIT_SHA=$(git log -1 --format=\\\"%H\\\" -- \\\"${ZED_RELATIVE_FILE}\\\"); echo \\\"${REPO_URL}/blob/${COMMIT_SHA}/${ZED_RELATIVE_FILE}#L${ZED_ROW}-$(echo $(($(wc -l <<< \\\"$ZED_SELECTED_TEXT\\\") + $ZED_ROW - 1)))\\\" | xclip -selection clipboard": "",
        "/some/work": "",
        "-i": "",
        "-c": "",
        "Use command should have been moved into the arguments, as we're spawning a new -i shell": "",
        "{shell} {interactive}-c '{user_command}'": "",
        "-i ": "",
        "We want to show to the user the entire command spawned": "",
        "asdf": "",
        "should spawn `FailedToSpawnTerminal` pane": ""
    },
    "zed/crates/terminal_view/src/terminal_tab_tooltip.rs": {
        "Process ID (PID): {}": ""
    },
    "zed/crates/terminal_view/src/terminal_view.rs": {
        "New Terminal": "",
        "Copy": "",
        "Paste": "",
        "Select All": "",
        "Clear": "",
        "Inline Assist": "",
        "Close Terminal Tab": "",
        "ctrl-cmd-space": "",
        "Terminal": "",
        "vi_mode": "",
        "screen": "",
        "alt": "",
        "normal": "",
        "DECCKM": "",
        "DECPAM": "",
        "DECPNM": "",
        "DECTCEM": "",
        "DECAWM": "",
        "DECOM": "",
        "IRM": "",
        "LNM": "",
        "report_focus": "",
        "alternate_scroll": "",
        "bracketed_paste": "",
        "any_mouse_reporting": "",
        "click": "",
        "drag": "",
        "motion": "",
        "off": "",
        "mouse_reporting": "",
        "sgr": "",
        "utf8": "",
        "mouse_format": "",
        "selection": "",
        "rerun-icon": "",
        "Rerun task": "",
        "terminal-view": "",
        "terminal-view-container": "",
        "term-tab-icon": "",
        "Updating workspace id for the terminal, old: {old_id:?}, new: {new_id:?}": "",
        "terminals": "",
        "/root/": "",
        "/root1/": "",
        "/root2/": ""
    },
    "zed/crates/text/src/text.rs": {
        "\\r\\n|\\r": "",
        "Failed to create LINE_SEPARATORS_REGEX": "",
        "Buffer id cannot be 0.": "",
        "gave up waiting for edits": "",
        "gave up waiting for anchors": "",
        "gave up waiting for version": "",
        "invalid edit": "",
        "fragment: {:?}\\ninsertion: {:?}": "",
        "\\r\\n": "",
        "mutating buffer {:?} with {:?}": "",
        "undoing buffer {:?} transaction {:?}": "",
        "invalid insertion for buffer {}@{:?} with anchor {:?}": "",
        "invalid insertion for buffer {}@{:?} and anchor {:?}": "",
        "invalid anchor - buffer id does not match: anchor {anchor:?}; buffer id: {}, version: {:?}": "",
        "invalid anchor - snapshot has not observed lamport: {:?}; version: {:?}": "",
        "invalid anchor {:?}. buffer id: {}, version: {:?}": "",
        "offset {} is out of bounds": "",
        "{value:?}": "",
        "invalid version": "",
        "offset {} is out of range, snapshot length is {}": "",
        "LF": "",
        "CRLF": ""
    },
    "zed/crates/theme_importer/src/main.rs": {
        "theme_printer": "",
        "could not initialize logger": "",
        "Failed to open file at path: {:?}": "",
        "failed to parse theme {theme_file_path:?}": "",
        "$schema": "",
        "Done!": ""
    },
    "zed/crates/theme_selector/src/theme_selector.rs": {
        "ThemeSelector": "",
        "error loading theme {}: {}": "",
        "Select Theme...": "",
        "Settings Changed": "",
        "theme": "",
        "docs": "",
        "View Theme Docs": "",
        "more-themes": "",
        "Install Themes": ""
    },
    "zed/crates/theme_selector/src/icon_theme_selector.rs": {
        "IconThemeSelector": "",
        "Select Icon Theme...": "",
        "Settings Changed": "",
        "icon_theme": "",
        "docs": "",
        "View Icon Theme Docs": "",
        "more-icon-themes": "",
        "Install Icon Themes": ""
    },
    "zed/crates/time_format/src/time_format.rs": {
        "2021-12-31 3:00AM": "",
        "Today at x": "",
        "Yesterday at x": "",
        "Today at 12:00 PM": "",
        "Yesterday at 11:00 AM": "",
        "Feb. 24, 2024": "",
        "just now": "",
        "1 minute ago": "",
        "2 hours ago": "",
        "2 months ago": "",
        "Today": "",
        "Yesterday": "",
        "en-US": "",
        "{} {}": "",
        "Today at {}": "",
        "Yesterday at {}": "",
        "Just now": "",
        "{} minutes ago": "",
        "1 hour ago": "",
        "{} hours ago": "",
        "{} days ago": "",
        "1 week ago": "",
        "{} weeks ago": "",
        "1 month ago": "",
        "{} months ago": "",
        "1 year ago": "",
        "{} years ago": "",
        "PM": "",
        "AM": "",
        "{}:{:02} {}": "",
        "{:02}:{:02}": "",
        "{:02}/{:02}/{}": "",
        "es-MX": "",
        "es-CO": "",
        "es-SV": "",
        "es-NI": "",
        "es-HN": "",
        "en-CA": "",
        "en-AU": "",
        "en-NZ": "",
        "ar-SA": "",
        "ar-EG": "",
        "ar-JO": "",
        "en-IN": "",
        "hi-IN": "",
        "en-PK": "",
        "ur-PK": "",
        "en-PH": "",
        "fil-PH": "",
        "bn-BD": "",
        "ccp-BD": "",
        "en-IE": "",
        "ga-IE": "",
        "en-MY": "",
        "ms-MY": "",
        "9:30 AM": "",
        "09:30": "",
        "3:45 PM": "",
        "15:45": "",
        "Today at 15:30": "",
        "Today at 3:30 PM": "",
        "Yesterday at 9:00 AM": "",
        "Yesterday at 8:00 PM": "",
        "Yesterday at 6:00 PM": "",
        "Yesterday at 11:55 PM": "",
        "04/10/1990 8:20 PM": "",
        "4 weeks ago": "",
        "Valid timezone offset": ""
    },
    "zed/crates/title_bar/src/application_menu.rs": {
        "{}-menu-item": "",
        "{}-menu-popover": "",
        "{}-menu-trigger": "",
        "Open Application Menu": "",
        "ZED_USE_CROSS_PLATFORM_MENU": "",
        "ApplicationMenu": ""
    },
    "zed/crates/title_bar/src/collab.rs": {
        "Screen Share Disabled": "",
        "Screen Share Enabled": "",
        "Sharing Screen Failed": "",
        "{:?}\\n\\nPlease check that you have given Zed permissions to record your screen in Settings.": "",
        "Microphone Enabled": "",
        "Microphone Disabled": "",
        "collaborator-list": "",
        "collaborator": "",
        "Follow {login}": "",
        "{} is muted": "",
        "+{extra_count}": "",
        "leave-call": "",
        "Leave Call": "",
        "toggle_sharing": "",
        "Unshare": "",
        "Share": "",
        "Stop sharing project with call participants": "",
        "Share project with call participants": "",
        "This project may not be shared in a public channel.": "",
        "mute-microphone": "",
        "Unmute Microphone": "",
        "Audio will be unmuted": "",
        "Mute Microphone": "",
        "mute-sound": "",
        "Unmute Audio": "",
        "Microphone will be unmuted": "",
        "Mute Audio": "",
        "Microphone will be muted": "",
        "screen-share": "",
        "Stop Sharing Screen": "",
        "Share Screen": "",
        "screen-share-screen-list": "",
        "screen-share-screen-list-trigger": "",
        "Unknown screen": "",
        "{} × {}": ""
    },
    "zed/crates/title_bar/src/title_bar.rs": {
        "stories": "",
        "title-bar": "",
        "ZED_USE_CROSS_PLATFORM_MENU": "",
        "ACP Claude Code Onboarding": "",
        "Claude Code": "",
        "Introducing:": "",
        "Connecting to: {host}": "",
        "Connected to: {host}": "",
        "Connection attempt to {host} missed. Retrying...": "",
        "Lost connection to {host}. Reconnecting...": "",
        "Disconnected from {host}": "",
        "ssh-server-icon": "",
        "Remote Project": "",
        "disconnected": "",
        "Disconnected": "",
        "project_owner_trigger": "",
        "{} is sharing this project. Click to follow.": "",
        "Open recent project": "",
        "project_name_trigger": "",
        "Recent Projects": "",
        "project_branch_trigger": "",
        "Recent Branches": "",
        "Local branches only": "",
        "Please restart Zed to Collaborate": "",
        "Updating...": "",
        "Please update Zed to Collaborate": "",
        "connection-status": "",
        "sign_in": "",
        "Sign in": "",
        "user-menu": "",
        "Free": "",
        "Pro Trial": "",
        "Pro": "",
        "Settings": "",
        "Keymap": "",
        "Themes…": "",
        "Icon Themes…": "",
        "Extensions": "",
        "Sign Out": "",
        "Toggle User Menu": ""
    },
    "zed/crates/toolchain_selector/src/active_toolchain.rs": {
        "Toolchain": "",
        "change-toolchain": "",
        "Select {}": ""
    },
    "zed/crates/toolchain_selector/src/toolchain_selector.rs": {
        "These tasks have to be kept alive to run to completion": "",
        "Select Toolchain Path": "",
        "select-toolchain-label": "",
        "Failed to resolve toolchain": "",
        "Add": "",
        "Scope": "",
        "scope-option-{i}": "",
        "scope-{i}": "",
        "add-toolchain": "",
        "inspecting-user-toolchain": "",
        "ToolchainSelector": "",
        "Add {}": "",
        "worktree root": "",
        "Select a {} for {pretty_path}…": "",
        "Select a toolchain…": "",
        "Add Toolchain": "",
        ".{}{suffix}": "",
        "toolchain-{ix}": "",
        "delete-custom-toolchain-{}-{}": "",
        "xd": "",
        "select": "",
        "Select": ""
    },
    "zed/crates/util/src/paths.rs": {
        "/Users/zed": "",
        "C:\\\\Users\\\\zed": "",
        "/home/zed": "",
        "failed to determine home directory": "",
        "Invalid WTF-8 sequence: {bytes:?}": "",
        "full": "",
        "/mnt/{}": "",
        "Path contains invalid UTF-8": "",
        "Failed to quote path": "",
        "{left}{}{right}": "",
        "parent reference `..` points outside of base directory": "",
        "warning": "",
        "lexical": "",
        "a/b/../c": "",
        "C:\\\" as a single ": "",
        " even though\n    // `components` splits it into two: (Prefix, RootDir).\n    let root = match iter.peek() {\n        Some(Component::ParentDir) => return Err(NormalizeError),\n        Some(p @ Component::RootDir) | Some(p @ Component::CurDir) => {\n            lexical.push(p);\n            iter.next();\n            lexical.as_os_str().len()\n        }\n        Some(Component::Prefix(prefix)) => {\n            lexical.push(prefix.as_os_str());\n            iter.next();\n            if let Some(p @ Component::RootDir) = iter.peek() {\n                lexical.push(p);\n                iter.next();\n            }\n            lexical.as_os_str().len()\n        }\n        None => return Ok(PathBuf::new()),\n        Some(Component::Normal(_)) => 0,\n    };\n\n    for component in iter {\n        match component {\n            Component::RootDir => unreachable!(),\n            Component::Prefix(_) => return Err(NormalizeError),\n            Component::CurDir => continue,\n            Component::ParentDir => {\n                // It's an error if ParentDir causes us to go above the ": "",
        ".\n                if lexical.as_os_str().len() == root {\n                    return Err(NormalizeError);\n                } else {\n                    lexical.pop();\n                }\n            }\n            Component::Normal(path) => lexical.push(path),\n        }\n    }\n    Ok(lexical)\n}\n\n/// A delimiter to use in `path_query:row_number:column_number` strings parsing.\npub const FILE_ROW_COLUMN_DELIMITER: char = ':';\n\nconst ROW_COL_CAPTURE_REGEX: &str = r": "",
        ";\n\n/// A representation of a path-like string with optional row and column numbers.\n/// Matching values example: `te`, `test.rs:22`, `te:22:5`, `test.c(22)`, `test.c(22,5)`etc.\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize, Hash)]\npub struct PathWithPosition {\n    pub path: PathBuf,\n    pub row: Option<u32>,\n    // Absent if row is absent.\n    pub column: Option<u32>,\n}\n\nimpl PathWithPosition {\n    /// Returns a PathWithPosition from a path.\n    pub fn from_path(path: PathBuf) -> Self {\n        Self {\n            path,\n            row: None,\n            column: None,\n        }\n    }\n\n    /// Parses a string that possibly has `:row:column` or `(row, column)` suffix.\n    /// Parenthesis format is used by [MSBuild](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-diagnostic-format-for-tasks) compatible tools\n    /// Ignores trailing `:`s, so `test.rs:22:` is parsed as `test.rs:22`.\n    /// If the suffix parsing fails, the whole string is parsed as a path.\n    ///\n    /// Be mindful that `test_file:10:1:` is a valid posix filename.\n    /// `PathWithPosition` class assumes that the ending position-like suffix is **not** part of the filename.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use util::paths::PathWithPosition;\n    /// # use std::path::PathBuf;\n    /// assert_eq!(PathWithPosition::parse_str(": "",
        "), PathWithPosition {\n    ///     path: PathBuf::from(": "",
        "),\n    ///     row: None,\n    ///     column: None,\n    /// });\n    /// assert_eq!(PathWithPosition::parse_str(": "",
        "),\n    ///     row: Some(10),\n    ///     column: None,\n    /// });\n    /// assert_eq!(PathWithPosition::parse_str(": "",
        "),\n    ///     row: Some(1),\n    ///     column: None,\n    /// });\n    /// assert_eq!(PathWithPosition::parse_str(": "",
        "),\n    ///     row: Some(1),\n    ///     column: Some(2),\n    /// });\n    /// ```\n    ///\n    /// # Expected parsing results when encounter ill-formatted inputs.\n    /// ```\n    /// # use util::paths::PathWithPosition;\n    /// # use std::path::PathBuf;\n    /// assert_eq!(PathWithPosition::parse_str(": "",
        "),\n    ///     row: Some(1),\n    ///     column: Some(2),\n    /// });\n    /// assert_eq!(PathWithPosition::parse_str(": "",
        "),\n    ///     row: Some(2),\n    ///     column: None,\n    /// });\n    /// assert_eq!(PathWithPosition::parse_str(": "",
        "),\n    ///     row: Some(2),\n    ///     column: Some(3),\n    /// });\n    /// ```\n    pub fn parse_str(s: &str) -> Self {\n        let trimmed = s.trim();\n        let path = Path::new(trimmed);\n        let maybe_file_name_with_row_col = path.file_name().unwrap_or_default().to_string_lossy();\n        if maybe_file_name_with_row_col.is_empty() {\n            return Self {\n                path: Path::new(s).to_path_buf(),\n                row: None,\n                column: None,\n            };\n        }\n\n        // Let's avoid repeated init cost on this. It is subject to thread contention, but\n        // so far this code isn't called from multiple hot paths. Getting contention here\n        // in the future seems unlikely.\n        static SUFFIX_RE: LazyLock<Regex> =\n            LazyLock::new(|| Regex::new(ROW_COL_CAPTURE_REGEX).unwrap());\n        match SUFFIX_RE\n            .captures(&maybe_file_name_with_row_col)\n            .map(|caps| caps.extract())\n        {\n            Some((_, [file_name, maybe_row, maybe_column])) => {\n                let row = maybe_row.parse::<u32>().ok();\n                let column = maybe_column.parse::<u32>().ok();\n\n                let suffix_length = maybe_file_name_with_row_col.len() - file_name.len();\n                let path_without_suffix = &trimmed[..trimmed.len() - suffix_length];\n\n                Self {\n                    path: Path::new(path_without_suffix).to_path_buf(),\n                    row,\n                    column,\n                }\n            }\n            None => {\n                // The `ROW_COL_CAPTURE_REGEX` deals with separated digits only,\n                // but in reality there could be `foo/bar.py:22:in` inputs which we want to match too.\n                // The regex mentioned is not very extendable with ": "",
        " checks, so do this here instead.\n                let delimiter = ':';\n                let mut path_parts = s\n                    .rsplitn(3, delimiter)\n                    .collect::<Vec<_>>()\n                    .into_iter()\n                    .rev()\n                    .fuse();\n                let mut path_string = path_parts.next().expect(": "",
        ").to_owned();\n                let mut row = None;\n                let mut column = None;\n                if let Some(maybe_row) = path_parts.next() {\n                    if let Ok(parsed_row) = maybe_row.parse::<u32>() {\n                        row = Some(parsed_row);\n                        if let Some(parsed_column) = path_parts\n                            .next()\n                            .and_then(|maybe_col| maybe_col.parse::<u32>().ok())\n                        {\n                            column = Some(parsed_column);\n                        }\n                    } else {\n                        path_string.push(delimiter);\n                        path_string.push_str(maybe_row);\n                    }\n                }\n                for split in path_parts {\n                    path_string.push(delimiter);\n                    path_string.push_str(split);\n                }\n\n                Self {\n                    path: PathBuf::from(path_string),\n                    row,\n                    column,\n                }\n            }\n        }\n    }\n\n    pub fn map_path<E>(\n        self,\n        mapping: impl FnOnce(PathBuf) -> Result<PathBuf, E>,\n    ) -> Result<PathWithPosition, E> {\n        Ok(PathWithPosition {\n            path: mapping(self.path)?,\n            row: self.row,\n            column: self.column,\n        })\n    }\n\n    pub fn to_string(&self, path_to_string: impl Fn(&PathBuf) -> String) -> String {\n        let path_string = path_to_string(&self.path);\n        if let Some(row) = self.row {\n            if let Some(column) = self.column {\n                format!(": "",
        ")\n            } else {\n                format!(": "",
        ")\n            }\n        } else {\n            path_string\n        }\n    }\n}\n\n#[derive(Clone, Debug)]\npub struct PathMatcher {\n    sources: Vec<String>,\n    glob: GlobSet,\n    path_style: PathStyle,\n}\n\n// impl std::fmt::Display for PathMatcher {\n//     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n//         self.sources.fmt(f)\n//     }\n// }\n\nimpl PartialEq for PathMatcher {\n    fn eq(&self, other: &Self) -> bool {\n        self.sources.eq(&other.sources)\n    }\n}\n\nimpl Eq for PathMatcher {}\n\nimpl PathMatcher {\n    pub fn new(\n        globs: impl IntoIterator<Item = impl AsRef<str>>,\n        path_style: PathStyle,\n    ) -> Result<Self, globset::Error> {\n        let globs = globs\n            .into_iter()\n            .map(|as_str| Glob::new(as_str.as_ref()))\n            .collect::<Result<Vec<_>, _>>()?;\n        let sources = globs.iter().map(|glob| glob.glob().to_owned()).collect();\n        let mut glob_builder = GlobSetBuilder::new();\n        for single_glob in globs {\n            glob_builder.add(single_glob);\n        }\n        let glob = glob_builder.build()?;\n        Ok(PathMatcher {\n            glob,\n            sources,\n            path_style,\n        })\n    }\n\n    pub fn sources(&self) -> &[String] {\n        &self.sources\n    }\n\n    pub fn is_match<P: AsRef<Path>>(&self, other: P) -> bool {\n        let other_path = other.as_ref();\n        self.sources.iter().any(|source| {\n            let as_bytes = other_path.as_os_str().as_encoded_bytes();\n            as_bytes.starts_with(source.as_bytes()) || as_bytes.ends_with(source.as_bytes())\n        }) || self.glob.is_match(other_path)\n            || self.check_with_end_separator(other_path)\n    }\n\n    fn check_with_end_separator(&self, path: &Path) -> bool {\n        let path_str = path.to_string_lossy();\n        let separator = self.path_style.separator();\n        if path_str.ends_with(separator) {\n            false\n        } else {\n            self.glob.is_match(path_str.to_string() + separator)\n        }\n    }\n}\n\nimpl Default for PathMatcher {\n    fn default() -> Self {\n        Self {\n            path_style: PathStyle::local(),\n            glob: GlobSet::empty(),\n            sources: vec![],\n        }\n    }\n}\n\n/// Custom character comparison that prioritizes lowercase for same letters\nfn compare_chars(a: char, b: char) -> Ordering {\n    // First compare case-insensitive\n    match a.to_ascii_lowercase().cmp(&b.to_ascii_lowercase()) {\n        Ordering::Equal => {\n            // If same letter, prioritize lowercase (lowercase < uppercase)\n            match (a.is_ascii_lowercase(), b.is_ascii_lowercase()) {\n                (true, false) => Ordering::Less,    // lowercase comes first\n                (false, true) => Ordering::Greater, // uppercase comes after\n                _ => Ordering::Equal,               // both same case or both non-ascii\n            }\n        }\n        other => other,\n    }\n}\n\n/// Compares two sequences of consecutive digits for natural sorting.\n///\n/// This function is a core component of natural sorting that handles numeric comparison\n/// in a way that feels natural to humans. It extracts and compares consecutive digit\n/// sequences from two iterators, handling various cases like leading zeros and very large numbers.\n///\n/// # Behavior\n///\n/// The function implements the following comparison rules:\n/// 1. Different numeric values: Compares by actual numeric value (e.g., ": "",
        " < ": "",
        ")\n/// 2. Leading zeros: When values are equal, longer sequence wins (e.g., ": "",
        " > ": "",
        ")\n/// 3. Large numbers: Falls back to string comparison for numbers that would overflow u128\n///\n/// # Examples\n///\n/// ```text\n/// ": "",
        " vs ": "",
        "      -> Less       (different values)\n/// ": "",
        "     -> Less       (numeric comparison)\n/// ": "",
        "    -> Greater    (leading zeros)\n/// ": "",
        "   -> Less       (leading zeros)\n/// ": "",
        " -> Less (large number comparison)\n/// ```\n///\n/// # Implementation Details\n///\n/// 1. Extracts consecutive digits into strings\n/// 2. Compares sequence lengths for leading zero handling\n/// 3. For equal lengths, compares digit by digit\n/// 4. For different lengths:\n///    - Attempts numeric comparison first (for numbers up to 2^128 - 1)\n///    - Falls back to string comparison if numbers would overflow\n///\n/// The function advances both iterators past their respective numeric sequences,\n/// regardless of the comparison result.\nfn compare_numeric_segments<I>(\n    a_iter: &mut std::iter::Peekable<I>,\n    b_iter: &mut std::iter::Peekable<I>,\n) -> Ordering\nwhere\n    I: Iterator<Item = char>,\n{\n    // Collect all consecutive digits into strings\n    let mut a_num_str = String::new();\n    let mut b_num_str = String::new();\n\n    while let Some(&c) = a_iter.peek() {\n        if !c.is_ascii_digit() {\n            break;\n        }\n\n        a_num_str.push(c);\n        a_iter.next();\n    }\n\n    while let Some(&c) = b_iter.peek() {\n        if !c.is_ascii_digit() {\n            break;\n        }\n\n        b_num_str.push(c);\n        b_iter.next();\n    }\n\n    // First compare lengths (handle leading zeros)\n    match a_num_str.len().cmp(&b_num_str.len()) {\n        Ordering::Equal => {\n            // Same length, compare digit by digit\n            match a_num_str.cmp(&b_num_str) {\n                Ordering::Equal => Ordering::Equal,\n                ordering => ordering,\n            }\n        }\n\n        // Different lengths but same value means leading zeros\n        ordering => {\n            // Try parsing as numbers first\n            if let (Ok(a_val), Ok(b_val)) = (a_num_str.parse::<u128>(), b_num_str.parse::<u128>()) {\n                match a_val.cmp(&b_val) {\n                    Ordering::Equal => ordering, // Same value, longer one is greater (leading zeros)\n                    ord => ord,\n                }\n            } else {\n                // If parsing fails (overflow), compare as strings\n                a_num_str.cmp(&b_num_str)\n            }\n        }\n    }\n}\n\n/// Performs natural sorting comparison between two strings.\n///\n/// Natural sorting is an ordering that handles numeric sequences in a way that matches human expectations.\n/// For example, ": "",
        " comes before ": "",
        " (unlike standard lexicographic sorting).\n///\n/// # Characteristics\n///\n/// * Case-sensitive with lowercase priority: When comparing same letters, lowercase comes before uppercase\n/// * Numbers are compared by numeric value, not character by character\n/// * Leading zeros affect ordering when numeric values are equal\n/// * Can handle numbers larger than u128::MAX (falls back to string comparison)\n///\n/// # Algorithm\n///\n/// The function works by:\n/// 1. Processing strings character by character\n/// 2. When encountering digits, treating consecutive digits as a single number\n/// 3. Comparing numbers by their numeric value rather than lexicographically\n/// 4. For non-numeric characters, using case-sensitive comparison with lowercase priority\npub fn natural_sort(a: &str, b: &str) -> Ordering {\n    let mut a_iter = a.chars().peekable();\n    let mut b_iter = b.chars().peekable();\n\n    loop {\n        match (a_iter.peek(), b_iter.peek()) {\n            (None, None) => return Ordering::Equal,\n            (None, _) => return Ordering::Less,\n            (_, None) => return Ordering::Greater,\n            (Some(&a_char), Some(&b_char)) => {\n                if a_char.is_ascii_digit() && b_char.is_ascii_digit() {\n                    match compare_numeric_segments(&mut a_iter, &mut b_iter) {\n                        Ordering::Equal => continue,\n                        ordering => return ordering,\n                    }\n                } else {\n                    match compare_chars(a_char, b_char) {\n                        Ordering::Equal => {\n                            a_iter.next();\n                            b_iter.next();\n                        }\n                        ordering => return ordering,\n                    }\n                }\n            }\n        }\n    }\n}\npub fn compare_rel_paths(\n    (path_a, a_is_file): (&RelPath, bool),\n    (path_b, b_is_file): (&RelPath, bool),\n) -> Ordering {\n    let mut components_a = path_a.components();\n    let mut components_b = path_b.components();\n\n    fn stem_and_extension(filename: &str) -> (Option<&str>, Option<&str>) {\n        if filename.is_empty() {\n            return (None, None);\n        }\n\n        match filename.rsplit_once('.') {\n            // Case 1: No dot was found. The entire name is the stem.\n            None => (Some(filename), None),\n\n            // Case 2: A dot was found.\n            Some((before, after)) => {\n                // This is the crucial check for dotfiles like ": "",
        ".\n                // If `before` is empty, the dot was the first character.\n                // In that case, we revert to the ": "",
        " logic.\n                if before.is_empty() {\n                    (Some(filename), None)\n                } else {\n                    // Otherwise, we have a standard stem and extension.\n                    (Some(before), Some(after))\n                }\n            }\n        }\n    }\n    loop {\n        match (components_a.next(), components_b.next()) {\n            (Some(component_a), Some(component_b)) => {\n                let a_is_file = a_is_file && components_a.rest().is_empty();\n                let b_is_file = b_is_file && components_b.rest().is_empty();\n\n                let ordering = a_is_file.cmp(&b_is_file).then_with(|| {\n                    let (a_stem, a_extension) = a_is_file\n                        .then(|| stem_and_extension(component_a))\n                        .unwrap_or_default();\n                    let path_string_a = if a_is_file { a_stem } else { Some(component_a) };\n\n                    let (b_stem, b_extension) = b_is_file\n                        .then(|| stem_and_extension(component_b))\n                        .unwrap_or_default();\n                    let path_string_b = if b_is_file { b_stem } else { Some(component_b) };\n\n                    let compare_components = match (path_string_a, path_string_b) {\n                        (Some(a), Some(b)) => natural_sort(&a, &b),\n                        (Some(_), None) => Ordering::Greater,\n                        (None, Some(_)) => Ordering::Less,\n                        (None, None) => Ordering::Equal,\n                    };\n\n                    compare_components.then_with(|| {\n                        if a_is_file && b_is_file {\n                            let ext_a = a_extension.unwrap_or_default();\n                            let ext_b = b_extension.unwrap_or_default();\n                            ext_a.cmp(ext_b)\n                        } else {\n                            Ordering::Equal\n                        }\n                    })\n                });\n\n                if !ordering.is_eq() {\n                    return ordering;\n                }\n            }\n            (Some(_), None) => break Ordering::Greater,\n            (None, Some(_)) => break Ordering::Less,\n            (None, None) => break Ordering::Equal,\n        }\n    }\n}\n\npub fn compare_paths(\n    (path_a, a_is_file): (&Path, bool),\n    (path_b, b_is_file): (&Path, bool),\n) -> Ordering {\n    let mut components_a = path_a.components().peekable();\n    let mut components_b = path_b.components().peekable();\n\n    loop {\n        match (components_a.next(), components_b.next()) {\n            (Some(component_a), Some(component_b)) => {\n                let a_is_file = components_a.peek().is_none() && a_is_file;\n                let b_is_file = components_b.peek().is_none() && b_is_file;\n\n                let ordering = a_is_file.cmp(&b_is_file).then_with(|| {\n                    let path_a = Path::new(component_a.as_os_str());\n                    let path_string_a = if a_is_file {\n                        path_a.file_stem()\n                    } else {\n                        path_a.file_name()\n                    }\n                    .map(|s| s.to_string_lossy());\n\n                    let path_b = Path::new(component_b.as_os_str());\n                    let path_string_b = if b_is_file {\n                        path_b.file_stem()\n                    } else {\n                        path_b.file_name()\n                    }\n                    .map(|s| s.to_string_lossy());\n\n                    let compare_components = match (path_string_a, path_string_b) {\n                        (Some(a), Some(b)) => natural_sort(&a, &b),\n                        (Some(_), None) => Ordering::Greater,\n                        (None, Some(_)) => Ordering::Less,\n                        (None, None) => Ordering::Equal,\n                    };\n\n                    compare_components.then_with(|| {\n                        if a_is_file && b_is_file {\n                            let ext_a = path_a.extension().unwrap_or_default();\n                            let ext_b = path_b.extension().unwrap_or_default();\n                            ext_a.cmp(ext_b)\n                        } else {\n                            Ordering::Equal\n                        }\n                    })\n                });\n\n                if !ordering.is_eq() {\n                    return ordering;\n                }\n            }\n            (Some(_), None) => break Ordering::Greater,\n            (None, Some(_)) => break Ordering::Less,\n            (None, None) => break Ordering::Equal,\n        }\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct WslPath {\n    pub distro: String,\n\n    // the reason this is an OsString and not any of the path types is that it needs to\n    // represent a unix path (with '/' separators) on windows. `from_path` does this by\n    // manually constructing it from the path components of a given windows path.\n    pub path: std::ffi::OsString,\n}\n\nimpl WslPath {\n    pub fn from_path<P: AsRef<Path>>(path: P) -> Option<WslPath> {\n        if cfg!(not(target_os = ": "",
        ")) {\n            return None;\n        }\n        use std::{\n            ffi::OsString,\n            path::{Component, Prefix},\n        };\n\n        let mut components = path.as_ref().components();\n        let Some(Component::Prefix(prefix)) = components.next() else {\n            return None;\n        };\n        let (server, distro) = match prefix.kind() {\n            Prefix::UNC(server, distro) => (server, distro),\n            Prefix::VerbatimUNC(server, distro) => (server, distro),\n            _ => return None,\n        };\n        let Some(Component::RootDir) = components.next() else {\n            return None;\n        };\n\n        let server_str = server.to_string_lossy();\n        if server_str == ": "",
        " || server_str == ": "",
        " {\n            let mut result = OsString::from(": "",
        ");\n            for c in components {\n                use Component::*;\n                match c {\n                    Prefix(p) => unreachable!(": "",
        "),\n                    RootDir => unreachable!(": "",
        "),\n                    CurDir => continue,\n                    ParentDir => result.push(": "",
        "),\n                    Normal(s) => {\n                        result.push(": "",
        ");\n                        result.push(s);\n                    }\n                }\n            }\n            if result.is_empty() {\n                result.push(": "",
        ");\n            }\n            Some(WslPath {\n                distro: distro.to_string_lossy().to_string(),\n                path: result,\n            })\n        } else {\n            None\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use util_macros::perf;\n\n    #[perf]\n    fn compare_paths_with_dots() {\n        let mut paths = vec![\n            (Path::new(": "",
        "), false),\n            (Path::new(": "",
        "), true),\n            (Path::new(": "",
        "), true),\n        ];\n        paths.sort_by(|&a, &b| compare_paths(a, b));\n        assert_eq!(\n            paths,\n            vec![\n                (Path::new(": "",
        "), false),\n                (Path::new(": "",
        "), true),\n                (Path::new(": "",
        "), true),\n            ]\n        );\n        let mut paths = vec![\n            (Path::new(": "",
        "), true),\n            ]\n        );\n    }\n\n    #[perf]\n    fn compare_paths_with_same_name_different_extensions() {\n        let mut paths = vec![\n            (Path::new(": "",
        "), true),\n            ]\n        );\n    }\n\n    #[perf]\n    fn compare_paths_case_semi_sensitive() {\n        let mut paths = vec![\n            (Path::new(": "",
        "), true),\n            ]\n        );\n    }\n\n    #[perf]\n    fn path_with_position_parse_posix_path() {\n        // Test POSIX filename edge cases\n        // Read more at https://en.wikipedia.org/wiki/Filename\n        assert_eq!(\n            PathWithPosition::parse_str(": "",
        "),\n            PathWithPosition {\n                path: PathBuf::from(": "",
        "),\n                row: None,\n                column: None\n            }\n        );\n\n        assert_eq!(\n            PathWithPosition::parse_str(": "",
        "),\n                row: Some(1),\n                column: None\n            }\n        );\n\n        assert_eq!(\n            PathWithPosition::parse_str(": "",
        "),\n                row: Some(1),\n                column: None\n            }\n        );\n\n        // Trim off trailing `:`s for otherwise valid input.\n        assert_eq!(\n            PathWithPosition::parse_str(": "",
        "),\n                row: Some(10),\n                column: Some(1)\n            }\n        );\n\n        assert_eq!(\n            PathWithPosition::parse_str(": "",
        "),\n                row: Some(617),\n                column: Some(9),\n            }\n        );\n    }\n\n    #[perf]\n    #[cfg(not(target_os = ": "",
        "))]\n    fn path_with_position_parse_posix_path_with_suffix() {\n        assert_eq!(\n            PathWithPosition::parse_str(": "",
        "),\n                row: Some(34),\n                column: None,\n            }\n        );\n        assert_eq!(\n            PathWithPosition::parse_str(": "",
        "),\n                row: Some(15),\n                column: None\n            }\n        );\n\n        assert_eq!(\n            PathWithPosition::parse_str(": "",
        "),\n                row: Some(34),\n                column: None,\n            }\n        );\n\n        assert_eq!(\n            PathWithPosition::parse_str(": "",
        "),\n                row: Some(1902),\n                column: Some(13),\n            }\n        );\n\n        assert_eq!(\n            PathWithPosition::parse_str(": "",
        "),\n                row: Some(7),\n                column: Some(15),\n            }\n        );\n    }\n\n    #[perf]\n    #[cfg(target_os = ": "",
        ")]\n    fn path_with_position_parse_windows_path() {\n        assert_eq!(\n            PathWithPosition::parse_str(": "",
        "),\n                row: None,\n                column: None\n            }\n        );\n    }\n\n    #[perf]\n    #[cfg(target_os = ": "",
        ")]\n    fn path_with_position_parse_windows_path_with_suffix() {\n        assert_eq!(\n            PathWithPosition::parse_str(": "",
        "),\n                row: Some(101),\n                column: None\n            }\n        );\n\n        assert_eq!(\n            PathWithPosition::parse_str(": "",
        "),\n                row: Some(1),\n                column: Some(20)\n            }\n        );\n\n        assert_eq!(\n            PathWithPosition::parse_str(": "",
        "),\n                row: Some(1902),\n                column: Some(13)\n            }\n        );\n\n        // Trim off trailing `:`s for otherwise valid input.\n        assert_eq!(\n            PathWithPosition::parse_str(": "",
        "),\n                row: Some(1902),\n                column: Some(13)\n            }\n        );\n\n        assert_eq!(\n            PathWithPosition::parse_str(": "",
        "),\n                row: Some(13),\n                column: Some(15)\n            }\n        );\n\n        assert_eq!(\n            PathWithPosition::parse_str(": "",
        "),\n                row: Some(1902),\n                column: None,\n            }\n        );\n\n        assert_eq!(\n            PathWithPosition::parse_str(": "",
        "),\n                row: Some(101),\n                column: None,\n            }\n        );\n    }\n\n    #[perf]\n    fn test_path_compact() {\n        let path: PathBuf = [\n            home_dir().to_string_lossy().into_owned(),\n            ": "",
        ".to_string(),\n        ]\n        .iter()\n        .collect();\n        if cfg!(any(target_os = ": "",
        ", target_os = ": "",
        ")) || cfg!(target_os = ": "",
        ") {\n            assert_eq!(path.compact().to_str(), Some(": "",
        "));\n        } else {\n            assert_eq!(path.compact().to_str(), path.to_str());\n        }\n    }\n\n    #[perf]\n    fn test_extension_or_hidden_file_name() {\n        // No dots in name\n        let path = Path::new(": "",
        ");\n        assert_eq!(path.extension_or_hidden_file_name(), Some(": "",
        "));\n\n        // Single dot in name\n        let path = Path::new(": "",
        "));\n\n        // Multiple dots in name\n        let path = Path::new(": "",
        "));\n\n        // Hidden file, no extension\n        let path = Path::new(": "",
        "));\n\n        // Hidden file, with extension\n        let path = Path::new(": "",
        "));\n    }\n\n    #[perf]\n    fn edge_of_glob() {\n        let path = Path::new(": "",
        ");\n        let path_matcher =\n            PathMatcher::new(&[": "",
        ".to_owned()], PathStyle::Posix).unwrap();\n        assert!(\n            path_matcher.is_match(path),\n            ": "",
        "\n        );\n    }\n\n    #[perf]\n    fn file_in_dirs() {\n        let path = Path::new(": "",
        ");\n        let path_matcher = PathMatcher::new(&[": "",
        "\n        );\n        let path = Path::new(": "",
        ");\n        assert!(\n            !path_matcher.is_match(path),\n            ": "",
        "\n        );\n    }\n\n    #[perf]\n    fn project_search() {\n        let path = Path::new(": "",
        "\n        );\n    }\n\n    #[perf]\n    #[cfg(target_os = ": "",
        ")]\n    fn test_sanitized_path() {\n        let path = Path::new(": "",
        ");\n        let sanitized_path = SanitizedPath::new(path);\n        assert_eq!(\n            sanitized_path.to_string(),\n            ": "",
        "\n        );\n\n        let path = Path::new(": "",
        "\n        );\n    }\n\n    #[perf]\n    fn test_compare_numeric_segments() {\n        // Helper function to create peekable iterators and test\n        fn compare(a: &str, b: &str) -> Ordering {\n            let mut a_iter = a.chars().peekable();\n            let mut b_iter = b.chars().peekable();\n\n            let result = compare_numeric_segments(&mut a_iter, &mut b_iter);\n\n            // Verify iterators advanced correctly\n            assert!(\n                !a_iter.next().is_some_and(|c| c.is_ascii_digit()),\n                ": "",
        "\n            );\n            assert!(\n                !b_iter.next().is_some_and(|c| c.is_ascii_digit()),\n                ": "",
        "\n            );\n\n            result\n        }\n\n        // Basic numeric comparisons\n        assert_eq!(compare(": "",
        ", ": "",
        "), Ordering::Equal);\n        assert_eq!(compare(": "",
        "), Ordering::Less);\n        assert_eq!(compare(": "",
        "), Ordering::Greater);\n        assert_eq!(compare(": "",
        "), Ordering::Less);\n\n        // Leading zeros\n        assert_eq!(compare(": "",
        "), Ordering::Greater);\n\n        // Same value different representation\n        assert_eq!(compare(": "",
        "), Ordering::Less);\n\n        // Large numbers\n        assert_eq!(compare(": "",
        "), Ordering::Less);\n        assert_eq!(\n            compare(\n                ": "",
        ", // u128::MAX\n                ": "",
        "\n            ),\n            Ordering::Less\n        );\n        assert_eq!(\n            compare(\n                ": "",
        ", // > u128::MAX\n                ": "",
        "\n            ),\n            Ordering::Greater\n        );\n\n        // Iterator advancement verification\n        let mut a_iter = ": "",
        ".chars().peekable();\n        let mut b_iter = ": "",
        ".chars().peekable();\n\n        compare_numeric_segments(&mut a_iter, &mut b_iter);\n\n        assert_eq!(a_iter.collect::<String>(), ": "",
        ");\n        assert_eq!(b_iter.collect::<String>(), ": "",
        ");\n    }\n\n    #[perf]\n    fn test_natural_sort() {\n        // Basic alphanumeric\n        assert_eq!(natural_sort(": "",
        "), Ordering::Less);\n        assert_eq!(natural_sort(": "",
        "), Ordering::Greater);\n        assert_eq!(natural_sort(": "",
        "), Ordering::Equal);\n\n        // Case sensitivity\n        assert_eq!(natural_sort(": "",
        "), Ordering::Less);\n\n        // Numbers\n        assert_eq!(natural_sort(": "",
        "), Ordering::Greater);\n\n        // Mixed alphanumeric\n        assert_eq!(natural_sort(": "",
        "), Ordering::Less);\n\n        // Multiple numeric segments\n        assert_eq!(natural_sort(": "",
        "), Ordering::Less);\n\n        // Special characters\n        assert_eq!(natural_sort(": "",
        "), Ordering::Less);\n\n        // Unicode\n        assert_eq!(natural_sort(": "",
        "), Ordering::Less);\n\n        // Empty and special cases\n        assert_eq!(natural_sort(": "",
        "), Ordering::Equal);\n        assert_eq!(natural_sort(": "",
        "), Ordering::Less);\n\n        // Mixed everything\n        assert_eq!(natural_sort(": "",
        "), Ordering::Less);\n    }\n\n    #[perf]\n    fn test_compare_paths() {\n        // Helper function for cleaner tests\n        fn compare(a: &str, is_a_file: bool, b: &str, is_b_file: bool) -> Ordering {\n            compare_paths((Path::new(a), is_a_file), (Path::new(b), is_b_file))\n        }\n\n        // Basic path comparison\n        assert_eq!(compare(": "",
        ", true, ": "",
        ", true), Ordering::Less);\n        assert_eq!(compare(": "",
        ", true), Ordering::Greater);\n        assert_eq!(compare(": "",
        ", true), Ordering::Equal);\n\n        // Files vs Directories\n        assert_eq!(compare(": "",
        ", false), Ordering::Greater);\n        assert_eq!(compare(": "",
        ", false, ": "",
        ", true), Ordering::Less);\n\n        // Extensions\n        assert_eq!(compare(": "",
        ", true), Ordering::Less);\n\n        // Nested paths\n        assert_eq!(compare(": "",
        ", true), Ordering::Less);\n\n        // Case sensitivity in paths\n        assert_eq!(\n            compare(": "",
        ", true),\n            Ordering::Greater\n        );\n        assert_eq!(\n            compare(": "",
        ", true),\n            Ordering::Greater\n        );\n        assert_eq!(compare(": "",
        ", true), Ordering::Less);\n\n        // Hidden files and special names\n        assert_eq!(compare(": "",
        ", false), Ordering::Less);\n\n        // Mixed numeric paths\n        assert_eq!(\n            compare(": "",
        ", true),\n            Ordering::Less\n        );\n        assert_eq!(\n            compare(": "",
        ", true),\n            Ordering::Greater\n        );\n\n        // Root paths\n        assert_eq!(compare(": "",
        ", true), Ordering::Less);\n\n        // Complex real-world examples\n        assert_eq!(\n            compare(": "",
        ", true),\n            Ordering::Greater\n        );\n        assert_eq!(\n            compare(\n                ": "",
        ",\n                true,\n                ": "",
        ",\n                true\n            ),\n            Ordering::Less\n        );\n        assert_eq!(\n            compare(\n                ": "",
        ",\n                true\n            ),\n            Ordering::Less\n        );\n    }\n\n    #[perf]\n    fn test_natural_sort_case_sensitivity() {\n        std::thread::sleep(std::time::Duration::from_millis(100));\n        // Same letter different case - lowercase should come first\n        assert_eq!(natural_sort(": "",
        "), Ordering::Equal);\n\n        // Mixed case strings\n        assert_eq!(natural_sort(": "",
        "), Ordering::Less);\n\n        // Different letters\n        assert_eq!(natural_sort(": "",
        "), Ordering::Less);\n    }\n\n    #[perf]\n    fn test_natural_sort_with_numbers() {\n        // Basic number ordering\n        assert_eq!(natural_sort(": "",
        "), Ordering::Greater);\n\n        // Numbers in different positions\n        assert_eq!(natural_sort(": "",
        "), Ordering::Less);\n\n        // Multiple numbers in string\n        assert_eq!(natural_sort(": "",
        "), Ordering::Less);\n\n        // Leading zeros\n        assert_eq!(natural_sort(": "",
        "), Ordering::Less);\n\n        // Very large numbers\n        assert_eq!(\n            natural_sort(": "",
        "),\n            Ordering::Greater\n        );\n\n        // u128 edge cases\n\n        // Numbers near u128::MAX (340,282,366,920,938,463,463,374,607,431,768,211,455)\n        assert_eq!(\n            natural_sort(\n                ": "",
        ",\n                ": "",
        "\n            ),\n            Ordering::Less\n        );\n\n        // Equal length numbers that overflow u128\n        assert_eq!(\n            natural_sort(\n                ": "",
        "\n            ),\n            Ordering::Greater\n        );\n\n        // Different length numbers that overflow u128\n        assert_eq!(\n            natural_sort(\n                ": "",
        "\n            ),\n            Ordering::Greater\n        );\n\n        // Leading zeros with numbers near u128::MAX\n        assert_eq!(\n            natural_sort(\n                ": "",
        "\n            ),\n            Ordering::Greater\n        );\n\n        // Very large numbers with different lengths (both overflow u128)\n        assert_eq!(\n            natural_sort(\n                ": "",
        "\n            ),\n            Ordering::Less\n        );\n\n        // Mixed case with numbers\n        assert_eq!(natural_sort(": "",
        "), Ordering::Less);\n    }\n\n    #[perf]\n    fn test_natural_sort_edge_cases() {\n        // Empty strings\n        assert_eq!(natural_sort(": "",
        "), Ordering::Greater);\n\n        // Special characters\n        assert_eq!(natural_sort(": "",
        "), Ordering::Less);\n\n        // Unicode characters\n        // 9312 vs 9313\n        assert_eq!(natural_sort(": "",
        "), Ordering::Less);\n        // 9321 vs 9313\n        assert_eq!(natural_sort(": "",
        "), Ordering::Greater);\n        // 28450 vs 23383\n        assert_eq!(natural_sort(": "",
        "), Ordering::Greater);\n\n        // Mixed alphanumeric with special chars\n        assert_eq!(natural_sort(": "",
        "), Ordering::Greater);\n    }\n\n    #[test]\n    fn test_multiple_extensions() {\n        // No extensions\n        let path = Path::new(": "",
        ");\n        assert_eq!(path.multiple_extensions(), None);\n\n        // Only one extension\n        let path = Path::new(": "",
        ");\n        assert_eq!(path.multiple_extensions(), None);\n\n        // Stories sample extension\n        let path = Path::new(": "",
        ");\n        assert_eq!(path.multiple_extensions(), Some(": "",
        ".to_string()));\n\n        // Longer sample extension\n        let path = Path::new(": "",
        ".to_string()));\n    }\n\n    #[test]\n    fn test_strip_path_suffix() {\n        let base = Path::new(": "",
        ");\n        let suffix = Path::new(": "",
        ");\n        assert_eq!(strip_path_suffix(base, suffix), Some(Path::new(": "",
        ")));\n\n        let base = Path::new(": "",
        ");\n        assert_eq!(strip_path_suffix(base, suffix), None);\n\n        let base = Path::new(": "",
        ");\n        assert_eq!(strip_path_suffix(base, suffix), None);\n    }\n\n    #[cfg(target_os = ": "",
        ")]\n    #[test]\n    fn test_wsl_path() {\n        use super::WslPath;\n        let path = ": "",
        ";\n        assert_eq!(WslPath::from_path(&path), None);\n\n        let path = r": "",
        ";\n        assert_eq!(\n            WslPath::from_path(&path),\n            Some(WslPath {\n                distro: ": "",
        ".to_owned(),\n                path: ": "",
        ".into(),\n            })\n        );\n\n        let path = r": "",
        ".into()\n            })\n        );\n\n        let path = r": ""
    },
    "zed/crates/util/src/test.rs": {
        ".git": "",
        "JSON object must contain only objects, strings, or null": "",
        "You must pass a JSON object to this helper": ""
    },
    "zed/crates/util/src/util.rs": {
        "{}\\n{:?}": "",
        "\\n…": "",
        "Line 1\\nLine 2\\nLine 3\\nLine 4": "",
        "Line 1\\n": "",
        "Line 1\\nLine 2\\n": "",
        "Line ": "",
        "Line 1\\nLíne 2\\nLine 3": "",
        "Line 1\\nLíne 2\\n": "",
        "ZED_ALLOW_ROOT": "",
        "true": "",
        "\n        );\n        std::process::exit(1);\n    }\n}\n\n#[cfg(unix)]\nfn load_shell_from_passwd() -> Result<()> {\n    let buflen = match unsafe { libc::sysconf(libc::_SC_GETPW_R_SIZE_MAX) } {\n        n if n < 0 => 1024,\n        n => n as usize,\n    };\n    let mut buffer = Vec::with_capacity(buflen);\n\n    let mut pwd: std::mem::MaybeUninit<libc::passwd> = std::mem::MaybeUninit::uninit();\n    let mut result: *mut libc::passwd = std::ptr::null_mut();\n\n    let uid = unsafe { libc::getuid() };\n    let status = unsafe {\n        libc::getpwuid_r(\n            uid,\n            pwd.as_mut_ptr(),\n            buffer.as_mut_ptr() as *mut libc::c_char,\n            buflen,\n            &mut result,\n        )\n    };\n    anyhow::ensure!(!result.is_null(), ": "",
        ", uid);\n\n    // SAFETY: If `getpwuid_r` doesn't error, we have the entry here.\n    let entry = unsafe { pwd.assume_init() };\n\n    anyhow::ensure!(\n        status == 0,\n        ": "",
        ",\n        uid,\n        status\n    );\n    anyhow::ensure!(\n        entry.pw_uid == uid,\n        ": "",
        ",\n        entry.pw_uid,\n        uid,\n    );\n\n    let shell = unsafe { std::ffi::CStr::from_ptr(entry.pw_shell).to_str().unwrap() };\n    let should_set_shell = env::var(": "",
        ").map_or(true, |shell_env| {\n        shell_env != shell && !std::path::Path::new(&shell_env).exists()\n    });\n\n    if should_set_shell {\n        log::info!(\n            ": "",
        ",\n            shell,\n        );\n        unsafe { env::set_var(": "",
        ", shell) };\n    }\n\n    Ok(())\n}\n\n/// Returns a shell escaped path for the current zed executable\npub fn get_shell_safe_zed_path(shell_kind: shell::ShellKind) -> anyhow::Result<String> {\n    let zed_path =\n        std::env::current_exe().context(": "",
        ")?;\n\n    zed_path\n        .try_shell_safe(shell_kind)\n        .context(": "",
        ")\n}\n\n/// Returns a path for the zed cli executable, this function\n/// should be called from the zed executable, not zed-cli.\npub fn get_zed_cli_path() -> Result<PathBuf> {\n    let zed_path =\n        std::env::current_exe().context(": "",
        ")?;\n    let parent = zed_path\n        .parent()\n        .context(": "",
        ")?;\n\n    let possible_locations: &[&str] = if cfg!(target_os = ": "",
        ") {\n        // On macOS, the zed executable and zed-cli are inside the app bundle,\n        // so here ./cli is for both installed and development builds.\n        &[": "",
        "]\n    } else if cfg!(target_os = ": "",
        ") {\n        // bin/zed.exe is for installed builds, ./cli.exe is for development builds.\n        &[": "",
        ", ": "",
        ") || cfg!(target_os = ": "",
        ") {\n        // bin is the standard, ./cli is for the target directory in development builds.\n        &[": "",
        "]\n    } else {\n        anyhow::bail!(": "",
        ");\n    };\n\n    possible_locations\n        .iter()\n        .find_map(|p| {\n            parent\n                .join(p)\n                .canonicalize()\n                .ok()\n                .filter(|p| p != &zed_path)\n        })\n        .with_context(|| {\n            format!(\n                ": "",
        ",\n                possible_locations.join(": "",
        ")\n            )\n        })\n}\n\n#[cfg(unix)]\npub async fn load_login_shell_environment() -> Result<()> {\n    load_shell_from_passwd().log_err();\n\n    // If possible, we want to `cd` in the user's `$HOME` to trigger programs\n    // such as direnv, asdf, mise, ... to adjust the PATH. These tools often hook\n    // into shell's `cd` command (and hooks) to manipulate env.\n    // We do this so that we get the env a user would have when spawning a shell\n    // in home directory.\n    for (name, value) in shell_env::capture(get_system_shell(), &[], paths::home_dir())\n        .await\n        .with_context(|| format!(": "",
        ", get_system_shell()))?\n    {\n        unsafe { env::set_var(&name, &value) };\n    }\n\n    log::info!(\n        ": "",
        ",\n        std::env::var(": "",
        ").unwrap_or_default(),\n        std::env::var(": "",
        ").unwrap_or_default(),\n    );\n\n    Ok(())\n}\n\n/// Configures the process to start a new session, to prevent interactive shells from taking control\n/// of the terminal.\n///\n/// For more details: <https://registerspill.thorstenball.com/p/how-to-lose-control-of-your-shell>\npub fn set_pre_exec_to_start_new_session(\n    command: &mut std::process::Command,\n) -> &mut std::process::Command {\n    // safety: code in pre_exec should be signal safe.\n    // https://man7.org/linux/man-pages/man7/signal-safety.7.html\n    #[cfg(not(target_os = ": "",
        "))]\n    unsafe {\n        use std::os::unix::process::CommandExt;\n        command.pre_exec(|| {\n            libc::setsid();\n            Ok(())\n        });\n    };\n    command\n}\n\npub fn merge_json_lenient_value_into(\n    source: serde_json_lenient::Value,\n    target: &mut serde_json_lenient::Value,\n) {\n    match (source, target) {\n        (serde_json_lenient::Value::Object(source), serde_json_lenient::Value::Object(target)) => {\n            for (key, value) in source {\n                if let Some(target) = target.get_mut(&key) {\n                    merge_json_lenient_value_into(value, target);\n                } else {\n                    target.insert(key, value);\n                }\n            }\n        }\n\n        (serde_json_lenient::Value::Array(source), serde_json_lenient::Value::Array(target)) => {\n            for value in source {\n                target.push(value);\n            }\n        }\n\n        (source, target) => *target = source,\n    }\n}\n\npub fn merge_json_value_into(source: serde_json::Value, target: &mut serde_json::Value) {\n    use serde_json::Value;\n\n    match (source, target) {\n        (Value::Object(source), Value::Object(target)) => {\n            for (key, value) in source {\n                if let Some(target) = target.get_mut(&key) {\n                    merge_json_value_into(value, target);\n                } else {\n                    target.insert(key, value);\n                }\n            }\n        }\n\n        (Value::Array(source), Value::Array(target)) => {\n            for value in source {\n                target.push(value);\n            }\n        }\n\n        (source, target) => *target = source,\n    }\n}\n\npub fn merge_non_null_json_value_into(source: serde_json::Value, target: &mut serde_json::Value) {\n    use serde_json::Value;\n    if let Value::Object(source_object) = source {\n        let target_object = if let Value::Object(target) = target {\n            target\n        } else {\n            *target = Value::Object(Default::default());\n            target.as_object_mut().unwrap()\n        };\n        for (key, value) in source_object {\n            if let Some(target) = target_object.get_mut(&key) {\n                merge_non_null_json_value_into(value, target);\n            } else if !value.is_null() {\n                target_object.insert(key, value);\n            }\n        }\n    } else if !source.is_null() {\n        *target = source\n    }\n}\n\npub fn measure<R>(label: &str, f: impl FnOnce() -> R) -> R {\n    static ZED_MEASUREMENTS: OnceLock<bool> = OnceLock::new();\n    let zed_measurements = ZED_MEASUREMENTS.get_or_init(|| {\n        env::var(": "",
        ")\n            .map(|measurements| measurements == ": "",
        " || measurements == ": "",
        ")\n            .unwrap_or(false)\n    });\n\n    if *zed_measurements {\n        let start = Instant::now();\n        let result = f();\n        let elapsed = start.elapsed();\n        eprintln!(": "",
        ", label, elapsed);\n        result\n    } else {\n        f()\n    }\n}\n\npub fn expanded_and_wrapped_usize_range(\n    range: Range<usize>,\n    additional_before: usize,\n    additional_after: usize,\n    wrap_length: usize,\n) -> impl Iterator<Item = usize> {\n    let start_wraps = range.start < additional_before;\n    let end_wraps = wrap_length < range.end + additional_after;\n    if start_wraps && end_wraps {\n        Either::Left(0..wrap_length)\n    } else if start_wraps {\n        let wrapped_start = (range.start + wrap_length).saturating_sub(additional_before);\n        if wrapped_start <= range.end {\n            Either::Left(0..wrap_length)\n        } else {\n            Either::Right((0..range.end + additional_after).chain(wrapped_start..wrap_length))\n        }\n    } else if end_wraps {\n        let wrapped_end = range.end + additional_after - wrap_length;\n        if range.start <= wrapped_end {\n            Either::Left(0..wrap_length)\n        } else {\n            Either::Right((0..wrapped_end).chain(range.start - additional_before..wrap_length))\n        }\n    } else {\n        Either::Left((range.start - additional_before)..(range.end + additional_after))\n    }\n}\n\n/// Yields `[i, i + 1, i - 1, i + 2, ..]`, each modulo `wrap_length` and bounded by\n/// `additional_before` and `additional_after`. If the wrapping causes overlap, duplicates are not\n/// emitted. If wrap_length is 0, nothing is yielded.\npub fn wrapped_usize_outward_from(\n    start: usize,\n    additional_before: usize,\n    additional_after: usize,\n    wrap_length: usize,\n) -> impl Iterator<Item = usize> {\n    let mut count = 0;\n    let mut after_offset = 1;\n    let mut before_offset = 1;\n\n    std::iter::from_fn(move || {\n        count += 1;\n        if count > wrap_length {\n            None\n        } else if count == 1 {\n            Some(start % wrap_length)\n        } else if after_offset <= additional_after && after_offset <= before_offset {\n            let value = (start + after_offset) % wrap_length;\n            after_offset += 1;\n            Some(value)\n        } else if before_offset <= additional_before {\n            let value = (start + wrap_length - before_offset) % wrap_length;\n            before_offset += 1;\n            Some(value)\n        } else if after_offset <= additional_after {\n            let value = (start + after_offset) % wrap_length;\n            after_offset += 1;\n            Some(value)\n        } else {\n            None\n        }\n    })\n}\n\npub trait ResultExt<E> {\n    type Ok;\n\n    fn log_err(self) -> Option<Self::Ok>;\n    /// Assert that this result should never be an error in development or tests.\n    fn debug_assert_ok(self, reason: &str) -> Self;\n    fn warn_on_err(self) -> Option<Self::Ok>;\n    fn log_with_level(self, level: log::Level) -> Option<Self::Ok>;\n    fn anyhow(self) -> anyhow::Result<Self::Ok>\n    where\n        E: Into<anyhow::Error>;\n}\n\nimpl<T, E> ResultExt<E> for Result<T, E>\nwhere\n    E: std::fmt::Debug,\n{\n    type Ok = T;\n\n    #[track_caller]\n    fn log_err(self) -> Option<T> {\n        self.log_with_level(log::Level::Error)\n    }\n\n    #[track_caller]\n    fn debug_assert_ok(self, reason: &str) -> Self {\n        if let Err(error) = &self {\n            debug_panic!(": "",
        ");\n        }\n        self\n    }\n\n    #[track_caller]\n    fn warn_on_err(self) -> Option<T> {\n        self.log_with_level(log::Level::Warn)\n    }\n\n    #[track_caller]\n    fn log_with_level(self, level: log::Level) -> Option<T> {\n        match self {\n            Ok(value) => Some(value),\n            Err(error) => {\n                log_error_with_caller(*Location::caller(), error, level);\n                None\n            }\n        }\n    }\n\n    fn anyhow(self) -> anyhow::Result<T>\n    where\n        E: Into<anyhow::Error>,\n    {\n        self.map_err(Into::into)\n    }\n}\n\nfn log_error_with_caller<E>(caller: core::panic::Location<'_>, error: E, level: log::Level)\nwhere\n    E: std::fmt::Debug,\n{\n    #[cfg(not(target_os = ": "",
        "))]\n    let file = caller.file();\n    #[cfg(target_os = ": "",
        ")]\n    let file = caller.file().replace('\\\\', ": "",
        ");\n    // In this codebase all crates reside in a `crates` directory,\n    // so discard the prefix up to that segment to find the crate name\n    let file = file.split_once(": "",
        ");\n    let target = file.as_ref().and_then(|(_, s)| s.split_once(": "",
        "));\n\n    let module_path = target.map(|(krate, module)| {\n        if module.starts_with(krate) {\n            module.trim_end_matches(": "",
        ").replace('/', ": "",
        ")\n        } else {\n            krate.to_owned() + ": "",
        " + &module.trim_end_matches(": "",
        ")\n        }\n    });\n    let file = file.map(|(_, file)| format!(": "",
        "));\n    log::logger().log(\n        &log::Record::builder()\n            .target(module_path.as_deref().unwrap_or(": "",
        "))\n            .module_path(file.as_deref())\n            .args(format_args!(": "",
        ", error))\n            .file(Some(caller.file()))\n            .line(Some(caller.line()))\n            .level(level)\n            .build(),\n    );\n}\n\npub fn log_err<E: std::fmt::Debug>(error: &E) {\n    log_error_with_caller(*Location::caller(), error, log::Level::Error);\n}\n\npub trait TryFutureExt {\n    fn log_err(self) -> LogErrorFuture<Self>\n    where\n        Self: Sized;\n\n    fn log_tracked_err(self, location: core::panic::Location<'static>) -> LogErrorFuture<Self>\n    where\n        Self: Sized;\n\n    fn warn_on_err(self) -> LogErrorFuture<Self>\n    where\n        Self: Sized;\n    fn unwrap(self) -> UnwrapFuture<Self>\n    where\n        Self: Sized;\n}\n\nimpl<F, T, E> TryFutureExt for F\nwhere\n    F: Future<Output = Result<T, E>>,\n    E: std::fmt::Debug,\n{\n    #[track_caller]\n    fn log_err(self) -> LogErrorFuture<Self>\n    where\n        Self: Sized,\n    {\n        let location = Location::caller();\n        LogErrorFuture(self, log::Level::Error, *location)\n    }\n\n    fn log_tracked_err(self, location: core::panic::Location<'static>) -> LogErrorFuture<Self>\n    where\n        Self: Sized,\n    {\n        LogErrorFuture(self, log::Level::Error, location)\n    }\n\n    #[track_caller]\n    fn warn_on_err(self) -> LogErrorFuture<Self>\n    where\n        Self: Sized,\n    {\n        let location = Location::caller();\n        LogErrorFuture(self, log::Level::Warn, *location)\n    }\n\n    fn unwrap(self) -> UnwrapFuture<Self>\n    where\n        Self: Sized,\n    {\n        UnwrapFuture(self)\n    }\n}\n\n#[must_use]\npub struct LogErrorFuture<F>(F, log::Level, core::panic::Location<'static>);\n\nimpl<F, T, E> Future for LogErrorFuture<F>\nwhere\n    F: Future<Output = Result<T, E>>,\n    E: std::fmt::Debug,\n{\n    type Output = Option<T>;\n\n    fn poll(self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let level = self.1;\n        let location = self.2;\n        let inner = unsafe { Pin::new_unchecked(&mut self.get_unchecked_mut().0) };\n        match inner.poll(cx) {\n            Poll::Ready(output) => Poll::Ready(match output {\n                Ok(output) => Some(output),\n                Err(error) => {\n                    log_error_with_caller(location, error, level);\n                    None\n                }\n            }),\n            Poll::Pending => Poll::Pending,\n        }\n    }\n}\n\npub struct UnwrapFuture<F>(F);\n\nimpl<F, T, E> Future for UnwrapFuture<F>\nwhere\n    F: Future<Output = Result<T, E>>,\n    E: std::fmt::Debug,\n{\n    type Output = T;\n\n    fn poll(self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n        let inner = unsafe { Pin::new_unchecked(&mut self.get_unchecked_mut().0) };\n        match inner.poll(cx) {\n            Poll::Ready(result) => Poll::Ready(result.unwrap()),\n            Poll::Pending => Poll::Pending,\n        }\n    }\n}\n\npub struct Deferred<F: FnOnce()>(Option<F>);\n\nimpl<F: FnOnce()> Deferred<F> {\n    /// Drop without running the deferred function.\n    pub fn abort(mut self) {\n        self.0.take();\n    }\n}\n\nimpl<F: FnOnce()> Drop for Deferred<F> {\n    fn drop(&mut self) {\n        if let Some(f) = self.0.take() {\n            f()\n        }\n    }\n}\n\n/// Run the given function when the returned value is dropped (unless it's cancelled).\n#[must_use]\npub fn defer<F: FnOnce()>(f: F) -> Deferred<F> {\n    Deferred(Some(f))\n}\n\n#[cfg(any(test, feature = ": "",
        "))]\nmod rng {\n    use rand::prelude::*;\n\n    pub struct RandomCharIter<T: Rng> {\n        rng: T,\n        simple_text: bool,\n    }\n\n    impl<T: Rng> RandomCharIter<T> {\n        pub fn new(rng: T) -> Self {\n            Self {\n                rng,\n                simple_text: std::env::var(": "",
        ").is_ok_and(|v| !v.is_empty()),\n            }\n        }\n\n        pub fn with_simple_text(mut self) -> Self {\n            self.simple_text = true;\n            self\n        }\n    }\n\n    impl<T: Rng> Iterator for RandomCharIter<T> {\n        type Item = char;\n\n        fn next(&mut self) -> Option<Self::Item> {\n            if self.simple_text {\n                return if self.rng.random_range(0..100) < 5 {\n                    Some('\\n')\n                } else {\n                    Some(self.rng.random_range(b'a'..b'z' + 1).into())\n                };\n            }\n\n            match self.rng.random_range(0..100) {\n                // whitespace\n                0..=19 => [' ', '\\n', '\\r', '\\t'].choose(&mut self.rng).copied(),\n                // two-byte greek letters\n                20..=32 => char::from_u32(self.rng.random_range(('α' as u32)..('ω' as u32 + 1))),\n                // // three-byte characters\n                33..=45 => ['✋', '✅', '❌', '❎', '⭐']\n                    .choose(&mut self.rng)\n                    .copied(),\n                // // four-byte characters\n                46..=58 => ['🍐', '🏀', '🍗', '🎉'].choose(&mut self.rng).copied(),\n                // ascii letters\n                _ => Some(self.rng.random_range(b'a'..b'z' + 1).into()),\n            }\n        }\n    }\n}\n#[cfg(any(test, feature = ": "",
        "))]\npub use rng::RandomCharIter;\n\n/// Get an embedded file as a string.\npub fn asset_str<A: rust_embed::RustEmbed>(path: &str) -> Cow<'static, str> {\n    match A::get(path).expect(path).data {\n        Cow::Borrowed(bytes) => Cow::Borrowed(std::str::from_utf8(bytes).unwrap()),\n        Cow::Owned(bytes) => Cow::Owned(String::from_utf8(bytes).unwrap()),\n    }\n}\n\n/// Expands to an immediately-invoked function expression. Good for using the ? operator\n/// in functions which do not return an Option or Result.\n///\n/// Accepts a normal block, an async block, or an async move block.\n#[macro_export]\nmacro_rules! maybe {\n    ($block:block) => {\n        (|| $block)()\n    };\n    (async $block:block) => {\n        (async || $block)()\n    };\n    (async move $block:block) => {\n        (async move || $block)()\n    };\n}\n\npub trait RangeExt<T> {\n    fn sorted(&self) -> Self;\n    fn to_inclusive(&self) -> RangeInclusive<T>;\n    fn overlaps(&self, other: &Range<T>) -> bool;\n    fn contains_inclusive(&self, other: &Range<T>) -> bool;\n}\n\nimpl<T: Ord + Clone> RangeExt<T> for Range<T> {\n    fn sorted(&self) -> Self {\n        cmp::min(&self.start, &self.end).clone()..cmp::max(&self.start, &self.end).clone()\n    }\n\n    fn to_inclusive(&self) -> RangeInclusive<T> {\n        self.start.clone()..=self.end.clone()\n    }\n\n    fn overlaps(&self, other: &Range<T>) -> bool {\n        self.start < other.end && other.start < self.end\n    }\n\n    fn contains_inclusive(&self, other: &Range<T>) -> bool {\n        self.start <= other.start && other.end <= self.end\n    }\n}\n\nimpl<T: Ord + Clone> RangeExt<T> for RangeInclusive<T> {\n    fn sorted(&self) -> Self {\n        cmp::min(self.start(), self.end()).clone()..=cmp::max(self.start(), self.end()).clone()\n    }\n\n    fn to_inclusive(&self) -> RangeInclusive<T> {\n        self.clone()\n    }\n\n    fn overlaps(&self, other: &Range<T>) -> bool {\n        self.start() < &other.end && &other.start <= self.end()\n    }\n\n    fn contains_inclusive(&self, other: &Range<T>) -> bool {\n        self.start() <= &other.start && &other.end <= self.end()\n    }\n}\n\n/// A way to sort strings with starting numbers numerically first, falling back to alphanumeric one,\n/// case-insensitive.\n///\n/// This is useful for turning regular alphanumerically sorted sequences as `1-abc, 10, 11-def, .., 2, 21-abc`\n/// into `1-abc, 2, 10, 11-def, .., 21-abc`\n#[derive(Debug, PartialEq, Eq)]\npub struct NumericPrefixWithSuffix<'a>(Option<u64>, &'a str);\n\nimpl<'a> NumericPrefixWithSuffix<'a> {\n    pub fn from_numeric_prefixed_str(str: &'a str) -> Self {\n        let i = str.chars().take_while(|c| c.is_ascii_digit()).count();\n        let (prefix, remainder) = str.split_at(i);\n\n        let prefix = prefix.parse().ok();\n        Self(prefix, remainder)\n    }\n}\n\n/// When dealing with equality, we need to consider the case of the strings to achieve strict equality\n/// to handle cases like ": "",
        " < ": "",
        " instead of ": "",
        " == ": "",
        ".\nimpl Ord for NumericPrefixWithSuffix<'_> {\n    fn cmp(&self, other: &Self) -> Ordering {\n        match (self.0, other.0) {\n            (None, None) => UniCase::new(self.1)\n                .cmp(&UniCase::new(other.1))\n                .then_with(|| self.1.cmp(other.1).reverse()),\n            (None, Some(_)) => Ordering::Greater,\n            (Some(_), None) => Ordering::Less,\n            (Some(a), Some(b)) => a.cmp(&b).then_with(|| {\n                UniCase::new(self.1)\n                    .cmp(&UniCase::new(other.1))\n                    .then_with(|| self.1.cmp(other.1).reverse())\n            }),\n        }\n    }\n}\n\nimpl PartialOrd for NumericPrefixWithSuffix<'_> {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}\n\n/// Capitalizes the first character of a string.\n///\n/// This function takes a string slice as input and returns a new `String` with the first character\n/// capitalized.\n///\n/// # Examples\n///\n/// ```\n/// use util::capitalize;\n///\n/// assert_eq!(capitalize(": "",
        "), ": "",
        ");\n/// assert_eq!(capitalize(": "",
        ");\n/// ```\npub fn capitalize(str: &str) -> String {\n    let mut chars = str.chars();\n    match chars.next() {\n        None => String::new(),\n        Some(first_char) => first_char.to_uppercase().collect::<String>() + chars.as_str(),\n    }\n}\n\nfn emoji_regex() -> &'static Regex {\n    static EMOJI_REGEX: LazyLock<Regex> =\n        LazyLock::new(|| Regex::new(": "",
        ").unwrap());\n    &EMOJI_REGEX\n}\n\n/// Returns true if the given string consists of emojis only.\n/// E.g. ": "",
        " will return true, but ": "",
        " will return false.\npub fn word_consists_of_emojis(s: &str) -> bool {\n    let mut prev_end = 0;\n    for capture in emoji_regex().find_iter(s) {\n        if capture.start() != prev_end {\n            return false;\n        }\n        prev_end = capture.end();\n    }\n    prev_end == s.len()\n}\n\n/// Similar to `str::split`, but also provides byte-offset ranges of the results. Unlike\n/// `str::split`, this is not generic on pattern types and does not return an `Iterator`.\npub fn split_str_with_ranges(s: &str, pat: impl Fn(char) -> bool) -> Vec<(Range<usize>, &str)> {\n    let mut result = Vec::new();\n    let mut start = 0;\n\n    for (i, ch) in s.char_indices() {\n        if pat(ch) {\n            if i > start {\n                result.push((start..i, &s[start..i]));\n            }\n            start = i + ch.len_utf8();\n        }\n    }\n\n    if s.len() > start {\n        result.push((start..s.len(), &s[start..s.len()]));\n    }\n\n    result\n}\n\npub fn default<D: Default>() -> D {\n    Default::default()\n}\n\npub use self::shell::{\n    get_default_system_shell, get_default_system_shell_preferring_bash, get_system_shell,\n};\n\n#[derive(Debug)]\npub enum ConnectionResult<O> {\n    Timeout,\n    ConnectionReset,\n    Result(anyhow::Result<O>),\n}\n\nimpl<O> ConnectionResult<O> {\n    pub fn into_response(self) -> anyhow::Result<O> {\n        match self {\n            ConnectionResult::Timeout => anyhow::bail!(": "",
        "),\n            ConnectionResult::ConnectionReset => anyhow::bail!(": "",
        "),\n            ConnectionResult::Result(r) => r,\n        }\n    }\n}\n\nimpl<O> From<anyhow::Result<O>> for ConnectionResult<O> {\n    fn from(result: anyhow::Result<O>) -> Self {\n        ConnectionResult::Result(result)\n    }\n}\n\n#[track_caller]\npub fn some_or_debug_panic<T>(option: Option<T>) -> Option<T> {\n    #[cfg(debug_assertions)]\n    if option.is_none() {\n        panic!(": "",
        ");\n    }\n    option\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_extend_sorted() {\n        let mut vec = vec![];\n\n        extend_sorted(&mut vec, vec![21, 17, 13, 8, 1, 0], 5, |a, b| b.cmp(a));\n        assert_eq!(vec, &[21, 17, 13, 8, 1]);\n\n        extend_sorted(&mut vec, vec![101, 19, 17, 8, 2], 8, |a, b| b.cmp(a));\n        assert_eq!(vec, &[101, 21, 19, 17, 13, 8, 2, 1]);\n\n        extend_sorted(&mut vec, vec![1000, 19, 17, 9, 5], 8, |a, b| b.cmp(a));\n        assert_eq!(vec, &[1000, 101, 21, 19, 17, 13, 9, 8]);\n    }\n\n    #[test]\n    fn test_truncate_to_bottom_n_sorted_by() {\n        let mut vec: Vec<u32> = vec![5, 2, 3, 4, 1];\n        truncate_to_bottom_n_sorted_by(&mut vec, 10, &u32::cmp);\n        assert_eq!(vec, &[1, 2, 3, 4, 5]);\n\n        vec = vec![5, 2, 3, 4, 1];\n        truncate_to_bottom_n_sorted_by(&mut vec, 5, &u32::cmp);\n        assert_eq!(vec, &[1, 2, 3, 4, 5]);\n\n        vec = vec![5, 2, 3, 4, 1];\n        truncate_to_bottom_n_sorted_by(&mut vec, 4, &u32::cmp);\n        assert_eq!(vec, &[1, 2, 3, 4]);\n\n        vec = vec![5, 2, 3, 4, 1];\n        truncate_to_bottom_n_sorted_by(&mut vec, 1, &u32::cmp);\n        assert_eq!(vec, &[1]);\n\n        vec = vec![5, 2, 3, 4, 1];\n        truncate_to_bottom_n_sorted_by(&mut vec, 0, &u32::cmp);\n        assert!(vec.is_empty());\n    }\n\n    #[test]\n    fn test_iife() {\n        fn option_returning_function() -> Option<()> {\n            None\n        }\n\n        let foo = maybe!({\n            option_returning_function()?;\n            Some(())\n        });\n\n        assert_eq!(foo, None);\n    }\n\n    #[test]\n    fn test_truncate_and_trailoff() {\n        assert_eq!(truncate_and_trailoff(": "",
        ", 5), ": "",
        ");\n        assert_eq!(truncate_and_trailoff(": "",
        ", 7), ": "",
        ", 6), ": "",
        ");\n    }\n\n    #[test]\n    fn test_truncate_and_remove_front() {\n        assert_eq!(truncate_and_remove_front(": "",
        ");\n        assert_eq!(truncate_and_remove_front(": "",
        ");\n    }\n\n    #[test]\n    fn test_numeric_prefix_str_method() {\n        let target = ": "",
        ";\n        assert_eq!(\n            NumericPrefixWithSuffix::from_numeric_prefixed_str(target),\n            NumericPrefixWithSuffix(Some(1), ": "",
        ")\n        );\n\n        let target = ": "",
        ";\n        assert_eq!(\n            NumericPrefixWithSuffix::from_numeric_prefixed_str(target),\n            NumericPrefixWithSuffix(Some(12), ": "",
        ")\n        );\n    }\n\n    #[test]\n    fn test_numeric_prefix_with_suffix() {\n        let mut sorted = vec![": "",
        "];\n        sorted.sort_by_key(|s| NumericPrefixWithSuffix::from_numeric_prefixed_str(s));\n        assert_eq!(sorted, [": "",
        "]);\n\n        for numeric_prefix_less in [": "",
        "] {\n            assert_eq!(\n                NumericPrefixWithSuffix::from_numeric_prefixed_str(numeric_prefix_less),\n                NumericPrefixWithSuffix(None, numeric_prefix_less),\n                ": "",
        "\n            )\n        }\n    }\n\n    #[test]\n    fn test_word_consists_of_emojis() {\n        let words_to_test = vec![\n            (": "",
        ", true),\n            (": "",
        ", false),\n            (": "",
        ", false),\n        ];\n\n        for (text, expected_result) in words_to_test {\n            assert_eq!(word_consists_of_emojis(text), expected_result);\n        }\n    }\n\n    #[test]\n    fn test_truncate_lines_and_trailoff() {\n        let text = r#": "",
        "#;\n\n        assert_eq!(\n            truncate_lines_and_trailoff(text, 2),\n            r#": "",
        "#\n        );\n\n        assert_eq!(\n            truncate_lines_and_trailoff(text, 3),\n            r#": "",
        "#\n        );\n\n        assert_eq!(\n            truncate_lines_and_trailoff(text, 4),\n            r#": "",
        "#\n        );\n    }\n\n    #[test]\n    fn test_expanded_and_wrapped_usize_range() {\n        // Neither wrap\n        assert_eq!(\n            expanded_and_wrapped_usize_range(2..4, 1, 1, 8).collect::<Vec<usize>>(),\n            (1..5).collect::<Vec<usize>>()\n        );\n        // Start wraps\n        assert_eq!(\n            expanded_and_wrapped_usize_range(2..4, 3, 1, 8).collect::<Vec<usize>>(),\n            ((0..5).chain(7..8)).collect::<Vec<usize>>()\n        );\n        // Start wraps all the way around\n        assert_eq!(\n            expanded_and_wrapped_usize_range(2..4, 5, 1, 8).collect::<Vec<usize>>(),\n            (0..8).collect::<Vec<usize>>()\n        );\n        // Start wraps all the way around and past 0\n        assert_eq!(\n            expanded_and_wrapped_usize_range(2..4, 10, 1, 8).collect::<Vec<usize>>(),\n            (0..8).collect::<Vec<usize>>()\n        );\n        // End wraps\n        assert_eq!(\n            expanded_and_wrapped_usize_range(3..5, 1, 4, 8).collect::<Vec<usize>>(),\n            (0..1).chain(2..8).collect::<Vec<usize>>()\n        );\n        // End wraps all the way around\n        assert_eq!(\n            expanded_and_wrapped_usize_range(3..5, 1, 5, 8).collect::<Vec<usize>>(),\n            (0..8).collect::<Vec<usize>>()\n        );\n        // End wraps all the way around and past the end\n        assert_eq!(\n            expanded_and_wrapped_usize_range(3..5, 1, 10, 8).collect::<Vec<usize>>(),\n            (0..8).collect::<Vec<usize>>()\n        );\n        // Both start and end wrap\n        assert_eq!(\n            expanded_and_wrapped_usize_range(3..5, 4, 4, 8).collect::<Vec<usize>>(),\n            (0..8).collect::<Vec<usize>>()\n        );\n    }\n\n    #[test]\n    fn test_wrapped_usize_outward_from() {\n        // No wrapping\n        assert_eq!(\n            wrapped_usize_outward_from(4, 2, 2, 10).collect::<Vec<usize>>(),\n            vec![4, 5, 3, 6, 2]\n        );\n        // Wrapping at end\n        assert_eq!(\n            wrapped_usize_outward_from(8, 2, 3, 10).collect::<Vec<usize>>(),\n            vec![8, 9, 7, 0, 6, 1]\n        );\n        // Wrapping at start\n        assert_eq!(\n            wrapped_usize_outward_from(1, 3, 2, 10).collect::<Vec<usize>>(),\n            vec![1, 2, 0, 3, 9, 8]\n        );\n        // All values wrap around\n        assert_eq!(\n            wrapped_usize_outward_from(5, 10, 10, 8).collect::<Vec<usize>>(),\n            vec![5, 6, 4, 7, 3, 0, 2, 1]\n        );\n        // None before / after\n        assert_eq!(\n            wrapped_usize_outward_from(3, 0, 0, 8).collect::<Vec<usize>>(),\n            vec![3]\n        );\n        // Starting point already wrapped\n        assert_eq!(\n            wrapped_usize_outward_from(15, 2, 2, 10).collect::<Vec<usize>>(),\n            vec![5, 6, 4, 7, 3]\n        );\n        // wrap_length of 0\n        assert_eq!(\n            wrapped_usize_outward_from(4, 2, 2, 0).collect::<Vec<usize>>(),\n            Vec::<usize>::new()\n        );\n    }\n\n    #[test]\n    fn test_split_with_ranges() {\n        let input = ": "",
        ";\n        let result = split_str_with_ranges(input, |c| c == ' ');\n\n        assert_eq!(result.len(), 1);\n        assert_eq!(result[0], (0..2, ": "",
        "));\n\n        let input = ": "",
        ";\n        let result = split_str_with_ranges(input, |c| c == '🦀');\n\n        assert_eq!(result.len(), 2);\n        assert_eq!(result[0], (0..6, ": "",
        ")); // 'é' is 2 bytes\n        assert_eq!(result[1], (10..15, ": ""
    },
    "zed/crates/vim/src/change_list.rs": {
        "ˇ": "",
        "i 1 1 escape shift-o 2 2 escape shift-g o 3 3 escape": "",
        "22\n             11\n             3ˇ3": "",
        "g ;": "",
        "2ˇ2\n             11\n             33": "",
        "22\n             1ˇ1\n             33": "",
        "g ,": "",
        "shift-g i 4 4 escape": "",
        "22\n             11\n             34ˇ43": "",
        "2ˇ2\n             11\n             3443": "",
        "one two\n        three fˇour": "",
        "x k d i w ^ x": "",
        "ˇne•\n        three fur": "",
        "2 g ;": "",
        "ne•\n        three fˇur": "",
        "one two\n        three fˇr": "",
        "i o escape k g i": "",
        "u escape": "",
        "one two\n        three foˇur": "",
        "i o escape k ` .": "",
        "one two\n        three fˇor": ""
    },
    "zed/crates/vim/src/mode_indicator.rs": {
        "recording @{reg} ": "",
        "\\\"{reg}": "",
        "(insert) {}": "",
        "-- {} --": ""
    },
    "zed/crates/vim/src/normal.rs": {
        "Unexpected normal mode motion operator: {:?}": "",
        "[No Name]": "",
        " [modified]": "",
        "{}{} {} lines --{:.0}%--": "",
        "\\r": "",
        "h": "",
        "\n            ˇThe qˇuick\n            ˇbrown": "",
        "backspace": "",
        "\n            aaˇaa\n            😃😃": "",
        "j": "",
        "\n            aaaa\n            😃ˇ😃": "",
        "\n                ˇThe qˇuick broˇwn\n                ˇfox jumps": "",
        "enter": "",
        "\n            ˇThe qˇuick broˇwn\n            ˇfox jumps": "",
        "k": "",
        "\n            ˇThe qˇuick\n            ˇbrown fˇox jumˇps": "",
        "l": "",
        "\n            ˇThe qˇuicˇk\n            ˇbrowˇn": "",
        "\n                ˇThe qˇuicˇk\n                ˇbrowˇn": "",
        "shift-g": "",
        "\n                The ˇquick\n\n                brown fox jumps\n                overˇ the lazy doˇg": "",
        "\n            The quiˇck\n\n            brown": "",
        "\n            The quiˇck\n\n            ": "",
        "w": "",
        "\n            The ˇquickˇ-ˇbrown\n            ˇ\n            ˇ\n            ˇfox_jumps ˇover\n            ˇthˇe": "",
        "shift-w": "",
        "e": "",
        "\n            Thˇe quicˇkˇ-browˇn\n\n\n            fox_jumpˇs oveˇr\n            thˇe": "",
        "shift-e": "",
        "b": "",
        "\n            ˇThe ˇquickˇ-ˇbrown\n            ˇ\n            ˇ\n            ˇfox_jumps ˇover\n            ˇthe": "",
        "shift-b": "",
        "g g": "",
        "\n                The qˇuick\n\n                brown fox jumps\n                over ˇthe laˇzy dog": "",
        "\n\n\n                brown fox jumps\n                over the laˇzy dog": "",
        "2 g g": "",
        "\n                ˇ\n\n                brown fox jumps\n                over the lazydog": "",
        "2 shift-g": "",
        "a": "",
        "The qˇuicˇk": "",
        "shift-a": "",
        "\n            ˇ\n            The qˇuick\n            brown ˇfox ": "",
        "The qˇuick": "",
        " The qˇuick": "",
        "ˇ": "",
        "\n                The qˇuick\n                brown fox": "",
        "\n                ˇ\n                The quick": "",
        "   ˇ \\nThe quick": "",
        "shift-i": "",
        "shift-d": "",
        "\n                The quick\n                ˇ\n                brown fox": "",
        "x": "",
        "ˇTeˇsˇt": "",
        "\n                Tesˇt\n                test": "",
        "shift-x": "",
        "ˇTˇeˇsˇt": "",
        "\n                Test\n                ˇtest": "",
        "o": "",
        "The ˇquick": "",
        "\n                The qˇuick\n                brown ˇfox\n                jumps ˇover": "",
        "\n                fn test() {\n                    println!(ˇ);\n                }": "",
        "\n                fn test() {\n                    println!();\n                    ˇ\n                }": "",
        "\n                fn test(ˇ) {\n                    println!();\n                }": "",
        "\n                fn test() {\n                    ˇ\n                    println!();\n                }": "",
        "shift-o": "",
        "\n            The qˇuick\n            brown ˇfox\n            jumps ˇover": "",
        "\n            The quick\n            ˇ\n            brown fox": "",
        "\n                ˇ\n                fn test() {\n                    println!();\n                }": "",
        "[ space": "",
        "3 [ space": "",
        "] space": "",
        "3 ] space": "",
        "d d": "",
        "c c": "",
        "\n                The quˇick\n                brown ˇfox\n                jumps ˇover": "",
        "{count} w": "",
        "\n                    ˇThe quˇickˇ browˇn\n                    ˇ\n                    ˇfox ˇjumpsˇ-ˇoˇver\n                    ˇthe lazy dog\n                ": "",
        "Testˇ├ˇ──ˇ┐ˇTest": "",
        "\n                ˇaaaˇbˇ ˇbˇ   ˇbˇbˇ aˇaaˇbaaa\n                ˇ    ˇbˇaaˇa ˇbˇbˇb\n                ˇ\n                ˇb\n            ": "",
        "{count} f b": "",
        "{count} t b": "",
        "\n            ˇaaaˇbˇ ˇbˇ   ˇbˇbˇ aˇaaˇbaaa\n            ˇ    ˇbˇaaˇa ˇbˇbˇb\n            ˇ•••\n            ˇb\n            ": "",
        "{count} shift-f b": "",
        "{count} shift-t b": "",
        "f p": "",
        "ˇfmt.Println(\\\"Hello, World!\\\")": "",
        "fmt.ˇPrintln(\\\"Hello, World!\\\")": "",
        "shift-f p": "",
        "fmt.Printlnˇ(\\\"Hello, World!\\\")": "",
        "t p": "",
        "fmtˇ.Println(\\\"Hello, World!\\\")": "",
        "shift-t p": "",
        "fmt.Pˇrintln(\\\"Hello, World!\\\")": "",
        "ˇconsole.logˇ(ˇvaˇrˇ)ˇ;": "",
        "ˇconsole.logˇ(ˇ'var', ˇ[ˇ1, ˇ2, 3ˇ]ˇ)ˇ;": "",
        "let result = curried_funˇ(ˇ)ˇ(ˇ)ˇ;": "",
        "ˇaa\\nbb\\ncc": "",
        "aˇa\\nbb\\ncc": "",
        "2 $": "",
        "aa\\nbˇb\\ncc": "",
        "4 $": "",
        "aa\\nbb\\ncˇc": "",
        "Editor && VimControl && !VimWaiting && !menu": "",
        "g e": "",
        "ˇassert_binding": "",
        "assert_ˇbinding": "",
        "c w": "",
        "ˇ_binding": "",
        "asserˇt_binding": "",
        "assert_bindinˇg": "",
        "ˇhello\\n": "",
        "r -": "",
        "ˇ-ello\\n": "",
        "3 r -": "",
        "--ˇ-lo\\n": "",
        "r - 2 l .": "",
        "-eˇ-lo\\n": "",
        "ˇhello world\\n": "",
        "2 r - f w .": "",
        "--llo -ˇ-rld\\n": "",
        "2 0 r - ": "",
        "  helloˇ world\\n": "",
        "r enter": "",
        "  hello\\n ˇ world\\n": "",
        "2 r enter": "",
        "  hello\\n ˇ orld\\n": "",
        "textwidth=5": "",
        "ˇth th th th th th\\n": "",
        "g q q": "",
        "th th\\nth th\\nˇth th\\n": "",
        "ˇth th th th th th\\nth th th th th th\\n": "",
        "v j g q": "",
        "th th\\nth th\\nth th\\nth th\\nth th\\nˇth th\\n": "",
        "filetype=rust": "",
        "// helloˇ\\n": "",
        "// hello\\n// ˇ\\n": "",
        "x escape shift-o": "",
        "// hello\\n// ˇ\\n// x\\n": "",
        "heˇllo\\n": "",
        "y y p": "",
        "hello\\nˇhello\\n": "",
        "heˇllo": "",
        "hello\\nˇhello": "",
        "heˇllo\\nhello": "",
        "2 y y p": "",
        "hello\\nˇhello\\nhello\\nhello": "",
        "p p": "",
        "\\nhello\\nˇhello": "",
        "v i w shift-i": "",
        "ˇhello": "",
        "\n            The quick brown\n            fox ˇjumps over\n            the lazy dog": "",
        "shift-v shift-i": "",
        "\n            The quick brown\n            ˇfox jumps over\n            the lazy dog": "",
        "shift-v shift-a": "",
        "\n            The quick brown\n            fox jˇumps over\n            the lazy dog": "",
        "\n            ˇfn a() { }\n\n\n\n\n\n            fn b() { }\n\n\n\n\n\n            fn b() { }": "",
        "3 }": "",
        "ctrl-o": "",
        "ctrl-i": "",
        "1 1 k": "",
        "\n            ˇfn a() { }\n            fn a() { }\n            fn a() { }\n        ": "",
        "r a": "",
        "shift-u": "",
        "g g shift-u": "",
        "shift-g k": "",
        "o h e l l o escape": "",
        "x shift-g k": "",
        "x f a x f { x": "",
        "\n            ˇone two ˇone\n            two ˇone two\n        ": "",
        "3 r a": "",
        "\n            aaˇa two aaˇa\n            two aaˇa two\n        ": "",
        "escape escape": "",
        "\n            onˇe two onˇe\n            two onˇe two\n        ": "",
        ": tabnew": "",
        "1 g t": "",
        "3 g t": "",
        "4 g t": "",
        "g t": "",
        "2 g shift-t": "",
        "g shift-t": "",
        "6 g shift-t": ""
    },
    "zed/crates/vim/src/surrounds.rs": {
        "{}\\n": "",
        "\\n{}": "",
        " ": "",
        "hello in a word": "",
        "John": "",
        "b": "",
        "B": "",
        "a": "",
        "r": "",
        "\n            The quˇick brown\n            fox jumps over\n            the lazy dog.": "",
        "y s i w {": "",
        "\n            The ˇ{ quick } brown\n            fox jumps over\n            the lazy dog.": "",
        "y s i w }": "",
        "\n            The ˇ{quick} brown\n            fox jumps over\n            the lazy dog.": "",
        "y s $ }": "",
        "\n            The quˇ{ick brown}\n            fox jumps over\n            the lazy dog.": "",
        "\n            The quˇick brown\n            fox jumps over\n            the laˇzy dog.": "",
        "y s i w '": "",
        "\n            The ˇ'quick' brown\n            fox jumps over\n            the ˇ'lazy' dog.": "",
        "y s $ '": "",
        "\n            The quˇ'ick brown'\n            fox jumps over\n            the laˇ'zy dog.'": "",
        "y s $ 1": "",
        "\n            The quˇ1ick brown1\n            fox jumps over\n            the laˇ1zy dog.1": "",
        "y s s {": "",
        "\n            ˇ{ The quick brown }\n            fox jumps over\n            the lazy dog.": "",
        "\n                The quˇick brown•\n            fox jumps over\n            the lazy dog.": "",
        "\n                ˇ{ The quick brown }•\n            fox jumps over\n            the lazy dog.": "",
        "2 y s s )": "",
        "\n                ˇ({ The quick brown }•\n            fox jumps over)\n            the lazy dog.": "",
        "\n            The [quˇick] brown\n            fox jumps over\n            the lazy dog.": "",
        "y s a ] )": "",
        "\n            The ˇ([quick]) brown\n            fox jumps over\n            the lazy dog.": "",
        "y s i ] )": "",
        "\n            The [ˇ(quick)] brown\n            fox jumps over\n            the lazy dog.": "",
        "shift-s": "",
        "vim_mode == visual": "",
        "v i w shift-s {": "",
        "v i w shift-s }": "",
        "v e shift-s }": "",
        "\n            The quˇ{ick} brown\n            fox jumps over\n            the lazy dog.": "",
        "v i w shift-s '": "",
        "ctrl-v i w j j shift-s '": "",
        "\n            The ˇ'quick' brown\n            fox 'jumps' over\n            the 'lazy 'dog.": "",
        "j shift-v shift-s '": "",
        "\n            The quick brown\n            ˇ'\n            fox jumps over\n            '\n            the lazy dog.": "",
        "\n            The {quˇick} brown\n            fox jumps over\n            the lazy dog.": "",
        "d s {": "",
        "\n            The ˇquick brown\n            fox jumps over\n            the lazy dog.": "",
        "d s [": "",
        "\n            The {quick} brˇown\n            fox jumps over\n            the lazy dog.": "",
        "\n            The { quick brown\n            fox jumˇps over }\n            the lazy dog.": "",
        "\n            The [quˇick] brown\n            fox jumps over\n            the [laˇzy] dog.": "",
        "d s ]": "",
        "\n            The ˇquick brown\n            fox jumps over\n            the ˇlazy dog.": "",
        "\n            Tˇhe [ quick ] brown\n            fox jumps over\n            the [laˇzy] dog.": "",
        "\n            Tˇhe [ quick ] brown\n            fox jumps over\n            the [laˇzy ] dog.": "",
        "\n            The [quˇick] brown\n            fox jumps over\n            the {laˇzy} dog.": "",
        "\n            The [quick] brown\n            fox jumps over\n            the ˇlazy dog.": "",
        "\n            fn test_surround() {\n                ifˇ 2 > 1 {\n                    ˇprintln!(\\\"it is fine\\\");\n                };\n            }": "",
        "d s }": "",
        "\n            fn test_surround() ˇ\n                if 2 > 1 ˇ\n                    println!(\\\"it is fine\\\");\n                ;\n            ": "",
        "c s { [": "",
        "\n            The ˇ[ quick ] brown\n            fox jumps over\n            the lazy dog.": "",
        "\n            The {quˇick} brown\n            fox jumps over\n            the {laˇzy} dog.": "",
        "\n            The ˇ[ quick ] brown\n            fox jumps over\n            the ˇ[ lazy ] dog.": "",
        "\n            Thˇe {quick} brown\n            fox jumps over\n            the {laˇzy} dog.": "",
        "\n            Thˇe { quick } brown\n            fox jumps over\n            the {laˇzy} dog.": "",
        "c s { ]": "",
        "\n            The ˇ[quick] brown\n            fox jumps over\n            the ˇ[lazy] dog.": "",
        "\n            The {quˇick} brown\n            fox jumps over\n            the [laˇzy] dog.": "",
        "c s [ '": "",
        "\n            The {quick} brown\n            fox jumps over\n            the ˇ'lazy' dog.": "",
        "\n            fn test_surround() {\n                ifˇ 2 > 1 {\n                    ˇprintln!(\\\"it is fine\\\");\n                }\n            };": "",
        "c s } ]": "",
        "\n            fn test_surround() ˇ[\n                if 2 > 1 ˇ[\n                    println!(\\\"it is fine\\\");\n                ]\n            ];": "",
        "'  ˇstr  '": "",
        "c s ' \\\"": "",
        "ˇ\\\"  str  \\\"": "",
        "\n            '  ˇstr  '\n            some example text here\n            ˇ'  str  '\n        ": "",
        "\n            ˇ\\\"  str  \\\"\n            some example text here\n            ˇ\\\"  str  \\\"\n        ": "",
        "'ˇfoobar'": "",
        "c s ' {": "",
        "ˇ{ foobar }": "",
        "c s ' }": "",
        "ˇ{foobar}": "",
        "vim_operator == a || vim_operator == i || vim_operator == cs": "",
        "{braˇcketed}": "",
        "c s b [": "",
        "ˇ[ bracketed ]": "",
        "[braˇcketed]": "",
        "c s b {": "",
        "ˇ{ bracketed }": "",
        "<braˇcketed>": "",
        "(braˇcketed)": "",
        "(< name: ˇ'Zed' >)": "",
        "c s b }": "",
        "(ˇ{ name: 'Zed' })": "",
        "\n            (< name: ˇ'Zed' >)\n            (< nˇame: 'DeltaDB' >)\n        ": "",
        "\n            (ˇ{ name: 'Zed' })\n            (ˇ{ name: 'DeltaDB' })\n        ": "",
        "'  ˇa  '": "",
        "ˇ\\\"  a  \\\"": "",
        "\\\"  ˇa  \\\"": "",
        "c s \\\" '": "",
        "ˇ'  a  '": "",
        "ˇ{   a   }": "",
        "ˇ{  a  }": "",
        "{  ˇa  }": "",
        "c s { '": "",
        "ˇ'a'": "",
        "c s } '": "",
        "{   ˇa   }": "",
        "ˇ[ a ]": "",
        "ˇ[a]": "",
        "c s } [": "",
        "ˇ[   a   ]": "",
        "ˇ[  a  ]": "",
        "y s i w [": "",
        "c s [ }": "",
        "u": "",
        "y s i w b": "",
        "\n            The ˇ(quick) brown\n            fox jumps over\n            the lazy dog.": "",
        "y s i w B": "",
        "y s i w a": "",
        "\n            The ˇ<quick> brown\n            fox jumps over\n            the lazy dog.": "",
        "y s i w r": "",
        "\n            The ˇ[quick] brown\n            fox jumps over\n            the lazy dog.": "",
        "c s { b": "",
        "\n            The (quˇick) brown\n            fox jumps over\n            the lazy dog.": "",
        "c s ( B": "",
        "c s ( a": "",
        "\n            The <quˇick> brown\n            fox jumps over\n            the lazy dog.": "",
        "c s < b": "",
        "c s ( r": "",
        "c s [ b": "",
        "d s B": "",
        "d s b": "",
        "d s r": "",
        "d s a": ""
    },
    "zed/crates/workspace/src/notifications.rs": {
        "Error: {err}": "",
        "See docs": "",
        "Response already sent": "",
        "Stream already closed": "",
        "language_server_prompt_notification": "",
        "suppress": "",
        "close": "",
        "copy": "",
        "Copy Description": "",
        "Suppress.\\nClose with click.": "",
        "Close.\\nSuppress with shift-click.": "",
        "error_message_prompt_notification": "",
        "error_message": "",
        "error_message_prompt_notification_button": "",
        "Close": "",
        "Showing error notification in workspace: {err:?}": "",
        "{err:?}": "",
        "Showing error notification in app: {message}": "",
        "{err}": "",
        "{display}Please try again.": "",
        "Ok": ""
    },
    "zed/crates/workspace/src/pane_group.rs": {
        "Pane not found": "",
        "{} is in an unshared pane": "",
        "Follow {} to their active project": "",
        "{} is viewing an unshared Zed project": "",
        "{} is viewing a window outside of Zed": "",
        "up": "",
        "down": "",
        "left": "",
        "right": "",
        "1.33, 1, 1": "",
        "40%, 30%, 30%": "",
        "bucket": ""
    },
    "zed/crates/workspace/src/pane.rs": {
        "you have unsaved changes": "",
        "pane::CloseInactiveItems": "",
        "AddItem": "",
        "item": "",
        "ActivateItem": "",
        "local": "",
        "Remove": "",
        "RemovedItem": "",
        "Split": "",
        "direction": "",
        "clone_active_item": "",
        "JoinAll": "",
        "JoinIntoNext": "",
        "ChangeItemTitle": "",
        "Focus": "",
        "ZoomIn": "",
        "ZoomOut": "",
        "UserSavedItem": "",
        "save_intent": "",
        "ItemPinned": "",
        "ItemUnpinned": "",
        "untitled": "",
        "{}\\n.. and {} more": "",
        "Do you want to save changes to the following files?": "",
        "Save all": "",
        "Discard all": "",
        "Cancel": "",
        "Unable to save file: {}": "",
        "Close Without Saving": "",
        "This file has changed on disk since you started editing it. Do you want to overwrite it?": "",
        "This file has been deleted on disk since you started editing it. Do you want to recreate it?": "",
        "Save": "",
        "Close": "",
        "Overwrite": "",
        "Discard": "",
        "Don't Save": "",
        "save modal was not present in spawned modals after awaiting for its answer": "",
        "Unpin Tab": "",
        "unpin tab": "",
        "Close Tab": "",
        "close tab": "",
        "Close Others": "",
        "Close Multibuffers": "",
        "Close Left": "",
        "Close Right": "",
        "Close Clean": "",
        "Close All": "",
        "Pin Tab": "",
        "Copy Path": "",
        "Copy Relative Path": "",
        "Reveal In Project Panel": "",
        "Open in Terminal": "",
        "navigate_backward": "",
        "Go Back": "",
        "navigate_forward": "",
        "Go Forward": "",
        ",\n                self.pinned_tab_count,\n                tab_count\n            );\n            self.pinned_tab_count = tab_count;\n        }\n        let unpinned_tabs = tab_items.split_off(self.pinned_tab_count);\n        let pinned_tabs = tab_items;\n        TabBar::new(": "",
        ")\n            .when(\n                self.display_nav_history_buttons.unwrap_or_default(),\n                |tab_bar| {\n                    tab_bar\n                        .start_child(navigate_backward)\n                        .start_child(navigate_forward)\n                },\n            )\n            .map(|tab_bar| {\n                if self.show_tab_bar_buttons {\n                    let render_tab_buttons = self.render_tab_bar_buttons.clone();\n                    let (left_children, right_children) = render_tab_buttons(self, window, cx);\n                    tab_bar\n                        .start_children(left_children)\n                        .end_children(right_children)\n                } else {\n                    tab_bar\n                }\n            })\n            .children(pinned_tabs.len().ne(&0).then(|| {\n                let max_scroll = self.tab_bar_scroll_handle.max_offset().width;\n                // We need to check both because offset returns delta values even when the scroll handle is not scrollable\n                let is_scrollable = !max_scroll.is_zero();\n                let is_scrolled = self.tab_bar_scroll_handle.offset().x < px(0.);\n                let has_active_unpinned_tab = self.active_item_index >= self.pinned_tab_count;\n                h_flex()\n                    .children(pinned_tabs)\n                    .when(is_scrollable && is_scrolled, |this| {\n                        this.when(has_active_unpinned_tab, |this| this.border_r_2())\n                            .when(!has_active_unpinned_tab, |this| this.border_r_1())\n                            .border_color(cx.theme().colors().border)\n                    })\n            }))\n            .child(\n                h_flex()\n                    .id(": "",
        ")\n                    .overflow_x_scroll()\n                    .w_full()\n                    .track_scroll(&self.tab_bar_scroll_handle)\n                    .on_scroll_wheel(cx.listener(|this, _, _, _| {\n                        this.suppress_scroll = true;\n                    }))\n                    .children(unpinned_tabs)\n                    .child(\n                        div()\n                            .id(": "",
        ")\n                            .min_w_6()\n                            // HACK: This empty child is currently necessary to force the drop target to appear\n                            // despite us setting a min width above.\n                            .child(": "",
        ")\n                            // HACK: h_full doesn't occupy the complete height, using fixed height instead\n                            .h(Tab::container_height(cx))\n                            .flex_grow()\n                            .drag_over::<DraggedTab>(|bar, _, _, cx| {\n                                bar.bg(cx.theme().colors().drop_target_background)\n                            })\n                            .drag_over::<DraggedSelection>(|bar, _, _, cx| {\n                                bar.bg(cx.theme().colors().drop_target_background)\n                            })\n                            .on_drop(cx.listener(\n                                move |this, dragged_tab: &DraggedTab, window, cx| {\n                                    this.drag_split_direction = None;\n                                    this.handle_tab_drop(dragged_tab, this.items.len(), window, cx)\n                                },\n                            ))\n                            .on_drop(cx.listener(\n                                move |this, selection: &DraggedSelection, window, cx| {\n                                    this.drag_split_direction = None;\n                                    this.handle_project_entry_drop(\n                                        &selection.active_selection.entry_id,\n                                        Some(tab_count),\n                                        window,\n                                        cx,\n                                    )\n                                },\n                            ))\n                            .on_drop(cx.listener(move |this, paths, window, cx| {\n                                this.drag_split_direction = None;\n                                this.handle_external_paths_drop(paths, window, cx)\n                            }))\n                            .on_click(cx.listener(move |this, event: &ClickEvent, window, cx| {\n                                if event.click_count() == 2 {\n                                    window.dispatch_action(\n                                        this.double_click_dispatch_action.boxed_clone(),\n                                        cx,\n                                    );\n                                }\n                            })),\n                    ),\n            )\n            .into_any_element()\n    }\n\n    pub fn render_menu_overlay(menu: &Entity<ContextMenu>) -> Div {\n        div().absolute().bottom_0().right_0().size_0().child(\n            deferred(anchored().anchor(Corner::TopRight).child(menu.clone())).with_priority(1),\n        )\n    }\n\n    pub fn set_zoomed(&mut self, zoomed: bool, cx: &mut Context<Self>) {\n        self.zoomed = zoomed;\n        cx.notify();\n    }\n\n    pub fn is_zoomed(&self) -> bool {\n        self.zoomed\n    }\n\n    fn handle_drag_move<T: 'static>(\n        &mut self,\n        event: &DragMoveEvent<T>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let can_split_predicate = self.can_split_predicate.take();\n        let can_split = match &can_split_predicate {\n            Some(can_split_predicate) => {\n                can_split_predicate(self, event.dragged_item(), window, cx)\n            }\n            None => false,\n        };\n        self.can_split_predicate = can_split_predicate;\n        if !can_split {\n            return;\n        }\n\n        let rect = event.bounds.size;\n\n        let size = event.bounds.size.width.min(event.bounds.size.height)\n            * WorkspaceSettings::get_global(cx).drop_target_size;\n\n        let relative_cursor = Point::new(\n            event.event.position.x - event.bounds.left(),\n            event.event.position.y - event.bounds.top(),\n        );\n\n        let direction = if relative_cursor.x < size\n            || relative_cursor.x > rect.width - size\n            || relative_cursor.y < size\n            || relative_cursor.y > rect.height - size\n        {\n            [\n                SplitDirection::Up,\n                SplitDirection::Right,\n                SplitDirection::Down,\n                SplitDirection::Left,\n            ]\n            .iter()\n            .min_by_key(|side| match side {\n                SplitDirection::Up => relative_cursor.y,\n                SplitDirection::Right => rect.width - relative_cursor.x,\n                SplitDirection::Down => rect.height - relative_cursor.y,\n                SplitDirection::Left => relative_cursor.x,\n            })\n            .cloned()\n        } else {\n            None\n        };\n\n        if direction != self.drag_split_direction {\n            self.drag_split_direction = direction;\n        }\n    }\n\n    pub fn handle_tab_drop(\n        &mut self,\n        dragged_tab: &DraggedTab,\n        ix: usize,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(custom_drop_handle) = self.custom_drop_handle.clone()\n            && let ControlFlow::Break(()) = custom_drop_handle(self, dragged_tab, window, cx)\n        {\n            return;\n        }\n        let mut to_pane = cx.entity();\n        let split_direction = self.drag_split_direction;\n        let item_id = dragged_tab.item.item_id();\n        if let Some(preview_item_id) = self.preview_item_id\n            && item_id == preview_item_id\n        {\n            self.set_preview_item_id(None, cx);\n        }\n\n        let is_clone = cfg!(target_os = ": "",
        ") && window.modifiers().alt\n            || cfg!(not(target_os = ": "",
        ")) && window.modifiers().control;\n\n        let from_pane = dragged_tab.pane.clone();\n\n        self.workspace\n            .update(cx, |_, cx| {\n                cx.defer_in(window, move |workspace, window, cx| {\n                    if let Some(split_direction) = split_direction {\n                        to_pane = workspace.split_pane(to_pane, split_direction, window, cx);\n                    }\n                    let database_id = workspace.database_id();\n                    let was_pinned_in_from_pane = from_pane.read_with(cx, |pane, _| {\n                        pane.index_for_item_id(item_id)\n                            .is_some_and(|ix| pane.is_tab_pinned(ix))\n                    });\n                    let to_pane_old_length = to_pane.read(cx).items.len();\n                    if is_clone {\n                        let Some(item) = from_pane\n                            .read(cx)\n                            .items()\n                            .find(|item| item.item_id() == item_id)\n                            .cloned()\n                        else {\n                            return;\n                        };\n                        if item.can_split(cx) {\n                            let task = item.clone_on_split(database_id, window, cx);\n                            let to_pane = to_pane.downgrade();\n                            cx.spawn_in(window, async move |_, cx| {\n                                if let Some(item) = task.await {\n                                    to_pane\n                                        .update_in(cx, |pane, window, cx| {\n                                            pane.add_item(item, true, true, None, window, cx)\n                                        })\n                                        .ok();\n                                }\n                            })\n                            .detach();\n                        } else {\n                            move_item(&from_pane, &to_pane, item_id, ix, true, window, cx);\n                        }\n                    } else {\n                        move_item(&from_pane, &to_pane, item_id, ix, true, window, cx);\n                    }\n                    to_pane.update(cx, |this, _| {\n                        if to_pane == from_pane {\n                            let actual_ix = this\n                                .items\n                                .iter()\n                                .position(|item| item.item_id() == item_id)\n                                .unwrap_or(0);\n\n                            let is_pinned_in_to_pane = this.is_tab_pinned(actual_ix);\n\n                            if !was_pinned_in_from_pane && is_pinned_in_to_pane {\n                                this.pinned_tab_count += 1;\n                            } else if was_pinned_in_from_pane && !is_pinned_in_to_pane {\n                                this.pinned_tab_count -= 1;\n                            }\n                        } else if this.items.len() >= to_pane_old_length {\n                            let is_pinned_in_to_pane = this.is_tab_pinned(ix);\n                            let item_created_pane = to_pane_old_length == 0;\n                            let is_first_position = ix == 0;\n                            let was_dropped_at_beginning = item_created_pane || is_first_position;\n                            let should_remain_pinned = is_pinned_in_to_pane\n                                || (was_pinned_in_from_pane && was_dropped_at_beginning);\n\n                            if should_remain_pinned {\n                                this.pinned_tab_count += 1;\n                            }\n                        }\n                    });\n                });\n            })\n            .log_err();\n    }\n\n    fn handle_dragged_selection_drop(\n        &mut self,\n        dragged_selection: &DraggedSelection,\n        dragged_onto: Option<usize>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(custom_drop_handle) = self.custom_drop_handle.clone()\n            && let ControlFlow::Break(()) = custom_drop_handle(self, dragged_selection, window, cx)\n        {\n            return;\n        }\n        self.handle_project_entry_drop(\n            &dragged_selection.active_selection.entry_id,\n            dragged_onto,\n            window,\n            cx,\n        );\n    }\n\n    fn handle_project_entry_drop(\n        &mut self,\n        project_entry_id: &ProjectEntryId,\n        target: Option<usize>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(custom_drop_handle) = self.custom_drop_handle.clone()\n            && let ControlFlow::Break(()) = custom_drop_handle(self, project_entry_id, window, cx)\n        {\n            return;\n        }\n        let mut to_pane = cx.entity();\n        let split_direction = self.drag_split_direction;\n        let project_entry_id = *project_entry_id;\n        self.workspace\n            .update(cx, |_, cx| {\n                cx.defer_in(window, move |workspace, window, cx| {\n                    if let Some(project_path) = workspace\n                        .project()\n                        .read(cx)\n                        .path_for_entry(project_entry_id, cx)\n                    {\n                        let load_path_task = workspace.load_path(project_path.clone(), window, cx);\n                        cx.spawn_in(window, async move |workspace, cx| {\n                            if let Some((project_entry_id, build_item)) =\n                                load_path_task.await.notify_async_err(cx)\n                            {\n                                let (to_pane, new_item_handle) = workspace\n                                    .update_in(cx, |workspace, window, cx| {\n                                        if let Some(split_direction) = split_direction {\n                                            to_pane = workspace.split_pane(\n                                                to_pane,\n                                                split_direction,\n                                                window,\n                                                cx,\n                                            );\n                                        }\n                                        let new_item_handle = to_pane.update(cx, |pane, cx| {\n                                            pane.open_item(\n                                                project_entry_id,\n                                                project_path,\n                                                true,\n                                                false,\n                                                true,\n                                                target,\n                                                window,\n                                                cx,\n                                                build_item,\n                                            )\n                                        });\n                                        (to_pane, new_item_handle)\n                                    })\n                                    .log_err()?;\n                                to_pane\n                                    .update_in(cx, |this, window, cx| {\n                                        let Some(index) = this.index_for_item(&*new_item_handle)\n                                        else {\n                                            return;\n                                        };\n\n                                        if target.is_some_and(|target| this.is_tab_pinned(target)) {\n                                            this.pin_tab_at(index, window, cx);\n                                        }\n                                    })\n                                    .ok()?\n                            }\n                            Some(())\n                        })\n                        .detach();\n                    };\n                });\n            })\n            .log_err();\n    }\n\n    fn handle_external_paths_drop(\n        &mut self,\n        paths: &ExternalPaths,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(custom_drop_handle) = self.custom_drop_handle.clone()\n            && let ControlFlow::Break(()) = custom_drop_handle(self, paths, window, cx)\n        {\n            return;\n        }\n        let mut to_pane = cx.entity();\n        let mut split_direction = self.drag_split_direction;\n        let paths = paths.paths().to_vec();\n        let is_remote = self\n            .workspace\n            .update(cx, |workspace, cx| {\n                if workspace.project().read(cx).is_via_collab() {\n                    workspace.show_error(\n                        &anyhow::anyhow!(": "",
        "),\n                        cx,\n                    );\n                    true\n                } else {\n                    false\n                }\n            })\n            .unwrap_or(true);\n        if is_remote {\n            return;\n        }\n\n        self.workspace\n            .update(cx, |workspace, cx| {\n                let fs = Arc::clone(workspace.project().read(cx).fs());\n                cx.spawn_in(window, async move |workspace, cx| {\n                    let mut is_file_checks = FuturesUnordered::new();\n                    for path in &paths {\n                        is_file_checks.push(fs.is_file(path))\n                    }\n                    let mut has_files_to_open = false;\n                    while let Some(is_file) = is_file_checks.next().await {\n                        if is_file {\n                            has_files_to_open = true;\n                            break;\n                        }\n                    }\n                    drop(is_file_checks);\n                    if !has_files_to_open {\n                        split_direction = None;\n                    }\n\n                    if let Ok((open_task, to_pane)) =\n                        workspace.update_in(cx, |workspace, window, cx| {\n                            if let Some(split_direction) = split_direction {\n                                to_pane =\n                                    workspace.split_pane(to_pane, split_direction, window, cx);\n                            }\n                            (\n                                workspace.open_paths(\n                                    paths,\n                                    OpenOptions {\n                                        visible: Some(OpenVisible::OnlyDirectories),\n                                        ..Default::default()\n                                    },\n                                    Some(to_pane.downgrade()),\n                                    window,\n                                    cx,\n                                ),\n                                to_pane,\n                            )\n                        })\n                    {\n                        let opened_items: Vec<_> = open_task.await;\n                        _ = workspace.update_in(cx, |workspace, window, cx| {\n                            for item in opened_items.into_iter().flatten() {\n                                if let Err(e) = item {\n                                    workspace.show_error(&e, cx);\n                                }\n                            }\n                            if to_pane.read(cx).items_len() == 0 {\n                                workspace.remove_pane(to_pane, None, window, cx);\n                            }\n                        });\n                    }\n                })\n                .detach();\n            })\n            .log_err();\n    }\n\n    pub fn display_nav_history_buttons(&mut self, display: Option<bool>) {\n        self.display_nav_history_buttons = display;\n    }\n\n    fn pinned_item_ids(&self) -> Vec<EntityId> {\n        self.items\n            .iter()\n            .enumerate()\n            .filter_map(|(index, item)| {\n                if self.is_tab_pinned(index) {\n                    return Some(item.item_id());\n                }\n\n                None\n            })\n            .collect()\n    }\n\n    fn clean_item_ids(&self, cx: &mut Context<Pane>) -> Vec<EntityId> {\n        self.items()\n            .filter_map(|item| {\n                if !item.is_dirty(cx) {\n                    return Some(item.item_id());\n                }\n\n                None\n            })\n            .collect()\n    }\n\n    fn to_the_side_item_ids(&self, item_id: EntityId, side: Side) -> Vec<EntityId> {\n        match side {\n            Side::Left => self\n                .items()\n                .take_while(|item| item.item_id() != item_id)\n                .map(|item| item.item_id())\n                .collect(),\n            Side::Right => self\n                .items()\n                .rev()\n                .take_while(|item| item.item_id() != item_id)\n                .map(|item| item.item_id())\n                .collect(),\n        }\n    }\n\n    fn multibuffer_item_ids(&self, cx: &mut Context<Pane>) -> Vec<EntityId> {\n        self.items()\n            .filter(|item| item.buffer_kind(cx) == ItemBufferKind::Multibuffer)\n            .map(|item| item.item_id())\n            .collect()\n    }\n\n    pub fn drag_split_direction(&self) -> Option<SplitDirection> {\n        self.drag_split_direction\n    }\n\n    pub fn set_zoom_out_on_close(&mut self, zoom_out_on_close: bool) {\n        self.zoom_out_on_close = zoom_out_on_close;\n    }\n}\n\nfn default_render_tab_bar_buttons(\n    pane: &mut Pane,\n    window: &mut Window,\n    cx: &mut Context<Pane>,\n) -> (Option<AnyElement>, Option<AnyElement>) {\n    if !pane.has_focus(window, cx) && !pane.context_menu_focused(window, cx) {\n        return (None, None);\n    }\n    let (can_clone, can_split_move) = match pane.active_item() {\n        Some(active_item) if active_item.can_split(cx) => (true, false),\n        Some(_) => (false, pane.items_len() > 1),\n        None => (false, false),\n    };\n    // Ideally we would return a vec of elements here to pass directly to the [TabBar]'s\n    // `end_slot`, but due to needing a view here that isn't possible.\n    let right_children = h_flex()\n        // Instead we need to replicate the spacing from the [TabBar]'s `end_slot` here.\n        .gap(DynamicSpacing::Base04.rems(cx))\n        .child(\n            PopoverMenu::new(": "",
        ")\n                .trigger_with_tooltip(\n                    IconButton::new(": "",
        ", IconName::Plus).icon_size(IconSize::Small),\n                    Tooltip::text(": "",
        "),\n                )\n                .anchor(Corner::TopRight)\n                .with_handle(pane.new_item_context_menu_handle.clone())\n                .menu(move |window, cx| {\n                    Some(ContextMenu::build(window, cx, |menu, _, _| {\n                        menu.action(": "",
        ", NewFile.boxed_clone())\n                            .action(": "",
        ", ToggleFileFinder::default().boxed_clone())\n                            .separator()\n                            .action(\n                                ": "",
        ",\n                                DeploySearch {\n                                    replace_enabled: false,\n                                    included_files: None,\n                                    excluded_files: None,\n                                }\n                                .boxed_clone(),\n                            )\n                            .action(": "",
        ", ToggleProjectSymbols.boxed_clone())\n                            .separator()\n                            .action(": "",
        ", NewTerminal.boxed_clone())\n                    }))\n                }),\n        )\n        .child(\n            PopoverMenu::new(": "",
        ", IconName::Split)\n                        .icon_size(IconSize::Small)\n                        .disabled(!can_clone && !can_split_move),\n                    Tooltip::text(": "",
        "),\n                )\n                .anchor(Corner::TopRight)\n                .with_handle(pane.split_item_context_menu_handle.clone())\n                .menu(move |window, cx| {\n                    ContextMenu::build(window, cx, |menu, _, _| {\n                        if can_split_move {\n                            menu.action(": "",
        ", SplitAndMoveRight.boxed_clone())\n                                .action(": "",
        ", SplitAndMoveLeft.boxed_clone())\n                                .action(": "",
        ", SplitAndMoveUp.boxed_clone())\n                                .action(": "",
        ", SplitAndMoveDown.boxed_clone())\n                        } else {\n                            menu.action(": "",
        ", SplitRight.boxed_clone())\n                                .action(": "",
        ", SplitLeft.boxed_clone())\n                                .action(": "",
        ", SplitUp.boxed_clone())\n                                .action(": "",
        ", SplitDown.boxed_clone())\n                        }\n                    })\n                    .into()\n                }),\n        )\n        .child({\n            let zoomed = pane.is_zoomed();\n            IconButton::new(": "",
        ", IconName::Maximize)\n                .icon_size(IconSize::Small)\n                .toggle_state(zoomed)\n                .selected_icon(IconName::Minimize)\n                .on_click(cx.listener(|pane, _, window, cx| {\n                    pane.toggle_zoom(&crate::ToggleZoom, window, cx);\n                }))\n                .tooltip(move |_window, cx| {\n                    Tooltip::for_action(\n                        if zoomed { ": "",
        " } else { ": "",
        " },\n                        &ToggleZoom,\n                        cx,\n                    )\n                })\n        })\n        .into_any_element()\n        .into();\n    (None, right_children)\n}\n\nimpl Focusable for Pane {\n    fn focus_handle(&self, _cx: &App) -> FocusHandle {\n        self.focus_handle.clone()\n    }\n}\n\nimpl Render for Pane {\n    fn render(&mut self, window: &mut Window, cx: &mut Context<Self>) -> impl IntoElement {\n        let mut key_context = KeyContext::new_with_defaults();\n        key_context.add(": "",
        ");\n        if self.active_item().is_none() {\n            key_context.add(": "",
        ");\n        }\n\n        self.toolbar\n            .read(cx)\n            .contribute_context(&mut key_context, cx);\n\n        let should_display_tab_bar = self.should_display_tab_bar.clone();\n        let display_tab_bar = should_display_tab_bar(window, cx);\n        let Some(project) = self.project.upgrade() else {\n            return div().track_focus(&self.focus_handle(cx));\n        };\n        let is_local = project.read(cx).is_local();\n\n        v_flex()\n            .key_context(key_context)\n            .track_focus(&self.focus_handle(cx))\n            .size_full()\n            .flex_none()\n            .overflow_hidden()\n            .on_action(\n                cx.listener(|pane, _: &SplitLeft, _, cx| pane.split(SplitDirection::Left, cx)),\n            )\n            .on_action(cx.listener(|pane, _: &SplitUp, _, cx| pane.split(SplitDirection::Up, cx)))\n            .on_action(cx.listener(|pane, _: &SplitHorizontal, _, cx| {\n                pane.split(SplitDirection::horizontal(cx), cx)\n            }))\n            .on_action(cx.listener(|pane, _: &SplitVertical, _, cx| {\n                pane.split(SplitDirection::vertical(cx), cx)\n            }))\n            .on_action(\n                cx.listener(|pane, _: &SplitRight, _, cx| pane.split(SplitDirection::Right, cx)),\n            )\n            .on_action(\n                cx.listener(|pane, _: &SplitDown, _, cx| pane.split(SplitDirection::Down, cx)),\n            )\n            .on_action(cx.listener(|pane, _: &SplitAndMoveUp, _, cx| {\n                pane.split_and_move(SplitDirection::Up, cx)\n            }))\n            .on_action(cx.listener(|pane, _: &SplitAndMoveDown, _, cx| {\n                pane.split_and_move(SplitDirection::Down, cx)\n            }))\n            .on_action(cx.listener(|pane, _: &SplitAndMoveLeft, _, cx| {\n                pane.split_and_move(SplitDirection::Left, cx)\n            }))\n            .on_action(cx.listener(|pane, _: &SplitAndMoveRight, _, cx| {\n                pane.split_and_move(SplitDirection::Right, cx)\n            }))\n            .on_action(cx.listener(|_, _: &JoinIntoNext, _, cx| {\n                cx.emit(Event::JoinIntoNext);\n            }))\n            .on_action(cx.listener(|_, _: &JoinAll, _, cx| {\n                cx.emit(Event::JoinAll);\n            }))\n            .on_action(cx.listener(Pane::toggle_zoom))\n            .on_action(cx.listener(Self::navigate_backward))\n            .on_action(cx.listener(Self::navigate_forward))\n            .on_action(\n                cx.listener(|pane: &mut Pane, action: &ActivateItem, window, cx| {\n                    pane.activate_item(\n                        action.0.min(pane.items.len().saturating_sub(1)),\n                        true,\n                        true,\n                        window,\n                        cx,\n                    );\n                }),\n            )\n            .on_action(cx.listener(Self::alternate_file))\n            .on_action(cx.listener(Self::activate_last_item))\n            .on_action(cx.listener(Self::activate_previous_item))\n            .on_action(cx.listener(Self::activate_next_item))\n            .on_action(cx.listener(Self::swap_item_left))\n            .on_action(cx.listener(Self::swap_item_right))\n            .on_action(cx.listener(Self::toggle_pin_tab))\n            .on_action(cx.listener(Self::unpin_all_tabs))\n            .when(PreviewTabsSettings::get_global(cx).enabled, |this| {\n                this.on_action(cx.listener(|pane: &mut Pane, _: &TogglePreviewTab, _, cx| {\n                    if let Some(active_item_id) = pane.active_item().map(|i| i.item_id()) {\n                        if pane.is_active_preview_item(active_item_id) {\n                            pane.set_preview_item_id(None, cx);\n                        } else {\n                            pane.set_preview_item_id(Some(active_item_id), cx);\n                        }\n                    }\n                }))\n            })\n            .on_action(\n                cx.listener(|pane: &mut Self, action: &CloseActiveItem, window, cx| {\n                    pane.close_active_item(action, window, cx)\n                        .detach_and_log_err(cx)\n                }),\n            )\n            .on_action(\n                cx.listener(|pane: &mut Self, action: &CloseOtherItems, window, cx| {\n                    pane.close_other_items(action, None, window, cx)\n                        .detach_and_log_err(cx);\n                }),\n            )\n            .on_action(\n                cx.listener(|pane: &mut Self, action: &CloseCleanItems, window, cx| {\n                    pane.close_clean_items(action, window, cx)\n                        .detach_and_log_err(cx)\n                }),\n            )\n            .on_action(cx.listener(\n                |pane: &mut Self, action: &CloseItemsToTheLeft, window, cx| {\n                    pane.close_items_to_the_left_by_id(None, action, window, cx)\n                        .detach_and_log_err(cx)\n                },\n            ))\n            .on_action(cx.listener(\n                |pane: &mut Self, action: &CloseItemsToTheRight, window, cx| {\n                    pane.close_items_to_the_right_by_id(None, action, window, cx)\n                        .detach_and_log_err(cx)\n                },\n            ))\n            .on_action(\n                cx.listener(|pane: &mut Self, action: &CloseAllItems, window, cx| {\n                    pane.close_all_items(action, window, cx)\n                        .detach_and_log_err(cx)\n                }),\n            )\n            .on_action(cx.listener(\n                |pane: &mut Self, action: &CloseMultibufferItems, window, cx| {\n                    pane.close_multibuffer_items(action, window, cx)\n                        .detach_and_log_err(cx)\n                },\n            ))\n            .on_action(\n                cx.listener(|pane: &mut Self, action: &RevealInProjectPanel, _, cx| {\n                    let entry_id = action\n                        .entry_id\n                        .map(ProjectEntryId::from_proto)\n                        .or_else(|| pane.active_item()?.project_entry_ids(cx).first().copied());\n                    if let Some(entry_id) = entry_id {\n                        pane.project\n                            .update(cx, |_, cx| {\n                                cx.emit(project::Event::RevealInProjectPanel(entry_id))\n                            })\n                            .ok();\n                    }\n                }),\n            )\n            .on_action(cx.listener(|_, _: &menu::Cancel, window, cx| {\n                if cx.stop_active_drag(window) {\n                } else {\n                    cx.propagate();\n                }\n            }))\n            .when(self.active_item().is_some() && display_tab_bar, |pane| {\n                pane.child((self.render_tab_bar.clone())(self, window, cx))\n            })\n            .child({\n                let has_worktrees = project.read(cx).visible_worktrees(cx).next().is_some();\n                // main content\n                div()\n                    .flex_1()\n                    .relative()\n                    .group(": "",
        ")\n                    .overflow_hidden()\n                    .on_drag_move::<DraggedTab>(cx.listener(Self::handle_drag_move))\n                    .on_drag_move::<DraggedSelection>(cx.listener(Self::handle_drag_move))\n                    .when(is_local, |div| {\n                        div.on_drag_move::<ExternalPaths>(cx.listener(Self::handle_drag_move))\n                    })\n                    .map(|div| {\n                        if let Some(item) = self.active_item() {\n                            div.id(": "",
        ")\n                                .v_flex()\n                                .size_full()\n                                .overflow_hidden()\n                                .child(self.toolbar.clone())\n                                .child(item.to_any())\n                        } else {\n                            let placeholder = div\n                                .id(": "",
        ")\n                                .h_flex()\n                                .size_full()\n                                .justify_center()\n                                .on_click(cx.listener(\n                                    move |this, event: &ClickEvent, window, cx| {\n                                        if event.click_count() == 2 {\n                                            window.dispatch_action(\n                                                this.double_click_dispatch_action.boxed_clone(),\n                                                cx,\n                                            );\n                                        }\n                                    },\n                                ));\n                            if has_worktrees {\n                                placeholder\n                            } else {\n                                placeholder.child(\n                                    Label::new(": "",
        ")\n                                        .color(Color::Muted),\n                                )\n                            }\n                        }\n                    })\n                    .child(\n                        // drag target\n                        div()\n                            .invisible()\n                            .absolute()\n                            .bg(cx.theme().colors().drop_target_background)\n                            .group_drag_over::<DraggedTab>(": "",
        ", |style| style.visible())\n                            .group_drag_over::<DraggedSelection>(": "",
        ", |style| style.visible())\n                            .when(is_local, |div| {\n                                div.group_drag_over::<ExternalPaths>(": "",
        ", |style| style.visible())\n                            })\n                            .when_some(self.can_drop_predicate.clone(), |this, p| {\n                                this.can_drop(move |a, window, cx| p(a, window, cx))\n                            })\n                            .on_drop(cx.listener(move |this, dragged_tab, window, cx| {\n                                this.handle_tab_drop(\n                                    dragged_tab,\n                                    this.active_item_index(),\n                                    window,\n                                    cx,\n                                )\n                            }))\n                            .on_drop(cx.listener(\n                                move |this, selection: &DraggedSelection, window, cx| {\n                                    this.handle_dragged_selection_drop(selection, None, window, cx)\n                                },\n                            ))\n                            .on_drop(cx.listener(move |this, paths, window, cx| {\n                                this.handle_external_paths_drop(paths, window, cx)\n                            }))\n                            .map(|div| {\n                                let size = DefiniteLength::Fraction(0.5);\n                                match self.drag_split_direction {\n                                    None => div.top_0().right_0().bottom_0().left_0(),\n                                    Some(SplitDirection::Up) => {\n                                        div.top_0().left_0().right_0().h(size)\n                                    }\n                                    Some(SplitDirection::Down) => {\n                                        div.left_0().bottom_0().right_0().h(size)\n                                    }\n                                    Some(SplitDirection::Left) => {\n                                        div.top_0().left_0().bottom_0().w(size)\n                                    }\n                                    Some(SplitDirection::Right) => {\n                                        div.top_0().bottom_0().right_0().w(size)\n                                    }\n                                }\n                            }),\n                    )\n            })\n            .on_mouse_down(\n                MouseButton::Navigate(NavigationDirection::Back),\n                cx.listener(|pane, _, window, cx| {\n                    if let Some(workspace) = pane.workspace.upgrade() {\n                        let pane = cx.entity().downgrade();\n                        window.defer(cx, move |window, cx| {\n                            workspace.update(cx, |workspace, cx| {\n                                workspace.go_back(pane, window, cx).detach_and_log_err(cx)\n                            })\n                        })\n                    }\n                }),\n            )\n            .on_mouse_down(\n                MouseButton::Navigate(NavigationDirection::Forward),\n                cx.listener(|pane, _, window, cx| {\n                    if let Some(workspace) = pane.workspace.upgrade() {\n                        let pane = cx.entity().downgrade();\n                        window.defer(cx, move |window, cx| {\n                            workspace.update(cx, |workspace, cx| {\n                                workspace\n                                    .go_forward(pane, window, cx)\n                                    .detach_and_log_err(cx)\n                            })\n                        })\n                    }\n                }),\n            )\n    }\n}\n\nimpl ItemNavHistory {\n    pub fn push<D: 'static + Send + Any>(&mut self, data: Option<D>, cx: &mut App) {\n        if self\n            .item\n            .upgrade()\n            .is_some_and(|item| item.include_in_nav_history())\n        {\n            self.history\n                .push(data, self.item.clone(), self.is_preview, cx);\n        }\n    }\n\n    pub fn pop_backward(&mut self, cx: &mut App) -> Option<NavigationEntry> {\n        self.history.pop(NavigationMode::GoingBack, cx)\n    }\n\n    pub fn pop_forward(&mut self, cx: &mut App) -> Option<NavigationEntry> {\n        self.history.pop(NavigationMode::GoingForward, cx)\n    }\n}\n\nimpl NavHistory {\n    pub fn for_each_entry(\n        &self,\n        cx: &App,\n        mut f: impl FnMut(&NavigationEntry, (ProjectPath, Option<PathBuf>)),\n    ) {\n        let borrowed_history = self.0.lock();\n        borrowed_history\n            .forward_stack\n            .iter()\n            .chain(borrowed_history.backward_stack.iter())\n            .chain(borrowed_history.closed_stack.iter())\n            .for_each(|entry| {\n                if let Some(project_and_abs_path) =\n                    borrowed_history.paths_by_item.get(&entry.item.id())\n                {\n                    f(entry, project_and_abs_path.clone());\n                } else if let Some(item) = entry.item.upgrade()\n                    && let Some(path) = item.project_path(cx)\n                {\n                    f(entry, (path, None));\n                }\n            })\n    }\n\n    pub fn set_mode(&mut self, mode: NavigationMode) {\n        self.0.lock().mode = mode;\n    }\n\n    pub fn mode(&self) -> NavigationMode {\n        self.0.lock().mode\n    }\n\n    pub fn disable(&mut self) {\n        self.0.lock().mode = NavigationMode::Disabled;\n    }\n\n    pub fn enable(&mut self) {\n        self.0.lock().mode = NavigationMode::Normal;\n    }\n\n    pub fn clear(&mut self, cx: &mut App) {\n        let mut state = self.0.lock();\n\n        if state.backward_stack.is_empty()\n            && state.forward_stack.is_empty()\n            && state.closed_stack.is_empty()\n            && state.paths_by_item.is_empty()\n        {\n            return;\n        }\n\n        state.mode = NavigationMode::Normal;\n        state.backward_stack.clear();\n        state.forward_stack.clear();\n        state.closed_stack.clear();\n        state.paths_by_item.clear();\n        state.did_update(cx);\n    }\n\n    pub fn pop(&mut self, mode: NavigationMode, cx: &mut App) -> Option<NavigationEntry> {\n        let mut state = self.0.lock();\n        let entry = match mode {\n            NavigationMode::Normal | NavigationMode::Disabled | NavigationMode::ClosingItem => {\n                return None;\n            }\n            NavigationMode::GoingBack => &mut state.backward_stack,\n            NavigationMode::GoingForward => &mut state.forward_stack,\n            NavigationMode::ReopeningClosedItem => &mut state.closed_stack,\n        }\n        .pop_back();\n        if entry.is_some() {\n            state.did_update(cx);\n        }\n        entry\n    }\n\n    pub fn push<D: 'static + Send + Any>(\n        &mut self,\n        data: Option<D>,\n        item: Arc<dyn WeakItemHandle>,\n        is_preview: bool,\n        cx: &mut App,\n    ) {\n        let state = &mut *self.0.lock();\n        match state.mode {\n            NavigationMode::Disabled => {}\n            NavigationMode::Normal | NavigationMode::ReopeningClosedItem => {\n                if state.backward_stack.len() >= MAX_NAVIGATION_HISTORY_LEN {\n                    state.backward_stack.pop_front();\n                }\n                state.backward_stack.push_back(NavigationEntry {\n                    item,\n                    data: data.map(|data| Box::new(data) as Box<dyn Any + Send>),\n                    timestamp: state.next_timestamp.fetch_add(1, Ordering::SeqCst),\n                    is_preview,\n                });\n                state.forward_stack.clear();\n            }\n            NavigationMode::GoingBack => {\n                if state.forward_stack.len() >= MAX_NAVIGATION_HISTORY_LEN {\n                    state.forward_stack.pop_front();\n                }\n                state.forward_stack.push_back(NavigationEntry {\n                    item,\n                    data: data.map(|data| Box::new(data) as Box<dyn Any + Send>),\n                    timestamp: state.next_timestamp.fetch_add(1, Ordering::SeqCst),\n                    is_preview,\n                });\n            }\n            NavigationMode::GoingForward => {\n                if state.backward_stack.len() >= MAX_NAVIGATION_HISTORY_LEN {\n                    state.backward_stack.pop_front();\n                }\n                state.backward_stack.push_back(NavigationEntry {\n                    item,\n                    data: data.map(|data| Box::new(data) as Box<dyn Any + Send>),\n                    timestamp: state.next_timestamp.fetch_add(1, Ordering::SeqCst),\n                    is_preview,\n                });\n            }\n            NavigationMode::ClosingItem => {\n                if state.closed_stack.len() >= MAX_NAVIGATION_HISTORY_LEN {\n                    state.closed_stack.pop_front();\n                }\n                state.closed_stack.push_back(NavigationEntry {\n                    item,\n                    data: data.map(|data| Box::new(data) as Box<dyn Any + Send>),\n                    timestamp: state.next_timestamp.fetch_add(1, Ordering::SeqCst),\n                    is_preview,\n                });\n            }\n        }\n        state.did_update(cx);\n    }\n\n    pub fn remove_item(&mut self, item_id: EntityId) {\n        let mut state = self.0.lock();\n        state.paths_by_item.remove(&item_id);\n        state\n            .backward_stack\n            .retain(|entry| entry.item.id() != item_id);\n        state\n            .forward_stack\n            .retain(|entry| entry.item.id() != item_id);\n        state\n            .closed_stack\n            .retain(|entry| entry.item.id() != item_id);\n    }\n\n    pub fn rename_item(\n        &mut self,\n        item_id: EntityId,\n        project_path: ProjectPath,\n        abs_path: Option<PathBuf>,\n    ) {\n        let mut state = self.0.lock();\n        let path_for_item = state.paths_by_item.get_mut(&item_id);\n        if let Some(path_for_item) = path_for_item {\n            path_for_item.0 = project_path;\n            path_for_item.1 = abs_path;\n        }\n    }\n\n    pub fn path_for_item(&self, item_id: EntityId) -> Option<(ProjectPath, Option<PathBuf>)> {\n        self.0.lock().paths_by_item.get(&item_id).cloned()\n    }\n}\n\nimpl NavHistoryState {\n    pub fn did_update(&self, cx: &mut App) {\n        if let Some(pane) = self.pane.upgrade() {\n            cx.defer(move |cx| {\n                pane.update(cx, |pane, cx| pane.history_updated(cx));\n            });\n        }\n    }\n}\n\nfn dirty_message_for(buffer_path: Option<ProjectPath>, path_style: PathStyle) -> String {\n    let path = buffer_path\n        .as_ref()\n        .and_then(|p| {\n            let path = p.path.display(path_style);\n            if path.is_empty() { None } else { Some(path) }\n        })\n        .unwrap_or(": "",
        ".into());\n    let path = truncate_and_remove_front(&path, 80);\n    format!(": "",
        ")\n}\n\npub fn tab_details(items: &[Box<dyn ItemHandle>], _window: &Window, cx: &App) -> Vec<usize> {\n    let mut tab_details = items.iter().map(|_| 0).collect::<Vec<_>>();\n    let mut tab_descriptions = HashMap::default();\n    let mut done = false;\n    while !done {\n        done = true;\n\n        // Store item indices by their tab description.\n        for (ix, (item, detail)) in items.iter().zip(&tab_details).enumerate() {\n            let description = item.tab_content_text(*detail, cx);\n            if *detail == 0 || description != item.tab_content_text(detail - 1, cx) {\n                tab_descriptions\n                    .entry(description)\n                    .or_insert(Vec::new())\n                    .push(ix);\n            }\n        }\n\n        // If two or more items have the same tab description, increase their level\n        // of detail and try again.\n        for (_, item_ixs) in tab_descriptions.drain() {\n            if item_ixs.len() > 1 {\n                done = false;\n                for ix in item_ixs {\n                    tab_details[ix] += 1;\n                }\n            }\n        }\n    }\n\n    tab_details\n}\n\npub fn render_item_indicator(item: Box<dyn ItemHandle>, cx: &App) -> Option<Indicator> {\n    maybe!({\n        let indicator_color = match (item.has_conflict(cx), item.is_dirty(cx)) {\n            (true, _) => Color::Warning,\n            (_, true) => Color::Accent,\n            (false, false) => return None,\n        };\n\n        Some(Indicator::dot().color(indicator_color))\n    })\n}\n\nimpl Render for DraggedTab {\n    fn render(&mut self, window: &mut Window, cx: &mut Context<Self>) -> impl IntoElement {\n        let ui_font = ThemeSettings::get_global(cx).ui_font.clone();\n        let label = self.item.tab_content(\n            TabContentParams {\n                detail: Some(self.detail),\n                selected: false,\n                preview: false,\n                deemphasized: false,\n            },\n            window,\n            cx,\n        );\n        Tab::new(": "",
        ")\n            .toggle_state(self.is_active)\n            .child(label)\n            .render(window, cx)\n            .font(ui_font)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use std::num::NonZero;\n\n    use super::*;\n    use crate::item::test::{TestItem, TestProjectItem};\n    use gpui::{TestAppContext, VisualTestContext, size};\n    use project::FakeFs;\n    use settings::SettingsStore;\n    use theme::LoadThemes;\n    use util::TryFutureExt;\n\n    #[gpui::test]\n    async fn test_add_item_capped_to_max_tabs(cx: &mut TestAppContext) {\n        init_test(cx);\n        let fs = FakeFs::new(cx.executor());\n\n        let project = Project::test(fs, None, cx).await;\n        let (workspace, cx) =\n            cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n        let pane = workspace.read_with(cx, |workspace, _| workspace.active_pane().clone());\n\n        for i in 0..7 {\n            add_labeled_item(&pane, format!(": "",
        ", i).as_str(), false, cx);\n        }\n\n        set_max_tabs(cx, Some(5));\n        add_labeled_item(&pane, ": "",
        ", false, cx);\n        // Remove items to respect the max tab cap.\n        assert_item_labels(&pane, [": "",
        ", ": "",
        "], cx);\n        pane.update_in(cx, |pane, window, cx| {\n            pane.activate_item(0, false, false, window, cx);\n        });\n        add_labeled_item(&pane, ": "",
        ", false, cx);\n        // Respect activation order.\n        assert_item_labels(&pane, [": "",
        "], cx);\n\n        for i in 0..7 {\n            add_labeled_item(&pane, format!(": "",
        ", i).as_str(), true, cx);\n        }\n        // Keeps dirty items, even over max tab cap.\n        assert_item_labels(\n            &pane,\n            [": "",
        "],\n            cx,\n        );\n\n        set_max_tabs(cx, None);\n        for i in 0..7 {\n            add_labeled_item(&pane, format!(": "",
        ", i).as_str(), false, cx);\n        }\n        // No cap when max tabs is None.\n        assert_item_labels(\n            &pane,\n            [\n                ": "",
        ",\n                ": "",
        ",\n            ],\n            cx,\n        );\n    }\n\n    #[gpui::test]\n    async fn test_reduce_max_tabs_closes_existing_items(cx: &mut TestAppContext) {\n        init_test(cx);\n        let fs = FakeFs::new(cx.executor());\n\n        let project = Project::test(fs, None, cx).await;\n        let (workspace, cx) =\n            cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n        let pane = workspace.read_with(cx, |workspace, _| workspace.active_pane().clone());\n\n        add_labeled_item(&pane, ": "",
        ", false, cx);\n        add_labeled_item(&pane, ": "",
        ", false, cx);\n        let item_c = add_labeled_item(&pane, ": "",
        ", false, cx);\n        let item_d = add_labeled_item(&pane, ": "",
        ", false, cx);\n        assert_item_labels(&pane, [": "",
        "], cx);\n\n        set_max_tabs(cx, Some(5));\n        assert_item_labels(&pane, [": "",
        "], cx);\n\n        set_max_tabs(cx, Some(4));\n        assert_item_labels(&pane, [": "",
        "], cx);\n\n        pane.update_in(cx, |pane, window, cx| {\n            let ix = pane.index_for_item_id(item_c.item_id()).unwrap();\n            pane.pin_tab_at(ix, window, cx);\n\n            let ix = pane.index_for_item_id(item_d.item_id()).unwrap();\n            pane.pin_tab_at(ix, window, cx);\n        });\n        assert_item_labels(&pane, [": "",
        "], cx);\n\n        set_max_tabs(cx, Some(2));\n        assert_item_labels(&pane, [": "",
        "], cx);\n    }\n\n    #[gpui::test]\n    async fn test_allow_pinning_dirty_item_at_max_tabs(cx: &mut TestAppContext) {\n        init_test(cx);\n        let fs = FakeFs::new(cx.executor());\n\n        let project = Project::test(fs, None, cx).await;\n        let (workspace, cx) =\n            cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n        let pane = workspace.read_with(cx, |workspace, _| workspace.active_pane().clone());\n\n        set_max_tabs(cx, Some(1));\n        let item_a = add_labeled_item(&pane, ": "",
        ", true, cx);\n\n        pane.update_in(cx, |pane, window, cx| {\n            let ix = pane.index_for_item_id(item_a.item_id()).unwrap();\n            pane.pin_tab_at(ix, window, cx);\n        });\n        assert_item_labels(&pane, [": "",
        "], cx);\n    }\n\n    #[gpui::test]\n    async fn test_allow_pinning_non_dirty_item_at_max_tabs(cx: &mut TestAppContext) {\n        init_test(cx);\n        let fs = FakeFs::new(cx.executor());\n\n        let project = Project::test(fs, None, cx).await;\n        let (workspace, cx) =\n            cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n        let pane = workspace.read_with(cx, |workspace, _| workspace.active_pane().clone());\n\n        set_max_tabs(cx, Some(1));\n        let item_a = add_labeled_item(&pane, ": "",
        ", false, cx);\n\n        pane.update_in(cx, |pane, window, cx| {\n            let ix = pane.index_for_item_id(item_a.item_id()).unwrap();\n            pane.pin_tab_at(ix, window, cx);\n        });\n        assert_item_labels(&pane, [": "",
        "], cx);\n    }\n\n    #[gpui::test]\n    async fn test_pin_tabs_incrementally_at_max_capacity(cx: &mut TestAppContext) {\n        init_test(cx);\n        let fs = FakeFs::new(cx.executor());\n\n        let project = Project::test(fs, None, cx).await;\n        let (workspace, cx) =\n            cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n        let pane = workspace.read_with(cx, |workspace, _| workspace.active_pane().clone());\n\n        set_max_tabs(cx, Some(3));\n\n        let item_a = add_labeled_item(&pane, ": "",
        "], cx);\n\n        pane.update_in(cx, |pane, window, cx| {\n            let ix = pane.index_for_item_id(item_a.item_id()).unwrap();\n            pane.pin_tab_at(ix, window, cx);\n        });\n        assert_item_labels(&pane, [": "",
        "], cx);\n\n        let item_b = add_labeled_item(&pane, ": "",
        "], cx);\n\n        pane.update_in(cx, |pane, window, cx| {\n            let ix = pane.index_for_item_id(item_b.item_id()).unwrap();\n            pane.pin_tab_at(ix, window, cx);\n        });\n        assert_item_labels(&pane, [": "",
        "], cx);\n\n        let item_c = add_labeled_item(&pane, ": "",
        "], cx);\n\n        pane.update_in(cx, |pane, window, cx| {\n            let ix = pane.index_for_item_id(item_c.item_id()).unwrap();\n            pane.pin_tab_at(ix, window, cx);\n        });\n        assert_item_labels(&pane, [": "",
        "], cx);\n    }\n\n    #[gpui::test]\n    async fn test_pin_tabs_left_to_right_after_opening_at_max_capacity(cx: &mut TestAppContext) {\n        init_test(cx);\n        let fs = FakeFs::new(cx.executor());\n\n        let project = Project::test(fs, None, cx).await;\n        let (workspace, cx) =\n            cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n        let pane = workspace.read_with(cx, |workspace, _| workspace.active_pane().clone());\n\n        set_max_tabs(cx, Some(3));\n\n        let item_a = add_labeled_item(&pane, ": "",
        "], cx);\n    }\n\n    #[gpui::test]\n    async fn test_pin_tabs_right_to_left_after_opening_at_max_capacity(cx: &mut TestAppContext) {\n        init_test(cx);\n        let fs = FakeFs::new(cx.executor());\n\n        let project = Project::test(fs, None, cx).await;\n        let (workspace, cx) =\n            cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n        let pane = workspace.read_with(cx, |workspace, _| workspace.active_pane().clone());\n\n        set_max_tabs(cx, Some(3));\n\n        let item_a = add_labeled_item(&pane, ": "",
        "], cx);\n    }\n\n    #[gpui::test]\n    async fn test_pinned_tabs_never_closed_at_max_tabs(cx: &mut TestAppContext) {\n        init_test(cx);\n        let fs = FakeFs::new(cx.executor());\n\n        let project = Project::test(fs, None, cx).await;\n        let (workspace, cx) =\n            cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n        let pane = workspace.read_with(cx, |workspace, _| workspace.active_pane().clone());\n\n        let item_a = add_labeled_item(&pane, ": "",
        ", false, cx);\n        pane.update_in(cx, |pane, window, cx| {\n            let ix = pane.index_for_item_id(item_a.item_id()).unwrap();\n            pane.pin_tab_at(ix, window, cx);\n        });\n\n        let item_b = add_labeled_item(&pane, ": "",
        ", false, cx);\n        pane.update_in(cx, |pane, window, cx| {\n            let ix = pane.index_for_item_id(item_b.item_id()).unwrap();\n            pane.pin_tab_at(ix, window, cx);\n        });\n\n        add_labeled_item(&pane, ": "",
        "], cx);\n\n        set_max_tabs(cx, Some(3));\n        add_labeled_item(&pane, ": "",
        "], cx);\n\n        add_labeled_item(&pane, ": "",
        "], cx);\n    }\n\n    #[gpui::test]\n    async fn test_always_allows_one_unpinned_item_over_max_tabs_regardless_of_pinned_count(\n        cx: &mut TestAppContext,\n    ) {\n        init_test(cx);\n        let fs = FakeFs::new(cx.executor());\n\n        let project = Project::test(fs, None, cx).await;\n        let (workspace, cx) =\n            cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n        let pane = workspace.read_with(cx, |workspace, _| workspace.active_pane().clone());\n\n        set_max_tabs(cx, Some(3));\n\n        let item_a = add_labeled_item(&pane, ": "",
        ", false, cx);\n        pane.update_in(cx, |pane, window, cx| {\n            let ix = pane.index_for_item_id(item_b.item_id()).unwrap();\n            pane.pin_tab_at(ix, window, cx);\n        });\n\n        let item_c = add_labeled_item(&pane, ": "",
        ", false, cx);\n        pane.update_in(cx, |pane, window, cx| {\n            let ix = pane.index_for_item_id(item_c.item_id()).unwrap();\n            pane.pin_tab_at(ix, window, cx);\n        });\n\n        assert_item_labels(&pane, [": "",
        "], cx);\n\n        let item_d = add_labeled_item(&pane, ": "",
        "], cx);\n\n        pane.update_in(cx, |pane, window, cx| {\n            let ix = pane.index_for_item_id(item_d.item_id()).unwrap();\n            pane.pin_tab_at(ix, window, cx);\n        });\n        assert_item_labels(&pane, [": "",
        "], cx);\n    }\n\n    #[gpui::test]\n    async fn test_can_open_one_item_when_all_tabs_are_dirty_at_max(cx: &mut TestAppContext) {\n        init_test(cx);\n        let fs = FakeFs::new(cx.executor());\n\n        let project = Project::test(fs, None, cx).await;\n        let (workspace, cx) =\n            cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n        let pane = workspace.read_with(cx, |workspace, _| workspace.active_pane().clone());\n\n        set_max_tabs(cx, Some(3));\n\n        add_labeled_item(&pane, ": "",
        ", true, cx);\n        assert_item_labels(&pane, [": "",
        "], cx);\n    }\n\n    #[gpui::test]\n    async fn test_toggle_pin_tab(cx: &mut TestAppContext) {\n        init_test(cx);\n        let fs = FakeFs::new(cx.executor());\n\n        let project = Project::test(fs, None, cx).await;\n        let (workspace, cx) =\n            cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n        let pane = workspace.read_with(cx, |workspace, _| workspace.active_pane().clone());\n\n        set_labeled_items(&pane, [": "",
        "], cx);\n        assert_item_labels(&pane, [": "",
        "], cx);\n\n        pane.update_in(cx, |pane, window, cx| {\n            pane.toggle_pin_tab(&TogglePinTab, window, cx);\n        });\n        assert_item_labels(&pane, [": "",
        "], cx);\n    }\n\n    #[gpui::test]\n    async fn test_unpin_all_tabs(cx: &mut TestAppContext) {\n        init_test(cx);\n        let fs = FakeFs::new(cx.executor());\n\n        let project = Project::test(fs, None, cx).await;\n        let (workspace, cx) =\n            cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n        let pane = workspace.read_with(cx, |workspace, _| workspace.active_pane().clone());\n\n        // Unpin all, in an empty pane\n        pane.update_in(cx, |pane, window, cx| {\n            pane.unpin_all_tabs(&UnpinAllTabs, window, cx);\n        });\n\n        assert_item_labels(&pane, [], cx);\n\n        let item_a = add_labeled_item(&pane, ": "",
        ", false, cx);\n        let item_b = add_labeled_item(&pane, ": "",
        "], cx);\n\n        // Unpin all, when no tabs are pinned\n        pane.update_in(cx, |pane, window, cx| {\n            pane.unpin_all_tabs(&UnpinAllTabs, window, cx);\n        });\n\n        assert_item_labels(&pane, [": "",
        "], cx);\n\n        // Pin inactive tabs only\n        pane.update_in(cx, |pane, window, cx| {\n            let ix = pane.index_for_item_id(item_a.item_id()).unwrap();\n            pane.pin_tab_at(ix, window, cx);\n\n            let ix = pane.index_for_item_id(item_b.item_id()).unwrap();\n            pane.pin_tab_at(ix, window, cx);\n        });\n        assert_item_labels(&pane, [": "",
        "], cx);\n\n        pane.update_in(cx, |pane, window, cx| {\n            pane.unpin_all_tabs(&UnpinAllTabs, window, cx);\n        });\n\n        assert_item_labels(&pane, [": "",
        "], cx);\n\n        // Pin all tabs\n        pane.update_in(cx, |pane, window, cx| {\n            let ix = pane.index_for_item_id(item_a.item_id()).unwrap();\n            pane.pin_tab_at(ix, window, cx);\n\n            let ix = pane.index_for_item_id(item_b.item_id()).unwrap();\n            pane.pin_tab_at(ix, window, cx);\n\n            let ix = pane.index_for_item_id(item_c.item_id()).unwrap();\n            pane.pin_tab_at(ix, window, cx);\n        });\n        assert_item_labels(&pane, [": "",
        "], cx);\n\n        // Activate middle tab\n        pane.update_in(cx, |pane, window, cx| {\n            pane.activate_item(1, false, false, window, cx);\n        });\n        assert_item_labels(&pane, [": "",
        "], cx);\n\n        pane.update_in(cx, |pane, window, cx| {\n            pane.unpin_all_tabs(&UnpinAllTabs, window, cx);\n        });\n\n        // Order has not changed\n        assert_item_labels(&pane, [": "",
        "], cx);\n    }\n\n    #[gpui::test]\n    async fn test_pinning_active_tab_without_position_change_maintains_focus(\n        cx: &mut TestAppContext,\n    ) {\n        init_test(cx);\n        let fs = FakeFs::new(cx.executor());\n\n        let project = Project::test(fs, None, cx).await;\n        let (workspace, cx) =\n            cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n        let pane = workspace.read_with(cx, |workspace, _| workspace.active_pane().clone());\n\n        // Add A\n        let item_a = add_labeled_item(&pane, ": "",
        "], cx);\n\n        // Add B\n        add_labeled_item(&pane, ": "",
        "], cx);\n\n        // Activate A again\n        pane.update_in(cx, |pane, window, cx| {\n            let ix = pane.index_for_item_id(item_a.item_id()).unwrap();\n            pane.activate_item(ix, true, true, window, cx);\n        });\n        assert_item_labels(&pane, [": "",
        "], cx);\n\n        // Pin A - remains active\n        pane.update_in(cx, |pane, window, cx| {\n            let ix = pane.index_for_item_id(item_a.item_id()).unwrap();\n            pane.pin_tab_at(ix, window, cx);\n        });\n        assert_item_labels(&pane, [": "",
        "], cx);\n\n        // Unpin A - remain active\n        pane.update_in(cx, |pane, window, cx| {\n            let ix = pane.index_for_item_id(item_a.item_id()).unwrap();\n            pane.unpin_tab_at(ix, window, cx);\n        });\n        assert_item_labels(&pane, [": "",
        "], cx);\n    }\n\n    #[gpui::test]\n    async fn test_pinning_active_tab_with_position_change_maintains_focus(cx: &mut TestAppContext) {\n        init_test(cx);\n        let fs = FakeFs::new(cx.executor());\n\n        let project = Project::test(fs, None, cx).await;\n        let (workspace, cx) =\n            cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n        let pane = workspace.read_with(cx, |workspace, _| workspace.active_pane().clone());\n\n        // Add A, B, C\n        add_labeled_item(&pane, ": "",
        "], cx);\n\n        // Pin C - moves to pinned area, remains active\n        pane.update_in(cx, |pane, window, cx| {\n            let ix = pane.index_for_item_id(item_c.item_id()).unwrap();\n            pane.pin_tab_at(ix, window, cx);\n        });\n        assert_item_labels(&pane, [": "",
        "], cx);\n\n        // Unpin C - moves after pinned area, remains active\n        pane.update_in(cx, |pane, window, cx| {\n            let ix = pane.index_for_item_id(item_c.item_id()).unwrap();\n            pane.unpin_tab_at(ix, window, cx);\n        });\n        assert_item_labels(&pane, [": "",
        "], cx);\n    }\n\n    #[gpui::test]\n    async fn test_pinning_inactive_tab_without_position_change_preserves_existing_focus(\n        cx: &mut TestAppContext,\n    ) {\n        init_test(cx);\n        let fs = FakeFs::new(cx.executor());\n\n        let project = Project::test(fs, None, cx).await;\n        let (workspace, cx) =\n            cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n        let pane = workspace.read_with(cx, |workspace, _| workspace.active_pane().clone());\n\n        // Add A, B\n        let item_a = add_labeled_item(&pane, ": "",
        "], cx);\n\n        // Pin A - already in pinned area, B remains active\n        pane.update_in(cx, |pane, window, cx| {\n            let ix = pane.index_for_item_id(item_a.item_id()).unwrap();\n            pane.pin_tab_at(ix, window, cx);\n        });\n        assert_item_labels(&pane, [": "",
        "], cx);\n\n        // Unpin A - stays in place, B remains active\n        pane.update_in(cx, |pane, window, cx| {\n            let ix = pane.index_for_item_id(item_a.item_id()).unwrap();\n            pane.unpin_tab_at(ix, window, cx);\n        });\n        assert_item_labels(&pane, [": "",
        "], cx);\n    }\n\n    #[gpui::test]\n    async fn test_pinning_inactive_tab_with_position_change_preserves_existing_focus(\n        cx: &mut TestAppContext,\n    ) {\n        init_test(cx);\n        let fs = FakeFs::new(cx.executor());\n\n        let project = Project::test(fs, None, cx).await;\n        let (workspace, cx) =\n            cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n        let pane = workspace.read_with(cx, |workspace, _| workspace.active_pane().clone());\n\n        // Add A, B, C\n        add_labeled_item(&pane, ": "",
        "], cx);\n\n        // Activate B\n        pane.update_in(cx, |pane, window, cx| {\n            let ix = pane.index_for_item_id(item_b.item_id()).unwrap();\n            pane.activate_item(ix, true, true, window, cx);\n        });\n        assert_item_labels(&pane, [": "",
        "], cx);\n\n        // Pin C - moves to pinned area, B remains active\n        pane.update_in(cx, |pane, window, cx| {\n            let ix = pane.index_for_item_id(item_c.item_id()).unwrap();\n            pane.pin_tab_at(ix, window, cx);\n        });\n        assert_item_labels(&pane, [": "",
        "], cx);\n\n        // Unpin C - moves after pinned area, B remains active\n        pane.update_in(cx, |pane, window, cx| {\n            let ix = pane.index_for_item_id(item_c.item_id()).unwrap();\n            pane.unpin_tab_at(ix, window, cx);\n        });\n        assert_item_labels(&pane, [": "",
        "], cx);\n    }\n\n    #[gpui::test]\n    async fn test_drag_unpinned_tab_to_split_creates_pane_with_unpinned_tab(\n        cx: &mut TestAppContext,\n    ) {\n        init_test(cx);\n        let fs = FakeFs::new(cx.executor());\n\n        let project = Project::test(fs, None, cx).await;\n        let (workspace, cx) =\n            cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n        let pane_a = workspace.read_with(cx, |workspace, _| workspace.active_pane().clone());\n\n        // Add A, B. Pin B. Activate A\n        let item_a = add_labeled_item(&pane_a, ": "",
        ", false, cx);\n        let item_b = add_labeled_item(&pane_a, ": "",
        ", false, cx);\n\n        pane_a.update_in(cx, |pane, window, cx| {\n            let ix = pane.index_for_item_id(item_b.item_id()).unwrap();\n            pane.pin_tab_at(ix, window, cx);\n\n            let ix = pane.index_for_item_id(item_a.item_id()).unwrap();\n            pane.activate_item(ix, true, true, window, cx);\n        });\n\n        // Drag A to create new split\n        pane_a.update_in(cx, |pane, window, cx| {\n            pane.drag_split_direction = Some(SplitDirection::Right);\n\n            let dragged_tab = DraggedTab {\n                pane: pane_a.clone(),\n                item: item_a.boxed_clone(),\n                ix: 0,\n                detail: 0,\n                is_active: true,\n            };\n            pane.handle_tab_drop(&dragged_tab, 0, window, cx);\n        });\n\n        // A should be moved to new pane. B should remain pinned, A should not be pinned\n        let (pane_a, pane_b) = workspace.read_with(cx, |workspace, _| {\n            let panes = workspace.panes();\n            (panes[0].clone(), panes[1].clone())\n        });\n        assert_item_labels(&pane_a, [": "",
        "], cx);\n        assert_item_labels(&pane_b, [": "",
        "], cx);\n    }\n\n    #[gpui::test]\n    async fn test_drag_pinned_tab_to_split_creates_pane_with_pinned_tab(cx: &mut TestAppContext) {\n        init_test(cx);\n        let fs = FakeFs::new(cx.executor());\n\n        let project = Project::test(fs, None, cx).await;\n        let (workspace, cx) =\n            cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n        let pane_a = workspace.read_with(cx, |workspace, _| workspace.active_pane().clone());\n\n        // Add A, B. Pin both. Activate A\n        let item_a = add_labeled_item(&pane_a, ": "",
        ", false, cx);\n\n        pane_a.update_in(cx, |pane, window, cx| {\n            let ix = pane.index_for_item_id(item_a.item_id()).unwrap();\n            pane.pin_tab_at(ix, window, cx);\n\n            let ix = pane.index_for_item_id(item_b.item_id()).unwrap();\n            pane.pin_tab_at(ix, window, cx);\n\n            let ix = pane.index_for_item_id(item_a.item_id()).unwrap();\n            pane.activate_item(ix, true, true, window, cx);\n        });\n        assert_item_labels(&pane_a, [": "",
        "], cx);\n\n        // Drag A to create new split\n        pane_a.update_in(cx, |pane, window, cx| {\n            pane.drag_split_direction = Some(SplitDirection::Right);\n\n            let dragged_tab = DraggedTab {\n                pane: pane_a.clone(),\n                item: item_a.boxed_clone(),\n                ix: 0,\n                detail: 0,\n                is_active: true,\n            };\n            pane.handle_tab_drop(&dragged_tab, 0, window, cx);\n        });\n\n        // A should be moved to new pane. Both A and B should still be pinned\n        let (pane_a, pane_b) = workspace.read_with(cx, |workspace, _| {\n            let panes = workspace.panes();\n            (panes[0].clone(), panes[1].clone())\n        });\n        assert_item_labels(&pane_a, [": "",
        "], cx);\n    }\n\n    #[gpui::test]\n    async fn test_drag_pinned_tab_into_existing_panes_pinned_region(cx: &mut TestAppContext) {\n        init_test(cx);\n        let fs = FakeFs::new(cx.executor());\n\n        let project = Project::test(fs, None, cx).await;\n        let (workspace, cx) =\n            cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n        let pane_a = workspace.read_with(cx, |workspace, _| workspace.active_pane().clone());\n\n        // Add A to pane A and pin\n        let item_a = add_labeled_item(&pane_a, ": "",
        ", false, cx);\n        pane_a.update_in(cx, |pane, window, cx| {\n            let ix = pane.index_for_item_id(item_a.item_id()).unwrap();\n            pane.pin_tab_at(ix, window, cx);\n        });\n        assert_item_labels(&pane_a, [": "",
        "], cx);\n\n        // Add B to pane B and pin\n        let pane_b = workspace.update_in(cx, |workspace, window, cx| {\n            workspace.split_pane(pane_a.clone(), SplitDirection::Right, window, cx)\n        });\n        let item_b = add_labeled_item(&pane_b, ": "",
        ", false, cx);\n        pane_b.update_in(cx, |pane, window, cx| {\n            let ix = pane.index_for_item_id(item_b.item_id()).unwrap();\n            pane.pin_tab_at(ix, window, cx);\n        });\n        assert_item_labels(&pane_b, [": "",
        "], cx);\n\n        // Move A from pane A to pane B's pinned region\n        pane_b.update_in(cx, |pane, window, cx| {\n            let dragged_tab = DraggedTab {\n                pane: pane_a.clone(),\n                item: item_a.boxed_clone(),\n                ix: 0,\n                detail: 0,\n                is_active: true,\n            };\n            pane.handle_tab_drop(&dragged_tab, 0, window, cx);\n        });\n\n        // A should stay pinned\n        assert_item_labels(&pane_a, [], cx);\n        assert_item_labels(&pane_b, [": "",
        "], cx);\n    }\n\n    #[gpui::test]\n    async fn test_drag_pinned_tab_into_existing_panes_unpinned_region(cx: &mut TestAppContext) {\n        init_test(cx);\n        let fs = FakeFs::new(cx.executor());\n\n        let project = Project::test(fs, None, cx).await;\n        let (workspace, cx) =\n            cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n        let pane_a = workspace.read_with(cx, |workspace, _| workspace.active_pane().clone());\n\n        // Add A to pane A and pin\n        let item_a = add_labeled_item(&pane_a, ": "",
        "], cx);\n\n        // Create pane B with pinned item B\n        let pane_b = workspace.update_in(cx, |workspace, window, cx| {\n            workspace.split_pane(pane_a.clone(), SplitDirection::Right, window, cx)\n        });\n        let item_b = add_labeled_item(&pane_b, ": "",
        ", false, cx);\n        assert_item_labels(&pane_b, [": "",
        "], cx);\n\n        pane_b.update_in(cx, |pane, window, cx| {\n            let ix = pane.index_for_item_id(item_b.item_id()).unwrap();\n            pane.pin_tab_at(ix, window, cx);\n        });\n        assert_item_labels(&pane_b, [": "",
        "], cx);\n\n        // Move A from pane A to pane B's unpinned region\n        pane_b.update_in(cx, |pane, window, cx| {\n            let dragged_tab = DraggedTab {\n                pane: pane_a.clone(),\n                item: item_a.boxed_clone(),\n                ix: 0,\n                detail: 0,\n                is_active: true,\n            };\n            pane.handle_tab_drop(&dragged_tab, 1, window, cx);\n        });\n\n        // A should become pinned\n        assert_item_labels(&pane_a, [], cx);\n        assert_item_labels(&pane_b, [": "",
        "], cx);\n    }\n\n    #[gpui::test]\n    async fn test_drag_pinned_tab_into_existing_panes_first_position_with_no_pinned_tabs(\n        cx: &mut TestAppContext,\n    ) {\n        init_test(cx);\n        let fs = FakeFs::new(cx.executor());\n\n        let project = Project::test(fs, None, cx).await;\n        let (workspace, cx) =\n            cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n        let pane_a = workspace.read_with(cx, |workspace, _| workspace.active_pane().clone());\n\n        // Add A to pane A and pin\n        let item_a = add_labeled_item(&pane_a, ": "",
        "], cx);\n\n        // Add B to pane B\n        let pane_b = workspace.update_in(cx, |workspace, window, cx| {\n            workspace.split_pane(pane_a.clone(), SplitDirection::Right, window, cx)\n        });\n        add_labeled_item(&pane_b, ": "",
        "], cx);\n\n        // Move A from pane A to position 0 in pane B, indicating it should stay pinned\n        pane_b.update_in(cx, |pane, window, cx| {\n            let dragged_tab = DraggedTab {\n                pane: pane_a.clone(),\n                item: item_a.boxed_clone(),\n                ix: 0,\n                detail: 0,\n                is_active: true,\n            };\n            pane.handle_tab_drop(&dragged_tab, 0, window, cx);\n        });\n\n        // A should stay pinned\n        assert_item_labels(&pane_a, [], cx);\n        assert_item_labels(&pane_b, [": "",
        "], cx);\n    }\n\n    #[gpui::test]\n    async fn test_drag_pinned_tab_into_existing_pane_at_max_capacity_closes_unpinned_tabs(\n        cx: &mut TestAppContext,\n    ) {\n        init_test(cx);\n        let fs = FakeFs::new(cx.executor());\n\n        let project = Project::test(fs, None, cx).await;\n        let (workspace, cx) =\n            cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n        let pane_a = workspace.read_with(cx, |workspace, _| workspace.active_pane().clone());\n        set_max_tabs(cx, Some(2));\n\n        // Add A, B to pane A. Pin both\n        let item_a = add_labeled_item(&pane_a, ": "",
        ", false, cx);\n        pane_a.update_in(cx, |pane, window, cx| {\n            let ix = pane.index_for_item_id(item_a.item_id()).unwrap();\n            pane.pin_tab_at(ix, window, cx);\n\n            let ix = pane.index_for_item_id(item_b.item_id()).unwrap();\n            pane.pin_tab_at(ix, window, cx);\n        });\n        assert_item_labels(&pane_a, [": "",
        "], cx);\n\n        // Add C, D to pane B. Pin both\n        let pane_b = workspace.update_in(cx, |workspace, window, cx| {\n            workspace.split_pane(pane_a.clone(), SplitDirection::Right, window, cx)\n        });\n        let item_c = add_labeled_item(&pane_b, ": "",
        ", false, cx);\n        let item_d = add_labeled_item(&pane_b, ": "",
        ", false, cx);\n        pane_b.update_in(cx, |pane, window, cx| {\n            let ix = pane.index_for_item_id(item_c.item_id()).unwrap();\n            pane.pin_tab_at(ix, window, cx);\n\n            let ix = pane.index_for_item_id(item_d.item_id()).unwrap();\n            pane.pin_tab_at(ix, window, cx);\n        });\n        assert_item_labels(&pane_b, [": "",
        "], cx);\n\n        // Add a third unpinned item to pane B (exceeds max tabs), but is allowed,\n        // as we allow 1 tab over max if the others are pinned or dirty\n        add_labeled_item(&pane_b, ": "",
        "], cx);\n\n        // Drag pinned A from pane A to position 0 in pane B\n        pane_b.update_in(cx, |pane, window, cx| {\n            let dragged_tab = DraggedTab {\n                pane: pane_a.clone(),\n                item: item_a.boxed_clone(),\n                ix: 0,\n                detail: 0,\n                is_active: true,\n            };\n            pane.handle_tab_drop(&dragged_tab, 0, window, cx);\n        });\n\n        // E (unpinned) should be closed, leaving 3 pinned items\n        assert_item_labels(&pane_a, [": "",
        "], cx);\n    }\n\n    #[gpui::test]\n    async fn test_drag_last_pinned_tab_to_same_position_stays_pinned(cx: &mut TestAppContext) {\n        init_test(cx);\n        let fs = FakeFs::new(cx.executor());\n\n        let project = Project::test(fs, None, cx).await;\n        let (workspace, cx) =\n            cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n        let pane_a = workspace.read_with(cx, |workspace, _| workspace.active_pane().clone());\n\n        // Add A to pane A and pin it\n        let item_a = add_labeled_item(&pane_a, ": "",
        "], cx);\n\n        // Drag pinned A to position 1 (directly to the right) in the same pane\n        pane_a.update_in(cx, |pane, window, cx| {\n            let dragged_tab = DraggedTab {\n                pane: pane_a.clone(),\n                item: item_a.boxed_clone(),\n                ix: 0,\n                detail: 0,\n                is_active: true,\n            };\n            pane.handle_tab_drop(&dragged_tab, 1, window, cx);\n        });\n\n        // A should still be pinned and active\n        assert_item_labels(&pane_a, [": "",
        "], cx);\n    }\n\n    #[gpui::test]\n    async fn test_drag_pinned_tab_beyond_last_pinned_tab_in_same_pane_stays_pinned(\n        cx: &mut TestAppContext,\n    ) {\n        init_test(cx);\n        let fs = FakeFs::new(cx.executor());\n\n        let project = Project::test(fs, None, cx).await;\n        let (workspace, cx) =\n            cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n        let pane_a = workspace.read_with(cx, |workspace, _| workspace.active_pane().clone());\n\n        // Add A, B to pane A and pin both\n        let item_a = add_labeled_item(&pane_a, ": "",
        "], cx);\n\n        // Drag pinned A right of B in the same pane\n        pane_a.update_in(cx, |pane, window, cx| {\n            let dragged_tab = DraggedTab {\n                pane: pane_a.clone(),\n                item: item_a.boxed_clone(),\n                ix: 0,\n                detail: 0,\n                is_active: true,\n            };\n            pane.handle_tab_drop(&dragged_tab, 2, window, cx);\n        });\n\n        // A stays pinned\n        assert_item_labels(&pane_a, [": "",
        "], cx);\n    }\n\n    #[gpui::test]\n    async fn test_dragging_pinned_tab_onto_unpinned_tab_reduces_unpinned_tab_count(\n        cx: &mut TestAppContext,\n    ) {\n        init_test(cx);\n        let fs = FakeFs::new(cx.executor());\n\n        let project = Project::test(fs, None, cx).await;\n        let (workspace, cx) =\n            cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n        let pane_a = workspace.read_with(cx, |workspace, _| workspace.active_pane().clone());\n\n        // Add A, B to pane A and pin A\n        let item_a = add_labeled_item(&pane_a, ": "",
        ", false, cx);\n        add_labeled_item(&pane_a, ": "",
        "], cx);\n\n        // Drag pinned A on top of B in the same pane, which changes tab order to B, A\n        pane_a.update_in(cx, |pane, window, cx| {\n            let dragged_tab = DraggedTab {\n                pane: pane_a.clone(),\n                item: item_a.boxed_clone(),\n                ix: 0,\n                detail: 0,\n                is_active: true,\n            };\n            pane.handle_tab_drop(&dragged_tab, 1, window, cx);\n        });\n\n        // Neither are pinned\n        assert_item_labels(&pane_a, [": "",
        "], cx);\n    }\n\n    #[gpui::test]\n    async fn test_drag_pinned_tab_beyond_unpinned_tab_in_same_pane_becomes_unpinned(\n        cx: &mut TestAppContext,\n    ) {\n        init_test(cx);\n        let fs = FakeFs::new(cx.executor());\n\n        let project = Project::test(fs, None, cx).await;\n        let (workspace, cx) =\n            cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n        let pane_a = workspace.read_with(cx, |workspace, _| workspace.active_pane().clone());\n\n        // Add A, B to pane A and pin A\n        let item_a = add_labeled_item(&pane_a, ": "",
        "], cx);\n\n        // Drag pinned A right of B in the same pane\n        pane_a.update_in(cx, |pane, window, cx| {\n            let dragged_tab = DraggedTab {\n                pane: pane_a.clone(),\n                item: item_a.boxed_clone(),\n                ix: 0,\n                detail: 0,\n                is_active: true,\n            };\n            pane.handle_tab_drop(&dragged_tab, 2, window, cx);\n        });\n\n        // A becomes unpinned\n        assert_item_labels(&pane_a, [": "",
        "], cx);\n    }\n\n    #[gpui::test]\n    async fn test_drag_unpinned_tab_in_front_of_pinned_tab_in_same_pane_becomes_pinned(\n        cx: &mut TestAppContext,\n    ) {\n        init_test(cx);\n        let fs = FakeFs::new(cx.executor());\n\n        let project = Project::test(fs, None, cx).await;\n        let (workspace, cx) =\n            cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n        let pane_a = workspace.read_with(cx, |workspace, _| workspace.active_pane().clone());\n\n        // Add A, B to pane A and pin A\n        let item_a = add_labeled_item(&pane_a, ": "",
        "], cx);\n\n        // Drag pinned B left of A in the same pane\n        pane_a.update_in(cx, |pane, window, cx| {\n            let dragged_tab = DraggedTab {\n                pane: pane_a.clone(),\n                item: item_b.boxed_clone(),\n                ix: 1,\n                detail: 0,\n                is_active: true,\n            };\n            pane.handle_tab_drop(&dragged_tab, 0, window, cx);\n        });\n\n        // A becomes unpinned\n        assert_item_labels(&pane_a, [": "",
        "], cx);\n    }\n\n    #[gpui::test]\n    async fn test_drag_unpinned_tab_to_the_pinned_region_stays_pinned(cx: &mut TestAppContext) {\n        init_test(cx);\n        let fs = FakeFs::new(cx.executor());\n\n        let project = Project::test(fs, None, cx).await;\n        let (workspace, cx) =\n            cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n        let pane_a = workspace.read_with(cx, |workspace, _| workspace.active_pane().clone());\n\n        // Add A, B, C to pane A and pin A\n        let item_a = add_labeled_item(&pane_a, ": "",
        ", false, cx);\n        let item_c = add_labeled_item(&pane_a, ": "",
        "], cx);\n\n        // Drag pinned C left of B in the same pane\n        pane_a.update_in(cx, |pane, window, cx| {\n            let dragged_tab = DraggedTab {\n                pane: pane_a.clone(),\n                item: item_c.boxed_clone(),\n                ix: 2,\n                detail: 0,\n                is_active: true,\n            };\n            pane.handle_tab_drop(&dragged_tab, 1, window, cx);\n        });\n\n        // A stays pinned, B and C remain unpinned\n        assert_item_labels(&pane_a, [": "",
        "], cx);\n    }\n\n    #[gpui::test]\n    async fn test_drag_unpinned_tab_into_existing_panes_pinned_region(cx: &mut TestAppContext) {\n        init_test(cx);\n        let fs = FakeFs::new(cx.executor());\n\n        let project = Project::test(fs, None, cx).await;\n        let (workspace, cx) =\n            cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n        let pane_a = workspace.read_with(cx, |workspace, _| workspace.active_pane().clone());\n\n        // Add unpinned item A to pane A\n        let item_a = add_labeled_item(&pane_a, ": "",
        ", false, cx);\n        assert_item_labels(&pane_a, [": "",
        "], cx);\n\n        // Move A from pane A to pane B's pinned region\n        pane_b.update_in(cx, |pane, window, cx| {\n            let dragged_tab = DraggedTab {\n                pane: pane_a.clone(),\n                item: item_a.boxed_clone(),\n                ix: 0,\n                detail: 0,\n                is_active: true,\n            };\n            pane.handle_tab_drop(&dragged_tab, 0, window, cx);\n        });\n\n        // A should become pinned since it was dropped in the pinned region\n        assert_item_labels(&pane_a, [], cx);\n        assert_item_labels(&pane_b, [": "",
        "], cx);\n    }\n\n    #[gpui::test]\n    async fn test_drag_unpinned_tab_into_existing_panes_unpinned_region(cx: &mut TestAppContext) {\n        init_test(cx);\n        let fs = FakeFs::new(cx.executor());\n\n        let project = Project::test(fs, None, cx).await;\n        let (workspace, cx) =\n            cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n        let pane_a = workspace.read_with(cx, |workspace, _| workspace.active_pane().clone());\n\n        // Add unpinned item A to pane A\n        let item_a = add_labeled_item(&pane_a, ": "",
        "], cx);\n\n        // Create pane B with one pinned item B\n        let pane_b = workspace.update_in(cx, |workspace, window, cx| {\n            workspace.split_pane(pane_a.clone(), SplitDirection::Right, window, cx)\n        });\n        let item_b = add_labeled_item(&pane_b, ": "",
        "], cx);\n\n        // Move A from pane A to pane B's unpinned region\n        pane_b.update_in(cx, |pane, window, cx| {\n            let dragged_tab = DraggedTab {\n                pane: pane_a.clone(),\n                item: item_a.boxed_clone(),\n                ix: 0,\n                detail: 0,\n                is_active: true,\n            };\n            pane.handle_tab_drop(&dragged_tab, 1, window, cx);\n        });\n\n        // A should remain unpinned since it was dropped outside the pinned region\n        assert_item_labels(&pane_a, [], cx);\n        assert_item_labels(&pane_b, [": "",
        "], cx);\n    }\n\n    #[gpui::test]\n    async fn test_drag_pinned_tab_throughout_entire_range_of_pinned_tabs_both_directions(\n        cx: &mut TestAppContext,\n    ) {\n        init_test(cx);\n        let fs = FakeFs::new(cx.executor());\n\n        let project = Project::test(fs, None, cx).await;\n        let (workspace, cx) =\n            cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n        let pane_a = workspace.read_with(cx, |workspace, _| workspace.active_pane().clone());\n\n        // Add A, B, C and pin all\n        let item_a = add_labeled_item(&pane_a, ": "",
        "], cx);\n\n        pane_a.update_in(cx, |pane, window, cx| {\n            let ix = pane.index_for_item_id(item_a.item_id()).unwrap();\n            pane.pin_tab_at(ix, window, cx);\n\n            let ix = pane.index_for_item_id(item_b.item_id()).unwrap();\n            pane.pin_tab_at(ix, window, cx);\n\n            let ix = pane.index_for_item_id(item_c.item_id()).unwrap();\n            pane.pin_tab_at(ix, window, cx);\n        });\n        assert_item_labels(&pane_a, [": "",
        "], cx);\n\n        // Move A to right of B\n        pane_a.update_in(cx, |pane, window, cx| {\n            let dragged_tab = DraggedTab {\n                pane: pane_a.clone(),\n                item: item_a.boxed_clone(),\n                ix: 0,\n                detail: 0,\n                is_active: true,\n            };\n            pane.handle_tab_drop(&dragged_tab, 1, window, cx);\n        });\n\n        // A should be after B and all are pinned\n        assert_item_labels(&pane_a, [": "",
        "], cx);\n\n        // Move A to right of C\n        pane_a.update_in(cx, |pane, window, cx| {\n            let dragged_tab = DraggedTab {\n                pane: pane_a.clone(),\n                item: item_a.boxed_clone(),\n                ix: 1,\n                detail: 0,\n                is_active: true,\n            };\n            pane.handle_tab_drop(&dragged_tab, 2, window, cx);\n        });\n\n        // A should be after C and all are pinned\n        assert_item_labels(&pane_a, [": "",
        "], cx);\n\n        // Move A to left of C\n        pane_a.update_in(cx, |pane, window, cx| {\n            let dragged_tab = DraggedTab {\n                pane: pane_a.clone(),\n                item: item_a.boxed_clone(),\n                ix: 2,\n                detail: 0,\n                is_active: true,\n            };\n            pane.handle_tab_drop(&dragged_tab, 1, window, cx);\n        });\n\n        // A should be before C and all are pinned\n        assert_item_labels(&pane_a, [": "",
        "], cx);\n\n        // Move A to left of B\n        pane_a.update_in(cx, |pane, window, cx| {\n            let dragged_tab = DraggedTab {\n                pane: pane_a.clone(),\n                item: item_a.boxed_clone(),\n                ix: 1,\n                detail: 0,\n                is_active: true,\n            };\n            pane.handle_tab_drop(&dragged_tab, 0, window, cx);\n        });\n\n        // A should be before B and all are pinned\n        assert_item_labels(&pane_a, [": "",
        "], cx);\n    }\n\n    #[gpui::test]\n    async fn test_drag_first_tab_to_last_position(cx: &mut TestAppContext) {\n        init_test(cx);\n        let fs = FakeFs::new(cx.executor());\n\n        let project = Project::test(fs, None, cx).await;\n        let (workspace, cx) =\n            cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n        let pane_a = workspace.read_with(cx, |workspace, _| workspace.active_pane().clone());\n\n        // Add A, B, C\n        let item_a = add_labeled_item(&pane_a, ": "",
        "], cx);\n\n        // Move A to the end\n        pane_a.update_in(cx, |pane, window, cx| {\n            let dragged_tab = DraggedTab {\n                pane: pane_a.clone(),\n                item: item_a.boxed_clone(),\n                ix: 0,\n                detail: 0,\n                is_active: true,\n            };\n            pane.handle_tab_drop(&dragged_tab, 2, window, cx);\n        });\n\n        // A should be at the end\n        assert_item_labels(&pane_a, [": "",
        "], cx);\n    }\n\n    #[gpui::test]\n    async fn test_drag_last_tab_to_first_position(cx: &mut TestAppContext) {\n        init_test(cx);\n        let fs = FakeFs::new(cx.executor());\n\n        let project = Project::test(fs, None, cx).await;\n        let (workspace, cx) =\n            cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n        let pane_a = workspace.read_with(cx, |workspace, _| workspace.active_pane().clone());\n\n        // Add A, B, C\n        add_labeled_item(&pane_a, ": "",
        "], cx);\n\n        // Move C to the beginning\n        pane_a.update_in(cx, |pane, window, cx| {\n            let dragged_tab = DraggedTab {\n                pane: pane_a.clone(),\n                item: item_c.boxed_clone(),\n                ix: 2,\n                detail: 0,\n                is_active: true,\n            };\n            pane.handle_tab_drop(&dragged_tab, 0, window, cx);\n        });\n\n        // C should be at the beginning\n        assert_item_labels(&pane_a, [": "",
        "], cx);\n    }\n\n    #[gpui::test]\n    async fn test_add_item_with_new_item(cx: &mut TestAppContext) {\n        init_test(cx);\n        let fs = FakeFs::new(cx.executor());\n\n        let project = Project::test(fs, None, cx).await;\n        let (workspace, cx) =\n            cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n        let pane = workspace.read_with(cx, |workspace, _| workspace.active_pane().clone());\n\n        // 1. Add with a destination index\n        //   a. Add before the active item\n        set_labeled_items(&pane, [": "",
        "], cx);\n        pane.update_in(cx, |pane, window, cx| {\n            pane.add_item(\n                Box::new(cx.new(|cx| TestItem::new(cx).with_label(": "",
        "))),\n                false,\n                false,\n                Some(0),\n                window,\n                cx,\n            );\n        });\n        assert_item_labels(&pane, [": "",
        "], cx);\n\n        //   b. Add after the active item\n        set_labeled_items(&pane, [": "",
        "))),\n                false,\n                false,\n                Some(2),\n                window,\n                cx,\n            );\n        });\n        assert_item_labels(&pane, [": "",
        "], cx);\n\n        //   c. Add at the end of the item list (including off the length)\n        set_labeled_items(&pane, [": "",
        "))),\n                false,\n                false,\n                Some(5),\n                window,\n                cx,\n            );\n        });\n        assert_item_labels(&pane, [": "",
        "], cx);\n\n        // 2. Add without a destination index\n        //   a. Add with active item at the start of the item list\n        set_labeled_items(&pane, [": "",
        "))),\n                false,\n                false,\n                None,\n                window,\n                cx,\n            );\n        });\n        set_labeled_items(&pane, [": "",
        "], cx);\n\n        //   b. Add with active item at the end of the item list\n        set_labeled_items(&pane, [": "",
        "))),\n                false,\n                false,\n                None,\n                window,\n                cx,\n            );\n        });\n        assert_item_labels(&pane, [": "",
        "], cx);\n    }\n\n    #[gpui::test]\n    async fn test_add_item_with_existing_item(cx: &mut TestAppContext) {\n        init_test(cx);\n        let fs = FakeFs::new(cx.executor());\n\n        let project = Project::test(fs, None, cx).await;\n        let (workspace, cx) =\n            cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n        let pane = workspace.read_with(cx, |workspace, _| workspace.active_pane().clone());\n\n        // 1. Add with a destination index\n        //   1a. Add before the active item\n        let [_, _, _, d] = set_labeled_items(&pane, [": "",
        "], cx);\n        pane.update_in(cx, |pane, window, cx| {\n            pane.add_item(d, false, false, Some(0), window, cx);\n        });\n        assert_item_labels(&pane, [": "",
        "], cx);\n\n        //   1b. Add after the active item\n        let [_, _, _, d] = set_labeled_items(&pane, [": "",
        "], cx);\n        pane.update_in(cx, |pane, window, cx| {\n            pane.add_item(d, false, false, Some(2), window, cx);\n        });\n        assert_item_labels(&pane, [": "",
        "], cx);\n\n        //   1c. Add at the end of the item list (including off the length)\n        let [a, _, _, _] = set_labeled_items(&pane, [": "",
        "], cx);\n        pane.update_in(cx, |pane, window, cx| {\n            pane.add_item(a, false, false, Some(5), window, cx);\n        });\n        assert_item_labels(&pane, [": "",
        "], cx);\n\n        //   1d. Add same item to active index\n        let [_, b, _] = set_labeled_items(&pane, [": "",
        "], cx);\n        pane.update_in(cx, |pane, window, cx| {\n            pane.add_item(b, false, false, Some(1), window, cx);\n        });\n        assert_item_labels(&pane, [": "",
        "], cx);\n\n        //   1e. Add item to index after same item in last position\n        let [_, _, c] = set_labeled_items(&pane, [": "",
        "], cx);\n        pane.update_in(cx, |pane, window, cx| {\n            pane.add_item(c, false, false, Some(2), window, cx);\n        });\n        assert_item_labels(&pane, [": "",
        "], cx);\n\n        // 2. Add without a destination index\n        //   2a. Add with active item at the start of the item list\n        let [_, _, _, d] = set_labeled_items(&pane, [": "",
        "], cx);\n        pane.update_in(cx, |pane, window, cx| {\n            pane.add_item(d, false, false, None, window, cx);\n        });\n        assert_item_labels(&pane, [": "",
        "], cx);\n\n        //   2b. Add with active item at the end of the item list\n        let [a, _, _, _] = set_labeled_items(&pane, [": "",
        "], cx);\n        pane.update_in(cx, |pane, window, cx| {\n            pane.add_item(a, false, false, None, window, cx);\n        });\n        assert_item_labels(&pane, [": "",
        "], cx);\n\n        //   2c. Add active item to active item at end of list\n        let [_, _, c] = set_labeled_items(&pane, [": "",
        "], cx);\n        pane.update_in(cx, |pane, window, cx| {\n            pane.add_item(c, false, false, None, window, cx);\n        });\n        assert_item_labels(&pane, [": "",
        "], cx);\n\n        //   2d. Add active item to active item at start of list\n        let [a, _, _] = set_labeled_items(&pane, [": "",
        "], cx);\n    }\n\n    #[gpui::test]\n    async fn test_add_item_with_same_project_entries(cx: &mut TestAppContext) {\n        init_test(cx);\n        let fs = FakeFs::new(cx.executor());\n\n        let project = Project::test(fs, None, cx).await;\n        let (workspace, cx) =\n            cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n        let pane = workspace.read_with(cx, |workspace, _| workspace.active_pane().clone());\n\n        // singleton view\n        pane.update_in(cx, |pane, window, cx| {\n            pane.add_item(\n                Box::new(cx.new(|cx| {\n                    TestItem::new(cx)\n                        .with_buffer_kind(ItemBufferKind::Singleton)\n                        .with_label(": "",
        ")\n                        .with_project_items(&[TestProjectItem::new(1, ": "",
        ", cx)])\n                })),\n                false,\n                false,\n                None,\n                window,\n                cx,\n            );\n        });\n        assert_item_labels(&pane, [": "",
        "], cx);\n\n        // new singleton view with the same project entry\n        pane.update_in(cx, |pane, window, cx| {\n            pane.add_item(\n                Box::new(cx.new(|cx| {\n                    TestItem::new(cx)\n                        .with_buffer_kind(ItemBufferKind::Singleton)\n                        .with_label(": "",
        "], cx);\n\n        // new singleton view with different project entry\n        pane.update_in(cx, |pane, window, cx| {\n            pane.add_item(\n                Box::new(cx.new(|cx| {\n                    TestItem::new(cx)\n                        .with_buffer_kind(ItemBufferKind::Singleton)\n                        .with_label(": "",
        ")\n                        .with_project_items(&[TestProjectItem::new(2, ": "",
        "], cx);\n\n        // new multibuffer view with the same project entry\n        pane.update_in(cx, |pane, window, cx| {\n            pane.add_item(\n                Box::new(cx.new(|cx| {\n                    TestItem::new(cx)\n                        .with_buffer_kind(ItemBufferKind::Multibuffer)\n                        .with_label(": "",
        "], cx);\n\n        // another multibuffer view with the same project entry\n        pane.update_in(cx, |pane, window, cx| {\n            pane.add_item(\n                Box::new(cx.new(|cx| {\n                    TestItem::new(cx)\n                        .with_buffer_kind(ItemBufferKind::Multibuffer)\n                        .with_label(": "",
        ", cx)])\n                })),\n                false,\n                false,\n                None,\n                window,\n                cx,\n            );\n        });\n        assert_item_labels(\n            &pane,\n            [": "",
        "],\n            cx,\n        );\n    }\n\n    #[gpui::test]\n    async fn test_remove_item_ordering_history(cx: &mut TestAppContext) {\n        init_test(cx);\n        let fs = FakeFs::new(cx.executor());\n\n        let project = Project::test(fs, None, cx).await;\n        let (workspace, cx) =\n            cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n        let pane = workspace.read_with(cx, |workspace, _| workspace.active_pane().clone());\n\n        add_labeled_item(&pane, ": "",
        "], cx);\n\n        pane.update_in(cx, |pane, window, cx| {\n            pane.activate_item(1, false, false, window, cx)\n        });\n        add_labeled_item(&pane, ": "",
        "], cx);\n\n        pane.update_in(cx, |pane, window, cx| {\n            pane.close_active_item(\n                &CloseActiveItem {\n                    save_intent: None,\n                    close_pinned: false,\n                },\n                window,\n                cx,\n            )\n        })\n        .await\n        .unwrap();\n        assert_item_labels(&pane, [": "",
        "], cx);\n\n        pane.update_in(cx, |pane, window, cx| {\n            pane.activate_item(3, false, false, window, cx)\n        });\n        assert_item_labels(&pane, [": "",
        "], cx);\n    }\n\n    #[gpui::test]\n    async fn test_remove_item_ordering_neighbour(cx: &mut TestAppContext) {\n        init_test(cx);\n        cx.update_global::<SettingsStore, ()>(|s, cx| {\n            s.update_user_settings(cx, |s| {\n                s.tabs.get_or_insert_default().activate_on_close = Some(ActivateOnClose::Neighbour);\n            });\n        });\n        let fs = FakeFs::new(cx.executor());\n\n        let project = Project::test(fs, None, cx).await;\n        let (workspace, cx) =\n            cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n        let pane = workspace.read_with(cx, |workspace, _| workspace.active_pane().clone());\n\n        add_labeled_item(&pane, ": "",
        "], cx);\n    }\n\n    #[gpui::test]\n    async fn test_remove_item_ordering_left_neighbour(cx: &mut TestAppContext) {\n        init_test(cx);\n        cx.update_global::<SettingsStore, ()>(|s, cx| {\n            s.update_user_settings(cx, |s| {\n                s.tabs.get_or_insert_default().activate_on_close =\n                    Some(ActivateOnClose::LeftNeighbour);\n            });\n        });\n        let fs = FakeFs::new(cx.executor());\n\n        let project = Project::test(fs, None, cx).await;\n        let (workspace, cx) =\n            cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n        let pane = workspace.read_with(cx, |workspace, _| workspace.active_pane().clone());\n\n        add_labeled_item(&pane, ": "",
        "], cx);\n\n        pane.update_in(cx, |pane, window, cx| {\n            pane.activate_item(0, false, false, window, cx)\n        });\n        assert_item_labels(&pane, [": "",
        "], cx);\n    }\n\n    #[gpui::test]\n    async fn test_close_inactive_items(cx: &mut TestAppContext) {\n        init_test(cx);\n        let fs = FakeFs::new(cx.executor());\n\n        let project = Project::test(fs, None, cx).await;\n        let (workspace, cx) =\n            cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n        let pane = workspace.read_with(cx, |workspace, _| workspace.active_pane().clone());\n\n        let item_a = add_labeled_item(&pane, ": "",
        ", false, cx);\n        pane.update_in(cx, |pane, window, cx| {\n            let ix = pane.index_for_item_id(item_a.item_id()).unwrap();\n            pane.pin_tab_at(ix, window, cx);\n        });\n        assert_item_labels(&pane, [": "",
        ", false, cx);\n        pane.update_in(cx, |pane, window, cx| {\n            let ix = pane.index_for_item_id(item_b.item_id()).unwrap();\n            pane.pin_tab_at(ix, window, cx);\n        });\n        assert_item_labels(&pane, [": "",
        "], cx);\n\n        pane.update_in(cx, |pane, window, cx| {\n            pane.close_other_items(\n                &CloseOtherItems {\n                    save_intent: None,\n                    close_pinned: false,\n                },\n                None,\n                window,\n                cx,\n            )\n        })\n        .await\n        .unwrap();\n        assert_item_labels(&pane, [": "",
        "], cx);\n    }\n\n    #[gpui::test]\n    async fn test_running_close_inactive_items_via_an_inactive_item(cx: &mut TestAppContext) {\n        init_test(cx);\n        let fs = FakeFs::new(cx.executor());\n\n        let project = Project::test(fs, None, cx).await;\n        let (workspace, cx) =\n            cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n        let pane = workspace.read_with(cx, |workspace, _| workspace.active_pane().clone());\n\n        add_labeled_item(&pane, ": "",
        "], cx);\n\n        pane.update_in(cx, |pane, window, cx| {\n            pane.close_other_items(\n                &CloseOtherItems {\n                    save_intent: None,\n                    close_pinned: false,\n                },\n                Some(item_b.item_id()),\n                window,\n                cx,\n            )\n        })\n        .await\n        .unwrap();\n        assert_item_labels(&pane, [": "",
        "], cx);\n    }\n\n    #[gpui::test]\n    async fn test_close_clean_items(cx: &mut TestAppContext) {\n        init_test(cx);\n        let fs = FakeFs::new(cx.executor());\n\n        let project = Project::test(fs, None, cx).await;\n        let (workspace, cx) =\n            cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n        let pane = workspace.read_with(cx, |workspace, _| workspace.active_pane().clone());\n\n        add_labeled_item(&pane, ": "",
        ", true, cx);\n        add_labeled_item(&pane, ": "",
        "], cx);\n\n        pane.update_in(cx, |pane, window, cx| {\n            pane.close_clean_items(\n                &CloseCleanItems {\n                    close_pinned: false,\n                },\n                window,\n                cx,\n            )\n        })\n        .await\n        .unwrap();\n        assert_item_labels(&pane, [": "",
        "], cx);\n    }\n\n    #[gpui::test]\n    async fn test_close_items_to_the_left(cx: &mut TestAppContext) {\n        init_test(cx);\n        let fs = FakeFs::new(cx.executor());\n\n        let project = Project::test(fs, None, cx).await;\n        let (workspace, cx) =\n            cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n        let pane = workspace.read_with(cx, |workspace, _| workspace.active_pane().clone());\n\n        set_labeled_items(&pane, [": "",
        "], cx);\n\n        pane.update_in(cx, |pane, window, cx| {\n            pane.close_items_to_the_left_by_id(\n                None,\n                &CloseItemsToTheLeft {\n                    close_pinned: false,\n                },\n                window,\n                cx,\n            )\n        })\n        .await\n        .unwrap();\n        assert_item_labels(&pane, [": "",
        "], cx);\n    }\n\n    #[gpui::test]\n    async fn test_close_items_to_the_right(cx: &mut TestAppContext) {\n        init_test(cx);\n        let fs = FakeFs::new(cx.executor());\n\n        let project = Project::test(fs, None, cx).await;\n        let (workspace, cx) =\n            cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n        let pane = workspace.read_with(cx, |workspace, _| workspace.active_pane().clone());\n\n        set_labeled_items(&pane, [": "",
        "], cx);\n\n        pane.update_in(cx, |pane, window, cx| {\n            pane.close_items_to_the_right_by_id(\n                None,\n                &CloseItemsToTheRight {\n                    close_pinned: false,\n                },\n                window,\n                cx,\n            )\n        })\n        .await\n        .unwrap();\n        assert_item_labels(&pane, [": "",
        "], cx);\n    }\n\n    #[gpui::test]\n    async fn test_close_all_items(cx: &mut TestAppContext) {\n        init_test(cx);\n        let fs = FakeFs::new(cx.executor());\n\n        let project = Project::test(fs, None, cx).await;\n        let (workspace, cx) =\n            cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n        let pane = workspace.read_with(cx, |workspace, _| workspace.active_pane().clone());\n\n        let item_a = add_labeled_item(&pane, ": "",
        "], cx);\n\n        pane.update_in(cx, |pane, window, cx| {\n            let ix = pane.index_for_item_id(item_a.item_id()).unwrap();\n            pane.pin_tab_at(ix, window, cx);\n            pane.close_all_items(\n                &CloseAllItems {\n                    save_intent: None,\n                    close_pinned: false,\n                },\n                window,\n                cx,\n            )\n        })\n        .await\n        .unwrap();\n        assert_item_labels(&pane, [": "",
        "], cx);\n\n        pane.update_in(cx, |pane, window, cx| {\n            let ix = pane.index_for_item_id(item_a.item_id()).unwrap();\n            pane.unpin_tab_at(ix, window, cx);\n            pane.close_all_items(\n                &CloseAllItems {\n                    save_intent: None,\n                    close_pinned: false,\n                },\n                window,\n                cx,\n            )\n        })\n        .await\n        .unwrap();\n\n        assert_item_labels(&pane, [], cx);\n\n        add_labeled_item(&pane, ": "",
        ", true, cx).update(cx, |item, cx| {\n            item.project_items\n                .push(TestProjectItem::new_dirty(1, ": "",
        ", cx))\n        });\n        add_labeled_item(&pane, ": "",
        ", true, cx).update(cx, |item, cx| {\n            item.project_items\n                .push(TestProjectItem::new_dirty(2, ": "",
        ", true, cx).update(cx, |item, cx| {\n            item.project_items\n                .push(TestProjectItem::new_dirty(3, ": "",
        ", cx))\n        });\n        assert_item_labels(&pane, [": "",
        "], cx);\n\n        let save = pane.update_in(cx, |pane, window, cx| {\n            pane.close_all_items(\n                &CloseAllItems {\n                    save_intent: None,\n                    close_pinned: false,\n                },\n                window,\n                cx,\n            )\n        });\n\n        cx.executor().run_until_parked();\n        cx.simulate_prompt_answer(": "",
        ");\n        save.await.unwrap();\n        assert_item_labels(&pane, [], cx);\n\n        add_labeled_item(&pane, ": "",
        "], cx);\n        let save = pane.update_in(cx, |pane, window, cx| {\n            pane.close_all_items(\n                &CloseAllItems {\n                    save_intent: None,\n                    close_pinned: false,\n                },\n                window,\n                cx,\n            )\n        });\n\n        cx.executor().run_until_parked();\n        cx.simulate_prompt_answer(": "",
        ");\n        save.await.unwrap();\n        assert_item_labels(&pane, [], cx);\n    }\n\n    #[gpui::test]\n    async fn test_close_multibuffer_items(cx: &mut TestAppContext) {\n        init_test(cx);\n        let fs = FakeFs::new(cx.executor());\n\n        let project = Project::test(fs, None, cx).await;\n        let (workspace, cx) =\n            cx.add_window_view(|window, cx| Workspace::test_new(project.clone(), window, cx));\n        let pane = workspace.read_with(cx, |workspace, _| workspace.active_pane().clone());\n\n        let add_labeled_item = |pane: &Entity<Pane>,\n                                label,\n                                is_dirty,\n                                kind: ItemBufferKind,\n                                cx: &mut VisualTestContext| {\n            pane.update_in(cx, |pane, window, cx| {\n                let labeled_item = Box::new(cx.new(|cx| {\n                    TestItem::new(cx)\n                        .with_label(label)\n                        .with_dirty(is_dirty)\n                        .with_buffer_kind(kind)\n                }));\n                pane.add_item(labeled_item.clone(), false, false, None, window, cx);\n                labeled_item\n            })\n        };\n\n        let item_a = add_labeled_item(&pane, ": "",
        ", false, ItemBufferKind::Multibuffer, cx);\n        add_labeled_item(&pane, ": "",
        ", false, ItemBufferKind::Singleton, cx);\n        assert_item_labels(&pane, [": "",
        "], cx);\n\n        pane.update_in(cx, |pane, window, cx| {\n            let ix = pane.index_for_item_id(item_a.item_id()).unwrap();\n            pane.pin_tab_at(ix, window, cx);\n            pane.close_multibuffer_items(\n                &CloseMultibufferItems {\n                    save_intent: None,\n                    close_pinned: false,\n                },\n                window,\n                cx,\n            )\n        })\n        .await\n        .unwrap();\n        assert_item_labels(&pane, [": "",
        "], cx);\n\n        pane.update_in(cx, |pane, window, cx| {\n            let ix = pane.index_for_item_id(item_a.item_id()).unwrap();\n            pane.unpin_tab_at(ix, window, cx);\n            pane.close_multibuffer_items(\n                &CloseMultibufferItems {\n                    save_intent: None,\n                    close_pinned: false,\n                },\n                window,\n                cx,\n            )\n        })\n        .await\n        .unwrap();\n\n        assert_item_labels(&pane, [": "",
        ", true, ItemBufferKind::Singleton, cx).update(cx, |item, cx| {\n            item.project_items\n                .push(TestProjectItem::new_dirty(1, ": "",
        ", true, ItemBufferKind::Multibuffer, cx).update(\n            cx,\n            |item, cx| {\n                item.project_items\n                    .push(TestProjectItem::new_dirty(2, ": "",
        ", cx))\n            },\n        );\n        add_labeled_item(&pane, ": "",
        ", true, ItemBufferKind::Multibuffer, cx).update(\n            cx,\n            |item, cx| {\n                item.project_items\n                    .push(TestProjectItem::new_dirty(3, ": "",
        ", cx))\n            },\n        );\n        assert_item_labels(&pane, [": "",
        "], cx);\n\n        let save = pane.update_in(cx, |pane, window, cx| {\n            pane.close_multibuffer_items(\n                &CloseMultibufferItems {\n                    save_intent: None,\n                    close_pinned: false,\n                },\n                window,\n                cx,\n            )\n        });\n\n        cx.executor().run_until_parked();\n        cx.simulate_prompt_answer(": "",
        ");\n        save.await.unwrap();\n        assert_item_labels(&pane, [": "",
        "], cx);\n        let save = pane.update_in(cx, |pane, window, cx| {\n            pane.close_multibuffer_items(\n                &CloseMultibufferItems {\n                    save_intent: None,\n                    close_pinned: false,\n                },\n                window,\n                cx,\n            )\n        });\n\n        cx.executor().run_until_parked();\n        cx.simulate_prompt_answer(": "",
        "], cx);\n    }\n\n    #[gpui::test]\n    async fn test_close_with_save_intent(cx: &mut TestAppContext) {\n        init_test(cx);\n        let fs = FakeFs::new(cx.executor());\n\n        let project = Project::test(fs, None, cx).await;\n        let (workspace, cx) =\n            cx.add_window_view(|window, cx| Workspace::test_new(project, window, cx));\n        let pane = workspace.read_with(cx, |workspace, _| workspace.active_pane().clone());\n\n        let a = cx.update(|_, cx| TestProjectItem::new_dirty(1, ": "",
        ", cx));\n        let b = cx.update(|_, cx| TestProjectItem::new_dirty(1, ": "",
        ", cx));\n        let c = cx.update(|_, cx| TestProjectItem::new_dirty(1, ": "",
        ", cx));\n\n        add_labeled_item(&pane, ": "",
        ", true, cx).update(cx, |item, _| {\n            item.project_items.push(a.clone());\n            item.project_items.push(b.clone());\n        });\n        add_labeled_item(&pane, ": "",
        ", true, cx)\n            .update(cx, |item, _| item.project_items.push(c.clone()));\n        assert_item_labels(&pane, [": "",
        "], cx);\n\n        pane.update_in(cx, |pane, window, cx| {\n            pane.close_all_items(\n                &CloseAllItems {\n                    save_intent: Some(SaveIntent::Save),\n                    close_pinned: false,\n                },\n                window,\n                cx,\n            )\n        })\n        .await\n        .unwrap();\n\n        assert_item_labels(&pane, [], cx);\n        cx.update(|_, cx| {\n            assert!(!a.read(cx).is_dirty);\n            assert!(!b.read(cx).is_dirty);\n            assert!(!c.read(cx).is_dirty);\n        });\n    }\n\n    #[gpui::test]\n    async fn test_new_tab_scrolls_into_view_completely(cx: &mut TestAppContext) {\n        // Arrange\n        init_test(cx);\n        let fs = FakeFs::new(cx.executor());\n\n        let project = Project::test(fs, None, cx).await;\n        let (workspace, cx) =\n            cx.add_window_view(|window, cx| Workspace::test_new(project, window, cx));\n        let pane = workspace.read_with(cx, |workspace, _| workspace.active_pane().clone());\n\n        cx.simulate_resize(size(px(300.), px(300.)));\n\n        add_labeled_item(&pane, ": "",
        ", false, cx);\n        // Act: this should trigger a scroll\n        add_labeled_item(&pane, ": "",
        ", false, cx);\n        // Assert\n        let tab_bar_scroll_handle =\n            pane.update_in(cx, |pane, _window, _cx| pane.tab_bar_scroll_handle.clone());\n        assert_eq!(tab_bar_scroll_handle.children_count(), 6);\n        let tab_bounds = cx.debug_bounds(": "",
        ").unwrap();\n        let new_tab_button_bounds = cx.debug_bounds(": "",
        ").unwrap();\n        let scroll_bounds = tab_bar_scroll_handle.bounds();\n        let scroll_offset = tab_bar_scroll_handle.offset();\n        assert!(tab_bounds.right() <= scroll_bounds.right() + scroll_offset.x);\n        // -39.5 is the magic number for this setup\n        assert_eq!(scroll_offset.x, px(-39.5));\n        assert!(\n            !tab_bounds.intersects(&new_tab_button_bounds),\n            ": "",
        "\n        );\n    }\n\n    #[gpui::test]\n    async fn test_close_all_items_including_pinned(cx: &mut TestAppContext) {\n        init_test(cx);\n        let fs = FakeFs::new(cx.executor());\n\n        let project = Project::test(fs, None, cx).await;\n        let (workspace, cx) =\n            cx.add_window_view(|window, cx| Workspace::test_new(project, window, cx));\n        let pane = workspace.read_with(cx, |workspace, _| workspace.active_pane().clone());\n\n        let item_a = add_labeled_item(&pane, ": "",
        "], cx);\n\n        pane.update_in(cx, |pane, window, cx| {\n            let ix = pane.index_for_item_id(item_a.item_id()).unwrap();\n            pane.pin_tab_at(ix, window, cx);\n            pane.close_all_items(\n                &CloseAllItems {\n                    save_intent: None,\n                    close_pinned: true,\n                },\n                window,\n                cx,\n            )\n        })\n        .await\n        .unwrap();\n        assert_item_labels(&pane, [], cx);\n    }\n\n    #[gpui::test]\n    async fn test_close_pinned_tab_with_non_pinned_in_same_pane(cx: &mut TestAppContext) {\n        init_test(cx);\n        let fs = FakeFs::new(cx.executor());\n        let project = Project::test(fs, None, cx).await;\n        let (workspace, cx) =\n            cx.add_window_view(|window, cx| Workspace::test_new(project, window, cx));\n\n        // Non-pinned tabs in same pane\n        let pane = workspace.read_with(cx, |workspace, _| workspace.active_pane().clone());\n        add_labeled_item(&pane, ": "",
        ", false, cx);\n        pane.update_in(cx, |pane, window, cx| {\n            pane.pin_tab_at(0, window, cx);\n        });\n        set_labeled_items(&pane, [": "",
        "], cx);\n        pane.update_in(cx, |pane, window, cx| {\n            pane.close_active_item(\n                &CloseActiveItem {\n                    save_intent: None,\n                    close_pinned: false,\n                },\n                window,\n                cx,\n            )\n            .unwrap();\n        });\n        // Non-pinned tab should be active\n        assert_item_labels(&pane, [": "",
        "], cx);\n    }\n\n    #[gpui::test]\n    async fn test_close_pinned_tab_with_non_pinned_in_different_pane(cx: &mut TestAppContext) {\n        init_test(cx);\n        let fs = FakeFs::new(cx.executor());\n        let project = Project::test(fs, None, cx).await;\n        let (workspace, cx) =\n            cx.add_window_view(|window, cx| Workspace::test_new(project, window, cx));\n\n        // No non-pinned tabs in same pane, non-pinned tabs in another pane\n        let pane1 = workspace.read_with(cx, |workspace, _| workspace.active_pane().clone());\n        let pane2 = workspace.update_in(cx, |workspace, window, cx| {\n            workspace.split_pane(pane1.clone(), SplitDirection::Right, window, cx)\n        });\n        add_labeled_item(&pane1, ": "",
        ", false, cx);\n        pane1.update_in(cx, |pane, window, cx| {\n            pane.pin_tab_at(0, window, cx);\n        });\n        set_labeled_items(&pane1, [": "",
        "], cx);\n        add_labeled_item(&pane2, ": "",
        ", false, cx);\n        set_labeled_items(&pane2, [": "",
        "], cx);\n        pane1.update_in(cx, |pane, window, cx| {\n            pane.close_active_item(\n                &CloseActiveItem {\n                    save_intent: None,\n                    close_pinned: false,\n                },\n                window,\n                cx,\n            )\n            .unwrap();\n        });\n        //  Non-pinned tab of other pane should be active\n        assert_item_labels(&pane2, [": "",
        "], cx);\n    }\n\n    #[gpui::test]\n    async fn ensure_item_closing_actions_do_not_panic_when_no_items_exist(cx: &mut TestAppContext) {\n        init_test(cx);\n        let fs = FakeFs::new(cx.executor());\n        let project = Project::test(fs, None, cx).await;\n        let (workspace, cx) =\n            cx.add_window_view(|window, cx| Workspace::test_new(project, window, cx));\n\n        let pane = workspace.read_with(cx, |workspace, _| workspace.active_pane().clone());\n        assert_item_labels(&pane, [], cx);\n\n        pane.update_in(cx, |pane, window, cx| {\n            pane.close_active_item(\n                &CloseActiveItem {\n                    save_intent: None,\n                    close_pinned: false,\n                },\n                window,\n                cx,\n            )\n        })\n        .await\n        .unwrap();\n\n        pane.update_in(cx, |pane, window, cx| {\n            pane.close_other_items(\n                &CloseOtherItems {\n                    save_intent: None,\n                    close_pinned: false,\n                },\n                None,\n                window,\n                cx,\n            )\n        })\n        .await\n        .unwrap();\n\n        pane.update_in(cx, |pane, window, cx| {\n            pane.close_all_items(\n                &CloseAllItems {\n                    save_intent: None,\n                    close_pinned: false,\n                },\n                window,\n                cx,\n            )\n        })\n        .await\n        .unwrap();\n\n        pane.update_in(cx, |pane, window, cx| {\n            pane.close_clean_items(\n                &CloseCleanItems {\n                    close_pinned: false,\n                },\n                window,\n                cx,\n            )\n        })\n        .await\n        .unwrap();\n\n        pane.update_in(cx, |pane, window, cx| {\n            pane.close_items_to_the_right_by_id(\n                None,\n                &CloseItemsToTheRight {\n                    close_pinned: false,\n                },\n                window,\n                cx,\n            )\n        })\n        .await\n        .unwrap();\n\n        pane.update_in(cx, |pane, window, cx| {\n            pane.close_items_to_the_left_by_id(\n                None,\n                &CloseItemsToTheLeft {\n                    close_pinned: false,\n                },\n                window,\n                cx,\n            )\n        })\n        .await\n        .unwrap();\n    }\n\n    #[gpui::test]\n    async fn test_item_swapping_actions(cx: &mut TestAppContext) {\n        init_test(cx);\n        let fs = FakeFs::new(cx.executor());\n        let project = Project::test(fs, None, cx).await;\n        let (workspace, cx) =\n            cx.add_window_view(|window, cx| Workspace::test_new(project, window, cx));\n\n        let pane = workspace.read_with(cx, |workspace, _| workspace.active_pane().clone());\n        assert_item_labels(&pane, [], cx);\n\n        // Test that these actions do not panic\n        pane.update_in(cx, |pane, window, cx| {\n            pane.swap_item_right(&Default::default(), window, cx);\n        });\n\n        pane.update_in(cx, |pane, window, cx| {\n            pane.swap_item_left(&Default::default(), window, cx);\n        });\n\n        add_labeled_item(&pane, ": "",
        "], cx);\n\n        pane.update_in(cx, |pane, window, cx| {\n            pane.swap_item_right(&Default::default(), window, cx);\n        });\n        assert_item_labels(&pane, [": "",
        "], cx);\n\n        pane.update_in(cx, |pane, window, cx| {\n            pane.swap_item_left(&Default::default(), window, cx);\n        });\n        assert_item_labels(&pane, [": "",
        "], cx);\n    }\n\n    fn init_test(cx: &mut TestAppContext) {\n        cx.update(|cx| {\n            let settings_store = SettingsStore::test(cx);\n            cx.set_global(settings_store);\n            theme::init(LoadThemes::JustBase, cx);\n        });\n    }\n\n    fn set_max_tabs(cx: &mut TestAppContext, value: Option<usize>) {\n        cx.update_global(|store: &mut SettingsStore, cx| {\n            store.update_user_settings(cx, |settings| {\n                settings.workspace.max_tabs = value.map(|v| NonZero::new(v).unwrap())\n            });\n        });\n    }\n\n    fn add_labeled_item(\n        pane: &Entity<Pane>,\n        label: &str,\n        is_dirty: bool,\n        cx: &mut VisualTestContext,\n    ) -> Box<Entity<TestItem>> {\n        pane.update_in(cx, |pane, window, cx| {\n            let labeled_item =\n                Box::new(cx.new(|cx| TestItem::new(cx).with_label(label).with_dirty(is_dirty)));\n            pane.add_item(labeled_item.clone(), false, false, None, window, cx);\n            labeled_item\n        })\n    }\n\n    fn set_labeled_items<const COUNT: usize>(\n        pane: &Entity<Pane>,\n        labels: [&str; COUNT],\n        cx: &mut VisualTestContext,\n    ) -> [Box<Entity<TestItem>>; COUNT] {\n        pane.update_in(cx, |pane, window, cx| {\n            pane.items.clear();\n            let mut active_item_index = 0;\n\n            let mut index = 0;\n            let items = labels.map(|mut label| {\n                if label.ends_with('*') {\n                    label = label.trim_end_matches('*');\n                    active_item_index = index;\n                }\n\n                let labeled_item = Box::new(cx.new(|cx| TestItem::new(cx).with_label(label)));\n                pane.add_item(labeled_item.clone(), false, false, None, window, cx);\n                index += 1;\n                labeled_item\n            });\n\n            pane.activate_item(active_item_index, false, false, window, cx);\n\n            items\n        })\n    }\n\n    // Assert the item label, with the active item label suffixed with a '*'\n    #[track_caller]\n    fn assert_item_labels<const COUNT: usize>(\n        pane: &Entity<Pane>,\n        expected_states: [&str; COUNT],\n        cx: &mut VisualTestContext,\n    ) {\n        let actual_states = pane.update(cx, |pane, cx| {\n            pane.items\n                .iter()\n                .enumerate()\n                .map(|(ix, item)| {\n                    let mut state = item\n                        .to_any()\n                        .downcast::<TestItem>()\n                        .unwrap()\n                        .read(cx)\n                        .label\n                        .clone();\n                    if ix == pane.active_item_index {\n                        state.push('*');\n                    }\n                    if item.is_dirty(cx) {\n                        state.push('^');\n                    }\n                    if pane.is_tab_pinned(ix) {\n                        state.push('!');\n                    }\n                    state\n                })\n                .collect::<Vec<_>>()\n        });\n        assert_eq!(\n            actual_states, expected_states,\n            ": ""
    },
    "zed/crates/workspace/src/persistence.rs": {
        "Horizontal": "",
        "Vertical": "",
        "Stored serialized item kind is incorrect": "",
        "Windowed": "",
        "Maximized": "",
        "FullScreen": "",
        "Fixed": "",
        "Window State did not have a valid string": "",
        "Invalid BreakpointState discriminant {state}": "",
        "Failed to read BreakPoint at index {start_index}": "",
        "' AND substr(paths, -2, 2) = '": "",
        "' || ',' || '": "",
        "ssh": "",
        "CREATE TABLE ssh_connections": "",
        "No workspaces found": "",
        "Getting center group": "",
        "Breakpoints are empty after querying database for them": "",
        "Got {} breakpoints from database at path: {}": "",
        "Breakpoints query failed with msg: {msg}": "",
        "Saving workspace at location: {:?}": "",
        "update_worktrees": "",
        "Clearing old panes": "",
        "Clearing old breakpoints": "",
        "Stored breakpoint at row: {} in path: {}": "",
        "{err}": "",
        "Clearing old user toolchains": "",
        "clearing out old locations": "",
        "Updating workspace": "",
        "save pane group in save workspace": "",
        "failed to insert remote project": "",
        "no such remote connection": "",
        "invalid remote_connection row": "",
        "Pane Group Child was neither a pane group or a pane": "",
        "Saving a pane group for workspace {workspace_id:?}": "",
        "Couldn't retrieve group_id from inserted pane_group": "",
        "Could not retrieve inserted pane_id": "",
        "Saving items": "",
        "Preparing insertion": "",
        "select toolchain": "",
        "select toolchains": "",
        "Setting toolchain for workspace, worktree: {worktree_id:?}, relative path: {relative_worktree_path:?}, toolchain: {}": "",
        ", ": "",
        "DELETE FROM {table} WHERE workspace_id = ? AND item_id NOT IN ({placeholders})": "",
        "test_breakpoints": "",
        "Test log message": "",
        "x > 5": "",
        ">= 3": "",
        "/tmp": "",
        "test_remove_last_breakpoint": "",
        "test_next_id_stability": "",
        "test_table": "",
        "test-text-1": "",
        "test_workspace_id_stability": "",
        "/tmp2": "",
        "test-text-2": "",
        "/tmp3": "",
        "test_full_workspace_serialization": "",
        "Terminal": "",
        "test_basic_functionality": "",
        "/tmp4": "",
        "tmp": "",
        "test_serializing_workspaces_session_id": "",
        "/tmp1": "",
        "session-id-1": "",
        "session-id-2": "",
        "my-host": "",
        "/tmp6c": "",
        "/tmp6b": "",
        "/tmp6a": "",
        "session-id-3": "",
        "dir1": "",
        "dir2": "",
        "dir3": "",
        "dir4": "",
        "test_serializing_workspaces_last_session_workspaces": "",
        "one-session": "",
        "test_serializing_workspaces_last_session_workspaces_remote": "",
        "host-1": "",
        "my-user-1": "",
        "host-2": "",
        "my-user-2": "",
        "host-3": "",
        "my-user-3": "",
        "host-4": "",
        "my-user-4": "",
        "test_get_or_create_ssh_project": "",
        "example.com": "",
        "user": "",
        "otherexample.com": "",
        "otheruser": "",
        "test_get_or_create_ssh_project_with_null_user": "",
        "test_get_remote_connections": "",
        "anotherexample.com": "",
        "user2": "",
        "yetanother.com": "",
        "simple_split": "",
        "test_cleanup_panes": ""
    },
    "zed/crates/workspace/src/theme_preview.rs": {
        "Overview": "",
        "Typography": "",
        "{} Preview": "",
        "{} ({:.2})": "",
        "Text": "",
        "Headline Sizes": "",
        "XLarge Headline": "",
        "Large Headline": "",
        "Medium Headline": "",
        "Small Headline": "",
        "XSmall Headline": "",
        "Text Colors": "",
        "Default Text": "",
        "Accent Text": "",
        "Conflict Text": "",
        "Created Text": "",
        "Deleted Text": "",
        "Disabled Text": "",
        "Error Text": "",
        "Hidden Text": "",
        "Hint Text": "",
        "Ignored Text": "",
        "Info Text": "",
        "Modified Text": "",
        "Muted Text": "",
        "Placeholder Text": "",
        "Selected Text": "",
        "Success Text": "",
        "Warning Text": "",
        "Wrapping Text": "",
        "This is a longer piece of text that should wrap to multiple lines. It demonstrates how text behaves when it exceeds the width of its container.": "",
        "Colors": "",
        "{:?}-preview": "",
        "theme-preview-overview": "",
        "Theme Preview": "",
        "This view lets you preview a range of UI elements across a theme. Use it for testing out changes to the theme.": "",
        "theme-preview-typography": "",
        "Headline 1": "",
        "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.": "",
        "Headline 2": "",
        "Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.": "",
        "Headline 3": "",
        "Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.": "",
        "Headline 4": "",
        "Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.": "",
        "Headline 5": "",
        "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.": "",
        "Body Text": "",
        "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.": "",
        "theme-preview-nav": "",
        "theme-preview": "",
        "ThemePreview": ""
    },
    "zed/crates/workspace/src/workspace.rs": {
        "ZED_WINDOW_SIZE": "",
        "ZED_WINDOW_POSITION": "",
        "default_1": "",
        "default_true": "",
        "default_right": "",
        "Toggle": "",
        "Failed to read WorkspaceId at index {start_index}": "",
        "opening project path {:?}": "",
        "cannot open file {:?}": "",
        "cannot deserialize {}, descriptor not found": "",
        "cannot cleanup {}, descriptor not found": "",
        "global context": "",
        "Navigating to {project_path:?}": "",
        "Navigating to {abs_path:?}": "",
        "Failed to navigate history: {open_by_project_path_e:#} and {open_by_abs_path_e:#}": "",
        "Do you want to leave the current call?": "",
        "Close window and hang up": "",
        "Cancel": "",
        "bindings": "",
        "g z": "",
        "workspace::SendKeystrokes": "",
        ": j <enter> u": "",
        "over 100 keystrokes passed to send_keystrokes": "",
        "Do you want to save all changes in the following files?": "",
        "Save all": "",
        "Discard all": "",
        "You cannot add folders to someone else's project": "",
        "open abs path {abs_path:?} task spawn": "",
        "open abs path {abs_path:?} task returned incorrect number of results": "",
        "ensured single task result": "",
        "open abs path {abs_path:?} task join": "",
        "open abs path {abs_path:?} task returned None": "",
        "There must be an active pane": "",
        "pane was dropped": "",
        "Could not find a focus target when in switching focus in {direction} direction for a pane": "",
        "Could not find a focus target when in switching focus in {direction} direction for a {:?} dock": "",
        "following interrupted": "",
        ", ": "",
        "empty project": "",
        " — ": "",
        " ↙": "",
        " ↗": "",
        "invalid update": "",
        "invalid view id": "",
        "missing update view variant": "",
        "missing update view id": "",
        "workspace dropped": "",
        "no id for view": "",
        "stopped following": "",
        "missing view variant": "",
        "failed to construct view from leader (maybe from a different version of zed?)": "",
        "failed to send serializable item over channel: {err}": "",
        "Failed to save": "",
        "Failed to load the database file.": "",
        "File an Issue": "",
        "Rendered first frame": "",
        "Workspace": "",
        "keyboard_layout": "",
        "debugger_running": "",
        "debugger_stopped": "",
        "left_dock": "",
        "right_dock": "",
        "bottom_dock": "",
        "workspace": "",
        "creator is missing": "",
        "Copy link to section": "",
        "Do you want to switch channels?": "",
        "Leaving this call will unshare your current project.": "",
        "Yes, Join Channel": "",
        "error connecting": "",
        "failed to join channel: {}": "",
        "Please sign in to continue.": "",
        "Your are running an unsupported version of Zed. Please update to continue.": "",
        "No matching channel was found. Please check the link and try again.": "",
        "This channel is private, and you do not have access. Please ask someone to add you and try again.": "",
        "Please check your internet connection and try again.": "",
        "{}\\n\\nPlease try again.": "",
        "Failed to join channel": "",
        "Ok": "",
        "could not open zed": "",
        "{display_path} is inside a WSL filesystem, some features may not work unless you open it with WSL remote": "",
        "Open in WSL": "",
        "path {path:?} is not a file": "",
        "no paths given": "",
        "SSH Project Opened": "",
        "path": "",
        "'{path}' does not exist": "",
        "not in a call": "",
        "Are you sure you want to restart?": "",
        "Restart": "",
        "window-backdrop": "",
        "fetching serialized ssh project": "",
        "c": "",
        "b1/c": "",
        "a/b1/c": "",
        "b2/c": "",
        "a/b2/c": "",
        "/root1": "",
        "one.txt": "",
        "two.txt": "",
        "/root2": "",
        "three.txt": "",
        "root1": "",
        "root1 — one.txt": "",
        "root1 — two.txt": "",
        "root2": "",
        "root1, root2 — one.txt": "",
        "root2 — one.txt": "",
        "/root": "",
        "one": "",
        "root": "",
        "1.txt": "",
        "2.txt": "",
        "3.txt": "",
        "Discard": "",
        "{project_entry_id}.txt": "",
        "4.txt": "",
        "Left dock should be open": "",
        "Left panel should be visible in left dock": "",
        "Right dock should be open": "",
        "Right panel should be visible in right dock": "",
        "Bottom dock should be closed": "",
        "Left panel should be focused": "",
        "Left dock should be closed": "",
        "Bottom dock should now be open": "",
        "Left panel should now be in the bottom dock": "",
        "Left panel should be the visible panel in the bottom dock": "",
        "Right dock should be closed": "",
        "Left dock should remain closed": "",
        "Right dock should remain open": "",
        "Bottom dock should remain open": "",
        "Left panel should remain in the bottom dock": "",
        "Right panel should remain in the right dock": "",
        "Left panel should be the visible panel in the right dock": "",
        "top.txt": "",
        "bottom.txt": "",
        "left.txt": "",
        "right.txt": "",
        "center.txt": "",
        "item{item_id}.txt": "",
        "item is in focus": "",
        "Fake Project Search": "",
        "Should select the multi buffer in the pane": "",
        "Closing all buffers but the multi buffer failed": "",
        "Should have only the multi buffer left in the pane": "",
        "The multi buffer containing the unsaved buffer should still be dirty": "",
        "Dirty multi buffer should prompt a save dialog": "",
        "Save": "",
        "Closing the multi buffer failed": "",
        "Multi buffer item should get be saved": "",
        "No more items should be left in the pane": "",
        "With one dirty item from the multi buffer not being in the pane, a save prompt should be shown": "",
        "test.txt": "",
        "Item should be automatically closed when file is deleted": "",
        "Item should remain open when close_on_disk_deletion is disabled": "",
        "Item should be marked as having deleted file": "",
        "Dirty items should not be automatically closed even when file is deleted": "",
        "Item should still be dirty": "",
        "test1.txt": "",
        "test2.txt": "",
        "Should have 1 item remaining after auto-close": "",
        "Navigation history should not contain closed item entries": "",
        "All dirty items from the multi buffer are in the pane still, no save prompts should be shown": "",
        "Closing multi buffer failed": "",
        "Should have no multi buffer left in the pane": "",
        "first.txt": "",
        "No new panes were created": "",
        "Single item was not moved anywhere": "",
        "second.txt": "",
        "A new pane should be created": "",
        "After moving, one item should be left in the original pane": "",
        "New item should have been moved to the new pane": "",
        "third.txt": "",
        "New pane should be ready to move one item out": "",
        "Previously created pane should be unchanged": "",
        "Two new panes were created": "",
        "Single item exists in all panes": "",
        "The third pane should be the active one: {:?}": "",
        "png": "",
        "ipynb": "",
        "one.png": "",
        "BINARYDATAHERE": "",
        "two.ipynb": "",
        "{ totally a notebook }": "",
        "editing text, sure why not?": "",
        "Status bar should be visible by default": "",
        "Status bar should be hidden when show is false": "",
        "Status bar should be visible when show is true": ""
    },
    "zed/crates/worktree/src/worktree.rs": {
        "ephemeral": "",
        "LoadedBinaryFile": "",
        "file": "",
        "content_bytes": "",
        "gitfile": "",
        "commondir": "",
        "parent": "",
        "failed to stat worktree path": "",
        "Failed to determine whether filesystem is case sensitive (falling back to true) due to error: {e:#}": "",
        "failed to open local worktree root at {}": "",
        "remote worktrees can't yet load files": "",
        "remote worktrees can't yet load binary files": "",
        "remote worktree can't yet write files": "",
        "received invalid relative path {:?}": "",
        "invalid entry": "",
        "no such entry": "",
        "refreshing entries for the following always included paths: {:?}": "",
        "Failed to determine whether filesystem is case sensitive: {e:#}": "",
        "worktree was dropped": "",
        "Loading metadata for excluded file {abs_path:?}": "",
        "Excluded file {abs_path:?} got removed during loading": "",
        "File is too large to load": "",
        "creating directory {task_abs_path:?}": "",
        "creating file {task_abs_path:?}": "",
        "worktree dropped": "",
        "Fetching metadata after saving the excluded buffer {abs_path:?}": "",
        "Excluded buffer {path:?} got removed during saving": "",
        "Failed to copy file from {source:?} to {target:?}": "",
        "Dropped worktree": "",
        "Worktree is not local": "",
        "refreshed entry {path:?} in {:?}": "",
        "Could not find entry in worktree for {path:?} after refresh": "",
        "waiting to resume updates": "",
        "consumer runs to completion": "",
        "C:\\Users\\user\\Desktop\\project": "",
        "applying remote worktree update. {} entries updated, {} removed": "",
        "insert entry {:?}": "",
        "error loading .gitignore file {:?} - {:?}": "",
        "entries_by_path and entries_by_id are inconsistent": "",
        "populating a directory {:?} that has been removed": "",
        "background scanner removing path {path:?}": "",
        "not building git repository for nested `.git` directory, `.git` path in the worktree: {dot_git_path:?}": "",
        "not building git repository for the worktree itself, `.git` path in the worktree: {dot_git_path:?}": "",
        "working directory `{}` not indexed": "",
        "failed to add common directory to watcher": "",
        "failed to add repository directory to watcher": "",
        "inserting new local git repository": "",
        "HEAD": "",
        "config": "",
        "failed to load gitignore file at {}": "",
        "Snapshot": "",
        "id": "",
        "root_name": "",
        "entries_by_path": "",
        "entries_by_id": "",
        "not remote": "",
        "worktree id does not match file": "",
        "invalid path in file protobuf": "",
        "containing git repository: {containing_git_repository:?}": "",
        "adding path prefix {:?}": "",
        "rescanning paths {:?}": "",
        "failed to canonicalize root path {root_path:?}: {err}": "",
        "process events: {abs_paths:?}": "",
        "root renamed from {} to {}": "",
        "root path could not be canonicalized: {:#}": "",
        "stripping off the ancestor": "",
        "ignoring event {abs_path:?} as it's in the .git directory among skipped files or directories": "",
        "ignoring event {abs_path:?}, since it's in git dir outside of root path {root_canonical_path:?}": "",
        "ignoring event {abs_path:?} outside of root path {root_canonical_path:?}": "",
        "ignoring event {relative_path:?} within unloaded directory": "",
        "ignoring FS event for excluded path {relative_path:?}": "",
        "received fs events {:?}": "",
        "error scanning directory {:?}: {}": "",
        "skipping excluded directory {:?}": "",
        "scanning directory {:?}": "",
        "error processing entry {:?}": "",
        "skipping excluded child entry {child_path:?}": "",
        "error processing {child_abs_path:?}: {err:?}": "",
        "error reading target of symlink {child_abs_path:?}: {err:#}": "",
        "error canonicalizing root {:?}: {:?}": "",
        "detected private file: {relative_path:?}": "",
        "detected hidden file: {relative_path:?}": "",
        "defer scanning directory {:?}": "",
        "channel is unbounded": "",
        "updating ancestor git repository": "",
        "error reading file {abs_path:?} on event: {err:#}": "",
        "remove repo path: {:?}": "",
        "update ignore status {:?}": "",
        "Failed to strip prefix '{}' from path '{}'": "",
        "reloading repositories: {dot_git_paths:?}": "",
        "update_git_repositories called with .git directory outside the worktree root": "",
        "considering ancestor: {ancestor_dot_git:?}": "",
        "inserting parent git repo for this worktree: {location_in_repo:?}": "",
        "redundant": "",
        "fs-event-sentinel": "",
        "invalid relative path in proto message": "",
        "gitdir:": "",
        "parsing gitfile content {content:?}": ""
    },
    "zed/crates/worktree/src/worktree_settings.rs": {
        "file_scan_exclusions": "",
        "file_scan_inclusions": "",
        "private_files": "",
        "hidden_files": "",
        "Failed to parse globs from {}": ""
    },
    "zed/crates/zed/src/main.rs": {
        "mimalloc": "",
        "Zed failed to launch": "",
        "{kind} when creating directory {:?}": "",
        "match arm checks for a single entry": "",
        "{kind} when creating directories {paths:?}": "",
        ");\n                }\n            }\n\n            Some(error_kind_details)\n        })\n        .collect::<Vec<_>>().join(": "",
        ");\n\n    eprintln!(": "",
        ");\n    Application::new()\n        .with_quit_mode(QuitMode::Explicit)\n        .run(move |cx| {\n            if let Ok(window) = cx.open_window(gpui::WindowOptions::default(), |_, cx| {\n                cx.new(|_| gpui::Empty)\n            }) {\n                window\n                    .update(cx, |_, window, cx| {\n                        let response = window.prompt(\n                            gpui::PromptLevel::Critical,\n                            message,\n                            Some(&error_details),\n                            &[": "",
        "],\n                            cx,\n                        );\n\n                        cx.spawn_in(window, async move |_, cx| {\n                            response.await?;\n                            cx.update(|_, cx| cx.quit())\n                        })\n                        .detach_and_log_err(cx);\n                    })\n                    .log_err();\n            } else {\n                fail_to_open_window(anyhow::anyhow!(": "",
        "), cx)\n            }\n        })\n}\n\nfn fail_to_open_window_async(e: anyhow::Error, cx: &mut AsyncApp) {\n    cx.update(|cx| fail_to_open_window(e, cx)).log_err();\n}\n\nfn fail_to_open_window(e: anyhow::Error, _cx: &mut App) {\n    eprintln!(\n        ": "",
        "\n    );\n    #[cfg(not(any(target_os = ": "",
        ", target_os = ": "",
        ")))]\n    {\n        process::exit(1);\n    }\n\n    #[cfg(any(target_os = ": "",
        "))]\n    {\n        use ashpd::desktop::notification::{Notification, NotificationProxy, Priority};\n        _cx.spawn(async move |_cx| {\n            let Ok(proxy) = NotificationProxy::new().await else {\n                process::exit(1);\n            };\n\n            let notification_id = ": "",
        ";\n            proxy\n                .add_notification(\n                    notification_id,\n                    Notification::new(": "",
        ")\n                        .body(Some(\n                            format!(\n                                ": "",
        "\n                            )\n                            .as_str(),\n                        ))\n                        .priority(Priority::High)\n                        .icon(ashpd::desktop::Icon::with_names(&[\n                            ": "",
        ",\n                        ])),\n                )\n                .await\n                .ok();\n\n            process::exit(1);\n        })\n        .detach();\n    }\n}\n\npub fn main() {\n    #[cfg(unix)]\n    util::prevent_root_execution();\n\n    let args = Args::parse();\n\n    // `zed --askpass` Makes zed operate in nc/netcat mode for use with askpass\n    #[cfg(not(target_os = ": "",
        "))]\n    if let Some(socket) = &args.askpass {\n        askpass::main(socket);\n        return;\n    }\n\n    // `zed --crash-handler` Makes zed operate in minidump crash handler mode\n    if let Some(socket) = &args.crash_handler {\n        crashes::crash_server(socket.as_path());\n        return;\n    }\n\n    // `zed --nc` Makes zed operate in nc/netcat mode for use with MCP\n    if let Some(socket) = &args.nc {\n        match nc::main(socket) {\n            Ok(()) => return,\n            Err(err) => {\n                eprintln!(": "",
        ", err);\n                process::exit(1);\n            }\n        }\n    }\n\n    #[cfg(all(not(debug_assertions), target_os = ": "",
        "))]\n    unsafe {\n        use windows::Win32::System::Console::{ATTACH_PARENT_PROCESS, AttachConsole};\n\n        if args.foreground {\n            let _ = AttachConsole(ATTACH_PARENT_PROCESS);\n        }\n    }\n\n    // `zed --printenv` Outputs environment variables as JSON to stdout\n    if args.printenv {\n        util::shell_env::print_env();\n        return;\n    }\n\n    if args.dump_all_actions {\n        dump_all_gpui_actions();\n        return;\n    }\n\n    // Set custom data directory.\n    if let Some(dir) = &args.user_data_dir {\n        paths::set_custom_data_dir(dir);\n    }\n\n    #[cfg(target_os = ": "",
        ")]\n    match util::get_zed_cli_path() {\n        Ok(path) => askpass::set_askpass_program(path),\n        Err(err) => {\n            eprintln!(": "",
        ", err);\n            if std::option_env!(": "",
        ").is_some() {\n                process::exit(1);\n            }\n        }\n    }\n\n    let file_errors = init_paths();\n    if !file_errors.is_empty() {\n        files_not_created_on_launch(file_errors);\n        return;\n    }\n\n    zlog::init();\n    if stdout_is_a_pty() {\n        zlog::init_output_stdout();\n    } else {\n        let result = zlog::init_output_file(paths::log_file(), Some(paths::old_log_file()));\n        if let Err(err) = result {\n            eprintln!(": "",
        ", err);\n            zlog::init_output_stdout();\n        };\n    }\n\n    let app_version = AppVersion::load(env!(": "",
        "));\n    let app_commit_sha =\n        option_env!(": "",
        ").map(|commit_sha| AppCommitSha::new(commit_sha.to_string()));\n\n    if args.system_specs {\n        let system_specs = system_specs::SystemSpecs::new_stateless(\n            app_version,\n            app_commit_sha,\n            *release_channel::RELEASE_CHANNEL,\n        );\n        println!(": "",
        ", system_specs);\n        return;\n    }\n\n    rayon::ThreadPoolBuilder::new()\n        .num_threads(4)\n        .stack_size(10 * 1024 * 1024)\n        .thread_name(|ix| format!(": "",
        ", ix))\n        .build_global()\n        .unwrap();\n\n    log::info!(\n        ": "",
        ",\n        app_version,\n        app_commit_sha\n            .as_ref()\n            .map(|sha| sha.short())\n            .as_deref()\n            .unwrap_or(": "",
        "),\n    );\n\n    #[cfg(windows)]\n    check_for_conpty_dll();\n\n    let app = Application::new().with_assets(Assets);\n\n    let system_id = app.background_executor().block(system_id()).ok();\n    let installation_id = app.background_executor().block(installation_id()).ok();\n    let session_id = Uuid::new_v4().to_string();\n    let session = app.background_executor().block(Session::new());\n\n    app.background_executor()\n        .spawn(crashes::init(InitCrashHandler {\n            session_id: session_id.clone(),\n            zed_version: app_version.to_string(),\n            binary: ": "",
        ".to_string(),\n            release_channel: release_channel::RELEASE_CHANNEL_NAME.clone(),\n            commit_sha: app_commit_sha\n                .as_ref()\n                .map(|sha| sha.full())\n                .unwrap_or_else(|| ": "",
        ".to_owned()),\n        }))\n        .detach();\n\n    let (open_listener, mut open_rx) = OpenListener::new();\n\n    let failed_single_instance_check = if *zed_env_vars::ZED_STATELESS\n        || *release_channel::RELEASE_CHANNEL == ReleaseChannel::Dev\n    {\n        false\n    } else {\n        #[cfg(any(target_os = ": "",
        "))]\n        {\n            crate::zed::listen_for_cli_connections(open_listener.clone()).is_err()\n        }\n\n        #[cfg(target_os = ": "",
        ")]\n        {\n            !crate::zed::windows_only_instance::handle_single_instance(open_listener.clone(), &args)\n        }\n\n        #[cfg(target_os = ": "",
        ")]\n        {\n            use zed::mac_only_instance::*;\n            ensure_only_instance() != IsOnlyInstance::Yes\n        }\n    };\n    if failed_single_instance_check {\n        println!(": "",
        ");\n        return;\n    }\n\n    let git_hosting_provider_registry = Arc::new(GitHostingProviderRegistry::new());\n    let git_binary_path =\n        if cfg!(target_os = ": "",
        ") && option_env!(": "",
        ").as_deref() == Some(": "",
        ") {\n            app.path_for_auxiliary_executable(": "",
        ")\n                .context(": "",
        ")\n                .log_err()\n        } else {\n            None\n        };\n    log::info!(": "",
        ", git_binary_path);\n\n    let fs = Arc::new(RealFs::new(git_binary_path, app.background_executor()));\n    let user_settings_file_rx = watch_config_file(\n        &app.background_executor(),\n        fs.clone(),\n        paths::settings_file().clone(),\n    );\n    let global_settings_file_rx = watch_config_file(\n        &app.background_executor(),\n        fs.clone(),\n        paths::global_settings_file().clone(),\n    );\n    let user_keymap_file_rx = watch_config_file(\n        &app.background_executor(),\n        fs.clone(),\n        paths::keymap_file().clone(),\n    );\n\n    let (shell_env_loaded_tx, shell_env_loaded_rx) = oneshot::channel();\n    if !stdout_is_a_pty() {\n        app.background_executor()\n            .spawn(async {\n                #[cfg(unix)]\n                util::load_login_shell_environment().await.log_err();\n                shell_env_loaded_tx.send(()).ok();\n            })\n            .detach()\n    } else {\n        drop(shell_env_loaded_tx)\n    }\n\n    app.on_open_urls({\n        let open_listener = open_listener.clone();\n        move |urls| {\n            open_listener.open(RawOpenRequest {\n                urls,\n                diff_paths: Vec::new(),\n                ..Default::default()\n            })\n        }\n    });\n    app.on_reopen(move |cx| {\n        if let Some(app_state) = AppState::try_global(cx).and_then(|app_state| app_state.upgrade())\n        {\n            cx.spawn({\n                let app_state = app_state;\n                async move |cx| {\n                    if let Err(e) = restore_or_create_workspace(app_state, cx).await {\n                        fail_to_open_window_async(e, cx)\n                    }\n                }\n            })\n            .detach();\n        }\n    });\n\n    app.run(move |cx| {\n        menu::init();\n        zed_actions::init();\n\n        release_channel::init(app_version, cx);\n        gpui_tokio::init(cx);\n        if let Some(app_commit_sha) = app_commit_sha {\n            AppCommitSha::set_global(app_commit_sha, cx);\n        }\n        settings::init(cx);\n        zlog_settings::init(cx);\n        handle_settings_file_changes(\n            user_settings_file_rx,\n            global_settings_file_rx,\n            cx,\n            handle_settings_changed,\n        );\n        handle_keymap_file_changes(user_keymap_file_rx, cx);\n\n        let user_agent = format!(\n            ": "",
        ",\n            AppVersion::global(cx),\n            std::env::consts::OS,\n            std::env::consts::ARCH\n        );\n        let proxy_url = ProxySettings::get_global(cx).proxy_url();\n        let http = {\n            let _guard = Tokio::handle(cx).enter();\n\n            ReqwestClient::proxy_and_user_agent(proxy_url, &user_agent)\n                .expect(": "",
        ")\n        };\n        cx.set_http_client(Arc::new(http));\n\n        <dyn Fs>::set_global(fs.clone(), cx);\n\n        GitHostingProviderRegistry::set_global(git_hosting_provider_registry, cx);\n        git_hosting_providers::init(cx);\n\n        OpenListener::set_global(cx, open_listener.clone());\n\n        extension::init(cx);\n        let extension_host_proxy = ExtensionHostProxy::global(cx);\n\n        let client = Client::production(cx);\n        cx.set_http_client(client.http_client());\n        let mut languages = LanguageRegistry::new(cx.background_executor().clone());\n        languages.set_language_server_download_dir(paths::languages_dir().clone());\n        let languages = Arc::new(languages);\n        let (mut tx, rx) = watch::channel(None);\n        cx.observe_global::<SettingsStore>(move |cx| {\n            let settings = &ProjectSettings::get_global(cx).node;\n            let options = NodeBinaryOptions {\n                allow_path_lookup: !settings.ignore_system_version,\n                // TODO: Expose this setting\n                allow_binary_download: true,\n                use_paths: settings.path.as_ref().map(|node_path| {\n                    let node_path = PathBuf::from(shellexpand::tilde(node_path).as_ref());\n                    let npm_path = settings\n                        .npm_path\n                        .as_ref()\n                        .map(|path| PathBuf::from(shellexpand::tilde(&path).as_ref()));\n                    (\n                        node_path.clone(),\n                        npm_path.unwrap_or_else(|| {\n                            let base_path = PathBuf::new();\n                            node_path.parent().unwrap_or(&base_path).join(": "",
        ")\n                        }),\n                    )\n                }),\n            };\n            tx.send(Some(options)).log_err();\n        })\n        .detach();\n        let node_runtime = NodeRuntime::new(client.http_client(), Some(shell_env_loaded_rx), rx);\n\n        debug_adapter_extension::init(extension_host_proxy.clone(), cx);\n        languages::init(languages.clone(), fs.clone(), node_runtime.clone(), cx);\n        let user_store = cx.new(|cx| UserStore::new(client.clone(), cx));\n        let workspace_store = cx.new(|cx| WorkspaceStore::new(client.clone(), cx));\n\n        language_extension::init(\n            language_extension::LspAccess::ViaWorkspaces({\n                let workspace_store = workspace_store.clone();\n                Arc::new(move |cx: &mut App| {\n                    workspace_store.update(cx, |workspace_store, cx| {\n                        workspace_store\n                            .workspaces()\n                            .iter()\n                            .map(|workspace| {\n                                workspace.update(cx, |workspace, _, cx| {\n                                    workspace.project().read(cx).lsp_store()\n                                })\n                            })\n                            .collect()\n                    })\n                })\n            }),\n            extension_host_proxy.clone(),\n            languages.clone(),\n        );\n\n        Client::set_global(client.clone(), cx);\n\n        zed::init(cx);\n        project::Project::init(&client, cx);\n        debugger_ui::init(cx);\n        debugger_tools::init(cx);\n        client::init(&client, cx);\n        let telemetry = client.telemetry();\n        telemetry.start(\n            system_id.as_ref().map(|id| id.to_string()),\n            installation_id.as_ref().map(|id| id.to_string()),\n            session_id.clone(),\n            cx,\n        );\n\n        // We should rename these in the future to `first app open`, `first app open for release channel`, and `app open`\n        if let (Some(system_id), Some(installation_id)) = (&system_id, &installation_id) {\n            match (&system_id, &installation_id) {\n                (IdType::New(_), IdType::New(_)) => {\n                    telemetry::event!(": "",
        ");\n                    telemetry::event!(": "",
        ");\n                }\n                (IdType::Existing(_), IdType::New(_)) => {\n                    telemetry::event!(": "",
        ");\n                }\n                (_, IdType::Existing(_)) => {\n                    telemetry::event!(": "",
        ");\n                }\n            }\n        }\n        let app_session = cx.new(|cx| AppSession::new(session, cx));\n\n        let app_state = Arc::new(AppState {\n            languages,\n            client: client.clone(),\n            user_store,\n            fs: fs.clone(),\n            build_window_options,\n            workspace_store,\n            node_runtime,\n            session: app_session,\n        });\n        AppState::set_global(Arc::downgrade(&app_state), cx);\n\n        auto_update::init(client.clone(), cx);\n        dap_adapters::init(cx);\n        auto_update_ui::init(cx);\n        reliability::init(\n            client.http_client(),\n            system_id.as_ref().map(|id| id.to_string()),\n            cx,\n        );\n        extension_host::init(\n            extension_host_proxy.clone(),\n            app_state.fs.clone(),\n            app_state.client.clone(),\n            app_state.node_runtime.clone(),\n            cx,\n        );\n\n        theme::init(theme::LoadThemes::All(Box::new(Assets)), cx);\n        eager_load_active_theme_and_icon_theme(fs.clone(), cx);\n        theme_extension::init(\n            extension_host_proxy,\n            ThemeRegistry::global(cx),\n            cx.background_executor().clone(),\n        );\n        command_palette::init(cx);\n        let copilot_language_server_id = app_state.languages.next_language_server_id();\n        copilot::init(\n            copilot_language_server_id,\n            app_state.fs.clone(),\n            app_state.client.http_client(),\n            app_state.node_runtime.clone(),\n            cx,\n        );\n        supermaven::init(app_state.client.clone(), cx);\n        language_model::init(app_state.client.clone(), cx);\n        language_models::init(app_state.user_store.clone(), app_state.client.clone(), cx);\n        acp_tools::init(cx);\n        zeta2_tools::init(cx);\n        web_search::init(cx);\n        web_search_providers::init(app_state.client.clone(), cx);\n        snippet_provider::init(cx);\n        edit_prediction_registry::init(app_state.client.clone(), app_state.user_store.clone(), cx);\n        let prompt_builder = PromptBuilder::load(app_state.fs.clone(), stdout_is_a_pty(), cx);\n        agent_ui::init(\n            app_state.fs.clone(),\n            app_state.client.clone(),\n            prompt_builder.clone(),\n            app_state.languages.clone(),\n            false,\n            cx,\n        );\n        repl::init(app_state.fs.clone(), cx);\n        recent_projects::init(cx);\n\n        load_embedded_fonts(cx);\n\n        editor::init(cx);\n        image_viewer::init(cx);\n        repl::notebook::init(cx);\n        diagnostics::init(cx);\n\n        audio::init(cx);\n        workspace::init(app_state.clone(), cx);\n        ui_prompt::init(cx);\n\n        go_to_line::init(cx);\n        file_finder::init(cx);\n        tab_switcher::init(cx);\n        outline::init(cx);\n        project_symbols::init(cx);\n        project_panel::init(cx);\n        outline_panel::init(cx);\n        tasks_ui::init(cx);\n        snippets_ui::init(cx);\n        channel::init(&app_state.client.clone(), app_state.user_store.clone(), cx);\n        search::init(cx);\n        vim::init(cx);\n        terminal_view::init(cx);\n        journal::init(app_state.clone(), cx);\n        language_selector::init(cx);\n        line_ending_selector::init(cx);\n        toolchain_selector::init(cx);\n        theme_selector::init(cx);\n        settings_profile_selector::init(cx);\n        language_tools::init(cx);\n        call::init(app_state.client.clone(), app_state.user_store.clone(), cx);\n        notifications::init(app_state.client.clone(), app_state.user_store.clone(), cx);\n        collab_ui::init(&app_state, cx);\n        git_ui::init(cx);\n        feedback::init(cx);\n        markdown_preview::init(cx);\n        svg_preview::init(cx);\n        onboarding::init(cx);\n        settings_ui::init(cx);\n        keymap_editor::init(cx);\n        extensions_ui::init(cx);\n        zeta::init(cx);\n        inspector_ui::init(app_state.clone(), cx);\n        json_schema_store::init(cx);\n\n        cx.observe_global::<SettingsStore>({\n            let http = app_state.client.http_client();\n            let client = app_state.client.clone();\n            move |cx| {\n                for &mut window in cx.windows().iter_mut() {\n                    let background_appearance = cx.theme().window_background_appearance();\n                    window\n                        .update(cx, |_, window, _| {\n                            window.set_background_appearance(background_appearance)\n                        })\n                        .ok();\n                }\n\n                let new_host = &client::ClientSettings::get_global(cx).server_url;\n                if &http.base_url() != new_host {\n                    http.set_base_url(new_host);\n                    if client.status().borrow().is_connected() {\n                        client.reconnect(&cx.to_async());\n                    }\n                }\n            }\n        })\n        .detach();\n        app_state.languages.set_theme(cx.theme().clone());\n        cx.observe_global::<GlobalTheme>({\n            let languages = app_state.languages.clone();\n            move |cx| {\n                languages.set_theme(cx.theme().clone());\n            }\n        })\n        .detach();\n        telemetry::event!(\n            ": "",
        ",\n            setting = ": "",
        ",\n            value = cx.theme().name.to_string()\n        );\n        telemetry::event!(\n            ": "",
        ",\n            value = BaseKeymap::get_global(cx).to_string()\n        );\n        telemetry.flush_events().detach();\n\n        let fs = app_state.fs.clone();\n        load_user_themes_in_background(fs.clone(), cx);\n        watch_themes(fs.clone(), cx);\n        watch_languages(fs.clone(), app_state.languages.clone(), cx);\n\n        let menus = app_menus(cx);\n        cx.set_menus(menus);\n        initialize_workspace(app_state.clone(), prompt_builder, cx);\n\n        cx.activate(true);\n\n        cx.spawn({\n            let client = app_state.client.clone();\n            async move |cx| authenticate(client, cx).await\n        })\n        .detach_and_log_err(cx);\n\n        let urls: Vec<_> = args\n            .paths_or_urls\n            .iter()\n            .map(|arg| parse_url_arg(arg, cx))\n            .collect();\n\n        let diff_paths: Vec<[String; 2]> = args\n            .diff\n            .chunks(2)\n            .map(|chunk| [chunk[0].clone(), chunk[1].clone()])\n            .collect();\n\n        #[cfg(target_os = ": "",
        ")]\n        let wsl = args.wsl;\n        #[cfg(not(target_os = ": "",
        "))]\n        let wsl = None;\n\n        if !urls.is_empty() || !diff_paths.is_empty() {\n            open_listener.open(RawOpenRequest {\n                urls,\n                diff_paths,\n                wsl,\n            })\n        }\n\n        match open_rx\n            .try_next()\n            .ok()\n            .flatten()\n            .and_then(|request| OpenRequest::parse(request, cx).log_err())\n        {\n            Some(request) => {\n                handle_open_request(request, app_state.clone(), cx);\n            }\n            None => {\n                cx.spawn({\n                    let app_state = app_state.clone();\n                    async move |cx| {\n                        if let Err(e) = restore_or_create_workspace(app_state, cx).await {\n                            fail_to_open_window_async(e, cx)\n                        }\n                    }\n                })\n                .detach();\n            }\n        }\n\n        let app_state = app_state.clone();\n\n        crate::zed::component_preview::init(app_state.clone(), cx);\n\n        cx.spawn(async move |cx| {\n            while let Some(urls) = open_rx.next().await {\n                cx.update(|cx| {\n                    if let Some(request) = OpenRequest::parse(urls, cx).log_err() {\n                        handle_open_request(request, app_state.clone(), cx);\n                    }\n                })\n                .ok();\n            }\n        })\n        .detach();\n    });\n}\n\nfn handle_open_request(request: OpenRequest, app_state: Arc<AppState>, cx: &mut App) {\n    if let Some(kind) = request.kind {\n        match kind {\n            OpenRequestKind::CliConnection(connection) => {\n                cx.spawn(async move |cx| handle_cli_connection(connection, app_state, cx).await)\n                    .detach();\n            }\n            OpenRequestKind::Extension { extension_id } => {\n                cx.spawn(async move |cx| {\n                    let workspace =\n                        workspace::get_any_active_workspace(app_state, cx.clone()).await?;\n                    workspace.update(cx, |_, window, cx| {\n                        window.dispatch_action(\n                            Box::new(zed_actions::Extensions {\n                                category_filter: None,\n                                id: Some(extension_id),\n                            }),\n                            cx,\n                        );\n                    })\n                })\n                .detach_and_log_err(cx);\n            }\n            OpenRequestKind::AgentPanel => {\n                cx.spawn(async move |cx| {\n                    let workspace =\n                        workspace::get_any_active_workspace(app_state, cx.clone()).await?;\n                    workspace.update(cx, |workspace, window, cx| {\n                        if let Some(panel) = workspace.panel::<AgentPanel>(cx) {\n                            panel.focus_handle(cx).focus(window);\n                        }\n                    })\n                })\n                .detach_and_log_err(cx);\n            }\n            OpenRequestKind::DockMenuAction { index } => {\n                cx.perform_dock_menu_action(index);\n            }\n            OpenRequestKind::BuiltinJsonSchema { schema_path } => {\n                workspace::with_active_or_new_workspace(cx, |_workspace, window, cx| {\n                    cx.spawn_in(window, async move |workspace, cx| {\n                        let res = async move {\n                            let json = app_state.languages.language_for_name(": "",
        ").await.ok();\n                            let json_schema_content =\n                                json_schema_store::resolve_schema_request_inner(\n                                    &app_state.languages,\n                                    &schema_path,\n                                    cx,\n                                )?;\n                            let json_schema_content =\n                                serde_json::to_string_pretty(&json_schema_content)\n                                    .context(": "",
        ")?;\n                            let buffer_task = workspace.update(cx, |workspace, cx| {\n                                workspace\n                                    .project()\n                                    .update(cx, |project, cx| project.create_buffer(false, cx))\n                            })?;\n\n                            let buffer = buffer_task.await?;\n\n                            workspace.update_in(cx, |workspace, window, cx| {\n                                buffer.update(cx, |buffer, cx| {\n                                    buffer.set_language(json, cx);\n                                    buffer.edit([(0..0, json_schema_content)], None, cx);\n                                    buffer.edit(\n                                        [(0..0, format!(": "",
        ", schema_path))],\n                                        None,\n                                        cx,\n                                    );\n                                });\n\n                                workspace.add_item_to_active_pane(\n                                    Box::new(cx.new(|cx| {\n                                        let mut editor =\n                                            editor::Editor::for_buffer(buffer, None, window, cx);\n                                        editor.set_read_only(true);\n                                        editor\n                                    })),\n                                    None,\n                                    true,\n                                    window,\n                                    cx,\n                                );\n                            })\n                        }\n                        .await;\n                        res.context(": "",
        ").log_err();\n                    })\n                    .detach();\n                });\n            }\n            OpenRequestKind::Setting { setting_path } => {\n                // zed://settings/languages/$(language)/tab_size  - DONT SUPPORT\n                // zed://settings/languages/Rust/tab_size  - SUPPORT\n                // languages.$(language).tab_size\n                // [ languages $(language) tab_size]\n                cx.spawn(async move |cx| {\n                    let workspace =\n                        workspace::get_any_active_workspace(app_state, cx.clone()).await?;\n\n                    workspace.update(cx, |_, window, cx| match setting_path {\n                        None => window.dispatch_action(Box::new(zed_actions::OpenSettings), cx),\n                        Some(setting_path) => window.dispatch_action(\n                            Box::new(zed_actions::OpenSettingsAt { path: setting_path }),\n                            cx,\n                        ),\n                    })\n                })\n                .detach_and_log_err(cx);\n            }\n        }\n\n        return;\n    }\n\n    if let Some(connection_options) = request.remote_connection {\n        cx.spawn(async move |cx| {\n            let paths: Vec<PathBuf> = request.open_paths.into_iter().map(PathBuf::from).collect();\n            open_remote_project(\n                connection_options,\n                paths,\n                app_state,\n                workspace::OpenOptions::default(),\n                cx,\n            )\n            .await\n        })\n        .detach_and_log_err(cx);\n        return;\n    }\n\n    let mut task = None;\n    if !request.open_paths.is_empty() || !request.diff_paths.is_empty() {\n        let app_state = app_state.clone();\n        task = Some(cx.spawn(async move |cx| {\n            let paths_with_position =\n                derive_paths_with_position(app_state.fs.as_ref(), request.open_paths).await;\n            let (_window, results) = open_paths_with_positions(\n                &paths_with_position,\n                &request.diff_paths,\n                app_state,\n                workspace::OpenOptions::default(),\n                cx,\n            )\n            .await?;\n            for result in results.into_iter().flatten() {\n                if let Err(err) = result {\n                    log::error!(": "",
        ",);\n                }\n            }\n            anyhow::Ok(())\n        }));\n    }\n\n    if !request.open_channel_notes.is_empty() || request.join_channel.is_some() {\n        cx.spawn(async move |cx| {\n            let result = maybe!(async {\n                if let Some(task) = task {\n                    task.await?;\n                }\n                let client = app_state.client.clone();\n                // we continue even if authentication fails as join_channel/ open channel notes will\n                // show a visible error message.\n                authenticate(client, cx).await.log_err();\n\n                if let Some(channel_id) = request.join_channel {\n                    cx.update(|cx| {\n                        workspace::join_channel(\n                            client::ChannelId(channel_id),\n                            app_state.clone(),\n                            None,\n                            cx,\n                        )\n                    })?\n                    .await?;\n                }\n\n                let workspace_window =\n                    workspace::get_any_active_workspace(app_state, cx.clone()).await?;\n                let workspace = workspace_window.entity(cx)?;\n\n                let mut promises = Vec::new();\n                for (channel_id, heading) in request.open_channel_notes {\n                    promises.push(cx.update_window(workspace_window.into(), |_, window, cx| {\n                        ChannelView::open(\n                            client::ChannelId(channel_id),\n                            heading,\n                            workspace.clone(),\n                            window,\n                            cx,\n                        )\n                        .log_err()\n                    })?)\n                }\n                future::join_all(promises).await;\n                anyhow::Ok(())\n            })\n            .await;\n            if let Err(err) = result {\n                fail_to_open_window_async(err, cx);\n            }\n        })\n        .detach()\n    } else if let Some(task) = task {\n        cx.spawn(async move |cx| {\n            if let Err(err) = task.await {\n                fail_to_open_window_async(err, cx);\n            }\n        })\n        .detach();\n    }\n}\n\nasync fn authenticate(client: Arc<Client>, cx: &AsyncApp) -> Result<()> {\n    if stdout_is_a_pty() {\n        if client::IMPERSONATE_LOGIN.is_some() {\n            client.sign_in_with_optional_connect(false, cx).await?;\n        } else if client.has_credentials(cx).await {\n            client.sign_in_with_optional_connect(true, cx).await?;\n        }\n    } else if client.has_credentials(cx).await {\n        client.sign_in_with_optional_connect(true, cx).await?;\n    }\n\n    Ok(())\n}\n\nasync fn system_id() -> Result<IdType> {\n    let key_name = ": "",
        ".to_string();\n\n    if let Ok(Some(system_id)) = GLOBAL_KEY_VALUE_STORE.read_kvp(&key_name) {\n        return Ok(IdType::Existing(system_id));\n    }\n\n    let system_id = Uuid::new_v4().to_string();\n\n    GLOBAL_KEY_VALUE_STORE\n        .write_kvp(key_name, system_id.clone())\n        .await?;\n\n    Ok(IdType::New(system_id))\n}\n\nasync fn installation_id() -> Result<IdType> {\n    let legacy_key_name = ": "",
        ".to_string();\n    let key_name = ": "",
        ".to_string();\n\n    // Migrate legacy key to new key\n    if let Ok(Some(installation_id)) = KEY_VALUE_STORE.read_kvp(&legacy_key_name) {\n        KEY_VALUE_STORE\n            .write_kvp(key_name, installation_id.clone())\n            .await?;\n        KEY_VALUE_STORE.delete_kvp(legacy_key_name).await?;\n        return Ok(IdType::Existing(installation_id));\n    }\n\n    if let Ok(Some(installation_id)) = KEY_VALUE_STORE.read_kvp(&key_name) {\n        return Ok(IdType::Existing(installation_id));\n    }\n\n    let installation_id = Uuid::new_v4().to_string();\n\n    KEY_VALUE_STORE\n        .write_kvp(key_name, installation_id.clone())\n        .await?;\n\n    Ok(IdType::New(installation_id))\n}\n\nasync fn restore_or_create_workspace(app_state: Arc<AppState>, cx: &mut AsyncApp) -> Result<()> {\n    if let Some(locations) = restorable_workspace_locations(cx, &app_state).await {\n        let use_system_window_tabs = cx\n            .update(|cx| WorkspaceSettings::get_global(cx).use_system_window_tabs)\n            .unwrap_or(false);\n        let mut results: Vec<Result<(), Error>> = Vec::new();\n        let mut tasks = Vec::new();\n\n        for (index, (location, paths)) in locations.into_iter().enumerate() {\n            match location {\n                SerializedWorkspaceLocation::Local => {\n                    let app_state = app_state.clone();\n                    let task = cx.spawn(async move |cx| {\n                        let open_task = cx.update(|cx| {\n                            workspace::open_paths(\n                                &paths.paths(),\n                                app_state,\n                                workspace::OpenOptions::default(),\n                                cx,\n                            )\n                        })?;\n                        open_task.await.map(|_| ())\n                    });\n\n                    // If we're using system window tabs and this is the first workspace,\n                    // wait for it to finish so that the other windows can be added as tabs.\n                    if use_system_window_tabs && index == 0 {\n                        results.push(task.await);\n                    } else {\n                        tasks.push(task);\n                    }\n                }\n                SerializedWorkspaceLocation::Remote(mut connection_options) => {\n                    let app_state = app_state.clone();\n                    if let RemoteConnectionOptions::Ssh(options) = &mut connection_options {\n                        cx.update(|cx| {\n                            SshSettings::get_global(cx)\n                                .fill_connection_options_from_settings(options)\n                        })?;\n                    }\n                    let task = cx.spawn(async move |cx| {\n                        recent_projects::open_remote_project(\n                            connection_options,\n                            paths.paths().into_iter().map(PathBuf::from).collect(),\n                            app_state,\n                            workspace::OpenOptions::default(),\n                            cx,\n                        )\n                        .await\n                        .map_err(|e| anyhow::anyhow!(e))\n                    });\n                    tasks.push(task);\n                }\n            }\n        }\n\n        // Wait for all workspaces to open concurrently\n        results.extend(future::join_all(tasks).await);\n\n        // Show notifications for any errors that occurred\n        let mut error_count = 0;\n        for result in results {\n            if let Err(e) = result {\n                log::error!(": "",
        ", e);\n                error_count += 1;\n            }\n        }\n\n        if error_count > 0 {\n            let message = if error_count == 1 {\n                ": "",
        ".to_string()\n            } else {\n                format!(\n                    ": "",
        ",\n                    error_count\n                )\n            };\n\n            // Try to find an active workspace to show the toast\n            let toast_shown = cx\n                .update(|cx| {\n                    if let Some(window) = cx.active_window()\n                        && let Some(workspace) = window.downcast::<Workspace>()\n                    {\n                        workspace\n                            .update(cx, |workspace, _, cx| {\n                                workspace.show_toast(\n                                    Toast::new(NotificationId::unique::<()>(), message),\n                                    cx,\n                                )\n                            })\n                            .ok();\n                        return true;\n                    }\n                    false\n                })\n                .unwrap_or(false);\n\n            // If we couldn't show a toast (no windows opened successfully),\n            // we've already logged the errors above, so the user can check logs\n            if !toast_shown {\n                log::error!(\n                    ": "",
        "\n                );\n            }\n        }\n    } else if matches!(KEY_VALUE_STORE.read_kvp(FIRST_OPEN), Ok(None)) {\n        cx.update(|cx| show_onboarding_view(app_state, cx))?.await?;\n    } else {\n        cx.update(|cx| {\n            workspace::open_new(\n                Default::default(),\n                app_state,\n                cx,\n                |workspace, window, cx| {\n                    Editor::new_file(workspace, &Default::default(), window, cx)\n                },\n            )\n        })?\n        .await?;\n    }\n\n    Ok(())\n}\n\npub(crate) async fn restorable_workspace_locations(\n    cx: &mut AsyncApp,\n    app_state: &Arc<AppState>,\n) -> Option<Vec<(SerializedWorkspaceLocation, PathList)>> {\n    let mut restore_behavior = cx\n        .update(|cx| WorkspaceSettings::get(None, cx).restore_on_startup)\n        .ok()?;\n\n    let session_handle = app_state.session.clone();\n    let (last_session_id, last_session_window_stack) = cx\n        .update(|cx| {\n            let session = session_handle.read(cx);\n\n            (\n                session.last_session_id().map(|id| id.to_string()),\n                session.last_session_window_stack(),\n            )\n        })\n        .ok()?;\n\n    if last_session_id.is_none()\n        && matches!(\n            restore_behavior,\n            workspace::RestoreOnStartupBehavior::LastSession\n        )\n    {\n        restore_behavior = workspace::RestoreOnStartupBehavior::LastWorkspace;\n    }\n\n    match restore_behavior {\n        workspace::RestoreOnStartupBehavior::LastWorkspace => {\n            workspace::last_opened_workspace_location()\n                .await\n                .map(|location| vec![location])\n        }\n        workspace::RestoreOnStartupBehavior::LastSession => {\n            if let Some(last_session_id) = last_session_id {\n                let ordered = last_session_window_stack.is_some();\n\n                let mut locations = workspace::last_session_workspace_locations(\n                    &last_session_id,\n                    last_session_window_stack,\n                )\n                .filter(|locations| !locations.is_empty());\n\n                // Since last_session_window_order returns the windows ordered front-to-back\n                // we need to open the window that was frontmost last.\n                if ordered && let Some(locations) = locations.as_mut() {\n                    locations.reverse();\n                }\n\n                locations\n            } else {\n                None\n            }\n        }\n        _ => None,\n    }\n}\n\nfn init_paths() -> HashMap<io::ErrorKind, Vec<&'static Path>> {\n    [\n        paths::config_dir(),\n        paths::extensions_dir(),\n        paths::languages_dir(),\n        paths::debug_adapters_dir(),\n        paths::database_dir(),\n        paths::logs_dir(),\n        paths::temp_dir(),\n    ]\n    .into_iter()\n    .fold(HashMap::default(), |mut errors, path| {\n        if let Err(e) = std::fs::create_dir_all(path) {\n            errors.entry(e.kind()).or_insert_with(Vec::new).push(path);\n        }\n        errors\n    })\n}\n\npub fn stdout_is_a_pty() -> bool {\n    std::env::var(FORCE_CLI_MODE_ENV_VAR_NAME).ok().is_none() && io::stdout().is_terminal()\n}\n\n#[derive(Parser, Debug)]\n#[command(name = ": "",
        ", disable_version_flag = true)]\nstruct Args {\n    /// A sequence of space-separated paths or urls that you want to open.\n    ///\n    /// Use `path:line:row` syntax to open a file at a specific location.\n    /// Non-existing paths and directories will ignore `:line:row` suffix.\n    ///\n    /// URLs can either be `file://` or `zed://` scheme, or relative to <https://zed.dev>.\n    paths_or_urls: Vec<String>,\n\n    /// Pairs of file paths to diff. Can be specified multiple times.\n    #[arg(long, action = clap::ArgAction::Append, num_args = 2, value_names = [": "",
        ", ": "",
        "])]\n    diff: Vec<String>,\n\n    /// Sets a custom directory for all user data (e.g., database, extensions, logs).\n    /// This overrides the default platform-specific data directory location.\n    /// On macOS, the default is `~/Library/Application Support/Zed`.\n    /// On Linux/FreeBSD, the default is `$XDG_DATA_HOME/zed`.\n    /// On Windows, the default is `%LOCALAPPDATA%\\Zed`.\n    #[arg(long, value_name = ": "",
        ")]\n    user_data_dir: Option<String>,\n\n    /// The username and WSL distribution to use when opening paths. If not specified,\n    /// Zed will attempt to open the paths directly.\n    ///\n    /// The username is optional, and if not specified, the default user for the distribution\n    /// will be used.\n    ///\n    /// Example: `me@Ubuntu` or `Ubuntu`.\n    ///\n    /// WARN: You should not fill in this field by hand.\n    #[cfg(target_os = ": "",
        ")]\n    #[arg(long, value_name = ": "",
        ")]\n    wsl: Option<String>,\n\n    /// Instructs zed to run as a dev server on this machine. (not implemented)\n    #[arg(long)]\n    dev_server_token: Option<String>,\n\n    /// Prints system specs. Useful for submitting issues on GitHub when encountering a bug\n    /// that prevents Zed from starting, so you can't run `zed: copy system specs to clipboard`\n    #[arg(long)]\n    system_specs: bool,\n\n    /// Used for the MCP Server, to remove the need for netcat as a dependency,\n    /// by having Zed act like netcat communicating over a Unix socket.\n    #[arg(long, hide = true)]\n    nc: Option<String>,\n\n    /// Used for recording minidumps on crashes by having Zed run a separate\n    /// process communicating over a socket.\n    #[arg(long, hide = true)]\n    crash_handler: Option<PathBuf>,\n\n    /// Run zed in the foreground, only used on Windows, to match the behavior on macOS.\n    #[arg(long)]\n    #[cfg(target_os = ": "",
        ")]\n    #[arg(hide = true)]\n    foreground: bool,\n\n    /// The dock action to perform. This is used on Windows only.\n    #[arg(long)]\n    #[cfg(target_os = ": "",
        ")]\n    #[arg(hide = true)]\n    dock_action: Option<usize>,\n\n    /// Used for SSH/Git password authentication, to remove the need for netcat as a dependency,\n    /// by having Zed act like netcat communicating over a Unix socket.\n    #[arg(long)]\n    #[cfg(not(target_os = ": "",
        "))]\n    #[arg(hide = true)]\n    askpass: Option<String>,\n\n    #[arg(long, hide = true)]\n    dump_all_actions: bool,\n\n    /// Output current environment variables as JSON to stdout\n    #[arg(long, hide = true)]\n    printenv: bool,\n}\n\n#[derive(Clone, Debug)]\nenum IdType {\n    New(String),\n    Existing(String),\n}\n\nimpl ToString for IdType {\n    fn to_string(&self) -> String {\n        match self {\n            IdType::New(id) | IdType::Existing(id) => id.clone(),\n        }\n    }\n}\n\nfn parse_url_arg(arg: &str, cx: &App) -> String {\n    match std::fs::canonicalize(Path::new(&arg)) {\n        Ok(path) => format!(": "",
        ", path.display()),\n        Err(_) => {\n            if arg.starts_with(": "",
        ")\n                || arg.starts_with(": "",
        ")\n                || parse_zed_link(arg, cx).is_some()\n            {\n                arg.into()\n            } else {\n                format!(": "",
        ")\n            }\n        }\n    }\n}\n\nfn load_embedded_fonts(cx: &App) {\n    let asset_source = cx.asset_source();\n    let font_paths = asset_source.list(": "",
        ").unwrap();\n    let embedded_fonts = Mutex::new(Vec::new());\n    let executor = cx.background_executor();\n\n    executor.block(executor.scoped(|scope| {\n        for font_path in &font_paths {\n            if !font_path.ends_with(": "",
        ") {\n                continue;\n            }\n\n            scope.spawn(async {\n                let font_bytes = asset_source.load(font_path).unwrap().unwrap();\n                embedded_fonts.lock().push(font_bytes);\n            });\n        }\n    }));\n\n    cx.text_system()\n        .add_fonts(embedded_fonts.into_inner())\n        .unwrap();\n}\n\n/// Spawns a background task to load the user themes from the themes directory.\nfn load_user_themes_in_background(fs: Arc<dyn fs::Fs>, cx: &mut App) {\n    cx.spawn({\n        let fs = fs.clone();\n        async move |cx| {\n            if let Some(theme_registry) = cx.update(|cx| ThemeRegistry::global(cx)).log_err() {\n                let themes_dir = paths::themes_dir().as_ref();\n                match fs\n                    .metadata(themes_dir)\n                    .await\n                    .ok()\n                    .flatten()\n                    .map(|m| m.is_dir)\n                {\n                    Some(is_dir) => {\n                        anyhow::ensure!(is_dir, ": "",
        ")\n                    }\n                    None => {\n                        fs.create_dir(themes_dir).await.with_context(|| {\n                            format!(": "",
        ")\n                        })?;\n                    }\n                }\n                theme_registry.load_user_themes(themes_dir, fs).await?;\n                cx.update(GlobalTheme::reload_theme)?;\n            }\n            anyhow::Ok(())\n        }\n    })\n    .detach_and_log_err(cx);\n}\n\n/// Spawns a background task to watch the themes directory for changes.\nfn watch_themes(fs: Arc<dyn fs::Fs>, cx: &mut App) {\n    use std::time::Duration;\n    cx.spawn(async move |cx| {\n        let (mut events, _) = fs\n            .watch(paths::themes_dir(), Duration::from_millis(100))\n            .await;\n\n        while let Some(paths) = events.next().await {\n            for event in paths {\n                if fs.metadata(&event.path).await.ok().flatten().is_some()\n                    && let Some(theme_registry) =\n                        cx.update(|cx| ThemeRegistry::global(cx)).log_err()\n                    && let Some(()) = theme_registry\n                        .load_user_theme(&event.path, fs.clone())\n                        .await\n                        .log_err()\n                {\n                    cx.update(GlobalTheme::reload_theme).log_err();\n                }\n            }\n        }\n    })\n    .detach()\n}\n\n#[cfg(debug_assertions)]\nfn watch_languages(fs: Arc<dyn fs::Fs>, languages: Arc<LanguageRegistry>, cx: &mut App) {\n    use std::time::Duration;\n\n    cx.background_spawn(async move {\n        let languages_src = Path::new(": "",
        ");\n        let Some(languages_src) = fs.canonicalize(languages_src).await.log_err() else {\n            return;\n        };\n\n        let (mut events, watcher) = fs.watch(&languages_src, Duration::from_millis(100)).await;\n\n        // add subdirectories since fs.watch is not recursive on Linux\n        if let Some(mut paths) = fs.read_dir(&languages_src).await.log_err() {\n            while let Some(path) = paths.next().await {\n                if let Some(path) = path.log_err()\n                    && fs.is_dir(&path).await\n                {\n                    watcher.add(&path).log_err();\n                }\n            }\n        }\n\n        while let Some(event) = events.next().await {\n            let has_language_file = event\n                .iter()\n                .any(|event| event.path.extension().is_some_and(|ext| ext == ": "",
        "));\n            if has_language_file {\n                languages.reload();\n            }\n        }\n    })\n    .detach();\n}\n\n#[cfg(not(debug_assertions))]\nfn watch_languages(_fs: Arc<dyn fs::Fs>, _languages: Arc<LanguageRegistry>, _cx: &mut App) {}\n\nfn dump_all_gpui_actions() {\n    #[derive(Debug, serde::Serialize)]\n    struct ActionDef {\n        name: &'static str,\n        human_name: String,\n        aliases: &'static [&'static str],\n        documentation: Option<&'static str>,\n    }\n    let mut actions = gpui::generate_list_of_all_registered_actions()\n        .map(|action| ActionDef {\n            name: action.name,\n            human_name: command_palette::humanize_action_name(action.name),\n            aliases: action.deprecated_aliases,\n            documentation: action.documentation,\n        })\n        .collect::<Vec<ActionDef>>();\n\n    actions.sort_by_key(|a| a.name);\n\n    io::Write::write(\n        &mut std::io::stdout(),\n        serde_json::to_string_pretty(&actions).unwrap().as_bytes(),\n    )\n    .unwrap();\n}\n\n#[cfg(target_os = ": "",
        ")]\nfn check_for_conpty_dll() {\n    use windows::{\n        Win32::{Foundation::FreeLibrary, System::LibraryLoader::LoadLibraryW},\n        core::w,\n    };\n\n    if let Ok(hmodule) = unsafe { LoadLibraryW(w!(": "",
        ")) } {\n        unsafe {\n            FreeLibrary(hmodule)\n                .context(": "",
        ")\n                .log_err();\n        }\n    } else {\n        log::warn!(": ""
    },
    "zed/crates/zed/src/reliability.rs": {
        "C": "",
        "Suspected hang on main thread:\\n{}": "",
        "/telemetry/hangs": "",
        "x-zed-checksum": "",
        "Failed to send hang report: HTTP {:?}": "",
        "Minidump endpoint not set": "",
        "dmp": "",
        "json": "",
        "Failed to read minidump": "",
        "upload_file_minidump": "",
        "minidump.dmp": "",
        "application/octet-stream": "",
        "sentry[tags][channel]": "",
        "sentry[tags][version]": "",
        "sentry[tags][binary]": "",
        "sentry[release]": "",
        "platform": "",
        "rust": "",
        "sentry[logentry][formatted]": "",
        "span": "",
        "minidump_error": "",
        "sentry[user][id]": "",
        "Minidump Uploaded": "",
        "gpu{num}": "",
        "sentry[contexts][{name}]": "",
        "{root}[Description]": "",
        "A GPU found on the users system. May or may not be the GPU Zed is running on": "",
        "{root}[type]": "",
        "gpu": "",
        "{root}[name]": "",
        "{root}[id]": "",
        "{:#06x}": "",
        "{root}[vendor_id]": "",
        "{root}[vendor_name]": "",
        "{root}[driver_version]": "",
        "{root}[driver_name]": "",
        "sentry[contexts][Active_GPU][Description]": "",
        "The GPU Zed is running on": "",
        "sentry[contexts][Active_GPU][type]": "",
        "sentry[contexts][Active_GPU][name]": "",
        "sentry[contexts][Active_GPU][driver_version]": "",
        "sentry[contexts][Active_GPU][driver_name]": "",
        "sentry[contexts][Active_GPU][is_software_emulated]": "",
        "failed to upload minidump: {response_text}": "",
        "Uploaded minidump. event id: {response_text}": ""
    },
    "zed/crates/zed/src/zed.rs": {
        "Ran the TestPanic action": "",
        "C": "",
        "licenses.md": "",
        "Open Source License Attribution": "",
        "Default Settings": "",
        "JSON": "",
        "Default Key Bindings": "",
        "ZED_WINDOW_DECORATIONS": "",
        "server": "",
        "client": "",
        "Using GPU: {:?}": "",
        "Failed to store active gpu info for crash reporting: {}": "",
        "\n            inotify_init returned {}\n\n            This may be due to system-wide limits on inotify instances. For troubleshooting see: https://zed.dev/docs/linux\n            ": "",
        "Could not start inotify": "",
        "Troubleshoot and Quit": "",
        "\n            ReadDirectoryChangesW initialization failed: {}\n\n            This may occur on network filesystems and WSL paths. For troubleshooting see: https://zed.dev/docs/windows\n            ": "",
        "Could not start ReadDirectoryChangesW": "",
        "ZED_ALLOW_EMULATED_GPU": "",
        "DirectX": "",
        "Vulkan": "",
        "\n            Zed uses {} for rendering and requires a compatible GPU.\n\n            Currently you are using a software emulated GPU ({}) which\n            will result in awful performance.\n\n            For troubleshooting see: {}\n            Set ZED_ALLOW_EMULATED_GPU=1 env var to permanently override.\n            ": "",
        "Unsupported GPU": "",
        "Skip": "",
        "Project Opened": "",
        "zed:// links will now open in {}.": "",
        "Error registering zed:// scheme": "",
        "Settings file must have a location": "",
        "CARGO_PKG_VERSION": "",
        "(debug)": "",
        "{release_channel} {version} {debug}": "",
        "Copy": "",
        "OK": "",
        "{}\\n{}": "",
        "Are you sure you want to quit?": "",
        "Quit": "",
        "Cancel": "",
        "log": "",
        "Unable to access/open log file at path {:?}": "",
        "Log": "",
        "Last {} lines in {}": "",
        "failed-to-migrate-settings": "",
        "\n                            ),\n                            cx,\n                        )\n                        .primary_message(": "",
        ")\n                        .primary_icon(IconName::Settings)\n                        .primary_on_click(|window, cx| {\n                            window.dispatch_action(zed_actions::OpenSettingsFile.boxed_clone(), cx);\n                            cx.emit(DismissEvent);\n                        })\n                    })\n                });\n                // notify user here\n                false\n            }\n        };\n\n        if let settings::ParseStatus::Failed { error: err } = &result.parse_status {\n            let settings_type = if is_user { ": "",
        " } else { ": "",
        " };\n            log::error!(": "",
        ", settings_type);\n        }\n\n        settings_changed(\n            match result.parse_status {\n                settings::ParseStatus::Failed { error } => Some(anyhow::format_err!(error)),\n                settings::ParseStatus::Success => None,\n            },\n            cx,\n        );\n\n        content_migrated\n    };\n\n    // Initial load of both settings files\n    let global_content = cx\n        .background_executor()\n        .block(global_settings_file_rx.next())\n        .unwrap();\n    let user_content = cx\n        .background_executor()\n        .block(user_settings_file_rx.next())\n        .unwrap();\n\n    SettingsStore::update_global(cx, |store, cx| {\n        process_settings(global_content, false, store, cx);\n        process_settings(user_content, true, store, cx);\n    });\n\n    // Watch for changes in both files\n    cx.spawn(async move |cx| {\n        let mut settings_streams = futures::stream::select(\n            global_settings_file_rx.map(Either::Left),\n            user_settings_file_rx.map(Either::Right),\n        );\n\n        while let Some(content) = settings_streams.next().await {\n            let (content, is_user) = match content {\n                Either::Left(content) => (content, false),\n                Either::Right(content) => (content, true),\n            };\n\n            let result = cx.update_global(|store: &mut SettingsStore, cx| {\n                let migrating_in_memory = process_settings(content, is_user, store, cx);\n                if let Some(notifier) = MigrationNotification::try_global(cx) {\n                    notifier.update(cx, |_, cx| {\n                        cx.emit(MigrationEvent::ContentChanged {\n                            migration_type: MigrationType::Settings,\n                            migrating_in_memory,\n                        });\n                    });\n                }\n                cx.refresh_windows();\n            });\n\n            if result.is_err() {\n                break; // App dropped\n            }\n        }\n    })\n    .detach();\n}\n\npub fn handle_keymap_file_changes(\n    mut user_keymap_file_rx: mpsc::UnboundedReceiver<String>,\n    cx: &mut App,\n) {\n    let (base_keymap_tx, mut base_keymap_rx) = mpsc::unbounded();\n    let (keyboard_layout_tx, mut keyboard_layout_rx) = mpsc::unbounded();\n    let mut old_base_keymap = *BaseKeymap::get_global(cx);\n    let mut old_vim_enabled = VimModeSetting::get_global(cx).0;\n    let mut old_helix_enabled = vim_mode_setting::HelixModeSetting::get_global(cx).0;\n\n    cx.observe_global::<SettingsStore>(move |cx| {\n        let new_base_keymap = *BaseKeymap::get_global(cx);\n        let new_vim_enabled = VimModeSetting::get_global(cx).0;\n        let new_helix_enabled = vim_mode_setting::HelixModeSetting::get_global(cx).0;\n\n        if new_base_keymap != old_base_keymap\n            || new_vim_enabled != old_vim_enabled\n            || new_helix_enabled != old_helix_enabled\n        {\n            old_base_keymap = new_base_keymap;\n            old_vim_enabled = new_vim_enabled;\n            old_helix_enabled = new_helix_enabled;\n\n            base_keymap_tx.unbounded_send(()).unwrap();\n        }\n    })\n    .detach();\n\n    #[cfg(target_os = ": "",
        ")]\n    {\n        let mut current_layout_id = cx.keyboard_layout().id().to_string();\n        cx.on_keyboard_layout_change(move |cx| {\n            let next_layout_id = cx.keyboard_layout().id();\n            if next_layout_id != current_layout_id {\n                current_layout_id = next_layout_id.to_string();\n                keyboard_layout_tx.unbounded_send(()).ok();\n            }\n        })\n        .detach();\n    }\n\n    #[cfg(not(target_os = ": "",
        "))]\n    {\n        let mut current_mapping = cx.keyboard_mapper().get_key_equivalents().cloned();\n        cx.on_keyboard_layout_change(move |cx| {\n            let next_mapping = cx.keyboard_mapper().get_key_equivalents();\n            if current_mapping.as_ref() != next_mapping {\n                current_mapping = next_mapping.cloned();\n                keyboard_layout_tx.unbounded_send(()).ok();\n            }\n        })\n        .detach();\n    }\n\n    load_default_keymap(cx);\n\n    struct KeymapParseErrorNotification;\n    let notification_id = NotificationId::unique::<KeymapParseErrorNotification>();\n\n    cx.spawn(async move |cx| {\n        let mut user_keymap_content = String::new();\n        let mut migrating_in_memory = false;\n        loop {\n            select_biased! {\n                _ = base_keymap_rx.next() => {},\n                _ = keyboard_layout_rx.next() => {},\n                content = user_keymap_file_rx.next() => {\n                    if let Some(content) = content {\n                        if let Ok(Some(migrated_content)) = migrate_keymap(&content) {\n                            user_keymap_content = migrated_content;\n                            migrating_in_memory = true;\n                        } else {\n                            user_keymap_content = content;\n                            migrating_in_memory = false;\n                        }\n                    }\n                }\n            };\n            cx.update(|cx| {\n                if let Some(notifier) = MigrationNotification::try_global(cx) {\n                    notifier.update(cx, |_, cx| {\n                        cx.emit(MigrationEvent::ContentChanged {\n                            migration_type: MigrationType::Keymap,\n                            migrating_in_memory,\n                        });\n                    });\n                }\n                let load_result = KeymapFile::load(&user_keymap_content, cx);\n                match load_result {\n                    KeymapFileLoadResult::Success { key_bindings } => {\n                        reload_keymaps(cx, key_bindings);\n                        dismiss_app_notification(&notification_id.clone(), cx);\n                    }\n                    KeymapFileLoadResult::SomeFailedToLoad {\n                        key_bindings,\n                        error_message,\n                    } => {\n                        if !key_bindings.is_empty() {\n                            reload_keymaps(cx, key_bindings);\n                        }\n                        show_keymap_file_load_error(notification_id.clone(), error_message, cx);\n                    }\n                    KeymapFileLoadResult::JsonParseFailure { error } => {\n                        show_keymap_file_json_error(notification_id.clone(), &error, cx)\n                    }\n                }\n            })\n            .ok();\n        }\n    })\n    .detach();\n}\n\nfn show_keymap_file_json_error(\n    notification_id: NotificationId,\n    error: &anyhow::Error,\n    cx: &mut App,\n) {\n    let message: SharedString =\n        format!(": "",
        ").into();\n    show_app_notification(notification_id, cx, move |cx| {\n        cx.new(|cx| {\n            MessageNotification::new(message.clone(), cx)\n                .primary_message(": "",
        ")\n                .primary_on_click(|window, cx| {\n                    window.dispatch_action(zed_actions::OpenKeymapFile.boxed_clone(), cx);\n                    cx.emit(DismissEvent);\n                })\n        })\n    });\n}\n\nfn show_keymap_file_load_error(\n    notification_id: NotificationId,\n    error_message: MarkdownString,\n    cx: &mut App,\n) {\n    show_markdown_app_notification(\n        notification_id,\n        error_message,\n        ": "",
        ".into(),\n        |window, cx| {\n            window.dispatch_action(zed_actions::OpenKeymapFile.boxed_clone(), cx);\n            cx.emit(DismissEvent);\n        },\n        cx,\n    )\n}\n\nfn show_markdown_app_notification<F>(\n    notification_id: NotificationId,\n    message: MarkdownString,\n    primary_button_message: SharedString,\n    primary_button_on_click: F,\n    cx: &mut App,\n) where\n    F: 'static + Send + Sync + Fn(&mut Window, &mut Context<MessageNotification>),\n{\n    let parsed_markdown = cx.background_spawn(async move {\n        let file_location_directory = None;\n        let language_registry = None;\n        markdown_preview::markdown_parser::parse_markdown(\n            &message.0,\n            file_location_directory,\n            language_registry,\n        )\n        .await\n    });\n\n    cx.spawn(async move |cx| {\n        let parsed_markdown = Arc::new(parsed_markdown.await);\n        let primary_button_message = primary_button_message.clone();\n        let primary_button_on_click = Arc::new(primary_button_on_click);\n        cx.update(|cx| {\n            show_app_notification(notification_id, cx, move |cx| {\n                let workspace_handle = cx.entity().downgrade();\n                let parsed_markdown = parsed_markdown.clone();\n                let primary_button_message = primary_button_message.clone();\n                let primary_button_on_click = primary_button_on_click.clone();\n                cx.new(move |cx| {\n                    MessageNotification::new_from_builder(cx, move |window, cx| {\n                        image_cache(retain_all(": "",
        "))\n                            .text_xs()\n                            .child(markdown_preview::markdown_renderer::render_parsed_markdown(\n                                &parsed_markdown.clone(),\n                                Some(workspace_handle.clone()),\n                                window,\n                                cx,\n                            ))\n                            .into_any()\n                    })\n                    .primary_message(primary_button_message)\n                    .primary_on_click_arc(primary_button_on_click)\n                })\n            })\n        })\n        .ok();\n    })\n    .detach();\n}\n\nfn reload_keymaps(cx: &mut App, mut user_key_bindings: Vec<KeyBinding>) {\n    cx.clear_key_bindings();\n    load_default_keymap(cx);\n\n    for key_binding in &mut user_key_bindings {\n        key_binding.set_meta(KeybindSource::User.meta());\n    }\n    cx.bind_keys(user_key_bindings);\n\n    let menus = app_menus(cx);\n    cx.set_menus(menus);\n    // On Windows, this is set in the `update_jump_list` method of the `HistoryManager`.\n    #[cfg(not(target_os = ": "",
        "))]\n    cx.set_dock_menu(vec![gpui::MenuItem::action(\n        ": "",
        ",\n        workspace::NewWindow,\n    )]);\n    // todo: nicer api here?\n    keymap_editor::KeymapEventChannel::trigger_keymap_changed(cx);\n}\n\npub fn load_default_keymap(cx: &mut App) {\n    let base_keymap = *BaseKeymap::get_global(cx);\n    if base_keymap == BaseKeymap::None {\n        return;\n    }\n\n    cx.bind_keys(\n        KeymapFile::load_asset(DEFAULT_KEYMAP_PATH, Some(KeybindSource::Default), cx).unwrap(),\n    );\n\n    if let Some(asset_path) = base_keymap.asset_path() {\n        cx.bind_keys(KeymapFile::load_asset(asset_path, Some(KeybindSource::Base), cx).unwrap());\n    }\n\n    if VimModeSetting::get_global(cx).0 || vim_mode_setting::HelixModeSetting::get_global(cx).0 {\n        cx.bind_keys(\n            KeymapFile::load_asset(VIM_KEYMAP_PATH, Some(KeybindSource::Vim), cx).unwrap(),\n        );\n    }\n}\n\npub fn handle_settings_changed(error: Option<anyhow::Error>, cx: &mut App) {\n    struct SettingsParseErrorNotification;\n    let id = NotificationId::unique::<SettingsParseErrorNotification>();\n\n    match error {\n        Some(error) => {\n            if let Some(InvalidSettingsError::LocalSettings { .. }) =\n                error.downcast_ref::<InvalidSettingsError>()\n            {\n                // Local settings errors are displayed by the projects\n                return;\n            }\n            show_app_notification(id, cx, move |cx| {\n                cx.new(|cx| {\n                    MessageNotification::new(format!(": "",
        "), cx)\n                        .primary_message(": "",
        ")\n                        .primary_icon(IconName::Settings)\n                        .primary_on_click(|window, cx| {\n                            window.dispatch_action(zed_actions::OpenSettingsFile.boxed_clone(), cx);\n                            cx.emit(DismissEvent);\n                        })\n                })\n            });\n        }\n        None => {\n            dismiss_app_notification(&id, cx);\n        }\n    }\n}\n\npub fn open_new_ssh_project_from_project(\n    workspace: &mut Workspace,\n    paths: Vec<PathBuf>,\n    window: &mut Window,\n    cx: &mut Context<Workspace>,\n) -> Task<anyhow::Result<()>> {\n    let app_state = workspace.app_state().clone();\n    let Some(ssh_client) = workspace.project().read(cx).remote_client() else {\n        return Task::ready(Err(anyhow::anyhow!(": "",
        ")));\n    };\n    let connection_options = ssh_client.read(cx).connection_options();\n    cx.spawn_in(window, async move |_, cx| {\n        open_remote_project(\n            connection_options,\n            paths,\n            app_state,\n            workspace::OpenOptions {\n                open_new_workspace: Some(true),\n                ..Default::default()\n            },\n            cx,\n        )\n        .await\n    })\n}\n\nfn open_project_settings_file(\n    workspace: &mut Workspace,\n    _: &OpenProjectSettings,\n    window: &mut Window,\n    cx: &mut Context<Workspace>,\n) {\n    open_local_file(\n        workspace,\n        local_settings_file_relative_path(),\n        initial_project_settings_content(),\n        window,\n        cx,\n    )\n}\n\nfn open_project_tasks_file(\n    workspace: &mut Workspace,\n    _: &OpenProjectTasks,\n    window: &mut Window,\n    cx: &mut Context<Workspace>,\n) {\n    open_local_file(\n        workspace,\n        local_tasks_file_relative_path(),\n        initial_tasks_content(),\n        window,\n        cx,\n    )\n}\n\nfn open_project_debug_tasks_file(\n    workspace: &mut Workspace,\n    _: &zed_actions::OpenProjectDebugTasks,\n    window: &mut Window,\n    cx: &mut Context<Workspace>,\n) {\n    open_local_file(\n        workspace,\n        local_debug_file_relative_path(),\n        initial_local_debug_tasks_content(),\n        window,\n        cx,\n    )\n}\n\nfn open_local_file(\n    workspace: &mut Workspace,\n    settings_relative_path: &'static RelPath,\n    initial_contents: Cow<'static, str>,\n    window: &mut Window,\n    cx: &mut Context<Workspace>,\n) {\n    let project = workspace.project().clone();\n    let worktree = project\n        .read(cx)\n        .visible_worktrees(cx)\n        .find_map(|tree| tree.read(cx).root_entry()?.is_dir().then_some(tree));\n    if let Some(worktree) = worktree {\n        let tree_id = worktree.read(cx).id();\n        cx.spawn_in(window, async move |workspace, cx| {\n            // Check if the file actually exists on disk (even if it's excluded from worktree)\n            let file_exists = {\n                let full_path = worktree.read_with(cx, |tree, _| {\n                    tree.abs_path().join(settings_relative_path.as_std_path())\n                })?;\n\n                let fs = project.read_with(cx, |project, _| project.fs().clone())?;\n\n                fs.metadata(&full_path)\n                    .await\n                    .ok()\n                    .flatten()\n                    .is_some_and(|metadata| !metadata.is_dir && !metadata.is_fifo)\n            };\n\n            if !file_exists {\n                if let Some(dir_path) = settings_relative_path.parent()\n                    && worktree.read_with(cx, |tree, _| tree.entry_for_path(dir_path).is_none())?\n                {\n                    project\n                        .update(cx, |project, cx| {\n                            project.create_entry((tree_id, dir_path), true, cx)\n                        })?\n                        .await\n                        .context(": "",
        ")?;\n                }\n\n                if worktree.read_with(cx, |tree, _| {\n                    tree.entry_for_path(settings_relative_path).is_none()\n                })? {\n                    project\n                        .update(cx, |project, cx| {\n                            project.create_entry((tree_id, settings_relative_path), false, cx)\n                        })?\n                        .await\n                        .context(": "",
        ")?;\n                }\n            }\n\n            let editor = workspace\n                .update_in(cx, |workspace, window, cx| {\n                    workspace.open_path((tree_id, settings_relative_path), None, true, window, cx)\n                })?\n                .await?\n                .downcast::<Editor>()\n                .context(": "",
        ")?;\n\n            editor\n                .downgrade()\n                .update(cx, |editor, cx| {\n                    if let Some(buffer) = editor.buffer().read(cx).as_singleton()\n                        && buffer.read(cx).is_empty()\n                    {\n                        buffer.update(cx, |buffer, cx| {\n                            buffer.edit([(0..0, initial_contents)], None, cx)\n                        });\n                    }\n                })\n                .ok();\n\n            anyhow::Ok(())\n        })\n        .detach();\n    } else {\n        struct NoOpenFolders;\n\n        workspace.show_notification(NotificationId::unique::<NoOpenFolders>(), cx, |cx| {\n            cx.new(|cx| MessageNotification::new(": "",
        ", cx))\n        })\n    }\n}\n\nfn open_telemetry_log_file(\n    workspace: &mut Workspace,\n    window: &mut Window,\n    cx: &mut Context<Workspace>,\n) {\n    workspace.with_local_workspace(window, cx, move |workspace, window, cx| {\n        let app_state = workspace.app_state().clone();\n        cx.spawn_in(window, async move |workspace, cx| {\n            async fn fetch_log_string(app_state: &Arc<AppState>) -> Option<String> {\n                let path = client::telemetry::Telemetry::log_file_path();\n                app_state.fs.load(&path).await.log_err()\n            }\n\n            let log = fetch_log_string(&app_state).await.unwrap_or_else(|| ": "",
        ".to_string());\n\n            const MAX_TELEMETRY_LOG_LEN: usize = 5 * 1024 * 1024;\n            let mut start_offset = log.len().saturating_sub(MAX_TELEMETRY_LOG_LEN);\n            if let Some(newline_offset) = log[start_offset..].find('\\n') {\n                start_offset += newline_offset + 1;\n            }\n            let log_suffix = &log[start_offset..];\n            let header = concat!(\n                ": "",
        ",\n                ": "",
        ",\n            );\n            let content = format!(": "",
        ", header, log_suffix);\n            let json = app_state.languages.language_for_name(": "",
        ").await.log_err();\n\n            workspace.update_in( cx, |workspace, window, cx| {\n                let project = workspace.project().clone();\n                let buffer = project.update(cx, |project, cx| project.create_local_buffer(&content, json,false, cx));\n                let buffer = cx.new(|cx| {\n                    MultiBuffer::singleton(buffer, cx).with_title(": "",
        ".into())\n                });\n                workspace.add_item_to_active_pane(\n                    Box::new(cx.new(|cx| {\n                        let mut editor = Editor::for_multibuffer(buffer, Some(project), window, cx);\n                        editor.set_read_only(true);\n                        editor.set_breadcrumb_header(": "",
        ".into());\n                        editor\n                    })),\n                    None,\n                    true,\n                    window, cx,\n                );\n            }).log_err()?;\n\n            Some(())\n        })\n        .detach();\n    }).detach();\n}\n\nfn open_bundled_file(\n    workspace: &Workspace,\n    text: Cow<'static, str>,\n    title: &'static str,\n    language: &'static str,\n    window: &mut Window,\n    cx: &mut Context<Workspace>,\n) {\n    let language = workspace.app_state().languages.language_for_name(language);\n    cx.spawn_in(window, async move |workspace, cx| {\n        let language = language.await.log_err();\n        workspace\n            .update_in(cx, |workspace, window, cx| {\n                workspace.with_local_workspace(window, cx, |workspace, window, cx| {\n                    let project = workspace.project();\n                    let buffer = project.update(cx, move |project, cx| {\n                        let buffer =\n                            project.create_local_buffer(text.as_ref(), language, false, cx);\n                        buffer.update(cx, |buffer, cx| {\n                            buffer.set_capability(Capability::ReadOnly, cx);\n                        });\n                        buffer\n                    });\n                    let buffer =\n                        cx.new(|cx| MultiBuffer::singleton(buffer, cx).with_title(title.into()));\n                    workspace.add_item_to_active_pane(\n                        Box::new(cx.new(|cx| {\n                            let mut editor =\n                                Editor::for_multibuffer(buffer, Some(project.clone()), window, cx);\n                            editor.set_read_only(true);\n                            editor.set_should_serialize(false, cx);\n                            editor.set_breadcrumb_header(title.into());\n                            editor\n                        })),\n                        None,\n                        true,\n                        window,\n                        cx,\n                    );\n                })\n            })?\n            .await\n    })\n    .detach_and_log_err(cx);\n}\n\nfn open_settings_file(\n    abs_path: &'static Path,\n    default_content: impl FnOnce() -> Rope + Send + 'static,\n    window: &mut Window,\n    cx: &mut Context<Workspace>,\n) {\n    cx.spawn_in(window, async move |workspace, cx| {\n        let (worktree_creation_task, settings_open_task) = workspace\n            .update_in(cx, |workspace, window, cx| {\n                workspace.with_local_workspace(window, cx, move |workspace, window, cx| {\n                    let worktree_creation_task = workspace.project().update(cx, |project, cx| {\n                        // Set up a dedicated worktree for settings, since\n                        // otherwise we're dropping and re-starting LSP servers\n                        // for each file inside on every settings file\n                        // close/open\n\n                        // TODO: Do note that all other external files (e.g.\n                        // drag and drop from OS) still have their worktrees\n                        // released on file close, causing LSP servers'\n                        // restarts.\n                        project.find_or_create_worktree(paths::config_dir().as_path(), false, cx)\n                    });\n                    let settings_open_task =\n                        create_and_open_local_file(abs_path, window, cx, default_content);\n                    (worktree_creation_task, settings_open_task)\n                })\n            })?\n            .await?;\n        let _ = worktree_creation_task.await?;\n        let _ = settings_open_task.await?;\n        anyhow::Ok(())\n    })\n    .detach_and_log_err(cx);\n}\n\nfn capture_recent_audio(workspace: &mut Workspace, _: &mut Window, cx: &mut Context<Workspace>) {\n    struct CaptureRecentAudioNotification {\n        focus_handle: gpui::FocusHandle,\n        save_result: Option<Result<(PathBuf, Duration), anyhow::Error>>,\n        _save_task: Task<anyhow::Result<()>>,\n    }\n\n    impl gpui::EventEmitter<DismissEvent> for CaptureRecentAudioNotification {}\n    impl gpui::EventEmitter<SuppressEvent> for CaptureRecentAudioNotification {}\n    impl gpui::Focusable for CaptureRecentAudioNotification {\n        fn focus_handle(&self, _cx: &App) -> gpui::FocusHandle {\n            self.focus_handle.clone()\n        }\n    }\n    impl workspace::notifications::Notification for CaptureRecentAudioNotification {}\n\n    impl Render for CaptureRecentAudioNotification {\n        fn render(&mut self, _window: &mut Window, cx: &mut Context<Self>) -> impl IntoElement {\n            let message = match &self.save_result {\n                None => format!(\n                    ": "",
        ",\n                    REPLAY_DURATION.as_secs(),\n                ),\n                Some(Ok((path, duration))) => format!(\n                    ": "",
        ",\n                    duration.as_secs(),\n                    path.display(),\n                ),\n                Some(Err(e)) => format!(": "",
        "),\n            };\n\n            NotificationFrame::new()\n                .with_title(Some(": "",
        "))\n                .show_suppress_button(false)\n                .on_close(cx.listener(|_, _, _, cx| {\n                    cx.emit(DismissEvent);\n                }))\n                .with_content(message)\n        }\n    }\n\n    impl CaptureRecentAudioNotification {\n        fn new(cx: &mut Context<Self>) -> Self {\n            if AudioSettings::get_global(cx).rodio_audio {\n                let executor = cx.background_executor().clone();\n                let save_task = cx.default_global::<audio::Audio>().save_replays(executor);\n                let _save_task = cx.spawn(async move |this, cx| {\n                    let res = save_task.await;\n                    this.update(cx, |this, cx| {\n                        this.save_result = Some(res);\n                        cx.notify();\n                    })\n                });\n\n                Self {\n                    focus_handle: cx.focus_handle(),\n                    _save_task,\n                    save_result: None,\n                }\n            } else {\n                Self {\n                    focus_handle: cx.focus_handle(),\n                    _save_task: Task::ready(Ok(())),\n                    save_result: Some(Err(anyhow::anyhow!(\n                        ": "",
        "\n                    ))),\n                }\n            }\n        }\n    }\n\n    workspace.show_notification(\n        NotificationId::unique::<CaptureRecentAudioNotification>(),\n        cx,\n        |cx| cx.new(CaptureRecentAudioNotification::new),\n    );\n}\n\n/// Eagerly loads the active theme and icon theme based on the selections in the\n/// theme settings.\n///\n/// This fast path exists to load these themes as soon as possible so the user\n/// doesn't see the default themes while waiting on extensions to load.\npub(crate) fn eager_load_active_theme_and_icon_theme(fs: Arc<dyn Fs>, cx: &mut App) {\n    let extension_store = ExtensionStore::global(cx);\n    let theme_registry = ThemeRegistry::global(cx);\n    let theme_settings = ThemeSettings::get_global(cx);\n    let appearance = SystemAppearance::global(cx).0;\n\n    enum LoadTarget {\n        Theme(PathBuf),\n        IconTheme((PathBuf, PathBuf)),\n    }\n\n    let theme_name = theme_settings.theme.name(appearance);\n    let icon_theme_name = theme_settings.icon_theme.name(appearance);\n    let themes_to_load = [\n        theme_registry\n            .get(&theme_name.0)\n            .is_err()\n            .then(|| {\n                extension_store\n                    .read(cx)\n                    .path_to_extension_theme(&theme_name.0)\n            })\n            .flatten()\n            .map(LoadTarget::Theme),\n        theme_registry\n            .get_icon_theme(&icon_theme_name.0)\n            .is_err()\n            .then(|| {\n                extension_store\n                    .read(cx)\n                    .path_to_extension_icon_theme(&icon_theme_name.0)\n            })\n            .flatten()\n            .map(LoadTarget::IconTheme),\n    ];\n\n    enum ReloadTarget {\n        Theme,\n        IconTheme,\n    }\n\n    let executor = cx.background_executor();\n    let reload_tasks = parking_lot::Mutex::new(Vec::with_capacity(themes_to_load.len()));\n\n    let mut themes_to_load = themes_to_load.into_iter().flatten().peekable();\n\n    if themes_to_load.peek().is_none() {\n        return;\n    }\n\n    executor.block(executor.scoped(|scope| {\n        for load_target in themes_to_load {\n            let theme_registry = &theme_registry;\n            let reload_tasks = &reload_tasks;\n            let fs = fs.clone();\n\n            scope.spawn(async {\n                match load_target {\n                    LoadTarget::Theme(theme_path) => {\n                        if theme_registry\n                            .load_user_theme(&theme_path, fs)\n                            .await\n                            .log_err()\n                            .is_some()\n                        {\n                            reload_tasks.lock().push(ReloadTarget::Theme);\n                        }\n                    }\n                    LoadTarget::IconTheme((icon_theme_path, icons_root_path)) => {\n                        if theme_registry\n                            .load_icon_theme(&icon_theme_path, &icons_root_path, fs)\n                            .await\n                            .log_err()\n                            .is_some()\n                        {\n                            reload_tasks.lock().push(ReloadTarget::IconTheme);\n                        }\n                    }\n                }\n            });\n        }\n    }));\n\n    for reload_target in reload_tasks.into_inner() {\n        match reload_target {\n            ReloadTarget::Theme => GlobalTheme::reload_theme(cx),\n            ReloadTarget::IconTheme => GlobalTheme::reload_icon_theme(cx),\n        };\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use assets::Assets;\n    use collections::HashSet;\n    use editor::{DisplayPoint, Editor, SelectionEffects, display_map::DisplayRow};\n    use gpui::{\n        Action, AnyWindowHandle, App, AssetSource, BorrowAppContext, SemanticVersion,\n        TestAppContext, UpdateGlobal, VisualTestContext, WindowHandle, actions,\n    };\n    use language::{LanguageMatcher, LanguageRegistry};\n    use pretty_assertions::{assert_eq, assert_ne};\n    use project::{Project, ProjectPath};\n    use serde_json::json;\n    use settings::{SettingsStore, watch_config_file};\n    use std::{\n        path::{Path, PathBuf},\n        time::Duration,\n    };\n    use theme::ThemeRegistry;\n    use util::{\n        path,\n        rel_path::{RelPath, rel_path},\n    };\n    use workspace::{\n        NewFile, OpenOptions, OpenVisible, SERIALIZATION_THROTTLE_TIME, SaveIntent, SplitDirection,\n        WorkspaceHandle,\n        item::SaveOptions,\n        item::{Item, ItemHandle},\n        open_new, open_paths, pane,\n    };\n\n    #[gpui::test]\n    async fn test_open_non_existing_file(cx: &mut TestAppContext) {\n        let app_state = init_test(cx);\n        app_state\n            .fs\n            .as_fake()\n            .insert_tree(\n                path!(": "",
        "),\n                json!({\n                    ": "",
        ": {\n                    },\n                }),\n            )\n            .await;\n\n        cx.update(|cx| {\n            open_paths(\n                &[PathBuf::from(path!(": "",
        "))],\n                app_state.clone(),\n                workspace::OpenOptions::default(),\n                cx,\n            )\n        })\n        .await\n        .unwrap();\n        assert_eq!(cx.read(|cx| cx.windows().len()), 1);\n\n        let workspace = cx.windows()[0].downcast::<Workspace>().unwrap();\n        workspace\n            .update(cx, |workspace, _, cx| {\n                assert!(workspace.active_item_as::<Editor>(cx).is_some())\n            })\n            .unwrap();\n    }\n\n    #[gpui::test]\n    async fn test_open_paths_action(cx: &mut TestAppContext) {\n        let app_state = init_test(cx);\n        app_state\n            .fs\n            .as_fake()\n            .insert_tree(\n                ": "",
        ",\n                json!({\n                    ": "",
        ": {\n                        ": "",
        ": null,\n                        ": "",
        ": null,\n                    },\n                    ": "",
        ": null,\n                    }\n                }),\n            )\n            .await;\n\n        cx.update(|cx| {\n            open_paths(\n                &[PathBuf::from(": "",
        "), PathBuf::from(": "",
        ")],\n                app_state.clone(),\n                workspace::OpenOptions::default(),\n                cx,\n            )\n        })\n        .await\n        .unwrap();\n        assert_eq!(cx.read(|cx| cx.windows().len()), 1);\n\n        cx.update(|cx| {\n            open_paths(\n                &[PathBuf::from(": "",
        ")],\n                app_state.clone(),\n                workspace::OpenOptions::default(),\n                cx,\n            )\n        })\n        .await\n        .unwrap();\n        assert_eq!(cx.read(|cx| cx.windows().len()), 1);\n        let workspace_1 = cx\n            .read(|cx| cx.windows()[0].downcast::<Workspace>())\n            .unwrap();\n        cx.run_until_parked();\n        workspace_1\n            .update(cx, |workspace, window, cx| {\n                assert_eq!(workspace.worktrees(cx).count(), 2);\n                assert!(workspace.left_dock().read(cx).is_open());\n                assert!(\n                    workspace\n                        .active_pane()\n                        .read(cx)\n                        .focus_handle(cx)\n                        .is_focused(window)\n                );\n            })\n            .unwrap();\n\n        cx.update(|cx| {\n            open_paths(\n                &[PathBuf::from(": "",
        ")],\n                app_state.clone(),\n                workspace::OpenOptions::default(),\n                cx,\n            )\n        })\n        .await\n        .unwrap();\n        assert_eq!(cx.read(|cx| cx.windows().len()), 2);\n\n        // Replace existing windows\n        let window = cx\n            .update(|cx| cx.windows()[0].downcast::<Workspace>())\n            .unwrap();\n        cx.update(|cx| {\n            open_paths(\n                &[PathBuf::from(": "",
        ")],\n                app_state,\n                workspace::OpenOptions {\n                    replace_window: Some(window),\n                    ..Default::default()\n                },\n                cx,\n            )\n        })\n        .await\n        .unwrap();\n        cx.background_executor.run_until_parked();\n        assert_eq!(cx.read(|cx| cx.windows().len()), 2);\n        let workspace_1 = cx\n            .update(|cx| cx.windows()[0].downcast::<Workspace>())\n            .unwrap();\n        workspace_1\n            .update(cx, |workspace, window, cx| {\n                assert_eq!(\n                    workspace\n                        .worktrees(cx)\n                        .map(|w| w.read(cx).abs_path())\n                        .collect::<Vec<_>>(),\n                    &[Path::new(": "",
        ").into()]\n                );\n                assert!(workspace.left_dock().read(cx).is_open());\n                assert!(workspace.active_pane().focus_handle(cx).is_focused(window));\n            })\n            .unwrap();\n    }\n\n    #[gpui::test]\n    async fn test_open_add_new(cx: &mut TestAppContext) {\n        let app_state = init_test(cx);\n        app_state\n            .fs\n            .as_fake()\n            .insert_tree(\n                path!(": "",
        "),\n                json!({": "",
        ": ": "",
        ", ": "",
        ": {": "",
        "}}),\n            )\n            .await;\n\n        cx.update(|cx| {\n            open_paths(\n                &[PathBuf::from(path!(": "",
        "))],\n                app_state.clone(),\n                workspace::OpenOptions::default(),\n                cx,\n            )\n        })\n        .await\n        .unwrap();\n        assert_eq!(cx.update(|cx| cx.windows().len()), 1);\n\n        cx.update(|cx| {\n            open_paths(\n                &[PathBuf::from(path!(": "",
        "))],\n                app_state.clone(),\n                workspace::OpenOptions {\n                    open_new_workspace: Some(false),\n                    ..Default::default()\n                },\n                cx,\n            )\n        })\n        .await\n        .unwrap();\n        assert_eq!(cx.update(|cx| cx.windows().len()), 1);\n\n        cx.update(|cx| {\n            open_paths(\n                &[PathBuf::from(path!(": "",
        "))],\n                app_state.clone(),\n                workspace::OpenOptions {\n                    open_new_workspace: Some(true),\n                    ..Default::default()\n                },\n                cx,\n            )\n        })\n        .await\n        .unwrap();\n        assert_eq!(cx.update(|cx| cx.windows().len()), 2);\n    }\n\n    #[gpui::test]\n    async fn test_open_file_in_many_spaces(cx: &mut TestAppContext) {\n        let app_state = init_test(cx);\n        app_state\n            .fs\n            .as_fake()\n            .insert_tree(\n                path!(": "",
        "}, ": "",
        "))],\n                app_state.clone(),\n                workspace::OpenOptions::default(),\n                cx,\n            )\n        })\n        .await\n        .unwrap();\n        assert_eq!(cx.update(|cx| cx.windows().len()), 1);\n        let window1 = cx.update(|cx| cx.active_window().unwrap());\n\n        cx.update(|cx| {\n            open_paths(\n                &[PathBuf::from(path!(": "",
        "))],\n                app_state.clone(),\n                workspace::OpenOptions::default(),\n                cx,\n            )\n        })\n        .await\n        .unwrap();\n        assert_eq!(cx.update(|cx| cx.windows().len()), 2);\n        let window2 = cx.update(|cx| cx.active_window().unwrap());\n        assert!(window1 != window2);\n        cx.update_window(window1, |_, window, _| window.activate_window())\n            .unwrap();\n\n        cx.update(|cx| {\n            open_paths(\n                &[PathBuf::from(path!(": "",
        "))],\n                app_state.clone(),\n                workspace::OpenOptions::default(),\n                cx,\n            )\n        })\n        .await\n        .unwrap();\n        assert_eq!(cx.update(|cx| cx.windows().len()), 2);\n        // should have opened in window2 because that has dir2 visibly open (window1 has it open, but not in the project panel)\n        assert!(cx.update(|cx| cx.active_window().unwrap()) == window2);\n    }\n\n    #[gpui::test]\n    async fn test_window_edit_state_restoring_disabled(cx: &mut TestAppContext) {\n        let executor = cx.executor();\n        let app_state = init_test(cx);\n\n        cx.update(|cx| {\n            SettingsStore::update_global(cx, |store, cx| {\n                store.update_user_settings(cx, |settings| {\n                    settings\n                        .session\n                        .get_or_insert_default()\n                        .restore_unsaved_buffers = Some(false)\n                });\n            });\n        });\n\n        app_state\n            .fs\n            .as_fake()\n            .insert_tree(path!(": "",
        "), json!({": "",
        "}))\n            .await;\n\n        cx.update(|cx| {\n            open_paths(\n                &[PathBuf::from(path!(": "",
        "))],\n                app_state.clone(),\n                workspace::OpenOptions::default(),\n                cx,\n            )\n        })\n        .await\n        .unwrap();\n        assert_eq!(cx.update(|cx| cx.windows().len()), 1);\n\n        // When opening the workspace, the window is not in a edited state.\n        let window = cx.update(|cx| cx.windows()[0].downcast::<Workspace>().unwrap());\n\n        let window_is_edited = |window: WindowHandle<Workspace>, cx: &mut TestAppContext| {\n            cx.update(|cx| window.read(cx).unwrap().is_edited())\n        };\n        let pane = window\n            .read_with(cx, |workspace, _| workspace.active_pane().clone())\n            .unwrap();\n        let editor = window\n            .read_with(cx, |workspace, cx| {\n                workspace\n                    .active_item(cx)\n                    .unwrap()\n                    .downcast::<Editor>()\n                    .unwrap()\n            })\n            .unwrap();\n\n        assert!(!window_is_edited(window, cx));\n\n        // Editing a buffer marks the window as edited.\n        window\n            .update(cx, |_, window, cx| {\n                editor.update(cx, |editor, cx| editor.insert(": "",
        ", window, cx));\n            })\n            .unwrap();\n\n        assert!(window_is_edited(window, cx));\n\n        // Undoing the edit restores the window's edited state.\n        window\n            .update(cx, |_, window, cx| {\n                editor.update(cx, |editor, cx| {\n                    editor.undo(&Default::default(), window, cx)\n                });\n            })\n            .unwrap();\n        assert!(!window_is_edited(window, cx));\n\n        // Redoing the edit marks the window as edited again.\n        window\n            .update(cx, |_, window, cx| {\n                editor.update(cx, |editor, cx| {\n                    editor.redo(&Default::default(), window, cx)\n                });\n            })\n            .unwrap();\n        assert!(window_is_edited(window, cx));\n        let weak = editor.downgrade();\n\n        // Closing the item restores the window's edited state.\n        let close = window\n            .update(cx, |_, window, cx| {\n                pane.update(cx, |pane, cx| {\n                    drop(editor);\n                    pane.close_active_item(&Default::default(), window, cx)\n                })\n            })\n            .unwrap();\n        executor.run_until_parked();\n\n        cx.simulate_prompt_answer(": "",
        ");\n        close.await.unwrap();\n\n        // Advance the clock to ensure that the item has been serialized and dropped from the queue\n        cx.executor().advance_clock(Duration::from_secs(1));\n\n        weak.assert_released();\n        assert!(!window_is_edited(window, cx));\n        // Opening the buffer again doesn't impact the window's edited state.\n        cx.update(|cx| {\n            open_paths(\n                &[PathBuf::from(path!(": "",
        "))],\n                app_state,\n                workspace::OpenOptions::default(),\n                cx,\n            )\n        })\n        .await\n        .unwrap();\n        executor.run_until_parked();\n\n        window\n            .update(cx, |workspace, _, cx| {\n                let editor = workspace\n                    .active_item(cx)\n                    .unwrap()\n                    .downcast::<Editor>()\n                    .unwrap();\n\n                editor.update(cx, |editor, cx| {\n                    assert_eq!(editor.text(cx), ": "",
        ");\n                });\n            })\n            .unwrap();\n\n        let editor = window\n            .read_with(cx, |workspace, cx| {\n                workspace\n                    .active_item(cx)\n                    .unwrap()\n                    .downcast::<Editor>()\n                    .unwrap()\n            })\n            .unwrap();\n        assert!(!window_is_edited(window, cx));\n\n        // Editing the buffer marks the window as edited.\n        window\n            .update(cx, |_, window, cx| {\n                editor.update(cx, |editor, cx| editor.insert(": "",
        ", window, cx));\n            })\n            .unwrap();\n        executor.run_until_parked();\n        assert!(window_is_edited(window, cx));\n\n        // Ensure closing the window via the mouse gets preempted due to the\n        // buffer having unsaved changes.\n        assert!(!VisualTestContext::from_window(window.into(), cx).simulate_close());\n        executor.run_until_parked();\n        assert_eq!(cx.update(|cx| cx.windows().len()), 1);\n\n        // The window is successfully closed after the user dismisses the prompt.\n        cx.simulate_prompt_answer(": "",
        ");\n        executor.run_until_parked();\n        assert_eq!(cx.update(|cx| cx.windows().len()), 0);\n    }\n\n    #[gpui::test]\n    async fn test_window_edit_state_restoring_enabled(cx: &mut TestAppContext) {\n        let app_state = init_test(cx);\n        app_state\n            .fs\n            .as_fake()\n            .insert_tree(path!(": "",
        "))],\n                app_state.clone(),\n                workspace::OpenOptions::default(),\n                cx,\n            )\n        })\n        .await\n        .unwrap();\n\n        assert_eq!(cx.update(|cx| cx.windows().len()), 1);\n\n        // When opening the workspace, the window is not in a edited state.\n        let window = cx.update(|cx| cx.windows()[0].downcast::<Workspace>().unwrap());\n\n        let window_is_edited = |window: WindowHandle<Workspace>, cx: &mut TestAppContext| {\n            cx.update(|cx| window.read(cx).unwrap().is_edited())\n        };\n\n        let editor = window\n            .read_with(cx, |workspace, cx| {\n                workspace\n                    .active_item(cx)\n                    .unwrap()\n                    .downcast::<Editor>()\n                    .unwrap()\n            })\n            .unwrap();\n\n        assert!(!window_is_edited(window, cx));\n\n        // Editing a buffer marks the window as edited.\n        window\n            .update(cx, |_, window, cx| {\n                editor.update(cx, |editor, cx| editor.insert(": "",
        ", window, cx));\n            })\n            .unwrap();\n\n        assert!(window_is_edited(window, cx));\n        cx.run_until_parked();\n\n        // Advance the clock to make sure the workspace is serialized\n        cx.executor().advance_clock(Duration::from_secs(1));\n\n        // When closing the window, no prompt shows up and the window is closed.\n        // buffer having unsaved changes.\n        assert!(!VisualTestContext::from_window(window.into(), cx).simulate_close());\n        cx.run_until_parked();\n        assert_eq!(cx.update(|cx| cx.windows().len()), 0);\n\n        // When we now reopen the window, the edited state and the edited buffer are back\n        cx.update(|cx| {\n            open_paths(\n                &[PathBuf::from(path!(": "",
        "))],\n                app_state.clone(),\n                workspace::OpenOptions::default(),\n                cx,\n            )\n        })\n        .await\n        .unwrap();\n\n        assert_eq!(cx.update(|cx| cx.windows().len()), 1);\n        assert!(cx.update(|cx| cx.active_window().is_some()));\n\n        cx.run_until_parked();\n\n        // When opening the workspace, the window is not in a edited state.\n        let window = cx.update(|cx| cx.active_window().unwrap().downcast::<Workspace>().unwrap());\n        assert!(window_is_edited(window, cx));\n\n        window\n            .update(cx, |workspace, _, cx| {\n                let editor = workspace\n                    .active_item(cx)\n                    .unwrap()\n                    .downcast::<editor::Editor>()\n                    .unwrap();\n                editor.update(cx, |editor, cx| {\n                    assert_eq!(editor.text(cx), ": "",
        ");\n                    assert!(editor.is_dirty(cx));\n                });\n\n                editor\n            })\n            .unwrap();\n    }\n\n    #[gpui::test]\n    async fn test_new_empty_workspace(cx: &mut TestAppContext) {\n        let app_state = init_test(cx);\n        cx.update(|cx| {\n            open_new(\n                Default::default(),\n                app_state.clone(),\n                cx,\n                |workspace, window, cx| {\n                    Editor::new_file(workspace, &Default::default(), window, cx)\n                },\n            )\n        })\n        .await\n        .unwrap();\n        cx.run_until_parked();\n\n        let workspace = cx\n            .update(|cx| cx.windows().first().unwrap().downcast::<Workspace>())\n            .unwrap();\n\n        let editor = workspace\n            .update(cx, |workspace, _, cx| {\n                let editor = workspace\n                    .active_item(cx)\n                    .unwrap()\n                    .downcast::<editor::Editor>()\n                    .unwrap();\n                editor.update(cx, |editor, cx| {\n                    assert!(editor.text(cx).is_empty());\n                    assert!(!editor.is_dirty(cx));\n                });\n\n                editor\n            })\n            .unwrap();\n\n        let save_task = workspace\n            .update(cx, |workspace, window, cx| {\n                workspace.save_active_item(SaveIntent::Save, window, cx)\n            })\n            .unwrap();\n        app_state.fs.create_dir(Path::new(": "",
        ")).await.unwrap();\n        cx.background_executor.run_until_parked();\n        cx.simulate_new_path_selection(|_| Some(PathBuf::from(": "",
        ")));\n        save_task.await.unwrap();\n        workspace\n            .update(cx, |_, _, cx| {\n                editor.update(cx, |editor, cx| {\n                    assert!(!editor.is_dirty(cx));\n                    assert_eq!(editor.title(cx), ": "",
        ");\n                });\n            })\n            .unwrap();\n    }\n\n    #[gpui::test]\n    async fn test_open_entry(cx: &mut TestAppContext) {\n        let app_state = init_test(cx);\n        app_state\n            .fs\n            .as_fake()\n            .insert_tree(\n                path!(": "",
        ",\n                        ": "",
        ",\n                    },\n                }),\n            )\n            .await;\n\n        let project = Project::test(app_state.fs.clone(), [path!(": "",
        ").as_ref()], cx).await;\n        project.update(cx, |project, _cx| {\n            project.languages().add(markdown_language())\n        });\n        let window = cx.add_window(|window, cx| Workspace::test_new(project, window, cx));\n        let workspace = window.root(cx).unwrap();\n\n        let entries = cx.read(|cx| workspace.file_project_paths(cx));\n        let file1 = entries[0].clone();\n        let file2 = entries[1].clone();\n        let file3 = entries[2].clone();\n\n        // Open the first entry\n        let entry_1 = window\n            .update(cx, |w, window, cx| {\n                w.open_path(file1.clone(), None, true, window, cx)\n            })\n            .unwrap()\n            .await\n            .unwrap();\n        cx.read(|cx| {\n            let pane = workspace.read(cx).active_pane().read(cx);\n            assert_eq!(\n                pane.active_item().unwrap().project_path(cx),\n                Some(file1.clone())\n            );\n            assert_eq!(pane.items_len(), 1);\n        });\n\n        // Open the second entry\n        window\n            .update(cx, |w, window, cx| {\n                w.open_path(file2.clone(), None, true, window, cx)\n            })\n            .unwrap()\n            .await\n            .unwrap();\n        cx.read(|cx| {\n            let pane = workspace.read(cx).active_pane().read(cx);\n            assert_eq!(\n                pane.active_item().unwrap().project_path(cx),\n                Some(file2.clone())\n            );\n            assert_eq!(pane.items_len(), 2);\n        });\n\n        // Open the first entry again. The existing pane item is activated.\n        let entry_1b = window\n            .update(cx, |w, window, cx| {\n                w.open_path(file1.clone(), None, true, window, cx)\n            })\n            .unwrap()\n            .await\n            .unwrap();\n        assert_eq!(entry_1.item_id(), entry_1b.item_id());\n\n        cx.read(|cx| {\n            let pane = workspace.read(cx).active_pane().read(cx);\n            assert_eq!(\n                pane.active_item().unwrap().project_path(cx),\n                Some(file1.clone())\n            );\n            assert_eq!(pane.items_len(), 2);\n        });\n\n        // Split the pane with the first entry, then open the second entry again.\n        window\n            .update(cx, |w, window, cx| {\n                w.split_and_clone(w.active_pane().clone(), SplitDirection::Right, window, cx)\n            })\n            .unwrap()\n            .await\n            .unwrap();\n        window\n            .update(cx, |w, window, cx| {\n                w.open_path(file2.clone(), None, true, window, cx)\n            })\n            .unwrap()\n            .await\n            .unwrap();\n\n        window\n            .read_with(cx, |w, cx| {\n                assert_eq!(\n                    w.active_pane()\n                        .read(cx)\n                        .active_item()\n                        .unwrap()\n                        .project_path(cx),\n                    Some(file2.clone())\n                );\n            })\n            .unwrap();\n\n        // Open the third entry twice concurrently. Only one pane item is added.\n        let (t1, t2) = window\n            .update(cx, |w, window, cx| {\n                (\n                    w.open_path(file3.clone(), None, true, window, cx),\n                    w.open_path(file3.clone(), None, true, window, cx),\n                )\n            })\n            .unwrap();\n        t1.await.unwrap();\n        t2.await.unwrap();\n        cx.read(|cx| {\n            let pane = workspace.read(cx).active_pane().read(cx);\n            assert_eq!(\n                pane.active_item().unwrap().project_path(cx),\n                Some(file3.clone())\n            );\n            let pane_entries = pane\n                .items()\n                .map(|i| i.project_path(cx).unwrap())\n                .collect::<Vec<_>>();\n            assert_eq!(pane_entries, &[file1, file2, file3]);\n        });\n    }\n\n    #[gpui::test]\n    async fn test_open_paths(cx: &mut TestAppContext) {\n        let app_state = init_test(cx);\n\n        app_state\n            .fs\n            .as_fake()\n            .insert_tree(\n                path!(": "",
        "\n                    },\n                    ": "",
        "\n                }),\n            )\n            .await;\n\n        cx.update(|cx| {\n            open_paths(\n                &[PathBuf::from(path!(": "",
        "))],\n                app_state,\n                workspace::OpenOptions::default(),\n                cx,\n            )\n        })\n        .await\n        .unwrap();\n        cx.run_until_parked();\n        assert_eq!(cx.update(|cx| cx.windows().len()), 1);\n        let window = cx.update(|cx| cx.windows()[0].downcast::<Workspace>().unwrap());\n        let workspace = window.root(cx).unwrap();\n\n        #[track_caller]\n        fn assert_project_panel_selection(\n            workspace: &Workspace,\n            expected_worktree_path: &Path,\n            expected_entry_path: &RelPath,\n            cx: &App,\n        ) {\n            let project_panel = [\n                workspace.left_dock().read(cx).panel::<ProjectPanel>(),\n                workspace.right_dock().read(cx).panel::<ProjectPanel>(),\n                workspace.bottom_dock().read(cx).panel::<ProjectPanel>(),\n            ]\n            .into_iter()\n            .find_map(std::convert::identity)\n            .expect(": "",
        ")\n            .read(cx);\n            let (selected_worktree, selected_entry) = project_panel\n                .selected_entry(cx)\n                .expect(": "",
        ");\n            assert_eq!(\n                selected_worktree.abs_path().as_ref(),\n                expected_worktree_path,\n                ": "",
        "\n            );\n            assert_eq!(\n                selected_entry.path.as_ref(),\n                expected_entry_path,\n                ": "",
        "\n            );\n        }\n\n        // Open a file within an existing worktree.\n        window\n            .update(cx, |workspace, window, cx| {\n                workspace.open_paths(\n                    vec![path!(": "",
        ").into()],\n                    OpenOptions {\n                        visible: Some(OpenVisible::All),\n                        ..Default::default()\n                    },\n                    None,\n                    window,\n                    cx,\n                )\n            })\n            .unwrap()\n            .await;\n        cx.run_until_parked();\n        cx.read(|cx| {\n            let workspace = workspace.read(cx);\n            assert_project_panel_selection(\n                workspace,\n                Path::new(path!(": "",
        ")),\n                rel_path(": "",
        "),\n                cx,\n            );\n            assert_eq!(\n                workspace\n                    .active_pane()\n                    .read(cx)\n                    .active_item()\n                    .unwrap()\n                    .act_as::<Editor>(cx)\n                    .unwrap()\n                    .read(cx)\n                    .title(cx),\n                ": "",
        "\n            );\n        });\n\n        // Open a file outside of any existing worktree.\n        window\n            .update(cx, |workspace, window, cx| {\n                workspace.open_paths(\n                    vec![path!(": "",
        "),\n                cx,\n            );\n            let worktree_roots = workspace\n                .worktrees(cx)\n                .map(|w| w.read(cx).as_local().unwrap().abs_path().as_ref())\n                .collect::<HashSet<_>>();\n            assert_eq!(\n                worktree_roots,\n                vec![path!(": "",
        "), path!(": "",
        ")]\n                    .into_iter()\n                    .map(Path::new)\n                    .collect(),\n            );\n            assert_eq!(\n                workspace\n                    .active_pane()\n                    .read(cx)\n                    .active_item()\n                    .unwrap()\n                    .act_as::<Editor>(cx)\n                    .unwrap()\n                    .read(cx)\n                    .title(cx),\n                ": "",
        "\n            );\n        });\n\n        // Ensure opening a directory and one of its children only adds one worktree.\n        window\n            .update(cx, |workspace, window, cx| {\n                workspace.open_paths(\n                    vec![path!(": "",
        ").into(), path!(": "",
        "\n            );\n        });\n\n        // Ensure opening invisibly a file outside an existing worktree adds a new, invisible worktree.\n        window\n            .update(cx, |workspace, window, cx| {\n                workspace.open_paths(\n                    vec![path!(": "",
        ").into()],\n                    OpenOptions {\n                        visible: Some(OpenVisible::None),\n                        ..Default::default()\n                    },\n                    None,\n                    window,\n                    cx,\n                )\n            })\n            .unwrap()\n            .await;\n        cx.run_until_parked();\n        cx.read(|cx| {\n            let workspace = workspace.read(cx);\n            assert_project_panel_selection(workspace, Path::new(path!(": "",
        ")), rel_path(": "",
        "), cx);\n            let worktree_roots = workspace\n                .worktrees(cx)\n                .map(|w| w.read(cx).as_local().unwrap().abs_path().as_ref())\n                .collect::<HashSet<_>>();\n            assert_eq!(\n                worktree_roots,\n                vec![\n                    path!(": "",
        "),\n                    path!(": "",
        ")\n                ]\n                .into_iter()\n                .map(Path::new)\n                .collect(),\n            );\n\n            let visible_worktree_roots = workspace\n                .visible_worktrees(cx)\n                .map(|w| w.read(cx).as_local().unwrap().abs_path().as_ref())\n                .collect::<HashSet<_>>();\n            assert_eq!(\n                visible_worktree_roots,\n                vec![path!(": "",
        ")]\n                    .into_iter()\n                    .map(Path::new)\n                    .collect(),\n            );\n\n            assert_eq!(\n                workspace\n                    .active_pane()\n                    .read(cx)\n                    .active_item()\n                    .unwrap()\n                    .act_as::<Editor>(cx)\n                    .unwrap()\n                    .read(cx)\n                    .title(cx),\n                ": "",
        "\n            );\n        });\n    }\n\n    #[gpui::test]\n    async fn test_opening_excluded_paths(cx: &mut TestAppContext) {\n        let app_state = init_test(cx);\n        cx.update(|cx| {\n            cx.update_global::<SettingsStore, _>(|store, cx| {\n                store.update_user_settings(cx, |project_settings| {\n                    project_settings.project.worktree.file_scan_exclusions =\n                        Some(vec![": "",
        ".to_string(), ": "",
        ".to_string()]);\n                });\n            });\n        });\n        app_state\n            .fs\n            .as_fake()\n            .insert_tree(\n                path!(": "",
        ",\n                    ": "",
        ",\n                    },\n                    ": "",
        ": {\n                            ": "",
        ",\n                        },\n                        ": "",
        ",\n                        },\n                    },\n                }),\n            )\n            .await;\n\n        let project = Project::test(app_state.fs.clone(), [path!(": "",
        ").as_ref()], cx).await;\n        project.update(cx, |project, _cx| {\n            project.languages().add(markdown_language())\n        });\n        let window = cx.add_window(|window, cx| Workspace::test_new(project, window, cx));\n        let workspace = window.root(cx).unwrap();\n\n        let initial_entries = cx.read(|cx| workspace.file_project_paths(cx));\n        let paths_to_open = [\n            PathBuf::from(path!(": "",
        ")),\n            PathBuf::from(path!(": "",
        ")),\n        ];\n        let (opened_workspace, new_items) = cx\n            .update(|cx| {\n                workspace::open_paths(\n                    &paths_to_open,\n                    app_state,\n                    workspace::OpenOptions::default(),\n                    cx,\n                )\n            })\n            .await\n            .unwrap();\n\n        assert_eq!(\n            opened_workspace.root(cx).unwrap().entity_id(),\n            workspace.entity_id(),\n            ": "",
        "\n        );\n        let mut opened_paths = cx.read(|cx| {\n            assert_eq!(\n                new_items.len(),\n                paths_to_open.len(),\n                ": "",
        "\n            );\n            new_items\n                .iter()\n                .zip(paths_to_open.iter())\n                .map(|(i, path)| {\n                    match i {\n                        Some(Ok(i)) => Some(i.project_path(cx).map(|p| p.path)),\n                        Some(Err(e)) => panic!(": "",
        "),\n                        None => None,\n                    }\n                    .flatten()\n                })\n                .collect::<Vec<_>>()\n        });\n        opened_paths.sort();\n        assert_eq!(\n            opened_paths,\n            vec![\n                None,\n                Some(rel_path(": "",
        ").into()),\n                Some(rel_path(": "",
        ").into()),\n            ],\n            ": "",
        "\n        );\n\n        let entries = cx.read(|cx| workspace.file_project_paths(cx));\n        assert_eq!(\n            initial_entries, entries,\n            ": "",
        "\n        );\n\n        cx.read(|cx| {\n                let pane = workspace.read(cx).active_pane().read(cx);\n                let mut opened_buffer_paths = pane\n                    .items()\n                    .map(|i| {\n                        i.project_path(cx)\n                            .expect(": "",
        ")\n                            .path\n                    })\n                    .collect::<Vec<_>>();\n                opened_buffer_paths.sort();\n                assert_eq!(\n                    opened_buffer_paths,\n                    vec![rel_path(": "",
        ").into(), rel_path(": "",
        ").into()],\n                    ": "",
        "\n                );\n            });\n    }\n\n    #[gpui::test]\n    async fn test_save_conflicting_item(cx: &mut TestAppContext) {\n        let app_state = init_test(cx);\n        app_state\n            .fs\n            .as_fake()\n            .insert_tree(path!(": "",
        "), json!({ ": "",
        " }))\n            .await;\n\n        let project = Project::test(app_state.fs.clone(), [path!(": "",
        ").as_ref()], cx).await;\n        project.update(cx, |project, _cx| {\n            project.languages().add(markdown_language())\n        });\n        let window = cx.add_window(|window, cx| Workspace::test_new(project, window, cx));\n        let workspace = window.root(cx).unwrap();\n\n        // Open a file within an existing worktree.\n        window\n            .update(cx, |workspace, window, cx| {\n                workspace.open_paths(\n                    vec![PathBuf::from(path!(": "",
        "))],\n                    OpenOptions {\n                        visible: Some(OpenVisible::All),\n                        ..Default::default()\n                    },\n                    None,\n                    window,\n                    cx,\n                )\n            })\n            .unwrap()\n            .await;\n        let editor = cx.read(|cx| {\n            let pane = workspace.read(cx).active_pane().read(cx);\n            let item = pane.active_item().unwrap();\n            item.downcast::<Editor>().unwrap()\n        });\n\n        window\n            .update(cx, |_, window, cx| {\n                editor.update(cx, |editor, cx| editor.handle_input(": "",
        ", window, cx));\n            })\n            .unwrap();\n\n        app_state\n            .fs\n            .as_fake()\n            .insert_file(path!(": "",
        "), b": "",
        ".to_vec())\n            .await;\n\n        cx.run_until_parked();\n        cx.read(|cx| assert!(editor.is_dirty(cx)));\n        cx.read(|cx| assert!(editor.has_conflict(cx)));\n\n        let save_task = window\n            .update(cx, |workspace, window, cx| {\n                workspace.save_active_item(SaveIntent::Save, window, cx)\n            })\n            .unwrap();\n        cx.background_executor.run_until_parked();\n        cx.simulate_prompt_answer(": "",
        ");\n        save_task.await.unwrap();\n        window\n            .update(cx, |_, _, cx| {\n                editor.update(cx, |editor, cx| {\n                    assert!(!editor.is_dirty(cx));\n                    assert!(!editor.has_conflict(cx));\n                });\n            })\n            .unwrap();\n    }\n\n    #[gpui::test]\n    async fn test_open_and_save_new_file(cx: &mut TestAppContext) {\n        let app_state = init_test(cx);\n        app_state\n            .fs\n            .create_dir(Path::new(path!(": "",
        ")))\n            .await\n            .unwrap();\n\n        let project = Project::test(app_state.fs.clone(), [path!(": "",
        ").as_ref()], cx).await;\n        project.update(cx, |project, _| {\n            project.languages().add(markdown_language());\n            project.languages().add(rust_lang());\n        });\n        let window = cx.add_window(|window, cx| Workspace::test_new(project, window, cx));\n        let worktree = cx.update(|cx| window.read(cx).unwrap().worktrees(cx).next().unwrap());\n\n        // Create a new untitled buffer\n        cx.dispatch_action(window.into(), NewFile);\n        let editor = window\n            .read_with(cx, |workspace, cx| {\n                workspace\n                    .active_item(cx)\n                    .unwrap()\n                    .downcast::<Editor>()\n                    .unwrap()\n            })\n            .unwrap();\n\n        window\n            .update(cx, |_, window, cx| {\n                editor.update(cx, |editor, cx| {\n                    assert!(!editor.is_dirty(cx));\n                    assert_eq!(editor.title(cx), ": "",
        ");\n                    assert!(Arc::ptr_eq(\n                        &editor.buffer().read(cx).language_at(0, cx).unwrap(),\n                        &languages::PLAIN_TEXT\n                    ));\n                    editor.handle_input(": "",
        ", window, cx);\n                    assert!(editor.is_dirty(cx));\n                });\n            })\n            .unwrap();\n\n        // Save the buffer. This prompts for a filename.\n        let save_task = window\n            .update(cx, |workspace, window, cx| {\n                workspace.save_active_item(SaveIntent::Save, window, cx)\n            })\n            .unwrap();\n        cx.background_executor.run_until_parked();\n        cx.simulate_new_path_selection(|parent_dir| {\n            assert_eq!(parent_dir, Path::new(path!(": "",
        ")));\n            Some(parent_dir.join(": "",
        "))\n        });\n        cx.read(|cx| {\n            assert!(editor.is_dirty(cx));\n            assert_eq!(editor.read(cx).title(cx), ": "",
        ");\n        });\n\n        // When the save completes, the buffer's title is updated and the language is assigned based\n        // on the path.\n        save_task.await.unwrap();\n        window\n            .update(cx, |_, _, cx| {\n                editor.update(cx, |editor, cx| {\n                    assert!(!editor.is_dirty(cx));\n                    assert_eq!(editor.title(cx), ": "",
        ");\n                    assert_eq!(\n                        editor.buffer().read(cx).language_at(0, cx).unwrap().name(),\n                        ": "",
        ".into()\n                    );\n                });\n            })\n            .unwrap();\n\n        // Edit the file and save it again. This time, there is no filename prompt.\n        window\n            .update(cx, |_, window, cx| {\n                editor.update(cx, |editor, cx| {\n                    editor.handle_input(": "",
        ", window, cx);\n                    assert!(editor.is_dirty(cx));\n                });\n            })\n            .unwrap();\n\n        let save_task = window\n            .update(cx, |workspace, window, cx| {\n                workspace.save_active_item(SaveIntent::Save, window, cx)\n            })\n            .unwrap();\n        save_task.await.unwrap();\n\n        assert!(!cx.did_prompt_for_new_path());\n        window\n            .update(cx, |_, _, cx| {\n                editor.update(cx, |editor, cx| {\n                    assert!(!editor.is_dirty(cx));\n                    assert_eq!(editor.title(cx), ": "",
        ")\n                });\n            })\n            .unwrap();\n\n        // Open the same newly-created file in another pane item. The new editor should reuse\n        // the same buffer.\n        cx.dispatch_action(window.into(), NewFile);\n        window\n            .update(cx, |workspace, window, cx| {\n                workspace.split_and_clone(\n                    workspace.active_pane().clone(),\n                    SplitDirection::Right,\n                    window,\n                    cx,\n                )\n            })\n            .unwrap()\n            .await\n            .unwrap();\n        window\n            .update(cx, |workspace, window, cx| {\n                workspace.open_path(\n                    (worktree.read(cx).id(), rel_path(": "",
        ")),\n                    None,\n                    true,\n                    window,\n                    cx,\n                )\n            })\n            .unwrap()\n            .await\n            .unwrap();\n        let editor2 = window\n            .update(cx, |workspace, _, cx| {\n                workspace\n                    .active_item(cx)\n                    .unwrap()\n                    .downcast::<Editor>()\n                    .unwrap()\n            })\n            .unwrap();\n        cx.read(|cx| {\n            assert_eq!(\n                editor2.read(cx).buffer().read(cx).as_singleton().unwrap(),\n                editor.read(cx).buffer().read(cx).as_singleton().unwrap()\n            );\n        })\n    }\n\n    #[gpui::test]\n    async fn test_setting_language_when_saving_as_single_file_worktree(cx: &mut TestAppContext) {\n        let app_state = init_test(cx);\n        app_state.fs.create_dir(Path::new(": "",
        ")).await.unwrap();\n\n        let project = Project::test(app_state.fs.clone(), [], cx).await;\n        project.update(cx, |project, _| {\n            project.languages().add(rust_lang());\n            project.languages().add(markdown_language());\n        });\n        let window = cx.add_window(|window, cx| Workspace::test_new(project, window, cx));\n\n        // Create a new untitled buffer\n        cx.dispatch_action(window.into(), NewFile);\n        let editor = window\n            .read_with(cx, |workspace, cx| {\n                workspace\n                    .active_item(cx)\n                    .unwrap()\n                    .downcast::<Editor>()\n                    .unwrap()\n            })\n            .unwrap();\n        window\n            .update(cx, |_, window, cx| {\n                editor.update(cx, |editor, cx| {\n                    assert!(Arc::ptr_eq(\n                        &editor.buffer().read(cx).language_at(0, cx).unwrap(),\n                        &languages::PLAIN_TEXT\n                    ));\n                    editor.handle_input(": "",
        ", window, cx);\n                    assert!(editor.is_dirty(cx));\n                });\n            })\n            .unwrap();\n\n        // Save the buffer. This prompts for a filename.\n        let save_task = window\n            .update(cx, |workspace, window, cx| {\n                workspace.save_active_item(SaveIntent::Save, window, cx)\n            })\n            .unwrap();\n        cx.background_executor.run_until_parked();\n        cx.simulate_new_path_selection(|_| Some(PathBuf::from(": "",
        ")));\n        save_task.await.unwrap();\n        // The buffer is not dirty anymore and the language is assigned based on the path.\n        window\n            .update(cx, |_, _, cx| {\n                editor.update(cx, |editor, cx| {\n                    assert!(!editor.is_dirty(cx));\n                    assert_eq!(\n                        editor.buffer().read(cx).language_at(0, cx).unwrap().name(),\n                        ": "",
        ".into()\n                    )\n                });\n            })\n            .unwrap();\n    }\n\n    #[gpui::test]\n    async fn test_pane_actions(cx: &mut TestAppContext) {\n        let app_state = init_test(cx);\n        app_state\n            .fs\n            .as_fake()\n            .insert_tree(\n                path!(": "",
        ").as_ref()], cx).await;\n        project.update(cx, |project, _cx| {\n            project.languages().add(markdown_language())\n        });\n        let window = cx.add_window(|window, cx| Workspace::test_new(project, window, cx));\n        let workspace = window.root(cx).unwrap();\n\n        let entries = cx.read(|cx| workspace.file_project_paths(cx));\n        let file1 = entries[0].clone();\n\n        let pane_1 = cx.read(|cx| workspace.read(cx).active_pane().clone());\n\n        window\n            .update(cx, |w, window, cx| {\n                w.open_path(file1.clone(), None, true, window, cx)\n            })\n            .unwrap()\n            .await\n            .unwrap();\n\n        let (editor_1, buffer) = window\n            .update(cx, |_, window, cx| {\n                pane_1.update(cx, |pane_1, cx| {\n                    let editor = pane_1.active_item().unwrap().downcast::<Editor>().unwrap();\n                    assert_eq!(editor.project_path(cx), Some(file1.clone()));\n                    let buffer = editor.update(cx, |editor, cx| {\n                        editor.insert(": "",
        ", window, cx);\n                        editor.buffer().downgrade()\n                    });\n                    (editor.downgrade(), buffer)\n                })\n            })\n            .unwrap();\n\n        cx.dispatch_action(window.into(), pane::SplitRight);\n        let editor_2 = cx.update(|cx| {\n            let pane_2 = workspace.read(cx).active_pane().clone();\n            assert_ne!(pane_1, pane_2);\n\n            let pane2_item = pane_2.read(cx).active_item().unwrap();\n            assert_eq!(pane2_item.project_path(cx), Some(file1.clone()));\n\n            pane2_item.downcast::<Editor>().unwrap().downgrade()\n        });\n        cx.dispatch_action(\n            window.into(),\n            workspace::CloseActiveItem {\n                save_intent: None,\n                close_pinned: false,\n            },\n        );\n\n        cx.background_executor.run_until_parked();\n        window\n            .read_with(cx, |workspace, _| {\n                assert_eq!(workspace.panes().len(), 1);\n                assert_eq!(workspace.active_pane(), &pane_1);\n            })\n            .unwrap();\n\n        cx.dispatch_action(\n            window.into(),\n            workspace::CloseActiveItem {\n                save_intent: None,\n                close_pinned: false,\n            },\n        );\n        cx.background_executor.run_until_parked();\n        cx.simulate_prompt_answer(": "",
        ");\n        cx.background_executor.run_until_parked();\n\n        window\n            .update(cx, |workspace, _, cx| {\n                assert_eq!(workspace.panes().len(), 1);\n                assert!(workspace.active_item(cx).is_none());\n            })\n            .unwrap();\n\n        cx.background_executor\n            .advance_clock(SERIALIZATION_THROTTLE_TIME);\n        cx.update(|_| {});\n        editor_1.assert_released();\n        editor_2.assert_released();\n        buffer.assert_released();\n    }\n\n    #[gpui::test]\n    async fn test_navigation(cx: &mut TestAppContext) {\n        let app_state = init_test(cx);\n        app_state\n            .fs\n            .as_fake()\n            .insert_tree(\n                path!(": "",
        ".repeat(20),\n                        ": "",
        ".repeat(20),\n                    },\n                }),\n            )\n            .await;\n\n        let project = Project::test(app_state.fs.clone(), [path!(": "",
        ").as_ref()], cx).await;\n        project.update(cx, |project, _cx| {\n            project.languages().add(markdown_language())\n        });\n        let workspace =\n            cx.add_window(|window, cx| Workspace::test_new(project.clone(), window, cx));\n        let pane = workspace\n            .read_with(cx, |workspace, _| workspace.active_pane().clone())\n            .unwrap();\n\n        let entries = cx.update(|cx| workspace.root(cx).unwrap().file_project_paths(cx));\n        let file1 = entries[0].clone();\n        let file2 = entries[1].clone();\n        let file3 = entries[2].clone();\n\n        let editor1 = workspace\n            .update(cx, |w, window, cx| {\n                w.open_path(file1.clone(), None, true, window, cx)\n            })\n            .unwrap()\n            .await\n            .unwrap()\n            .downcast::<Editor>()\n            .unwrap();\n        workspace\n            .update(cx, |_, window, cx| {\n                editor1.update(cx, |editor, cx| {\n                    editor.change_selections(Default::default(), window, cx, |s| {\n                        s.select_display_ranges([DisplayPoint::new(DisplayRow(10), 0)\n                            ..DisplayPoint::new(DisplayRow(10), 0)])\n                    });\n                });\n            })\n            .unwrap();\n\n        let editor2 = workspace\n            .update(cx, |w, window, cx| {\n                w.open_path(file2.clone(), None, true, window, cx)\n            })\n            .unwrap()\n            .await\n            .unwrap()\n            .downcast::<Editor>()\n            .unwrap();\n        let editor3 = workspace\n            .update(cx, |w, window, cx| {\n                w.open_path(file3.clone(), None, true, window, cx)\n            })\n            .unwrap()\n            .await\n            .unwrap()\n            .downcast::<Editor>()\n            .unwrap();\n\n        workspace\n            .update(cx, |_, window, cx| {\n                editor3.update(cx, |editor, cx| {\n                    editor.change_selections(Default::default(), window, cx, |s| {\n                        s.select_display_ranges([DisplayPoint::new(DisplayRow(12), 0)\n                            ..DisplayPoint::new(DisplayRow(12), 0)])\n                    });\n                    editor.newline(&Default::default(), window, cx);\n                    editor.newline(&Default::default(), window, cx);\n                    editor.move_down(&Default::default(), window, cx);\n                    editor.move_down(&Default::default(), window, cx);\n                    editor.save(\n                        SaveOptions {\n                            format: true,\n                            autosave: false,\n                        },\n                        project.clone(),\n                        window,\n                        cx,\n                    )\n                })\n            })\n            .unwrap()\n            .await\n            .unwrap();\n        workspace\n            .update(cx, |_, window, cx| {\n                editor3.update(cx, |editor, cx| {\n                    editor.set_scroll_position(point(0., 12.5), window, cx)\n                });\n            })\n            .unwrap();\n        assert_eq!(\n            active_location(&workspace, cx),\n            (file3.clone(), DisplayPoint::new(DisplayRow(16), 0), 12.5)\n        );\n\n        workspace\n            .update(cx, |w, window, cx| {\n                w.go_back(w.active_pane().downgrade(), window, cx)\n            })\n            .unwrap()\n            .await\n            .unwrap();\n        assert_eq!(\n            active_location(&workspace, cx),\n            (file3.clone(), DisplayPoint::new(DisplayRow(0), 0), 0.)\n        );\n\n        workspace\n            .update(cx, |w, window, cx| {\n                w.go_back(w.active_pane().downgrade(), window, cx)\n            })\n            .unwrap()\n            .await\n            .unwrap();\n        assert_eq!(\n            active_location(&workspace, cx),\n            (file2.clone(), DisplayPoint::new(DisplayRow(0), 0), 0.)\n        );\n\n        workspace\n            .update(cx, |w, window, cx| {\n                w.go_back(w.active_pane().downgrade(), window, cx)\n            })\n            .unwrap()\n            .await\n            .unwrap();\n        assert_eq!(\n            active_location(&workspace, cx),\n            (file1.clone(), DisplayPoint::new(DisplayRow(10), 0), 0.)\n        );\n\n        workspace\n            .update(cx, |w, window, cx| {\n                w.go_back(w.active_pane().downgrade(), window, cx)\n            })\n            .unwrap()\n            .await\n            .unwrap();\n        assert_eq!(\n            active_location(&workspace, cx),\n            (file1.clone(), DisplayPoint::new(DisplayRow(0), 0), 0.)\n        );\n\n        // Go back one more time and ensure we don't navigate past the first item in the history.\n        workspace\n            .update(cx, |w, window, cx| {\n                w.go_back(w.active_pane().downgrade(), window, cx)\n            })\n            .unwrap()\n            .await\n            .unwrap();\n        assert_eq!(\n            active_location(&workspace, cx),\n            (file1.clone(), DisplayPoint::new(DisplayRow(0), 0), 0.)\n        );\n\n        workspace\n            .update(cx, |w, window, cx| {\n                w.go_forward(w.active_pane().downgrade(), window, cx)\n            })\n            .unwrap()\n            .await\n            .unwrap();\n        assert_eq!(\n            active_location(&workspace, cx),\n            (file1.clone(), DisplayPoint::new(DisplayRow(10), 0), 0.)\n        );\n\n        workspace\n            .update(cx, |w, window, cx| {\n                w.go_forward(w.active_pane().downgrade(), window, cx)\n            })\n            .unwrap()\n            .await\n            .unwrap();\n        assert_eq!(\n            active_location(&workspace, cx),\n            (file2.clone(), DisplayPoint::new(DisplayRow(0), 0), 0.)\n        );\n\n        // Go forward to an item that has been closed, ensuring it gets re-opened at the same\n        // location.\n        workspace\n            .update(cx, |_, window, cx| {\n                pane.update(cx, |pane, cx| {\n                    let editor3_id = editor3.entity_id();\n                    drop(editor3);\n                    pane.close_item_by_id(editor3_id, SaveIntent::Close, window, cx)\n                })\n            })\n            .unwrap()\n            .await\n            .unwrap();\n        workspace\n            .update(cx, |w, window, cx| {\n                w.go_forward(w.active_pane().downgrade(), window, cx)\n            })\n            .unwrap()\n            .await\n            .unwrap();\n        assert_eq!(\n            active_location(&workspace, cx),\n            (file3.clone(), DisplayPoint::new(DisplayRow(0), 0), 0.)\n        );\n\n        workspace\n            .update(cx, |w, window, cx| {\n                w.go_forward(w.active_pane().downgrade(), window, cx)\n            })\n            .unwrap()\n            .await\n            .unwrap();\n        assert_eq!(\n            active_location(&workspace, cx),\n            (file3.clone(), DisplayPoint::new(DisplayRow(16), 0), 12.5)\n        );\n\n        workspace\n            .update(cx, |w, window, cx| {\n                w.go_back(w.active_pane().downgrade(), window, cx)\n            })\n            .unwrap()\n            .await\n            .unwrap();\n        assert_eq!(\n            active_location(&workspace, cx),\n            (file3.clone(), DisplayPoint::new(DisplayRow(0), 0), 0.)\n        );\n\n        // Go back to an item that has been closed and removed from disk\n        workspace\n            .update(cx, |_, window, cx| {\n                pane.update(cx, |pane, cx| {\n                    let editor2_id = editor2.entity_id();\n                    drop(editor2);\n                    pane.close_item_by_id(editor2_id, SaveIntent::Close, window, cx)\n                })\n            })\n            .unwrap()\n            .await\n            .unwrap();\n        app_state\n            .fs\n            .remove_file(Path::new(path!(": "",
        ")), Default::default())\n            .await\n            .unwrap();\n        cx.background_executor.run_until_parked();\n\n        workspace\n            .update(cx, |w, window, cx| {\n                w.go_back(w.active_pane().downgrade(), window, cx)\n            })\n            .unwrap()\n            .await\n            .unwrap();\n        assert_eq!(\n            active_location(&workspace, cx),\n            (file2.clone(), DisplayPoint::new(DisplayRow(0), 0), 0.)\n        );\n        workspace\n            .update(cx, |w, window, cx| {\n                w.go_forward(w.active_pane().downgrade(), window, cx)\n            })\n            .unwrap()\n            .await\n            .unwrap();\n        assert_eq!(\n            active_location(&workspace, cx),\n            (file3.clone(), DisplayPoint::new(DisplayRow(0), 0), 0.)\n        );\n\n        // Modify file to collapse multiple nav history entries into the same location.\n        // Ensure we don't visit the same location twice when navigating.\n        workspace\n            .update(cx, |_, window, cx| {\n                editor1.update(cx, |editor, cx| {\n                    editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n                        s.select_display_ranges([DisplayPoint::new(DisplayRow(15), 0)\n                            ..DisplayPoint::new(DisplayRow(15), 0)])\n                    })\n                });\n            })\n            .unwrap();\n        for _ in 0..5 {\n            workspace\n                .update(cx, |_, window, cx| {\n                    editor1.update(cx, |editor, cx| {\n                        editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n                            s.select_display_ranges([DisplayPoint::new(DisplayRow(3), 0)\n                                ..DisplayPoint::new(DisplayRow(3), 0)])\n                        });\n                    });\n                })\n                .unwrap();\n\n            workspace\n                .update(cx, |_, window, cx| {\n                    editor1.update(cx, |editor, cx| {\n                        editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n                            s.select_display_ranges([DisplayPoint::new(DisplayRow(13), 0)\n                                ..DisplayPoint::new(DisplayRow(13), 0)])\n                        })\n                    });\n                })\n                .unwrap();\n        }\n        workspace\n            .update(cx, |_, window, cx| {\n                editor1.update(cx, |editor, cx| {\n                    editor.transact(window, cx, |editor, window, cx| {\n                        editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n                            s.select_display_ranges([DisplayPoint::new(DisplayRow(2), 0)\n                                ..DisplayPoint::new(DisplayRow(14), 0)])\n                        });\n                        editor.insert(": "",
        ", window, cx);\n                    })\n                });\n            })\n            .unwrap();\n\n        workspace\n            .update(cx, |_, window, cx| {\n                editor1.update(cx, |editor, cx| {\n                    editor.change_selections(SelectionEffects::no_scroll(), window, cx, |s| {\n                        s.select_display_ranges([DisplayPoint::new(DisplayRow(1), 0)\n                            ..DisplayPoint::new(DisplayRow(1), 0)])\n                    })\n                });\n            })\n            .unwrap();\n        workspace\n            .update(cx, |w, window, cx| {\n                w.go_back(w.active_pane().downgrade(), window, cx)\n            })\n            .unwrap()\n            .await\n            .unwrap();\n        assert_eq!(\n            active_location(&workspace, cx),\n            (file1.clone(), DisplayPoint::new(DisplayRow(2), 0), 0.)\n        );\n        workspace\n            .update(cx, |w, window, cx| {\n                w.go_back(w.active_pane().downgrade(), window, cx)\n            })\n            .unwrap()\n            .await\n            .unwrap();\n        assert_eq!(\n            active_location(&workspace, cx),\n            (file1.clone(), DisplayPoint::new(DisplayRow(3), 0), 0.)\n        );\n\n        fn active_location(\n            workspace: &WindowHandle<Workspace>,\n            cx: &mut TestAppContext,\n        ) -> (ProjectPath, DisplayPoint, f64) {\n            workspace\n                .update(cx, |workspace, _, cx| {\n                    let item = workspace.active_item(cx).unwrap();\n                    let editor = item.downcast::<Editor>().unwrap();\n                    let (selections, scroll_position) = editor.update(cx, |editor, cx| {\n                        (\n                            editor\n                                .selections\n                                .display_ranges(&editor.display_snapshot(cx)),\n                            editor.scroll_position(cx),\n                        )\n                    });\n                    (\n                        item.project_path(cx).unwrap(),\n                        selections[0].start,\n                        scroll_position.y,\n                    )\n                })\n                .unwrap()\n        }\n    }\n\n    #[gpui::test]\n    async fn test_reopening_closed_items(cx: &mut TestAppContext) {\n        let app_state = init_test(cx);\n        app_state\n            .fs\n            .as_fake()\n            .insert_tree(\n                path!(": "",
        ").as_ref()], cx).await;\n        project.update(cx, |project, _cx| {\n            project.languages().add(markdown_language())\n        });\n        let workspace = cx.add_window(|window, cx| Workspace::test_new(project, window, cx));\n        let pane = workspace\n            .read_with(cx, |workspace, _| workspace.active_pane().clone())\n            .unwrap();\n\n        let entries = cx.update(|cx| workspace.root(cx).unwrap().file_project_paths(cx));\n        let file1 = entries[0].clone();\n        let file2 = entries[1].clone();\n        let file3 = entries[2].clone();\n        let file4 = entries[3].clone();\n\n        let file1_item_id = workspace\n            .update(cx, |w, window, cx| {\n                w.open_path(file1.clone(), None, true, window, cx)\n            })\n            .unwrap()\n            .await\n            .unwrap()\n            .item_id();\n        let file2_item_id = workspace\n            .update(cx, |w, window, cx| {\n                w.open_path(file2.clone(), None, true, window, cx)\n            })\n            .unwrap()\n            .await\n            .unwrap()\n            .item_id();\n        let file3_item_id = workspace\n            .update(cx, |w, window, cx| {\n                w.open_path(file3.clone(), None, true, window, cx)\n            })\n            .unwrap()\n            .await\n            .unwrap()\n            .item_id();\n        let file4_item_id = workspace\n            .update(cx, |w, window, cx| {\n                w.open_path(file4.clone(), None, true, window, cx)\n            })\n            .unwrap()\n            .await\n            .unwrap()\n            .item_id();\n        assert_eq!(active_path(&workspace, cx), Some(file4.clone()));\n\n        // Close all the pane items in some arbitrary order.\n        workspace\n            .update(cx, |_, window, cx| {\n                pane.update(cx, |pane, cx| {\n                    pane.close_item_by_id(file1_item_id, SaveIntent::Close, window, cx)\n                })\n            })\n            .unwrap()\n            .await\n            .unwrap();\n        assert_eq!(active_path(&workspace, cx), Some(file4.clone()));\n\n        workspace\n            .update(cx, |_, window, cx| {\n                pane.update(cx, |pane, cx| {\n                    pane.close_item_by_id(file4_item_id, SaveIntent::Close, window, cx)\n                })\n            })\n            .unwrap()\n            .await\n            .unwrap();\n        assert_eq!(active_path(&workspace, cx), Some(file3.clone()));\n\n        workspace\n            .update(cx, |_, window, cx| {\n                pane.update(cx, |pane, cx| {\n                    pane.close_item_by_id(file2_item_id, SaveIntent::Close, window, cx)\n                })\n            })\n            .unwrap()\n            .await\n            .unwrap();\n        assert_eq!(active_path(&workspace, cx), Some(file3.clone()));\n        workspace\n            .update(cx, |_, window, cx| {\n                pane.update(cx, |pane, cx| {\n                    pane.close_item_by_id(file3_item_id, SaveIntent::Close, window, cx)\n                })\n            })\n            .unwrap()\n            .await\n            .unwrap();\n\n        assert_eq!(active_path(&workspace, cx), None);\n\n        // Reopen all the closed items, ensuring they are reopened in the same order\n        // in which they were closed.\n        workspace\n            .update(cx, Workspace::reopen_closed_item)\n            .unwrap()\n            .await\n            .unwrap();\n        assert_eq!(active_path(&workspace, cx), Some(file3.clone()));\n\n        workspace\n            .update(cx, Workspace::reopen_closed_item)\n            .unwrap()\n            .await\n            .unwrap();\n        assert_eq!(active_path(&workspace, cx), Some(file2.clone()));\n\n        workspace\n            .update(cx, Workspace::reopen_closed_item)\n            .unwrap()\n            .await\n            .unwrap();\n        assert_eq!(active_path(&workspace, cx), Some(file4.clone()));\n\n        workspace\n            .update(cx, Workspace::reopen_closed_item)\n            .unwrap()\n            .await\n            .unwrap();\n        assert_eq!(active_path(&workspace, cx), Some(file1.clone()));\n\n        // Reopening past the last closed item is a no-op.\n        workspace\n            .update(cx, Workspace::reopen_closed_item)\n            .unwrap()\n            .await\n            .unwrap();\n        assert_eq!(active_path(&workspace, cx), Some(file1.clone()));\n\n        // Reopening closed items doesn't interfere with navigation history.\n        workspace\n            .update(cx, |workspace, window, cx| {\n                workspace.go_back(workspace.active_pane().downgrade(), window, cx)\n            })\n            .unwrap()\n            .await\n            .unwrap();\n        assert_eq!(active_path(&workspace, cx), Some(file4.clone()));\n\n        workspace\n            .update(cx, |workspace, window, cx| {\n                workspace.go_back(workspace.active_pane().downgrade(), window, cx)\n            })\n            .unwrap()\n            .await\n            .unwrap();\n        assert_eq!(active_path(&workspace, cx), Some(file2.clone()));\n\n        workspace\n            .update(cx, |workspace, window, cx| {\n                workspace.go_back(workspace.active_pane().downgrade(), window, cx)\n            })\n            .unwrap()\n            .await\n            .unwrap();\n        assert_eq!(active_path(&workspace, cx), Some(file3.clone()));\n\n        workspace\n            .update(cx, |workspace, window, cx| {\n                workspace.go_back(workspace.active_pane().downgrade(), window, cx)\n            })\n            .unwrap()\n            .await\n            .unwrap();\n        assert_eq!(active_path(&workspace, cx), Some(file4.clone()));\n\n        workspace\n            .update(cx, |workspace, window, cx| {\n                workspace.go_back(workspace.active_pane().downgrade(), window, cx)\n            })\n            .unwrap()\n            .await\n            .unwrap();\n        assert_eq!(active_path(&workspace, cx), Some(file3.clone()));\n\n        workspace\n            .update(cx, |workspace, window, cx| {\n                workspace.go_back(workspace.active_pane().downgrade(), window, cx)\n            })\n            .unwrap()\n            .await\n            .unwrap();\n        assert_eq!(active_path(&workspace, cx), Some(file2.clone()));\n\n        workspace\n            .update(cx, |workspace, window, cx| {\n                workspace.go_back(workspace.active_pane().downgrade(), window, cx)\n            })\n            .unwrap()\n            .await\n            .unwrap();\n        assert_eq!(active_path(&workspace, cx), Some(file1.clone()));\n\n        workspace\n            .update(cx, |workspace, window, cx| {\n                workspace.go_back(workspace.active_pane().downgrade(), window, cx)\n            })\n            .unwrap()\n            .await\n            .unwrap();\n        assert_eq!(active_path(&workspace, cx), Some(file1.clone()));\n\n        fn active_path(\n            workspace: &WindowHandle<Workspace>,\n            cx: &TestAppContext,\n        ) -> Option<ProjectPath> {\n            workspace\n                .read_with(cx, |workspace, cx| {\n                    let item = workspace.active_item(cx)?;\n                    item.project_path(cx)\n                })\n                .unwrap()\n        }\n    }\n\n    fn init_keymap_test(cx: &mut TestAppContext) -> Arc<AppState> {\n        cx.update(|cx| {\n            let app_state = AppState::test(cx);\n\n            theme::init(theme::LoadThemes::JustBase, cx);\n            client::init(&app_state.client, cx);\n            workspace::init(app_state.clone(), cx);\n            onboarding::init(cx);\n            app_state\n        })\n    }\n\n    actions!(test_only, [ActionA, ActionB]);\n\n    #[gpui::test]\n    async fn test_base_keymap(cx: &mut gpui::TestAppContext) {\n        let executor = cx.executor();\n        let app_state = init_keymap_test(cx);\n        let project = Project::test(app_state.fs.clone(), [], cx).await;\n        let workspace =\n            cx.add_window(|window, cx| Workspace::test_new(project.clone(), window, cx));\n\n        // From the Atom keymap\n        use workspace::ActivatePreviousPane;\n        // From the JetBrains keymap\n        use workspace::ActivatePreviousItem;\n\n        app_state\n            .fs\n            .save(\n                ": "",
        ".as_ref(),\n                &r#": "",
        "base_keymap": "",
        "Atom": "",
        "#.into(),\n                Default::default(),\n            )\n            .await\n            .unwrap();\n\n        app_state\n            .fs\n            .save(\n                ": "",
        "bindings": "",
        "backspace": "",
        "test_only::ActionA": "",
        "#.into(),\n                Default::default(),\n            )\n            .await\n            .unwrap();\n        executor.run_until_parked();\n        cx.update(|cx| {\n            let settings_rx = watch_config_file(\n                &executor,\n                app_state.fs.clone(),\n                PathBuf::from(": "",
        "),\n            );\n            let keymap_rx = watch_config_file(\n                &executor,\n                app_state.fs.clone(),\n                PathBuf::from(": "",
        "),\n            );\n            let global_settings_rx = watch_config_file(\n                &executor,\n                app_state.fs.clone(),\n                PathBuf::from(": "",
        "),\n            );\n            handle_settings_file_changes(settings_rx, global_settings_rx, cx, |_, _| {});\n            handle_keymap_file_changes(keymap_rx, cx);\n        });\n        workspace\n            .update(cx, |workspace, _, cx| {\n                workspace.register_action(|_, _: &ActionA, _window, _cx| {});\n                workspace.register_action(|_, _: &ActionB, _window, _cx| {});\n                workspace.register_action(|_, _: &ActivatePreviousPane, _window, _cx| {});\n                workspace.register_action(|_, _: &ActivatePreviousItem, _window, _cx| {});\n                cx.notify();\n            })\n            .unwrap();\n        executor.run_until_parked();\n        // Test loading the keymap base at all\n        assert_key_bindings_for(\n            workspace.into(),\n            cx,\n            vec![(": "",
        ", &ActionA), (": "",
        ", &ActivatePreviousPane)],\n            line!(),\n        );\n\n        // Test modifying the users keymap, while retaining the base keymap\n        app_state\n            .fs\n            .save(\n                ": "",
        "test_only::ActionB": "",
        "#.into(),\n                Default::default(),\n            )\n            .await\n            .unwrap();\n\n        executor.run_until_parked();\n\n        assert_key_bindings_for(\n            workspace.into(),\n            cx,\n            vec![(": "",
        ", &ActionB), (": "",
        ", &ActivatePreviousPane)],\n            line!(),\n        );\n\n        // Test modifying the base, while retaining the users keymap\n        app_state\n            .fs\n            .save(\n                ": "",
        "JetBrains": "",
        ", &ActivatePreviousItem)],\n            line!(),\n        );\n    }\n\n    #[gpui::test]\n    async fn test_disabled_keymap_binding(cx: &mut gpui::TestAppContext) {\n        let executor = cx.executor();\n        let app_state = init_keymap_test(cx);\n        let project = Project::test(app_state.fs.clone(), [], cx).await;\n        let workspace =\n            cx.add_window(|window, cx| Workspace::test_new(project.clone(), window, cx));\n\n        // From the Atom keymap\n        use workspace::ActivatePreviousPane;\n        // From the JetBrains keymap\n        use diagnostics::Deploy;\n\n        workspace\n            .update(cx, |workspace, _, _| {\n                workspace.register_action(|_, _: &ActionA, _window, _cx| {});\n                workspace.register_action(|_, _: &ActionB, _window, _cx| {});\n                workspace.register_action(|_, _: &Deploy, _window, _cx| {});\n            })\n            .unwrap();\n        app_state\n            .fs\n            .save(\n                ": "",
        "#.into(),\n                Default::default(),\n            )\n            .await\n            .unwrap();\n        app_state\n            .fs\n            .save(\n                ": "",
        "#.into(),\n                Default::default(),\n            )\n            .await\n            .unwrap();\n\n        cx.update(|cx| {\n            let settings_rx = watch_config_file(\n                &executor,\n                app_state.fs.clone(),\n                PathBuf::from(": "",
        "),\n            );\n\n            let global_settings_rx = watch_config_file(\n                &executor,\n                app_state.fs.clone(),\n                PathBuf::from(": "",
        "),\n            );\n            handle_settings_file_changes(settings_rx, global_settings_rx, cx, |_, _| {});\n            handle_keymap_file_changes(keymap_rx, cx);\n        });\n\n        cx.background_executor.run_until_parked();\n\n        cx.background_executor.run_until_parked();\n        // Test loading the keymap base at all\n        assert_key_bindings_for(\n            workspace.into(),\n            cx,\n            vec![(": "",
        ", &ActivatePreviousPane)],\n            line!(),\n        );\n\n        // Test disabling the key binding for the base keymap\n        app_state\n            .fs\n            .save(\n                ": "",
        "#.into(),\n                Default::default(),\n            )\n            .await\n            .unwrap();\n\n        cx.background_executor.run_until_parked();\n\n        assert_key_bindings_for(\n            workspace.into(),\n            cx,\n            vec![(": "",
        "#.into(),\n                Default::default(),\n            )\n            .await\n            .unwrap();\n\n        cx.background_executor.run_until_parked();\n\n        assert_key_bindings_for(workspace.into(), cx, vec![(": "",
        ", &Deploy)], line!());\n    }\n\n    #[gpui::test]\n    async fn test_generate_keymap_json_schema_for_registered_actions(\n        cx: &mut gpui::TestAppContext,\n    ) {\n        init_keymap_test(cx);\n        cx.update(|cx| {\n            // Make sure it doesn't panic.\n            KeymapFile::generate_json_schema_for_registered_actions(cx);\n        });\n    }\n\n    /// Checks that action namespaces are the expected set. The purpose of this is to prevent typos\n    /// and let you know when introducing a new namespace.\n    #[gpui::test]\n    async fn test_action_namespaces(cx: &mut gpui::TestAppContext) {\n        use itertools::Itertools;\n\n        init_keymap_test(cx);\n        cx.update(|cx| {\n            let all_actions = cx.all_action_names();\n\n            let mut actions_without_namespace = Vec::new();\n            let all_namespaces = all_actions\n                .iter()\n                .filter_map(|action_name| {\n                    let namespace = action_name\n                        .split(": "",
        ")\n                        .collect::<Vec<_>>()\n                        .into_iter()\n                        .rev()\n                        .skip(1)\n                        .rev()\n                        .join(": "",
        ");\n                    if namespace.is_empty() {\n                        actions_without_namespace.push(*action_name);\n                    }\n                    if &namespace == ": "",
        " || &namespace == ": "",
        " {\n                        None\n                    } else {\n                        Some(namespace)\n                    }\n                })\n                .sorted()\n                .dedup()\n                .collect::<Vec<_>>();\n            assert_eq!(actions_without_namespace, Vec::<&str>::new());\n\n            let expected_namespaces = vec![\n                ": "",
        ",\n                #[cfg(not(target_os = ": "",
        "))]\n                ": "",
        ",\n            ];\n            assert_eq!(\n                all_namespaces,\n                expected_namespaces\n                    .into_iter()\n                    .map(|namespace| namespace.to_string())\n                    .sorted()\n                    .collect::<Vec<_>>()\n            );\n        });\n    }\n\n    #[gpui::test]\n    fn test_bundled_settings_and_themes(cx: &mut App) {\n        cx.text_system()\n            .add_fonts(vec![\n                Assets\n                    .load(": "",
        ")\n                    .unwrap()\n                    .unwrap(),\n                Assets\n                    .load(": "",
        ")\n                    .unwrap()\n                    .unwrap(),\n            ])\n            .unwrap();\n        let themes = ThemeRegistry::default();\n        settings::init(cx);\n        theme::init(theme::LoadThemes::JustBase, cx);\n\n        let mut has_default_theme = false;\n        for theme_name in themes.list().into_iter().map(|meta| meta.name) {\n            let theme = themes.get(&theme_name).unwrap();\n            assert_eq!(theme.name, theme_name);\n            if theme.name.as_ref() == ": "",
        " {\n                has_default_theme = true;\n            }\n        }\n        assert!(has_default_theme);\n    }\n\n    #[gpui::test]\n    async fn test_bundled_files_editor(cx: &mut TestAppContext) {\n        let app_state = init_test(cx);\n        cx.update(init);\n\n        let project = Project::test(app_state.fs.clone(), [], cx).await;\n        let _window = cx.add_window(|window, cx| Workspace::test_new(project, window, cx));\n\n        cx.update(|cx| {\n            cx.dispatch_action(&OpenDefaultSettings);\n        });\n        cx.run_until_parked();\n\n        assert_eq!(cx.read(|cx| cx.windows().len()), 1);\n\n        let workspace = cx.windows()[0].downcast::<Workspace>().unwrap();\n        let active_editor = workspace\n            .update(cx, |workspace, _, cx| {\n                workspace.active_item_as::<Editor>(cx)\n            })\n            .unwrap();\n        assert!(\n            active_editor.is_some(),\n            ": "",
        "\n        );\n\n        let active_editor = active_editor.unwrap();\n        assert!(\n            active_editor.read_with(cx, |editor, cx| editor.read_only(cx)),\n            ": "",
        "\n        );\n        assert!(\n            active_editor.read_with(cx, |editor, cx| editor.buffer().read(cx).read_only()),\n            ": "",
        "\n        );\n    }\n\n    #[gpui::test]\n    async fn test_bundled_languages(cx: &mut TestAppContext) {\n        let fs = fs::FakeFs::new(cx.background_executor.clone());\n        env_logger::builder().is_test(true).try_init().ok();\n        let settings = cx.update(SettingsStore::test);\n        cx.set_global(settings);\n        let languages = LanguageRegistry::test(cx.executor());\n        let languages = Arc::new(languages);\n        let node_runtime = node_runtime::NodeRuntime::unavailable();\n        cx.update(|cx| {\n            languages::init(languages.clone(), fs, node_runtime, cx);\n        });\n        for name in languages.language_names() {\n            languages\n                .language_for_name(name.as_ref())\n                .await\n                .with_context(|| format!(": "",
        "))\n                .unwrap();\n        }\n        cx.run_until_parked();\n    }\n\n    pub(crate) fn init_test(cx: &mut TestAppContext) -> Arc<AppState> {\n        init_test_with_state(cx, cx.update(AppState::test))\n    }\n\n    fn init_test_with_state(\n        cx: &mut TestAppContext,\n        mut app_state: Arc<AppState>,\n    ) -> Arc<AppState> {\n        cx.update(move |cx| {\n            env_logger::builder().is_test(true).try_init().ok();\n\n            let state = Arc::get_mut(&mut app_state).unwrap();\n            state.build_window_options = build_window_options;\n            app_state.languages.add(markdown_language());\n\n            gpui_tokio::init(cx);\n            theme::init(theme::LoadThemes::JustBase, cx);\n            audio::init(cx);\n            channel::init(&app_state.client, app_state.user_store.clone(), cx);\n            call::init(app_state.client.clone(), app_state.user_store.clone(), cx);\n            notifications::init(app_state.client.clone(), app_state.user_store.clone(), cx);\n            workspace::init(app_state.clone(), cx);\n            release_channel::init(SemanticVersion::default(), cx);\n            command_palette::init(cx);\n            editor::init(cx);\n            collab_ui::init(&app_state, cx);\n            git_ui::init(cx);\n            project_panel::init(cx);\n            outline_panel::init(cx);\n            terminal_view::init(cx);\n            copilot::copilot_chat::init(\n                app_state.fs.clone(),\n                app_state.client.http_client(),\n                copilot::copilot_chat::CopilotChatConfiguration::default(),\n                cx,\n            );\n            image_viewer::init(cx);\n            language_model::init(app_state.client.clone(), cx);\n            language_models::init(app_state.user_store.clone(), app_state.client.clone(), cx);\n            web_search::init(cx);\n            web_search_providers::init(app_state.client.clone(), cx);\n            let prompt_builder = PromptBuilder::load(app_state.fs.clone(), false, cx);\n            agent_ui::init(\n                app_state.fs.clone(),\n                app_state.client.clone(),\n                prompt_builder.clone(),\n                app_state.languages.clone(),\n                false,\n                cx,\n            );\n            repl::init(app_state.fs.clone(), cx);\n            repl::notebook::init(cx);\n            tasks_ui::init(cx);\n            project::debugger::breakpoint_store::BreakpointStore::init(\n                &app_state.client.clone().into(),\n            );\n            project::debugger::dap_store::DapStore::init(&app_state.client.clone().into(), cx);\n            debugger_ui::init(cx);\n            initialize_workspace(app_state.clone(), prompt_builder, cx);\n            search::init(cx);\n            app_state\n        })\n    }\n\n    fn rust_lang() -> Arc<language::Language> {\n        Arc::new(language::Language::new(\n            language::LanguageConfig {\n                name: ": "",
        ".into(),\n                matcher: LanguageMatcher {\n                    path_suffixes: vec![": "",
        ".to_string()],\n                    ..Default::default()\n                },\n                ..Default::default()\n            },\n            Some(tree_sitter_rust::LANGUAGE.into()),\n        ))\n    }\n\n    fn markdown_language() -> Arc<language::Language> {\n        Arc::new(language::Language::new(\n            language::LanguageConfig {\n                name: ": "",
        ".to_string()],\n                    ..Default::default()\n                },\n                ..Default::default()\n            },\n            Some(tree_sitter_md::LANGUAGE.into()),\n        ))\n    }\n\n    #[track_caller]\n    fn assert_key_bindings_for(\n        window: AnyWindowHandle,\n        cx: &TestAppContext,\n        actions: Vec<(&'static str, &dyn Action)>,\n        line: u32,\n    ) {\n        let available_actions = cx\n            .update(|cx| window.update(cx, |_, window, cx| window.available_actions(cx)))\n            .unwrap();\n        for (key, action) in actions {\n            let bindings = cx\n                .update(|cx| window.update(cx, |_, window, _| window.bindings_for_action(action)))\n                .unwrap();\n            // assert that...\n            assert!(\n                available_actions.iter().any(|bound_action| {\n                    // actions match...\n                    bound_action.partial_eq(action)\n                }),\n                ": "",
        ",\n                line,\n                action.name(),\n            );\n            assert!(\n                // and key strokes contain the given key\n                bindings\n                    .into_iter()\n                    .any(|binding| binding.keystrokes().iter().any(|k| k.key() == key)),\n                ": "",
        ",\n                line,\n                action.name(),\n                key\n            );\n        }\n    }\n\n    #[gpui::test]\n    async fn test_opening_project_settings_when_excluded(cx: &mut gpui::TestAppContext) {\n        // Use the proper initialization for runtime state\n        let app_state = init_keymap_test(cx);\n\n        eprintln!(": "",
        ");\n\n        // 1. Set up a project with some project settings\n        let settings_init =\n            r#": "",
        "UNIQUEVALUE": "",
        "git": "",
        "inline_blame": "",
        "enabled": "",
        "#;\n        app_state\n            .fs\n            .as_fake()\n            .insert_tree(\n                Path::new(": "",
        ": settings_init\n                    }\n                }),\n            )\n            .await;\n\n        eprintln!(": "",
        ");\n\n        // 2. Create a project with the file system and load it\n        let project = Project::test(app_state.fs.clone(), [Path::new(": "",
        ")], cx).await;\n\n        // Save original settings content for comparison\n        let original_settings = app_state\n            .fs\n            .load(Path::new(": "",
        "))\n            .await\n            .unwrap();\n\n        let original_settings_str = original_settings.clone();\n\n        // Verify settings exist on disk and have expected content\n        eprintln!(": "",
        ", original_settings_str);\n        assert!(\n            original_settings_str.contains(": "",
        "),\n            ": "",
        "\n        );\n\n        // 3. Add .zed to file scan exclusions in user settings\n        cx.update_global::<SettingsStore, _>(|store, cx| {\n            store.update_user_settings(cx, |worktree_settings| {\n                worktree_settings.project.worktree.file_scan_exclusions =\n                    Some(vec![": "",
        ".to_string()]);\n            });\n        });\n\n        eprintln!(": "",
        ");\n\n        // 4. Run tasks to apply settings\n        cx.background_executor.run_until_parked();\n\n        // 5. Critical: Verify .zed is actually excluded from worktree\n        let worktree = cx.update(|cx| project.read(cx).worktrees(cx).next().unwrap());\n\n        let has_zed_entry =\n            cx.update(|cx| worktree.read(cx).entry_for_path(rel_path(": "",
        ")).is_some());\n\n        eprintln!(\n            ": "",
        ",\n            has_zed_entry\n        );\n\n        // This assertion verifies the test is set up correctly to show the bug\n        // If .zed is not excluded, the test will fail here\n        assert!(\n            !has_zed_entry,\n            ": "",
        "\n        );\n\n        // 6. Create workspace and trigger the actual function that causes the bug\n        let window = cx.add_window(|window, cx| Workspace::test_new(project.clone(), window, cx));\n        window\n            .update(cx, |workspace, window, cx| {\n                // Call the exact function that contains the bug\n                eprintln!(": "",
        ");\n                open_project_settings_file(workspace, &OpenProjectSettings, window, cx);\n            })\n            .unwrap();\n\n        // 7. Run background tasks until completion\n        cx.background_executor.run_until_parked();\n\n        // 8. Verify file contents after calling function\n        let new_content = app_state\n            .fs\n            .load(Path::new(": "",
        "))\n            .await\n            .unwrap();\n\n        let new_content_str = new_content;\n        eprintln!(": "",
        ", new_content_str);\n\n        // The bug causes the settings to be overwritten with empty settings\n        // So if the unique value is no longer present, the bug has been reproduced\n        let bug_exists = !new_content_str.contains(": "",
        ");\n        eprintln!(": "",
        ", bug_exists);\n\n        // This assertion should fail if the bug exists - showing the bug is real\n        assert!(\n            new_content_str.contains(": "",
        "\n        );\n    }\n\n    #[gpui::test]\n    async fn test_prefer_focused_window(cx: &mut gpui::TestAppContext) {\n        let app_state = init_test(cx);\n        let paths = [PathBuf::from(path!(": "",
        "))];\n\n        app_state\n            .fs\n            .as_fake()\n            .insert_tree(\n                path!(": "",
        "\n                }),\n            )\n            .await;\n\n        let project_a = Project::test(app_state.fs.clone(), [path!(": "",
        ").as_ref()], cx).await;\n        let window_a =\n            cx.add_window(|window, cx| Workspace::test_new(project_a.clone(), window, cx));\n\n        let project_b = Project::test(app_state.fs.clone(), [path!(": "",
        ").as_ref()], cx).await;\n        let window_b =\n            cx.add_window(|window, cx| Workspace::test_new(project_b.clone(), window, cx));\n\n        let project_c = Project::test(app_state.fs.clone(), [path!(": "",
        ").as_ref()], cx).await;\n        let window_c =\n            cx.add_window(|window, cx| Workspace::test_new(project_c.clone(), window, cx));\n\n        for window in [window_a, window_b, window_c] {\n            let _ = cx.update_window(*window, |_, window, _| {\n                window.activate_window();\n            });\n\n            cx.update(|cx| {\n                let open_options = OpenOptions {\n                    prefer_focused_window: true,\n                    ..Default::default()\n                };\n\n                workspace::open_paths(&paths, app_state.clone(), open_options, cx)\n            })\n            .await\n            .unwrap();\n\n            cx.update_window(*window, |_, window, _| assert!(window.is_window_active()))\n                .unwrap();\n\n            let _ = window.read_with(cx, |workspace, cx| {\n                let pane = workspace.active_pane().read(cx);\n                let project_path = pane.active_item().unwrap().project_path(cx).unwrap();\n\n                assert_eq!(\n                    project_path.path.as_ref().as_std_path().to_str().unwrap(),\n                    path!(": ""
    },
    "zed/crates/zed/src/zed/app_menus.rs": {
        "Zoom In": "",
        "Zoom Out": "",
        "Reset Zoom": "",
        "Reset All Zoom": "",
        "Toggle Left Dock": "",
        "Toggle Right Dock": "",
        "Toggle Bottom Dock": "",
        "Toggle All Docks": "",
        "Editor Layout": "",
        "Split Up": "",
        "Split Down": "",
        "Split Left": "",
        "Split Right": "",
        "Project Panel": "",
        "Outline Panel": "",
        "Collab Panel": "",
        "Terminal Panel": "",
        "Debugger Panel": "",
        "Diagnostics": "",
        "Toggle GPUI Inspector": "",
        "About Zed": "",
        "Check for Updates": "",
        "Settings": "",
        "Open Settings": "",
        "Open Settings File": "",
        "Open Project Settings": "",
        "Open Default Settings": "",
        "Open Keymap": "",
        "Open Keymap File": "",
        "Open Default Key Bindings": "",
        "Select Theme...": "",
        "Select Icon Theme...": "",
        "Services": "",
        "Extensions": "",
        "Install CLI": "",
        "Hide Zed": "",
        "Hide Others": "",
        "Show All": "",
        "Quit Zed": "",
        "File": "",
        "New": "",
        "New Window": "",
        "Open File...": "",
        "Open Folder...": "",
        "Open…": "",
        "Open Recent...": "",
        "Open Remote...": "",
        "Add Folder to Project…": "",
        "Save": "",
        "Save As…": "",
        "Save All": "",
        "Close Editor": "",
        "Close Window": "",
        "Edit": "",
        "Undo": "",
        "Redo": "",
        "Cut": "",
        "Copy": "",
        "Copy and Trim": "",
        "Paste": "",
        "Find": "",
        "Find In Project": "",
        "Toggle Line Comment": "",
        "Selection": "",
        "Select All": "",
        "Expand Selection": "",
        "Shrink Selection": "",
        "Select Next Sibling": "",
        "Select Previous Sibling": "",
        "Add Cursor Above": "",
        "Add Cursor Below": "",
        "Select Next Occurrence": "",
        "Select Previous Occurrence": "",
        "Select All Occurrences": "",
        "Move Line Up": "",
        "Move Line Down": "",
        "Duplicate Selection": "",
        "View": "",
        "Go": "",
        "Back": "",
        "Forward": "",
        "Command Palette...": "",
        "Go to File...": "",
        "Go to Symbol in Project": "",
        "Go to Symbol in Editor...": "",
        "Go to Line/Column...": "",
        "Go to Definition": "",
        "Go to Declaration": "",
        "Go to Type Definition": "",
        "Find All References": "",
        "Next Problem": "",
        "Previous Problem": "",
        "Run": "",
        "Spawn Task": "",
        "Start Debugger": "",
        "Edit tasks.json...": "",
        "Edit debug.json...": "",
        "Continue": "",
        "Step Over": "",
        "Step Into": "",
        "Step Out": "",
        "Toggle Breakpoint": "",
        "Edit Breakpoint": "",
        "Clear all Breakpoints": "",
        "Window": "",
        "Minimize": "",
        "Zoom": "",
        "Help": "",
        "View Release Notes Locally": "",
        "View Telemetry": "",
        "View Dependency Licenses": "",
        "Show Welcome": "",
        "File Bug Report...": "",
        "Request Feature...": "",
        "Email Us...": "",
        "Documentation": "",
        "Zed Repository": "",
        "Zed Twitter": "",
        "Join the Team": ""
    },
    "zed/crates/zed/src/zed/mac_only_instance.rs": {
        "Zed Editor Dev Instance Running": "",
        "Zed Editor Nightly Instance Running": "",
        "Zed Editor Preview Instance Running": "",
        "Zed Editor Stable Instance Running": "",
        "Error binding to single instance port: {err}": "",
        "Backup handshake request failed, continuing without handshake": "",
        "EnsureSingleton": "",
        "Connected to single instance port but failed to read: {err}": "",
        "Got instance handshake": "",
        "Got wrong instance handshake value": ""
    },
    "zed/crates/zed/src/zed/open_listener.rs": {
        "user is empty in wsl argument": "",
        "zed-cli://": "",
        "zed-dock-action://": "",
        "file://": "",
        "zed://file": "",
        "zed://ssh": "",
        "ssh:/": "",
        "zed://extension/": "",
        "zed://agent": "",
        "zed://schemas/": "",
        "zed://settings": "",
        "zed://settings/": "",
        "ssh://": "",
        "unhandled url: {}": "",
        "missing host in ssh url: {file}": "",
        "cannot open both local and ssh paths": "",
        "cannot open multiple different remote connections": "",
        "channel": "",
        "notes#": "",
        "notes": "",
        "invalid zed url: {request_path}": "",
        "no listener for open requests": "",
        "zed-{}.sock": "",
        "error connecting to cli": "",
        "error sending ipc handshake": "",
        "error opening {path:?}: {error}": "",
        "{e}": "",
        "failed to open a workspace": "",
        "error opening {paths_with_position:?}: {error}": "",
        "ssh://me@localhost:/": "",
        "localhost": "",
        "me": "",
        "/root": "",
        "dir1": "",
        "file1.txt": "",
        "content1": "",
        "file2.txt": "",
        "content2": "",
        "/root/dir1": "",
        "Workspace should have two items": "",
        "C:\\\\root": ""
    },
    "zed/crates/zed/src/zed/quick_action_bar.rs": {
        "empty quick action bar": "",
        "toggle buffer search": "",
        "Buffer Search": "",
        "toggle inline assistant": "",
        "Inline Assist": "",
        "toggle_code_actions_icon": "",
        "Code Actions": "",
        "No Code Actions Available": "",
        "editor-selections-dropdown": "",
        "toggle_editor_selections_icon": "",
        "Selection Controls": "",
        "Select All": "",
        "Select Next Occurrence": "",
        "Expand Selection": "",
        "Shrink Selection": "",
        "Add Cursor Above": "",
        "Add Cursor Below": "",
        "Add to Agent Thread": "",
        "Go to Symbol": "",
        "Go to Line/Column": "",
        "Next Problem": "",
        "Previous Problem": "",
        "Next Hunk": "",
        "Previous Hunk": "",
        "Move Line Up": "",
        "Move Line Down": "",
        "Duplicate Selection": "",
        "editor-settings": "",
        "toggle_editor_settings_icon": "",
        "Editor Controls": "",
        "Inlay Hints": "",
        "Inline Values": "",
        "Minimap": "",
        "Edit Predictions": "",
        "You can't toggle edit predictions for this file as it is within the excluded files list.": "",
        "Diagnostics": "",
        "Inline Diagnostics": "",
        "Inline diagnostics are not available until regular diagnostics are enabled.": "",
        "Line Numbers": "",
        "Selection Menu": "",
        "Auto Signature Help": "",
        "Inline Git Blame": "",
        "Column Git Blame": "",
        "Vim Mode": "",
        "Helix Mode": "",
        "quick action bar": ""
    },
    "zed/crates/zed/src/zed/windows_only_instance.rs": {
        "{}-Instance-Mutex": "",
        "Unable to create instance mutex.": "",
        "EnsureSingleton": "",
        "\\\\\\\\.\\\\pipe\\\\{}-Named-Pipe": "",
        "Failed to create named pipe: {:?}": "",
        "Failed to read from named pipe": "",
        "zed-dock-action://{}": "",
        "Handshake before Zed spawn": "",
        "zed-cli://{server_name}": "",
        "zed://": "",
        "file://": "",
        "ssh://": "",
        "error parsing path argument: {}": "",
        "CliReceiver": "",
        "Handshake after Zed spawn": "",
        "{message}": ""
    },
    "zed/crates/zed/src/zed/quick_action_bar/repl_menu.rs": {
        "repl-menu": "",
        "menu": "",
        "kernel: {} ({})": "",
        "Run Selection": "",
        "Run Line": "",
        "Interrupt": "",
        "Clear Outputs": "",
        "Shut Down Kernel": "",
        "Restart Kernel": "",
        "View Sessions": "",
        "Shut Down all Kernels": "",
        "dropdown": "",
        "REPL Menu": "",
        "toggle_repl_icon": "",
        "Start REPL for {}": "",
        "kernel-selector": "",
        "Select Kernel": "",
        "Setup Zed REPL for {}": "",
        "{}#installation": "",
        "Nothing running": "",
        "Restarting {}": "",
        "Run code on {} ({})": "",
        "Interrupt {} ({})": "",
        "{} is starting": "",
        "Error with kernel {}: {}": "",
        "{} is shutting down": ""
    },
    "zed/crates/zeta/src/zeta.rs": {
        "<|user_cursor_is_here|>": "",
        "<|start_of_file|>": "",
        "<|editable_region_start|>": "",
        "<|editable_region_end|>": "",
        "zed_predict_data_collection_choice": "",
        "dismissed-edit-predict-upsell": "",
        "Accept and Enable": "",
        "EditPrediction": "",
        "id": "",
        "path": "",
        "edits": "",
        "untitled": "",
        "Events:\\n{}\\nExcerpt:\\n{:?}": "",
        "Update Zed": "",
        "completion response: {}": "",
        "Edit Prediction Request": "",
        "ZED_PREDICT_EDITS_URL": "",
        "/predict_edits/v2": "",
        "Content-Type": "",
        "application/json": "",
        "Authorization": "",
        "error predicting edits.\\nStatus: {:?}\\nBody: {}": "",
        "ZED_ACCEPT_PREDICTION_URL": "",
        "/predict_edits/accept": "",
        "error accepting edit prediction.\\nStatus: {:?}\\nBody: {}": "",
        "failed to parse request id": "",
        "expected exactly one start marker, found {}": "",
        "expected exactly one end marker, found {}": "",
        "expected at most one start-of-file marker, found {}": "",
        "could not find newline": "",
        "\\n{EDITABLE_REGION_END_MARKER}": "",
        "could not find end marker": "",
        "Edit Prediction Rated": "",
        "true": "",
        "false": "",
        "unknown value in '{ZED_PREDICT_DATA_COLLECTION_CHOICE}'": "",
        "You must update to Zed version {minimum_version} or higher to continue using edit predictions.": "",
        "\\n\\n": "",
        "User renamed {:?} to {:?}\\n": "",
        "User edited {:?}:\\n```diff\\n{}\\n```": "",
        "zed-predict": "",
        "Zed's Edit Predictions": "",
        "edit prediction failed": "",
        "Lorem ipsum dolor": "",
        "REM": "",
        "R": "",
        "EM": "",
        "E": "",
        "M": "",
        "\n                    fn main() {\n                        let word_1 = \\\"lorem\\\";\n                        let range = word.len()..word.len();\n                    }\n                ": "",
        "\n                    <|editable_region_start|>\n                    fn main() {\n                        let word_1 = \\\"lorem\\\";\n                        let range = word_1.len()..word_1.len();\n                    }\n\n                    <|editable_region_end|>\n                ": "",
        "\n                fn main() {\n                    let word_1 = \\\"lorem\\\";\n                    let range = word_1.len()..word_1.len();\n                }\n            ": "",
        "\n                    fn main() {\n                        let story = \\\"the quick\\\"\n                    }\n                ": "",
        "\n                    <|editable_region_start|>\n                    fn main() {\n                        let story = \\\"the quick brown fox jumps over the lazy dog\\\";\n                    }\n\n                    <|editable_region_end|>\n                ": "",
        "\n                fn main() {\n                    let story = \\\"the quick brown fox jumps over the lazy dog\\\";\n                }\n            ": "",
        "lorem\\n": "",
        "\n            ```animals.js\n            <|start_of_file|>\n            <|editable_region_start|>\n            lorem\n            ipsum\n            <|editable_region_end|>\n            ```": "",
        "lorem\\nipsum": "",
        "/project": "",
        "LICENSE": "",
        "fn main() {\\n    println!(\\\"Hello\\\");\\n}": "",
        ".env": "",
        "SECRET_KEY=secret": "",
        "main.rs": "",
        "fn main() {}": "",
        "/open_source_worktree": "",
        "/closed_source_worktree": "",
        "closed_source_worktree": "",
        "/worktree1": "",
        "other.rs": "",
        "/worktree2": "",
        "private.rs": "",
        "An edit for the history!": "",
        " ": "",
        "\n            ```main.rs\n            <|start_of_file|>\n            <|editable_region_start|>\n            hello world\n            <|editable_region_end|>\n            ```": "",
        "/client/llm_tokens": "",
        "the-llm-token": "",
        "Not Found": ""
    }
}